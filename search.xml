<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>开博序</title>
    <url>/2016/09/23/1600-Preface/</url>
    <content><![CDATA[<p>&emsp; &emsp; 我在IoT(物联网), M2M, 安防及智能建筑方面有丰富的需求分析和研发经验, 并且持续关注着这些领域. 如果我们把未来的网络世界看成一个生命体, 那么, 物联网的各个节点会是整个互联网世界的感知系统; 互联网和物联网扮演着神经系统; 人工智能则是大脑的角色; 而能量问题则全部由现有的电力系统来解决了.</p>
<p>&emsp; &emsp; 对于这个新生的生命体, 通过过去的30年左右的发育, 消化系统基本完善——单位能量的运算能力大幅提高, 神经系统 的主干也已经发育成熟——互联网已成为全球信息传输的不二选择. 目前, 物联网和人工智能的盛行, 则意味着这个生命体的已经开始在另外两个方面的发育成长了, 一是感官系统 ——借助于物联网的各个节点, 虚拟的网络世界会具有感知真实世界的能力; 二是大脑 ——人工智能的快速发展终将会使机器具有自主学习能力. 最终, 人类将成为造物主, 创造出一个智能生命体, 他能感知真实环境, 做出独立的判断(不知是福是祸!). 现在, 我们站在这个开端, 持续时间至少是30年以上!</p>
<p>&emsp; &emsp; 上面一段是我坚信不疑的脑洞. 结合自己的实际情况, 更多的精力会放在物联网方面.<br>目前物联网在特定的M2M领域很成功, 借助诸如 Zigbee, BLE, Enocean 或其它RF技术, 让各个节点采集的信息能联网汇总到一个网关, 然后通过 有线, wifi, 2G/3G/4G 以及值得关注的LPWAN(如NB-IOT) 等方式, 将数据发送到服务器端. 服务器端在收集存储数据后, 根据特定需求对这些数据进行整理和分析后, 或实现自动化, 或将信息交由人类决策, 整个系统最终就产生了商业价值.</p>
<p>&emsp; &emsp; 我的目标之一就是在技术上完全掌握这么一个系统. 各个节点的开发难度在于能耗和传感器技术, 组网难度相对比较小, 大多由无线协议帮助解决.  一般而言, 这些数据都需要通过一个中间设备传输给服务器或云端. 这个中间设备需要使用embedded linux实现socket, https之类的协议, 根据使用环境, 还需要平衡性能和功耗等不同的需求. 云端, 需要实现数据的收集, 提取, 归类, 分析, 展示功能, 这也都是成熟技术了, 更多的关注点在于云端的流量和运维. 需要特别提一下数据分析, 这个是没底的, 需要根据特定的需求来决定招聘怎样的人, 如何做分析. 在某些情况, 节点和中间设备会融合成一个终端设备, 这时候, 开发难度就很大了, 因为方案公司一般无法覆盖到这类设备的全部需求, 需要定制或自行研发这类设备.</p>
<p>&emsp; &emsp; 物联网在家庭中的应用就是智能家居, 智能家居的概念冷冷热热几回了, 但依旧一点也不实用, 不以人为本. 这里面的关键原因是, 物联网是物物链接, 信息收集处理展示就可以了, 基于这种概念做出来的智能家居系统, 不可能是智能的. 宣传上, 说是用户可以远程监视控制之类云云, 但实际上, 只是把一堆无用的数据直接展现给了最终客户, 操作过程繁琐, 一点也不好用! 因此, 智能家居的关键点在于物体和人的交互, 解决好交互问题, 才可能会是好用的智能家居系统. 综合来看, 智能家居的大规模应用时机尚未成熟, 需要继续等待. 几个关键点如下:</p>
<ul>
<li>传感器价格的降低, 易用性的提高. (涉及到能耗, 稳定性, 可靠性, 免维护)</li>
<li>组网标准的进一步统一. (目前重点关注BLE和LPWAN)</li>
<li>AI技术的进一步实用化.</li>
<li>UI交互体验的突破. (大部分基于AI的智能化判断, 但也需要提供非常便捷的人工介入方式)</li>
</ul>
<p>&emsp; &emsp; 技术选择上, 各个节点主要考量点在于功耗和组网方式, 来决定使用哪种无线技术. 譬如如果节点需要和手机交换数据, 那BLE是不二选择; 如果节点需要无源不间断工作, 价格也不太敏感, 那Enocean方案就是不错的选择. 中间设备的关键技术无疑就是embedded linux, 掌握后就能根据各种应用需求来灵活开发产品, 构建系统了. 云端目前主流也是使用linux系统的, 因此linux必学, 只是我会更侧重于嵌入式端的开发. 来到服务器端, 给自己安排的学习内容是python, 一来模块丰富, 开发快速, 二者可以用来写测试程序.<br>UI展示方面, 目前的云端应用基本都是基于HTML页面的, 因此可以简单了解学习HTML5. 关键是要了解技术标准, 懂得的系统架构和运行原理.</p>
<p>&emsp; &emsp; 对于AI的发展态势, 我无法继续无动于衷地持旁观态度. 不一定要将其作为主业, 但必须抽出业余时间慢慢学起来. 掌握一些基础知识, 尝试一些可能的应用.</p>
<p>&emsp; &emsp; 以上类似于一份职业规划了, 出发点是兴趣, 希望自己能坚持着一样样学下来, 并在这个博客内有所体现.</p>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下使用github和hexo建独立博客</title>
    <url>/2016/09/24/1601-InitBlog/</url>
    <content><![CDATA[<h1 id="内容更新-2021年3月"><a href="#内容更新-2021年3月" class="headerlink" title="内容更新(2021年3月)"></a>内容更新(2021年3月)</h1><ul>
<li>hexo 的安装方式不变<ul>
<li>先下载安装 Git 和 Node.JS.</li>
<li><code>npm install hexo-cli -g</code> 安装hexo即可.</li>
</ul>
</li>
<li><code>_config.yml</code> 文件改了某些地方. 具体参数参考 <a href="https://hexo.io/docs/configuration">Configuration</a></li>
<li><code>images</code>文件夹直接放到<code>source</code>目录下即可, 会自动生成图片网址.</li>
<li><a href="https://hexo.io/docs/">hexo 官方文档</a></li>
<li>提供了更为丰富的<a href="https://hexo.io/themes/">主题选择</a>.</li>
<li>依旧选 NexT主题, 改了参数设置. 参考 <a href="https://theme-next.iissnan.com/getting-started.html">NexT 开始使用</a></li>
<li>更新结束(2021年3月)</li>
</ul>
<h1 id="我需要一个博客"><a href="#我需要一个博客" class="headerlink" title="我需要一个博客"></a>我需要一个<a href="https://draapho.github.io/">博客</a></h1><p>三年前学linux的时候, 深感复杂,  然后也略微记录了些笔记放在电脑里. 但是真要用的时候, 依旧会google或baidu, 原因很简单: 电脑的笔记用起来不方便, 找文档慢不说, 找到后要么是没有格式的txt文档, 有些是花了力气排版好的word, 又觉得打开很慢. 于是觉得需要一个博客, 在CSDN开了博, 坚持不到10篇文章就放弃了, 原因很简单: 太麻烦了. 我的本意只是学习笔记加资料仓库, 但维护它的时间成本太高了. 一晃三年, 工作上进入一个新领域, 需要系统的学习嵌入式linux和python, 再度觉得需要建一个博客来管理和维护一些笔记和资料.</p>
<p><strong>工欲善其事, 必先利其器</strong>. 所以, 我需要一个博客. 寻寻觅觅, 幸运寻得github.io和markdown写作这么一个方案.</p>
<h1 id="折腾记-jekyII方案"><a href="#折腾记-jekyII方案" class="headerlink" title="折腾记, jekyII方案"></a><del>折腾记, jekyII方案</del></h1><p>不过依旧走了一点弯路, 因为github.io推荐的是jekyII环境, 如果对这个方案感兴趣, 点击<a href="https://help.github.com/articles/using-jekyll-as-a-static-site-generator-with-github-pages/">这里</a>可以按照官方教程来操作. 人家第一句话就是<a href="https://help.github.com/articles/setting-up-your-github-pages-site-locally-with-jekyll/"><strong>jekyII并不原生支持Windows</strong></a> , 但我岂是会轻易投降的人, 遇到问题就解决问题, 这不还有另外一句 <a href="http://jekyllrb.com/docs/windows/#installation"><strong>Jekyll on Windows</strong></a>, 流程如下, 然后还要注意编码问题.</p>
<ul>
<li>装<a href="http://rubyinstaller.org/downloads/">Ruby</a> 或者 <code>choco install ruby -y</code></li>
<li>装jekyII,   <code>gem install jekyll</code><br>最终, 我是安装失败了…具体卡在哪个错误提示也给忘了. 所幸的是搜到了对windows友好的hexo方案.</li>
</ul>
<h1 id="Hexo方案"><a href="#Hexo方案" class="headerlink" title="Hexo方案"></a>Hexo方案</h1><p>恩, 这里才是正文的开始! windows下安装hexo这个任务非常简单!</p>
<ul>
<li><p>对<a href="https://git-scm.com/">Git软件</a>和<a href="https://github.com/">GitHub网站</a>不熟的话, 建议安装<a href="https://desktop.github.com/">GitHub Windows</a>, 安装后根据提示操作.</p>
</li>
<li><p>安装<a href="https://nodejs.org/en/">Node.JS</a>, 选推荐版本, 目前是v4.5.0 LTS (即 Long Term Support), 环境变量默认会设置好.</p>
</li>
<li><p>安装Hexo</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li>
<li><p>创建并初始化博客文件夹,这里命名为<em><strong>Blog</strong></em>, 右键点”Git Bash Here”, 或者打开cmd进入到<em><strong>Blog</strong></em>目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd Blog           # 确保在Blog这文件夹下</span><br><span class="line">npm install hexo --save # 安装hexo</span><br><span class="line">hexo init         # 初始化Blog文件夹内容</span><br><span class="line">npm install       # 安装必要的依赖包</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面是必要的插件包</span></span><br><span class="line">npm install hexo-deployer-git --save      # 使用github发布</span><br><span class="line">npm install hexo-deployer-rsync --save    # 不装, 使用 rysnc发布</span><br><span class="line">npm install hexo-deployer-openshift --save    # 不装, 使用OpenShift发布</span><br><span class="line">npm install hexo-generator-feed --save    # 不装, 生成atom.xml, 供RSS使用</span><br><span class="line">npm install hexo-generator-sitemap --save # 不装, 生成sitemap.xml, 用于提高搜索量</span><br><span class="line">npm install hexo-generator-search --save  # 用于本地搜索</span><br></pre></td></tr></table></figure></li>
<li><p>本地查看效果, 输入<code>hexo s</code>成功后登录 <code>localhost:4000</code>查看效果<br>这里, 我遇到了错误, 提示是 4000 端口已经被占用.<br>最后发现是 foxitProtect.exe (福昕PDF保护进程)占用此端口, 先结束, 然后直接删除.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -aon | findstr &quot;4000&quot;     # 查找占用4000端口的PID, 譬如, 结果为1234</span><br><span class="line">tasklist | findstr &quot;1234&quot;         # 查找PID=1234的进程名称, 譬如, 结果为foxitProtect.exe</span><br><span class="line">taskkill /f /t /im foxitProtect.exe   # 强制杀死此进程</span><br></pre></td></tr></table></figure></li>
<li><p>配置 hexo 的 <code>_config.yml</code></p>
<blockquote>
<p># Site<br>title: DRA&amp;PHO                  # 博客名字<br>subtitle: thinking &amp; logging    # 副标题<br>description: Embedded System, IoT, M2M  # 博客描述<br>author: draapho                 # 作者<br>language: en        # 语言, 中文为 zh-Hans, 需设置category_map和tag_map</p>
<p># URL<br>url: <a href="https://yourgithubname.github.io/">https://YourGitHubName.github.io/</a>  # 替换<em><strong>YourGitHubName</strong></em><br># 譬如: <a href="https://draapho.github.io/">https://draapho.github.io/</a> 我的GitHub注册名是<em><strong>draapho</strong></em></p>
<p># Directory<br>source_dir: source      # source文件夹, 用来写文章<br>public_dir: public      # public文件夹, 自动生成的静态页面都放在这里<br>tag_dir: tags           # 标签文件夹, 需要安装 hexo-generator-tag<br>archive_dir: archives   # 归档文件夹, 需安装 hexo-generator-archive<br>category_dir: categories    # 分类文件夹, 需安装 hexo-generator-category</p>
<p># Extensions<br>theme: next         # 随了大流, 用了next主题</p>
<p># Deployment<br>deploy:<br>  type: git         # 使用git部署, 需安装 hexo-deployer-git<br>  repository: <a href="https://github.com/YourGitHubName/YourGitHubName.github.io.git">https://github.com/YourGitHubName/YourGitHubName.github.io.git</a><br>  # 我的注册名是<em><strong>draapho</strong></em>, 就写成: <a href="https://github.com/draapho/draapho.github.io.git">https://github.com/draapho/draapho.github.io.git</a><br>  branch: master</p>
<p># search Settings, 默认没有这行内容, 自己添加即可<br>search:             # 本地搜索功能, 需安装 hexo-generator-search<br>   path: search.xml<br>   field: post</p>
</blockquote>
</li>
<li><p>创建about,categories,tags文件夹及文件<br>在<code>Blog\source</code>下, 新建文件夹about, 然后新建文件index.md, 用于生成关于页面</p>
<blockquote>
<p>-–<br>title: about<br>date: 2016-09-08<br>comments: false<br>-–<br>这一篇的内容是自我介绍</p>
</blockquote>
<p>在<code>Blog\source</code>下, 新建文件夹categories, 然后新建文件index.md, 用于生成分类页面</p>
<blockquote>
<p>-–<br>title: categories<br>date: 2016-09-08<br>type: “categories”<br>comments: false<br>-–</p>
</blockquote>
<p>在<code>Blog\source</code>下, 新建文件夹tags, 然后新建文件index.md, 用于生成标签页面</p>
<blockquote>
<p>-–<br>title: tags<br>date: 2016-09-08<br>type: “tags”<br>comments: false<br>-–</p>
</blockquote>
</li>
</ul>
<h1 id="github端的配置"><a href="#github端的配置" class="headerlink" title="github端的配置"></a>github端的配置</h1><ul>
<li>如果之前没有使用过github, 第一次上传应该要求输入用户名和密码. 但如果每次部署都要这样, 就显得很麻烦. github端可以使用SSH 或 GPG keys来免去这个步骤. 建议使用GPG keys.</li>
<li>这里就不详细展开了, 具体步骤参考github, <a href="https://help.github.com/articles/generating-a-gpg-key/">生成一个GPG key</a></li>
</ul>
<h1 id="使用mermaid插件支持流程图等"><a href="#使用mermaid插件支持流程图等" class="headerlink" title="使用mermaid插件支持流程图等"></a><del>使用mermaid插件支持流程图等</del></h1><ul>
<li>安装<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-mermaid --save</span><br></pre></td></tr></table></figure></li>
<li>添加mermaid依赖到主题模板<br>进入themes/your_theme_folder/layout/partial目录，添加mermaid相关文件。<br>head.jade 添加如下代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link(rel&#x3D;&quot;stylesheet&quot;, href&#x3D;url_for(&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;mermaid&#x2F;6.0.0&#x2F;mermaid.min.css&quot;))</span><br></pre></td></tr></table></figure>
scripts.jade 添加如下代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link(rel&#x3D;&quot;stylesheet&quot;, script(src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;mermaid&#x2F;6.0.0&#x2F;mermaid.min.js&quot;)</span><br></pre></td></tr></table></figure></li>
<li>我暂时放弃了<br>next用的swig, 不知道和jade文件是什么关系. 暂时不愿去研究.<br>看了下此插件的格式, 和我常用的Typora使用的mermaid不一样.<br>博客上用到流程图之类的机会不多, 偶尔需要使用图片即可.<br>如有兴趣, 可参考 <a href="http://jcchow.com/2016/07/11/mermaid-sequence/">Hexo流程图等插件安装教程</a></li>
</ul>
<h1 id="NexT主题"><a href="#NexT主题" class="headerlink" title="NexT主题"></a>NexT主题</h1><p>主题的选择我没有花太多时间, 测试了2-3个主题后, 最终还是随大流的用了NexT主题. 说实话, 设计感很好, 用的人很多, 略有审美疲劳. 好在博客目标明确, NexT能很好的覆盖我几个基本需求, 文档又写的很完善, 就不折腾了.</p>
<ul>
<li>安装NexT, 见<a href="http://theme-next.iissnan.com/getting-started.html">官方文档</a></li>
<li>menu_icons 图标配置, 名称用的是<a href="http://fontawesome.io/icons/">Font Awesome</a></li>
<li>about 页面的链接是 <a href="https://yourgithubname.github.io/about">https://YourGitHubName.github.io/about</a><br>我的注册名是<em><strong>draapho</strong></em>, 就写成 <a href="https://draapho.github.io/about">https://draapho.github.io/about</a></li>
<li><code>\themes\next\_config.yml</code>文件内找到<code>use_motion:</code> 设置为<code>false</code>. 表示禁止动画效果, 立刻显示页面</li>
</ul>
<h1 id="Hexo的日常使用"><a href="#Hexo的日常使用" class="headerlink" title="Hexo的日常使用"></a>Hexo的日常使用</h1><ul>
<li>习惯于直接在 \Blog\source_posts\ 下面直接新建文件 xxx.md<br>然后打开文件, 添加并修改如下内容:<blockquote>
<p>title: Windows下使用github和hexo建立自己的博客<br>date: 2016-09-08<br>categories: environment<br>tags: [blog, hexo, next]</p>
</blockquote>
</li>
<li>Hexo的常用指令<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean    #更换hexo主题后, 建议先执行此条命令清空</span><br><span class="line">hexo g        # g=generate, 生成public静态文件</span><br><span class="line">hexo s        # s=server, 本地发布预览效果, 默认地址是 localhost:4000</span><br><span class="line">hexo d        # d=deploy, 自动部署</span><br><span class="line">hexo d -g     # 我最常用的指令, 意思是先generate再deploy.</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://wsgzao.github.io/post/hexo-guide/">使用GitHub和Hexo搭建免费静态Blog</a></li>
<li><a href="http://www.jianshu.com/p/35e197cb1273">Hexo搭建Github-Pages博客填坑教程</a></li>
<li><a href="https://hexo.io/zh-cn/docs/index.html">Hexo 文档</a></li>
<li><a href="http://theme-next.iissnan.com/getting-started.html">Next 主题</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 软件系列-提高效率</title>
    <url>/2016/09/28/1602-WinSoft-efficiency/</url>
    <content><![CDATA[<h1 id="AutoHotKey"><a href="#AutoHotKey" class="headerlink" title="AutoHotKey"></a><del><a href="https://autohotkey.com/">AutoHotKey</a></del></h1><h2 id="AHK-简介"><a href="#AHK-简介" class="headerlink" title="AHK 简介"></a>AHK 简介</h2><ul>
<li><a href="https://autohotkey.com/">AutoHotkey</a>是一个windows下的开源, 免费, 自动化软件工具.</li>
<li>我主要用于绑定快捷键, 便于快速打开应用和文件夹. 以此提高<strong>工作效率</strong></li>
<li>常用符号含义<blockquote>
<p><code>#</code> 代表 Win 键<br><code>!</code> 代表 Alt 键<br><code>^</code> 代表 Ctrl 键<br><code>+</code> 代表 shift 键<br><code>::</code> 起分隔作用<br><code>run</code> 非常常用 的 AHK 命令之一<br><code>;</code>  注释后面一行内容</p>
</blockquote>
</li>
<li>举个例子<br>用 <code>Ctrl - Alt - Shift - Win - n</code> 打开记事本的脚本<figure class="highlight ahk"><table><tr><td class="code"><pre><span class="line"><span class="title">^!+#n::</span>run C:\Windows\notepad.exe</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="AHK懒人用法-ezAHK"><a href="#AHK懒人用法-ezAHK" class="headerlink" title="AHK懒人用法: ezAHK"></a>AHK懒人用法: <a href="https://github.com/draapho/ezAHK">ezAHK</a></h2><ul>
<li>安装 <a href="https://autohotkey.com/download/">AutoHotKey</a> V1.1.* 版本</li>
<li>下载 <a href="https://github.com/draapho/ezAHK">ezAHK</a> 放到任意位置</li>
<li>把文件或目录的<strong>快捷方式放到link目录</strong>里, 改成希望使用的<strong>快捷键名称</strong>即可.<br>譬如, 希望把notepad绑定到 <code>win-n</code>这个快捷键, 只需要:<ol>
<li>创建<strong>notepad.exe的快捷方式</strong>到<strong>link目录</strong></li>
<li>重命名该快捷方式为 <code>win-n</code></li>
<li>注意 <code>-</code> 的左右<strong>没有空格</strong>, <strong>删除后缀</strong> <code>.exe</code><br> 4. 可以考虑使用 <code>win-r</code> 的方式替代, 毕竟快捷键数量有限, 命令行更灵活.</li>
</ol>
</li>
<li>ezAHK 还包括如下几个实用功能<ul>
<li><code>鼠标中键</code> 复制</li>
<li><code>shift-鼠标中键</code> 剪切</li>
<li><code>ctrl-shift-鼠标中键</code> 复制路径</li>
<li><code>鼠标右键</code> 使用鼠标中键复制后, 首次黏贴</li>
<li><code>ctrl-鼠标右键</code> 黏贴</li>
<li><code>ctrl-~</code> 根据所在目录打开终端</li>
<li><code>alt-win-鼠标中键</code> 复制颜色</li>
<li><code>alt-win-↑ ↓ ← →</code> 单像素移动鼠标</li>
<li><code>alt-win-d</code> 输入当前日期</li>
</ul>
</li>
<li>添加到开机自启动: 创建<code>ezAHK.ahk</code>的快捷方式, 并放到如下 Windows 的 <strong>StartUp目录</strong>.<br>Windows 10 的 StartUp 目录如下:<br><code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</code></li>
</ul>
<h2 id="资源和参考"><a href="#资源和参考" class="headerlink" title="资源和参考"></a>资源和参考</h2><ul>
<li><a href="https://autohotkey.com/boards/viewtopic.php?t=4296">实用 AutoHotkey 脚本推荐</a></li>
<li><a href="https://autohotkey.com/boards/viewtopic.php?t=4267">AHK 快餐店系列索引</a></li>
<li><a href="https://autohotkey.com/docs/scripts/#AutoHotkey_Script_Showcase">AutoHotkey_Script_Showcase</a></li>
<li><a href="https://autohotkey.com/board/topic/60985-get-paths-of-selected-items-in-an-explorer-window/">Get paths of selected items in an explorer window</a></li>
<li>AutoHotKey<a href="https://autohotkey.com/">官网</a> 及 <a href="http://ahkcn.sourceforge.net/docs/AutoHotkey.htm">中文帮助</a></li>
<li><a href="http://www.jeffjade.com/2016/03/11/2016-03-11-autohotkey/">Win下最爱效率神器:AutoHotKey</a></li>
</ul>
<h1 id="快速搜索和定位"><a href="#快速搜索和定位" class="headerlink" title="快速搜索和定位"></a>快速搜索和定位</h1><h2 id="Everything"><a href="#Everything" class="headerlink" title="Everything"></a><a href="https://www.voidtools.com/">Everything</a></h2><ul>
<li><a href="https://www.voidtools.com/">Everything</a>是免费软件, 有<strong>便携版</strong>.</li>
<li><a href="https://www.voidtools.com/">Everything</a>是<strong>普通搜索工具</strong>, 便于在搜索结果中慢慢查阅.</li>
</ul>
<h2 id="Listary"><a href="#Listary" class="headerlink" title="Listary"></a><del><a href="http://www.listary.com/">Listary</a></del></h2><ul>
<li><a href="http://www.listary.com/">Listary</a>分为免费版和专业版.</li>
<li>相比于 <a href="https://www.voidtools.com/">Everything</a>, 索引方式相似,但操作体验完全不同.</li>
<li><a href="http://www.listary.com/">Listary</a>是<strong>随时随地的查找定位</strong>, 目标明确时很方便.</li>
<li>强烈推荐都尝试一下后决定用哪个, 或和我一样同时使用.</li>
<li>Listary 实用快捷键</li>
</ul>
<table>
<thead>
<tr>
<th>Listary</th>
<th>助记</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>win-~</code></td>
<td></td>
<td>打开Listary</td>
</tr>
<tr>
<td><code>enter</code></td>
<td>enter</td>
<td>打开文件</td>
</tr>
<tr>
<td><code>ctrl-enter</code></td>
<td>enter</td>
<td>打开路径</td>
</tr>
<tr>
<td><code>ctrl-c</code></td>
<td>copy</td>
<td>复制</td>
</tr>
<tr>
<td><code>ctrl-shift-c</code></td>
<td>copy</td>
<td>复制路径</td>
</tr>
<tr>
<td><code>ctrl+j</code> <code>ctrl+k</code></td>
<td>vim j,k</td>
<td>下一个 / 上一个(需设置)</td>
</tr>
</tbody></table>
<h2 id="使用-win-r-快速启动"><a href="#使用-win-r-快速启动" class="headerlink" title="使用 win-r 快速启动"></a><del>使用 <code>win-r</code> 快速启动</del></h2><ul>
<li>基本原理是使用 <code>Run</code> 来直接运行配置在环境变量中的快捷方式 <code>.lnk</code>,</li>
<li>由于是执行命令行, 比快捷键方式有更好的扩展性和灵活性更好. 也可以在任何终端中直接调用!</li>
<li>运行环境的搭建可以参考 <a href="https://draapho.github.io/2016/10/09/1608-WinSoft-path/">Windows 软件系列-自定义环境变量</a></li>
<li>详细介绍可参考 <a href="https://xbeta.info/win-run.htm#h-6">最绿色最高效，用win+r启动常用程序和文档</a></li>
<li>为了更省事, 可以使用AHK设置为<code>win</code>键替代<code>win-r</code>键</li>
<li>要把win键也省了的话, 专业版 <a href="http://www.listary.com/">Listary</a> 可以满足这个需求</li>
</ul>
<h1 id="Ditto"><a href="#Ditto" class="headerlink" title="Ditto"></a><del><a href="http://ditto-cp.sourceforge.net/">Ditto</a></del></h1><ul>
<li><a href="http://ditto-cp.sourceforge.net/">Ditto</a> 一款剪切板增强软件, 免费开源. 有绿色便携版(无法支持部分功能)</li>
<li>对复制黏贴功能多多支持总是好的, 使用频率太高了! 这个软件的功能非常实用.<br> - 软件的核心在于 <code>ctrl-~</code> 调用出 Ditto 信息板<br> - <code>shift-enter</code> 忽略格式黏贴纯文本<br> - <code>新建剪辑</code>-&gt;<code>项目标题</code> <code>email</code>-&gt;<code>快速黏贴文本</code> <code>myemail@gmail.com</code>-&gt;设置为<code>禁止自动删除</code>, 也可以归类到组. 以后只需输入email, 就可以直接黏贴具体email地址了<br> - 轻松管理复制历史, 可用作搜索资料, 然后批量黏贴</li>
<li>重新设置 <code>激活Ditto</code> 快捷键为 <code>ctrl-q</code>, 因为 <code>ctrl-~</code>默认用于打开终端</li>
<li>参考 <a href="https://xbeta.info/ditto.htm">Ditto:首选的剪贴板增强软件</a></li>
</ul>
<h1 id="Chocolatey"><a href="#Chocolatey" class="headerlink" title="Chocolatey"></a><del><a href="https://chocolatey.org/">Chocolatey</a></del></h1><p><strong><a href="https://chocolatey.org/">Chocolatey</a>可以作为软件安装的补充, 但不做推荐</strong></p>
<h2 id="Chocolatey-简介"><a href="#Chocolatey-简介" class="headerlink" title="Chocolatey 简介"></a>Chocolatey 简介</h2><ul>
<li>  <a href="https://chocolatey.org/">Chocolatey</a>是windows下的软件管理工具. 软件源由社区成员提交和维护. 基础版免费.</li>
<li>  基于命令行来查找和安装软件,方便快捷,<del>耍酷</del>.</li>
<li>安装包的类型:<ul>
<li>无后缀, 如 git</li>
<li>*.install, 如 git.install, 这个会出现在系统的 <strong>卸载或更改程序</strong> 界面里</li>
<li>*.commandline, 如 git.commandline. 不建议使用</li>
<li>*.portable, 如 putty.portable, zip包, 我的理解就是绿色便携软件</li>
</ul>
</li>
<li>  软件都是自动静默安装, 无法指定安装位置, 无法再安装时配置.</li>
<li>由于运行在管理员权限且不能保证软件绝对无毒, 所以有安全风险. <a href="https://chocolatey.org/about">Chocolatey官网</a>有如下语句:<blockquote>
<p>If you need better peace of mind, we offer <a href="https://chocolatey.org/docs/features-virus-check">runtime malware protection</a> in <a href="https://chocolatey.org/pricing">Chocolatey Pro</a> and <a href="https://chocolatey.org/pricing">Chocolatey for Business</a></p>
</blockquote>
</li>
<li>  搜索和下载指定版本的软件也没有想象中方便.</li>
<li>  综合考虑后, <a href="https://chocolatey.org/">Chocolatey</a>可以作为软件安装的补充(如制作安装脚本), 但不做推荐</li>
</ul>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><ul>
<li>windows <a href="https://chocolatey.org/install">安装 Chocolatey</a>. 使用管理员权限打开 cmd.exe, 输入:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&#x27;https://chocolatey.org/install.ps1&#x27;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot;</span><br></pre></td></tr></table></figure></li>
<li>几个常用指令<ul>
<li><code>choco -?</code> 帮助指令, 获取choco指令的详细说明</li>
<li><code>choco search</code> 搜索. 用 <code>-all</code> 可显示所有版本. 也可以查看<a href="https://chocolatey.org/packages/">网页版</a></li>
<li><code>choco install</code> 安装. 用 ‘-version’ 可指定版本</li>
<li><code>choco upgrade</code> 升级</li>
<li><code>choco uninstall</code> 删除</li>
<li><code>choco list -localonly</code> 查看本地已安装的软件</li>
</ul>
</li>
<li>以nodejs为例<ul>
<li><code>choco search nodejs</code> 加 <code>-all</code> 会显示所有版本!!!</li>
<li>建议网页端搜索 <a href="https://chocolatey.org/packages/"><strong>软件源列表</strong></a></li>
<li><code>choco install nodejs -version 5.0.0</code>  安装nodejs 5.0.0这个版本, 默认使用安装 <strong>.install</strong></li>
<li><code>choco upgrade nodejs</code>  升级nodejs到最新版本</li>
<li><code>choco uninstall nodejs</code>  删除nodejs</li>
<li><code>choco list -localonly</code> 确认是否已删除</li>
</ul>
</li>
</ul>
<h2 id="资料和参考"><a href="#资料和参考" class="headerlink" title="资料和参考"></a>资料和参考</h2><ul>
<li>Chocolatey 官方说明的 <a href="https://chocolatey.org/install">安装方式</a></li>
<li><a href="https://chocolatey.org/packages/">Chocolatey 软件源列表</a></li>
<li><a href="http://ninghao.net/blog/2071">更好的安装软件的方法</a></li>
<li><a href="http://www.jianshu.com/p/831aa4a280e7">Windows下的包管理器Chocolatey</a></li>
<li><a href="https://medium.com/@keivan/why-chocolatey-is-broken-beyond-any-hope-d1a4e33b3d23#.jzmj9o5cd">Why Chocolatey is broken beyond any hope</a></li>
</ul>
<h1 id="Zeal"><a href="#Zeal" class="headerlink" title="Zeal"></a><del><a href="https://zealdocs.org/">Zeal</a></del></h1><ul>
<li><a href="https://zealdocs.org/">Zeal</a>是一款在windows和Linux上, 功能类似于Mac上Dash的一款离线文档查看软件.</li>
<li>免费软件, 有绿色便携版, 支持的手册种类和Dash是一样的. 应该是为了跨平台, 基于Qt5开发, 反应有点慢.</li>
<li>下载安装完成后, <code>Tool</code>-&gt;<code>Docksets...</code>-&gt;窗口<code>Docsets</code>下-&gt;<code>Available</code>-&gt;选择语言-&gt;<code>Download</code>即可.</li>
<li><strong>软件开发人员必备</strong>. 还可以在atom直接调用查看API, 省去大量的文档搜索时间.</li>
</ul>
<h1 id="方案更新-2021年3月"><a href="#方案更新-2021年3月" class="headerlink" title="方案更新(2021年3月)"></a>方案更新(2021年3月)</h1><ul>
<li>配置好以下两个软件就足够了.<ul>
<li><a href="https://getquicker.net/">Quicker</a> 免费版, 完全使用鼠标的效率提升软件.</li>
<li><a href="https://u.tools/">utools</a> 免费版, 完全使用键盘的效率提升软件.</li>
</ul>
</li>
<li>需要部分的第三方软件支持, 如 <a href="https://www.voidtools.com/">Everything</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>AutoHotKey</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 软件系列-文本编辑</title>
    <url>/2016/09/30/1603-WinSoft-editor/</url>
    <content><![CDATA[<h1 id="Notepad"><a href="#Notepad" class="headerlink" title="Notepad++"></a><a href="https://notepad-plus-plus.org/">Notepad++</a></h1><h2 id="Npp简介"><a href="#Npp简介" class="headerlink" title="Npp简介"></a>Npp简介</h2><ul>
<li><a href="https://notepad-plus-plus.org/">Notepad++</a>简称Npp, 是免费好用的记事本</li>
<li>轻便小巧, 打开速度快. 自带丰富功能且有插件, 如语法高亮</li>
<li>建议用他彻底替换windows自带的记事本</li>
<li>目前出到npp7, <strong>不要装64位版本</strong>, 很多插件都不支持</li>
<li>有绿色便携版, 但需要额外设置右键打开和文件关联功能</li>
</ul>
<h2 id="Npp设置"><a href="#Npp设置" class="headerlink" title="Npp设置"></a>Npp设置</h2><h3 id="首选项设置"><a href="#首选项设置" class="headerlink" title="首选项设置"></a>首选项设置</h3><ul>
<li><code>Setting</code>-&gt;<code>Preferences</code> 打开首选项页面</li>
<li><code>General</code>-&gt;<code>Double click to close document</code></li>
<li><code>Editing</code>-&gt;<code>Muli-Editing Setting</code>-&gt;<code>Enable (Ctrl...)</code></li>
<li><code>Editing</code>-&gt;<code>Vertical Edge Setting</code>-&gt;<code>Show vertical edge</code>-&gt;<code>Line mode</code>-&gt;<code>Number of columns: 80</code></li>
<li><code>File Association</code>-&gt;选择需要关联的文件后缀, 加入到<code>Registered extensions</code><br>关联其它后缀名, 只需在<code>customize</code>-&gt;填入后缀并加入, 如 <code>.config</code> <code>.gitignore</code><br>注意: <strong>绿色便携版设置了文件关联也是没有效果的</strong>, 用windows下右键<code>打开方式</code>设置吧</li>
<li><code>Tab Setting</code>-&gt;<code>[Default]</code>-&gt;<code>Tab size:4</code>-&gt;<code>Replace by space</code></li>
<li><code>Tab Setting</code>-&gt;<code>makefile</code>-&gt;<del><code>Use default value</code></del>-&gt;<del><code>Replace by space</code></del>, 因为make只认TAB键</li>
<li><code>Auto-Completion</code>-&gt;<code>Auto-Completion</code>-&gt;<code>From 2 th character</code></li>
<li><code>Auto-Completion</code>-&gt;<code>Auto-Insert</code>-&gt;<code>&#39;</code></li>
<li><code>Auto-Completion</code>-&gt;<code>Auto-Insert</code>-&gt;<code>html/xml close tag</code></li>
<li><del><code>Auto-Completion</code>-&gt;<code>Auto-Insert</code>-&gt;<code>Matched pair</code></del> 加入 <code>*</code> 和 <code>(即</code>~`键), !!!重启后失效, 原因不明.</li>
</ul>
<h3 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h3><ul>
<li><code>Settings</code>-&gt;<code>Style Configurator</code>-&gt;<code>Select theme</code>-&gt;<code>Twilight</code></li>
<li>对<code>Monokai </code>注释配色非常无语, 而且对python的配色也太不友好了, 只好放弃.</li>
</ul>
<h3 id="自定义语法高亮"><a href="#自定义语法高亮" class="headerlink" title="自定义语法高亮"></a>自定义语法高亮</h3><ul>
<li>以导入自定义的 markdown 语法高亮为例</li>
<li>可以去网上搜索<a href="https://github.com/draapho/Blog/tree/master/_blog_stuff/Notepad%2B%2B/markdown">下载markdown语法高亮文件</a></li>
<li><code>Language</code>-&gt;<code>Define your language ...</code>-&gt;<code>Import</code>-&gt;选择下载的<code>markdown_*.xml</code>文件即可</li>
<li>导入成功后, <code>Language</code>-&gt;<code>Define your language ...</code>下面就会有markdown语言了</li>
</ul>
<h3 id="Npp插件"><a href="#Npp插件" class="headerlink" title="Npp插件"></a>Npp插件</h3><ul>
<li>插件的安装 (<strong>64位版本无法支持大多数插件</strong>)<ol>
<li><code>Plugins</code>-&gt;<code>Plugin Manager</code>-&gt;<code>Show Plugin Manager</code>-&gt;安装插件</li>
<li>将插件的<code>.dll</code>文件直接放到<code>plugins</code>目录下. (说明插件可以免安装)</li>
</ol>
</li>
<li><code>compare</code> 文件比较功能.<br>由于使用了深色主题, 需要使用深色作为背景<br><code>Plugins</code>-&gt;<code>compare</code>-&gt;<code>Option</code>-&gt;<code>Clolr setting</code>-&gt;点选颜色<code>More Colors</code> 调深即可</li>
<li><code>customize toolbar</code> 可自定义工具栏</li>
<li><code>File Switcher</code> 提供<code>ctrl+tab</code>在视图窗口切换标签的功能</li>
<li><code>Hex-Editor</code> 增加二进制编辑模式</li>
<li><code>Light Explorer</code> 增加资源管理器界面</li>
<li><code>Location Navigate</code> 浏览历史跳转<br>取消 <code>Mark Changed Line</code>, 配色看不清楚!</li>
<li><del><code>ViSimulator</code></del> vim模式, <code>ctrl+shift+alt+v</code> 使能或禁止. 可以从<a href="https://web.archive.org/web/20150515145616/http://www.visimulator.com/download.html">这里下载</a></li>
<li><code>Zoom Disabler</code> 屏蔽ctrl+滚轮的缩放功能</li>
</ul>
<h2 id="Python-Script插件"><a href="#Python-Script插件" class="headerlink" title="Python Script插件"></a><a href="http://npppythonscript.sourceforge.net/index.shtml">Python Script</a>插件</h2><ul>
<li><p><a href="http://npppythonscript.sourceforge.net/index.shtml">Python Script</a>针对notepad++的python插件, 可以用来批量处理文件</p>
</li>
<li><p><a href="https://sourceforge.net/projects/npppythonscript/files/Python%20Script%201.0.8.0/">下载最新版本1.0.8.0</a> <code>PythonScript_Full_1.0.8.0.zip</code> 即可</p>
</li>
<li><p>解压后将整个文件拷贝到notepad++的根目录下, 目录结构如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Notepad++ (Notepad++ 根目录, 例如&quot;C:\Program Files\npp&quot;)</span><br><span class="line"> +</span><br><span class="line"> |-- python26.dll</span><br><span class="line"> +-- plugins</span><br><span class="line">           |-- PythonScript.dll</span><br><span class="line">           |-- PythonScript</span><br><span class="line">           |   |-- lib</span><br><span class="line">           |   |     |-- (*.py)</span><br><span class="line">           |   |-- scripts</span><br><span class="line">           |             |-- (machine-level scripts)</span><br><span class="line">           |-- doc</span><br><span class="line">           |     |-- PythonScript</span><br><span class="line">           |             |-- PythonScript.chm</span><br><span class="line">           |-- Config (也可能在 %APPDATA%\Notepad++\plugins\config\)</span><br><span class="line">                         \-- PythonScript</span><br><span class="line">                                         |-- scripts</span><br><span class="line">                                                   |-- (用户脚本)</span><br></pre></td></tr></table></figure></li>
<li><p>检测是否安装成功. 重启notepad++. 按如下步骤进行测试<br><code>Plugins-&gt;Python Script</code>-&gt;<code>Show Console</code>-&gt;显示<code>Python ... Ready.</code></p>
</li>
<li><p><a href="https://github.com/draapho/Blog/tree/master/_blog_stuff/Notepad%2B%2B/Python%20Script">一个实用的脚本示例</a>, <strong>注意</strong>, 需要使用Notepad++ 7及以上版本, 否则执行结果和预期会有差别.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os;</span><br><span class="line"><span class="keyword">import</span> sys;</span><br><span class="line"><span class="keyword">from</span> Npp <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对所有打开的文件去除行尾空格并将空格替换为TAB</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_menu_command</span>():</span></span><br><span class="line">  <span class="comment"># Edit-&gt;Blank Operations</span></span><br><span class="line">  notepad.runMenuCommand(<span class="string">&quot;Blank Operations&quot;</span>, <span class="string">&quot;Trim Trailing Space&quot;</span>)</span><br><span class="line">  notepad.runMenuCommand(<span class="string">&quot;Blank Operations&quot;</span>, <span class="string">&quot;Space to TAB (All)&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Find and operate files opened at notepad</span></span><br><span class="line"><span class="comment"># There is something wrong run in NPP6.X</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">operate_file_in_notepad</span>():</span></span><br><span class="line">  file_list = notepad.getFiles()</span><br><span class="line">  <span class="keyword">for</span> file <span class="keyword">in</span> file_list:</span><br><span class="line">      fn = file[<span class="number">0</span>]</span><br><span class="line">      notepad.activateFile(fn)</span><br><span class="line">      run_menu_command()</span><br><span class="line"></span><br><span class="line">operate_file_in_notepad()</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="绿色版注册右键"><a href="#绿色版注册右键" class="headerlink" title="绿色版注册右键"></a>绿色版注册右键</h2><ul>
<li>基本思路是直接修改注册表, 增加右键<code>Notepad++ Here</code></li>
<li>写了批处理文件, 放到notepad++根目录, 管理员权限执行即可.<br><a href="https://github.com/draapho/Blog/blob/master/_blog_stuff/Notepad%2B%2B/_RegisterKey_Admin.bat">_RegisterKey_Admin.bat</a> 注册右键, 需管理员权限执行.<br><a href="https://github.com/draapho/Blog/blob/master/_blog_stuff/Notepad%2B%2B/_UnregisterKey_Admin.bat">_UnregisterKey_Admin.bat</a> 注销右键, 需管理员权限执行.</li>
<li>也可以手动创建文件 <code>注册右键.reg</code>, 内容如下.<br><strong>上述批处理的思路</strong>就是自动生成这个 <code>.reg</code> 文件然后导入注册表.<br><strong>需要替换notepad++安装路径</strong>. 然后管理员权限执行即可.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line">[HKEY_CLASSES_ROOT\*\Shell\NotePad++ Here]</span><br><span class="line">[HKEY_CLASSES_ROOT\*\Shell\NotePad++ Here\Command]</span><br><span class="line">@&#x3D;&quot;\&quot;D:\\Program Files\\npp\\notepad++.exe\&quot; \&quot;%1\&quot;&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h2><ul>
<li>需按照<a href="https://draapho.github.io/2016/10/08/1607-CheatSheet-win/">编辑器快捷键</a>设置</li>
<li>设置好的<a href="https://github.com/draapho/Blog/tree/master/_blog_stuff/Notepad%2B%2B/shortcuts.xml">快捷键配置文件</a>, 直接替换原有的shortcuts.xml即可</li>
<li>说明一下<code>run</code>的设置, 可参考官方说明<a href="http://docs.notepad-plus-plus.org/index.php/External_Programs">Notepad++调用外部程序</a><ul>
<li><code>Zeal.lnk $(CURRENT_WORD)</code> 在Zeal中查询选中内容</li>
<li><code>Typora.lnk &quot;$(FULL_CURRENT_PATH)&quot;</code> 在Typora中预览文件</li>
<li><code>ConEmu.lnk -Dir &quot;$(CURRENT_DIRECTORY)&quot;</code> 使用当前路径打开ConEmu</li>
<li>上述三个指令需要配置好全局变量, 或者使用绝对路径.</li>
<li>后缀名为lnk是因为我用了快捷方式放在同一个目录下, 简化设置全局变量的步骤</li>
<li><code>http://www.google.com/search?q=$(CURRENT_WORD)</code> 选中的内容直接google搜索</li>
</ul>
</li>
<li>环境变量的配置, 可以参考<a href="https://draapho.github.io/2016/10/09/1608-WinSoft-path/">Windows 软件系列-自定义环境变量</a></li>
<li>notepad++的宏录制功能也非常有用, 譬如可以录制一个 <code>TAB to Space</code> + <code>Trim Trailing Space</code> + <code>Save</code> 保存并设置快捷键为 <code>ctrl-s</code>, 这样就可以保存前自动完成空格处理了.</li>
</ul>
<h2 id="资源和参考"><a href="#资源和参考" class="headerlink" title="资源和参考"></a>资源和参考</h2><p><a href="https://notepad-plus-plus.org/">Notepad++官网</a><br><a href="http://docs.notepad-plus-plus.org/index.php/Plugin_Central">Notepad++插件中心</a><br><a href="http://docs.notepad-plus-plus.org/index.php/External_Programs">Notepad++调用外部程序</a><br><a href="http://www.crifan.com/files/doc/docbook/rec_soft_npp/release/html/rec_soft_npp.html">轻量级文本编辑器，Notepad最佳替代品：Notepad++</a><br><a href="http://jingyan.baidu.com/article/a24b33cd71f2d619ff002b60.html">notepad++如何关联到右键菜单</a></p>
<h1 id="已不用atom"><a href="#已不用atom" class="headerlink" title="已不用atom"></a><del>已不用<a href="https://atom.io/">atom</a></del></h1><h2 id="已删除不用"><a href="#已删除不用" class="headerlink" title="已删除不用"></a>已删除不用</h2><ul>
<li>需要维护插件, 开发环境不够稳定可靠.</li>
<li>和专用IDE相比, 没有任何优势.</li>
</ul>
<h2 id="atom简介"><a href="#atom简介" class="headerlink" title="atom简介"></a>atom简介</h2><ul>
<li>界面简洁, 基本上手可用, 无需复杂设置</li>
<li>开源免费, 而且多平台支持, 有丰富的插件库</li>
<li>和git的整合度很好! 直观明了好用</li>
<li>启动相对较慢, 但可接受.</li>
<li>懒人不想折腾, atom无明显短板, 就作为主力代码编辑器了</li>
<li>定位是 Notepad++ 为快速处理文件, atom 处理项目</li>
</ul>
<h2 id="两个快捷键"><a href="#两个快捷键" class="headerlink" title="两个快捷键"></a>两个快捷键</h2><ul>
<li>为了避免打开atom后一头雾水, 需要记住两个快捷键</li>
<li><code>ctrl+shift+p</code>, 打开atom命令窗口, 可以输入指令如<code>setting</code></li>
<li><code>ctrl+,</code> 打开设置页面</li>
</ul>
<h2 id="atom设置"><a href="#atom设置" class="headerlink" title="atom设置"></a>atom设置</h2><ul>
<li><code>ctrl+,</code>进入设置界面 <code>Settings</code></li>
<li><code>Editor</code> 界面下, 设置基本参数<ul>
<li><code>Show Ivisibles</code></li>
<li><code>Soft Tabs</code></li>
<li><code>Tab Length</code>-&gt;<code>4</code></li>
<li><code>Tab Type</code>-&gt;<code>auto</code>, 由于makefile必须为TAB, 否则可以设为 <code>soft</code> Tab键输入4个空格</li>
</ul>
</li>
<li><code>System</code> 界面下, 增加系统右键<ul>
<li><code>Register as file handler</code></li>
<li><code>Show in file context menus</code></li>
<li><code>Show in folder context menus</code></li>
</ul>
</li>
<li><code>Themes</code> 界面下, 选个喜欢的主题. 默认是<code>One Dark</code></li>
<li><code>Packages</code>-&gt;搜索<code>tree view</code>-&gt;<code>Core Packages</code>-&gt;<code>tree-view</code>-&gt;<code>Settings</code><ul>
<li><code>Hide Ignored Names</code> 隐藏atom指定的文件</li>
<li><code>Hide VCS Ignored Files</code> 隐藏<code>.gitignore</code>指定的文件</li>
</ul>
</li>
</ul>
<h2 id="atom插件"><a href="#atom插件" class="headerlink" title="atom插件"></a>atom插件</h2><ul>
<li>插件太多, 脱离需求讲插件是没有意义的. 新手的话, 先探索着玩玩吧.</li>
<li>记得仔细阅读插件的使用说明, 有些插件配置起来挺麻烦的. 但atom的插件管理已经很好了.</li>
<li>后续会根据自己的需求再写一篇atom的插件篇, 并详述如何配置.</li>
<li>下面推荐几个通用型的实用插件.</li>
<li><code>ctrl+,</code>进入设置界面 <code>Settings</code></li>
<li><code>Install</code> 界面下, 搜索安装如下插件<ul>
<li><code>atom-beautify</code> 代码格式美化, 需要安装辅助软件</li>
<li><code>git-time-machine</code> 查看比较文件的git历史</li>
<li><code>highlight-selected</code> 高亮选择的词</li>
<li><code>minimap</code> 文件小地图</li>
<li><code>minimap-highlight-selected</code> 在minimap内高亮选择的词</li>
<li><code>platformio-ide-terminal</code> 内嵌终端</li>
<li><code>project-manager</code> 管理项目.</li>
<li><code>project-viewer</code> 管理项目, 带UI</li>
<li><code>Sublime-Style-Column-Selection</code> 列操作使用<code>alt+drag</code></li>
<li><code>tabs-to-spaces</code> 空格/TAB自动转换</li>
<li><code>vim-mode</code> 提供vim模式.</li>
</ul>
</li>
</ul>
<h2 id="自定义快捷键"><a href="#自定义快捷键" class="headerlink" title="自定义快捷键"></a>自定义快捷键</h2><ul>
<li>以 <code>ctrl-f</code> 为例, 安装vim后, 变成翻页键, 但希望的是文件搜索和替换键.</li>
<li>可以禁止vim的<code>keybindings</code>, 但这里不适用, 因为还要用vim的其它快捷键.</li>
<li><code>ctrl+,</code>-&gt;进入设置界面 <code>Settings</code>-&gt;<code>Keybindings</code>-&gt;输入<code>ctrl-f</code></li>
<li>找到<code>vim-mode:scroll-full-screen-down</code>-&gt;点左边的复制图标</li>
<li>点击<code>your keymap file</code>-&gt;打开<code>keymap.cson</code>-&gt;黏贴内容<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;atom-text-editor.vim-mode:not(.insert-mode)&#39;:</span><br><span class="line">  &#39;ctrl-f&#39;: &#39;vim-mode:scroll-full-screen-down&#39;</span><br></pre></td></tr></table></figure></li>
<li>要屏蔽 vim 的 <code>ctrl-f</code>, 修改为<code>unset!</code>即可. 内容如下:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;atom-text-editor.vim-mode:not(.insert-mode)&#39;:</span><br><span class="line">  &#39;ctrl-f&#39;: &#39;unset!&#39;</span><br></pre></td></tr></table></figure></li>
<li>自定义详情可以参考官网的<a href="http://flight-manual.atom.io/using-atom/sections/basic-customization/#_customizing_keybindings">Basic Customization</a></li>
<li>需按照<a href="https://draapho.github.io/2016/10/08/1607-CheatSheet-win/">编辑器快捷键</a>设置</li>
<li>环境变量的配置, 可以参考<a href="https://draapho.github.io/2016/10/09/1608-WinSoft-path/">Windows 软件系列-自定义环境变量</a></li>
</ul>
<h1 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a><a href="http://www.typora.io/">Typora</a></h1><h2 id="markdown简介"><a href="#markdown简介" class="headerlink" title="markdown简介"></a>markdown简介</h2><ul>
<li><em><strong>强烈推荐 Markdown</strong></em>, 基本可以放弃office word了!!!</li>
<li>markdown在专注于写作内容的同时, 快速便捷的自动美化格式</li>
<li><a href="https://draapho.github.io/about/markdownplus/">查看Markdown语法和效果</a></li>
<li>atom做编辑器也不错, 推荐插件 <code>markdown-preview-enhanced</code>. 但mermaid制图打印有问题.</li>
<li>而且什么都用atom, atom就太重了, 这里推荐 <a href="http://www.typora.io/">Typora</a>.</li>
</ul>
<h2 id="Typora简介"><a href="#Typora简介" class="headerlink" title="Typora简介"></a>Typora简介</h2><ul>
<li><a href="http://www.typora.io/">Typora</a>是一款极简的markdown编辑器. 多平台可用</li>
<li>单窗口显示, 使用 <code>ctrl+/</code> 切换预览和写作模式. 而且预览模式下也可直接写作.</li>
<li>支持<a href="https://en.wikibooks.org/wiki/LaTeX/Mathematics">LaTex数学公式</a>, <a href="http://knsv.github.io/mermaid/">mermaid制图</a>,<a href="http://www.webpagefx.com/tools/emoji-cheat-sheet/">Emoji图标</a></li>
<li>借助<a href="http://pandoc.org/">pandoc</a>,可导出多种格式</li>
<li>缺点: 打开较慢, 不支持列操作, 不能用鼠标右键.</li>
<li>熟悉markdown格式后, 可以用notepad++写作, 用Typora查看效果和转换格式.</li>
</ul>
<h2 id="Typora安装和设置"><a href="#Typora安装和设置" class="headerlink" title="Typora安装和设置"></a>Typora安装和设置</h2><ul>
<li>下载并安装<a href="http://www.typora.io/#windows">Typora windows 版本</a></li>
<li>下载并安装<a href="http://pandoc.org/installing.html">pandoc-xxx-windows.msi</a></li>
<li>打开<code>Typora</code>-&gt;<code>File</code>-&gt;<code>Preference</code></li>
<li><code>Syntax Support</code> 使能如下选项<ul>
<li><code>Inline math</code> 数学公式</li>
<li><code>Subscript</code> 下标</li>
<li><code>Superscript</code> 上标</li>
<li><code>Highlight</code> 高亮</li>
<li><code>Diagrams</code> 制图</li>
</ul>
</li>
<li><code>Syntax Preference</code><ul>
<li><code>Heading Style</code> <code>atx(#)</code> 偏好使用<code>#</code>标记为标题</li>
<li><code>Unodered List</code> <code>-</code> 偏好使用<code>-</code>标记为列表</li>
</ul>
</li>
</ul>
<h2 id="markdown语法参考"><a href="#markdown语法参考" class="headerlink" title="markdown语法参考"></a>markdown语法参考</h2><ul>
<li><a href="https://draapho.github.io/about/markdownplus/">Markdown语法</a></li>
<li><a href="http://knsv.github.io/mermaid/">mermaid制图</a></li>
<li><a href="https://en.wikibooks.org/wiki/LaTeX/Mathematics">LaTeX数学公式</a></li>
<li><a href="http://www.webpagefx.com/tools/emoji-cheat-sheet/">Emoji图标</a></li>
</ul>
<h2 id="Dynalist"><a href="#Dynalist" class="headerlink" title="Dynalist"></a><a href="https://dynalist.io/">Dynalist</a></h2><ul>
<li>多平台可用, 自动同步, 稳定可靠.</li>
<li>全文字版的话, 免费版够用.</li>
<li>免费版挂图片不太方便, 需要用到图床.</li>
</ul>
<h1 id="google-drive"><a href="#google-drive" class="headerlink" title="google drive"></a><a href="https://drive.google.com/">google drive</a></h1><ul>
<li>主要作为云使用, 不少手机APP支持<a href="https://drive.google.com/">google drive</a>, 而且还有好用的网页端应用</li>
<li>在线markdown编辑器<a href="https://stackedit.io/">stackedit</a></li>
<li>在线制图软件<a href="https://www.draw.io/">draw.io</a></li>
<li>手机端markdown编辑器<a href="https://ia.net/writer">iA Writer</a></li>
</ul>
<h1 id="默认新建utf-8文本文件"><a href="#默认新建utf-8文本文件" class="headerlink" title="默认新建utf-8文本文件"></a>默认新建utf-8文本文件</h1><ul>
<li>用notepad++建立一个样本文件, 命名为<code>UTF8.txt</code>, 设置为 <code>UTF-8</code> 编码(不带BOM), 放在 <code>C:\Windows\SHELLNEW</code> 下. 建议内容为空(内容会出现在新建文件中).</li>
<li><code>regedit</code>-&gt;打开 <code>注册表</code>-&gt;<code>HKEY_CLASSES_ROOT\.txt\ShellNew</code>-&gt;右侧新建 <code>字符串值</code>-&gt;名称 <code>FileName</code>-&gt; 数据 <code>UTF8.txt</code></li>
<li>此时, 新建的<code>文本文档</code>就是<code>UTF-8</code>编码的的文件. 事实上是复制了 <code>UTF8.txt</code> 这个样本文件.</li>
<li>参考 <a href="http://alanhou.org/windows-default-encoding-utf8/">Windows新建文件改为默认UTF8</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>Notepad++</tag>
        <tag>atom</tag>
        <tag>Typora</tag>
        <tag>utf-8</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim常用快捷键</title>
    <url>/2016/10/01/1604-CheatSheet-vim/</url>
    <content><![CDATA[<h1 id="Vim常用快捷键"><a href="#Vim常用快捷键" class="headerlink" title="Vim常用快捷键"></a>Vim常用快捷键</h1><h2 id="进入输入模式"><a href="#进入输入模式" class="headerlink" title="进入输入模式"></a>进入输入模式</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>助记</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>i</code></td>
<td>insert</td>
<td>光标前插入文本</td>
</tr>
<tr>
<td><code>I</code></td>
<td>insert</td>
<td>行首插入文本</td>
</tr>
<tr>
<td><code>ea</code></td>
<td>end append</td>
<td>单词末插入文本</td>
</tr>
<tr>
<td><code>a</code></td>
<td>append</td>
<td>光标后插入文本</td>
</tr>
<tr>
<td><code>A</code></td>
<td>append</td>
<td>行尾插入文本</td>
</tr>
<tr>
<td><code>o</code></td>
<td>open new line</td>
<td>向下插入新行</td>
</tr>
<tr>
<td><code>O</code></td>
<td>open new line</td>
<td>向上插入新行</td>
</tr>
<tr>
<td><code>cw</code></td>
<td>change word</td>
<td>修改单词</td>
</tr>
<tr>
<td><code>cc</code></td>
<td>change</td>
<td>删除整行后修改</td>
</tr>
<tr>
<td><code>c^</code> <code>c$</code></td>
<td>change</td>
<td>删除到行首/行尾后修改</td>
</tr>
</tbody></table>
<h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>助记</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>h</code> <code>j</code> <code>k</code> <code>l</code></td>
<td></td>
<td>左/下/上/右</td>
</tr>
<tr>
<td><code>^</code> <code>0</code> <code>$</code></td>
<td></td>
<td>行首/首字母/行尾</td>
</tr>
<tr>
<td><code>w</code></td>
<td>word</td>
<td>下个字开头</td>
</tr>
<tr>
<td><code>e</code></td>
<td>end</td>
<td>本字结尾</td>
</tr>
<tr>
<td><code>b</code></td>
<td>before</td>
<td>上个字开头</td>
</tr>
<tr>
<td><code>fx</code></td>
<td>find+字符</td>
<td>移动到x字符处</td>
</tr>
<tr>
<td><code>5enter</code></td>
<td></td>
<td>向下移5行</td>
</tr>
<tr>
<td><code>gg</code> <code>1G</code></td>
<td>go</td>
<td>回首行</td>
</tr>
<tr>
<td><code>G</code></td>
<td>go</td>
<td>到末行</td>
</tr>
<tr>
<td><code>5G</code></td>
<td>num+go</td>
<td>到第5行</td>
</tr>
<tr>
<td><code>ctrl+u</code></td>
<td>up</td>
<td>向上翻半页</td>
</tr>
<tr>
<td><code>ctrl+d</code></td>
<td>down</td>
<td>向下翻半页</td>
</tr>
<tr>
<td><code>&#123;</code> <code>&#125;</code></td>
<td></td>
<td>块首/块尾</td>
</tr>
<tr>
<td><code>H</code></td>
<td>high</td>
<td>屏幕顶部</td>
</tr>
<tr>
<td><code>M</code></td>
<td>medium</td>
<td>屏幕中部</td>
</tr>
<tr>
<td><code>L</code></td>
<td>low</td>
<td>屏幕底部</td>
</tr>
</tbody></table>
<h2 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>助记</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>r</code></td>
<td>repalce</td>
<td>替换单个字符</td>
</tr>
<tr>
<td><code>~</code></td>
<td></td>
<td>改变字符大小写</td>
</tr>
<tr>
<td><code>x</code> <code>5x</code></td>
<td></td>
<td>删除字符</td>
</tr>
<tr>
<td><code>dw</code> <code>5dw</code></td>
<td>delete word</td>
<td>删除单词</td>
</tr>
<tr>
<td><code>db</code> <code>5db</code></td>
<td>delete befor</td>
<td>向前删除单词</td>
</tr>
<tr>
<td><code>dd</code> <code>5dd</code></td>
<td>delete</td>
<td>删除整行</td>
</tr>
<tr>
<td><code>d^</code> <code>d$</code></td>
<td>delete</td>
<td>删除到行首/行尾</td>
</tr>
<tr>
<td><code>d1G</code> <code>dG</code></td>
<td>delete</td>
<td>删除到第一行/最后一行</td>
</tr>
<tr>
<td><code>yw</code> <code>5yw</code></td>
<td>yank word</td>
<td>复制单词</td>
</tr>
<tr>
<td><code>yy</code> <code>5yy</code></td>
<td>yank</td>
<td>复制整行</td>
</tr>
<tr>
<td><code>y^</code> <code>y$</code></td>
<td>yank</td>
<td>复制到行首/行尾</td>
</tr>
<tr>
<td><code>&gt;&gt;</code> <code>&lt;&lt;</code></td>
<td></td>
<td>单行缩进</td>
</tr>
<tr>
<td><code>p</code> <code>P</code></td>
<td>paste</td>
<td>黏贴(光标后/光标前)</td>
</tr>
<tr>
<td><code>J</code></td>
<td>join</td>
<td>将下一行合并到当前行</td>
</tr>
<tr>
<td><code>u</code></td>
<td>undo</td>
<td>撤销更改/撤销输入</td>
</tr>
<tr>
<td><code>ctrl+r</code></td>
<td>redo</td>
<td>恢复</td>
</tr>
<tr>
<td><code>ctrl+r</code></td>
<td>redo</td>
<td>恢复</td>
</tr>
<tr>
<td><code>.</code></td>
<td></td>
<td>重复编辑动作</td>
</tr>
</tbody></table>
<h2 id="视图模式"><a href="#视图模式" class="headerlink" title="视图模式"></a>视图模式</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>助记</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>v</code></td>
<td>visual</td>
<td>进入视图模式</td>
</tr>
<tr>
<td><code>&gt;</code> <code>&lt;</code></td>
<td></td>
<td>代码缩进</td>
</tr>
<tr>
<td><code>d</code> <code>y</code></td>
<td>delete yank</td>
<td>剪切/复制</td>
</tr>
<tr>
<td><code>~</code></td>
<td></td>
<td>改变大小写</td>
</tr>
</tbody></table>
<h2 id="查找与替换"><a href="#查找与替换" class="headerlink" title="查找与替换"></a>查找与替换</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>助记</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>/str</code></td>
<td></td>
<td>查找str</td>
</tr>
<tr>
<td><code>n</code> <code>N</code></td>
<td>next</td>
<td>查找下一个/上一个</td>
</tr>
<tr>
<td><code>:s/old/new/g</code></td>
<td>start…go</td>
<td>所在行old替换为new</td>
</tr>
<tr>
<td><code>:n1,n2s/old/new/g</code></td>
<td>start…go</td>
<td>n1-n2行old替换为new</td>
</tr>
<tr>
<td><code>:0,$/old/new/g</code></td>
<td>start…go</td>
<td>全文old替换为new</td>
</tr>
<tr>
<td><code>:%s/old/new/g</code></td>
<td>start…go</td>
<td>全文old替换为new</td>
</tr>
<tr>
<td><code>:n1,n2s/^/\/\//g</code></td>
<td><code>^</code> 行首 <code>/</code> 转义</td>
<td>行首替换为//, 即注释掉</td>
</tr>
</tbody></table>
<h2 id="保存与退出"><a href="#保存与退出" class="headerlink" title="保存与退出"></a>保存与退出</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>助记</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>esc</code></td>
<td></td>
<td>返回命令模式</td>
</tr>
<tr>
<td><code>:wq</code> <code>:wq!</code></td>
<td>write &amp; quit</td>
<td>保存并退出</td>
</tr>
<tr>
<td><code>:q</code> <code>:q!</code></td>
<td>quit  <code>!</code> sudo</td>
<td>退出</td>
</tr>
</tbody></table>
<h2 id="Vim-助记图-总有一款适合你"><a href="#Vim-助记图-总有一款适合你" class="headerlink" title="Vim 助记图, 总有一款适合你"></a>Vim 助记图, 总有一款适合你</h2><ul>
<li><p><a href="http://vim.rtorr.com/lang/zh_cn/">中文版 Vim Cheat Sheet</a> 网页版, 支持多语言</p>
</li>
<li><p><a href="http://vimsheet.com/">A Great Vim Cheat Sheet</a> 网页版</p>
</li>
<li><p><a href="http://www.viemu.com/a_vi_vim_graphical_cheat_sheet_tutorial.html">Graphical vi-vim Cheat Sheet and Tutorial</a><br><img src="http://www.viemu.com/vi-vim-cheat-sheet.gif" alt="vi/vim graphical cheat sheet"></p>
</li>
<li><p><a href="http://vimcheatsheet.com/">Beautiful Vim Cheat-Sheet</a><br><img src="https://cdn.shopify.com/s/files/1/0165/4168/files/preview.png" alt="Vim Cheat-Sheet Preview"></p>
</li>
<li><p><a href="https://www.gosquared.com/blog/vi-linux-terminal-help-sheet">VI (Linux Terminal) Help Sheet</a><br><img src="https://downloads.gosquared.com/help_sheets/10/VI-Help-Sheet-large.jpg" alt="VI Help Sheet"></p>
</li>
<li><p><a href="http://blog.vgod.tw/2009/12/08/vim-cheat-sheet-for-programmers/">給程式設計師的Vim入門圖解說明</a><br><img src="http://blog.vgod.tw.s3.amazonaws.com/wp-content/uploads/2009/12/vim-cheat-sheet-diagram.png" alt="Vim入門圖解說明"></p>
</li>
<li><p><a href="http://linux.vbird.org/linux_basic/0310vi.php">vim极简中文示意图</a>-&gt;<code>9.3.6 vim 常用指令示意图</code><br><img src="https://draapho.github.io/images/1604/vimCheatSheet.jpg" alt="vim极简中文示意图"></p>
</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shortcut</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>stm32选型及资料搜索指南</title>
    <url>/2016/10/01/1605-Stm32Selection/</url>
    <content><![CDATA[<h1 id="stm32选型及手册搜索"><a href="#stm32选型及手册搜索" class="headerlink" title="stm32选型及手册搜索"></a>stm32选型及手册搜索</h1><ul>
<li>进入搜索网页<a href="http://www.st.com/content/st_com/en/products/microcontrollers.html">STM选型</a></li>
<li>在搜索框输入指定型号, 点击进入具体型号的页面. 如<a href="http://www.st.com/content/st_com/en/products/microcontrollers/stm32-32-bit-arm-cortex-mcus/stm32f1-series/stm32f103/stm32f103rc.html">STM32F103RC</a></li>
<li><a href="http://www.st.com/content/ccc/resource/technical/document/datasheet/59/f6/fa/84/20/4e/4c/59/CD00191185.pdf/files/CD00191185.pdf/jcr:content/translations/en.CD00191185.pdf">DS5792</a> -  <strong>DataSheet, 数据手册. 电气参数详解, 软硬件必备</strong></li>
<li><a href="http://www.st.com/content/ccc/resource/technical/document/reference_manual/59/b9/ba/7f/11/af/43/d5/CD00171190.pdf/files/CD00171190.pdf/jcr:content/translations/en.CD00171190.pdf">RM0008</a> - <strong>Reference Manuals, 参考手册. 寄存器详解. 软件开发必备</strong></li>
<li><a href="http://www.st.com/content/ccc/resource/technical/document/application_note/a2/9c/07/d9/2a/b2/47/dc/CD00004479.pdf/files/CD00004479.pdf/jcr:content/translations/en.CD00004479.pdf">AN1709</a> - <strong>Application Notes, 应用指南. 需要仔细看这类文档</strong>. 是针对具体问题的指南, 如这一篇是EMC设计指南</li>
<li><a href="http://www.st.com/content/ccc/resource/technical/document/programming_manual/10/98/e8/d4/2b/51/4b/f5/CD00283419.pdf/files/CD00283419.pdf/jcr:content/translations/en.CD00283419.pdf">PM0075</a> - Programming Manuals, 烧录手册. 介绍擦写flash相关的流程和寄存器</li>
<li><a href="http://www.st.com/content/ccc/resource/technical/document/errata_sheet/f5/50/c9/46/56/db/4a/f6/CD00197763.pdf/files/CD00197763.pdf/jcr:content/translations/en.CD00197763.pdf">ES0340</a> - Errata Sheets, 勘误表. 遇到非常奇怪的问题时, 可以先来看看勘误表, 是否源文件就是错的!</li>
<li><a href="http://www.st.com/content/ccc/resource/technical/document/technical_note/92/30/3c/a1/4c/bb/43/6f/DM00103228.pdf/files/DM00103228.pdf/jcr:content/translations/en.DM00103228.pdf">TN1163</a> - Technical Notes &amp; Articles, 技术指南, 存储焊接, 开发工具配置之类的解答. <strong>生产必备</strong></li>
<li><a href="http://www.st.com/content/ccc/resource/technical/document/user_manual/f9/4a/8d/e6/b8/20/4a/46/DM00062592.pdf/files/DM00062592.pdf/jcr:content/translations/en.DM00062592.pdf">UM1561</a> - User Manuals, 对官方开发板或开发工具的用户说明书</li>
</ul>
<h1 id="其它设计资料的搜索"><a href="#其它设计资料的搜索" class="headerlink" title="其它设计资料的搜索"></a>其它设计资料的搜索</h1><ul>
<li>根据型号并不能找出期望的文档. 譬如需要一份电源设计参考.</li>
<li>进去搜索网页<a href="http://www.st.com/content/st_com/en/products/microcontrollers.html">STM选型</a></li>
<li>在搜索框输入关键词<code>hardware power</code>, 在搜索结果页面, 选择<code>Resouces</code>标签</li>
<li>这里第一条就是 <a href="http://www.st.com/content/ccc/resource/technical/document/application_note/87/b8/0f/5e/ab/d0/4f/2d/DM00071779.pdf/files/DM00071779.pdf/jcr:content/translations/en.DM00071779.pdf">AN4218: Hardware design guideline power supply and voltage measurement</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 软件系列-基于NFS的家庭网</title>
    <url>/2016/10/03/1606-WinSoft-cloud/</url>
    <content><![CDATA[<h1 id="家庭网设想"><a href="#家庭网设想" class="headerlink" title="家庭网设想"></a>家庭网设想</h1><h2 id="理想的云"><a href="#理想的云" class="headerlink" title="理想的云"></a>理想的云</h2><ul>
<li>理想的家庭网是由NAS做数据中心, 是家里的云</li>
<li>需要使用千兆网来支持数据分享(如视频流)</li>
<li>考虑到设备多样性, 可使用多种分享模式, 如NFS, windows共享服务等等</li>
<li>理想很丰满, 现实很骨干. 由于预算, 稳定性, 易用性等问题, 多半会用折中方案</li>
<li>可以看看混乱的方案推荐: <a href="https://www.zhihu.com/question/20791825">如何实现一个简单的家庭云存储（NAS）系统？</a></li>
</ul>
<h2 id="现实的云"><a href="#现实的云" class="headerlink" title="现实的云"></a>现实的云</h2><ul>
<li>理想之所以遥远, 往往是因为没有明确需求, 导致什么都想要! 所以, 先明确需求<ul>
<li>NAS是用来折腾和看电影的(电影存在硬盘上, 能在沙发上和床上观影).</li>
<li>日常资料还是存储在本地硬盘比较便捷</li>
<li>有安全需求, 要备份或镜像本地资料到家庭云(<strong>双设备备份</strong>, 相比NAS的各种RAID, 一大优势是<strong>防偷</strong>)</li>
<li>做嵌入式开发, 需要在windows上装linux虚拟机, 然后数据共享</li>
<li>关键数据出问题时, 在可靠和有把握的环境下来恢复数据.</li>
</ul>
</li>
<li>给出最终使用的方案. 折腾记就不写在此文了.<ul>
<li>使用 Intel NUC 作为桌面主机和云服务器. 小巧, 够用(不玩游戏), 省电.</li>
<li>使用 Hyper-V 安装 家用NAS 和 Ubuntu.</li>
<li>另有嵌入式linux开发板, 投影仪, 手机等设备需要和云交换数据.</li>
<li>使用 <a href="https://www.hanewin.net/nfs-e.htm">HaneWIN</a> 向其它设备提供NFS服务</li>
<li>使用 <a href="http://www.freefilesync.org/">freefilesync</a> 备份资料到移动硬盘(和理想中的备份方式差好多…)</li>
</ul>
</li>
</ul>
<h2 id="方案更新-2021年3月"><a href="#方案更新-2021年3月" class="headerlink" title="方案更新(2021年3月)"></a>方案更新(2021年3月)</h2><ul>
<li>基于NUC, 安装OpenMediaVault.</li>
<li>路由器使用 Ubiquiti AmpliFi.</li>
</ul>
<h1 id="HaneWIN"><a href="#HaneWIN" class="headerlink" title="HaneWIN"></a><a href="https://www.hanewin.net/nfs-e.htm">HaneWIN</a></h1><ul>
<li><a href="https://www.hanewin.net/nfs-e.htm">HaneWIN</a> 可免费试用30天. 适合做win下的nfs服务器.</li>
<li>如果要免费软件, 可尝试 <a href="https://sourceforge.net/projects/freenfs/">FreeNFS</a>. 功能较弱. 可参考<a href="https://wenku.baidu.com/view/b9dccaedf8c75fbfc77db2c1.html?from=search">FreeNFS简易教程</a>.</li>
<li>需要支持嵌入式linux端的NFS(只支持NFS v2), 配置见图:<br><img src="https://draapho.github.io/images/1606/haneWIN_NFS.PNG" alt="haneWIN_NFS"></li>
<li>务必使用<code>UTF-8 character set</code><br><img src="https://draapho.github.io/images/1606/haneWIN_Server.PNG" alt="haneWIN_Server"></li>
<li>重点说一下<code>Exports</code>这一块, 即把文件通过NFS分享出去.<br><img src="https://draapho.github.io/images/1606/haneWIN_Exports.PNG" alt="haneWIN_Exports"><ul>
<li><code>E:\Downloads -name:Downloads 10.0.0.99</code><br>就是把本地<code>Downloads</code>文件夹分享给<code>ip=10.0.0.99</code>的机器, 对外名称为<code>Downloads</code></li>
<li><code>-mapall:0:0</code> 是提供给linux端root权限. (这句最短? 花了一周时间才实验成功啊…)</li>
<li><code>-range 10.0.0.1 10.0.0.111</code> 是设置ip范围, 这里是从<code>10.0.0.1</code>-<code>10.0.0.111</code></li>
<li>语法规则不多, 详见<a href="https://www.hanewin.net/doc/nfs/nfsd.htm">官网说明</a>. 可用参数如下:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The following options are supported:</span><br><span class="line">-name:&lt;sharename&gt;   assigns a name to the exported path as an alternate name for mounting.</span><br><span class="line">-alldirs    allows the host(s) to mount at any point within the filesystem.</span><br><span class="line">-umask:&lt;mask&gt;   set the umask for group and world permissions on the filesystem, default 022</span><br><span class="line">-readonly   limits access to reading</span><br><span class="line">-public Enables WebNFS access.</span><br><span class="line">-lowercase  maps all file names to lowercase, otherwise case is preserved.</span><br><span class="line">-exec   forces in access rights the x bit for all files.</span><br><span class="line">-mapall:&lt;uid&gt;[:&lt;gid&gt;]   all Unix user-ids and group-ids are mapped to the specified user-id and group-id.</span><br><span class="line">-maproot:&lt;uid&gt;[:&lt;gid&gt;]  the Unix super user root is mapped to the specified user-id, group-id. Without a mapping entry root will be mapped to user and group nobody.</span><br><span class="line">-range  IP adresses are interpreted in pairs as from-to ranges enabling client access from all addresses in a range (more flexible than the unix -net -mask options).</span><br></pre></td></tr></table></figure></li>
<li>再举几个例子:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># exports example</span><br><span class="line">c:\ftp -range 192.168.1.1 192.168.1.10</span><br><span class="line">c:\public -public -readonly</span><br><span class="line">c:\tools -readonly 192.168.1.4</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>如果NFS被成功加载, 那么会在<code>Mounts</code>页显示出来<br><img src="https://draapho.github.io/images/1606/haneWIN_Mounts.PNG" alt="haneWIN_Mounts"></li>
<li>参考<ul>
<li><a href="http://www.nasyun.com/thread-25086-1-1.html">GEN8折腾日记-第三方NFS工具 hanewin 设置(需登录)</a></li>
<li><a href="http://wenku.baidu.com/view/c78baefefad6195f302ba665.html">GEN8折腾日记-第三方NFS工具 hanewin 设置(百度文库)</a></li>
<li><a href="https://www.chiphell.com/thread-1240623-1-1.html">群晖加载Windows NFS文件</a></li>
</ul>
</li>
</ul>
<h1 id="Hyper-V"><a href="#Hyper-V" class="headerlink" title="Hyper-V"></a>Hyper-V</h1><ul>
<li>从Win8开始, Hyper-V是Windows自带的软件.</li>
<li>启用Hper-V, <code>控制面板</code>-&gt;<code>程序和功能</code>-&gt;<code>启用或关闭Windows功能</code>-&gt;<code>Hyper-V</code><br><img src="https://draapho.github.io/images/1606/HyperV_Enable.PNG" alt="HyperV_Enable"></li>
<li>设置虚拟网络<br><img src="https://draapho.github.io/images/1606/HyperV_NIC1.PNG" alt="HyperV_NIC1"><br><img src="https://draapho.github.io/images/1606/HyperV_NIC2.PNG" alt="HyperV_NIC2"></li>
<li>新建虚拟机<br><img src="https://draapho.github.io/images/1606/HyperV_Install1.png" alt="HyperV_Install1"><br><img src="https://draapho.github.io/images/1606/HyperV_Install2.png" alt="HyperV_Install2"><br><img src="https://draapho.github.io/images/1606/HyperV_Install3.png" alt="HyperV_Install3"></li>
<li>安装Ubuntu 32位服务器版本, 用于交叉编译. (另一个备选方案是用cygwin)</li>
<li>安装家用NAS, 用于多设备(投影仪, 平板, 手机)看硬盘上的影片.</li>
</ul>
<h1 id="NAS和智能路由器"><a href="#NAS和智能路由器" class="headerlink" title="NAS和智能路由器"></a>NAS和智能路由器</h1><h2 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h2><ul>
<li>NAS, Network Attached Storage. 家用的话, 大多定位于多媒体观赏和数据备份两个核心功能.</li>
<li>专做NAS的厂家, <a href="https://www.synology.com/">Synology(群晖)</a> 和 <a href="https://www.qnap.com/">QNAP(威联通)</a> 比较有名</li>
<li>智能路由器, 从小米路由器到airport extreme.</li>
<li>两者区别的话, 就是一个更专业, 一个更娱乐.<br>所谓专业, 就是更多的权限设置和管理(对用户不友好), 更多的功能, 更高的安全要求.<br>所谓娱乐, 就是傻瓜易上手, 能用好用为主要需求.<br>简而言之, 一个是专业单反, 一个是傻瓜机, 然后有一些就是处于中间位置的微单…</li>
</ul>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul>
<li>大多数的家庭, 对此类产品的第一要求就是<strong>好用</strong>. 只有Geek一类的人需要<strong>好玩</strong>.</li>
<li>NAS在宣传上, 必然会强调数据安全, 列出诸如支持多种RAID这种让非专业人士云里雾里的概念.</li>
<li>而普通家庭最大的数据安全问题就是数据过于集中, 防偷防意外损坏之类的风险防范反而不足了.</li>
<li>因此, 家用云市场应该侧重于易于配置和使用. 家庭的数据安全问题不是靠一台专业NAS设备就能解决的.</li>
<li>结论: 在家用市场, 智能路由器有更好的市场前景.</li>
</ul>
<h2 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h2><ul>
<li>家庭环境的话, 建议用移动硬盘备份关键资料(即RAID1), 然后分开存储, 当然也可以基于SFTP等服务自动备份. 这样可以做到物理上相对独立, 而且因为用的是RAID1, 数据出问题后的恢复也非常简单.</li>
<li>中小企业就需要用到稍微专业一点的NAS才比较好了. 话说, 很多本土企业对数据安全这一块很不上心啊…</li>
<li>推荐完全免费的同步软件<a href="http://www.freefilesync.org/">freefilesync</a>, 买块硬盘, 家用足够了.</li>
</ul>
<h2 id="个人推荐"><a href="#个人推荐" class="headerlink" title="个人推荐"></a>个人推荐</h2><ul>
<li>听说过家庭云, 不知道具体需求, 买个便宜的小米路由器先体验体验.</li>
<li>苹果爱好者直接上 airport extreme, 二千元可以给手机平板太多额外的存储空间了.</li>
<li>想要玩NAS的, 可以先用虚拟机装了体验一下效果.</li>
<li>如果买专业的NAS, 推荐直接用企业入门级产品QNAP的<code>TS-251</code>或<code>TS-253 Pro</code>,内置虚拟机, 可玩性很高.</li>
<li>群晖的机器不太推荐, 因为数据的存储格式很奇怪, 万一出点问题自己一点办法也没有!</li>
<li>组装机也不是太推荐, 因为功耗美观服务都要考虑进去.</li>
</ul>
<h1 id="同步软件freefilesync"><a href="#同步软件freefilesync" class="headerlink" title="同步软件freefilesync"></a>同步软件<a href="http://www.freefilesync.org/">freefilesync</a></h1><ul>
<li><a href="http://www.freefilesync.org/">freefilesync</a>是一款完全免费的同步软件, 可以完全媲美GoodSync</li>
<li>支持sftp, 所以也可以通过网络自动备份数据</li>
<li>家庭用户使用RAID1, 即关键资料双硬盘完整备份, 然后分开存放就足够了.</li>
</ul>
<h1 id="远程开机"><a href="#远程开机" class="headerlink" title="远程开机"></a>远程开机</h1><p>如果是7x24小时开机当服务器用, 则不用考虑这一块. 远程开机是针对虚拟机和组装机用户说的.</p>
<h2 id="LAN唤醒"><a href="#LAN唤醒" class="headerlink" title="LAN唤醒"></a>LAN唤醒</h2><ul>
<li>LAN唤醒需要主板的支持, 不支持无线网络, 必须使用有线. 新一点的机器一般都能支持.</li>
<li>启用主板的WOL功能<ul>
<li>开机进入BIOS, 寻找<code>wake on lan``resume on lan``power on PME``power on by PCI-E device``Power on by Onboard LAN</code>等与电源管理和唤醒有关的选项并使能</li>
</ul>
</li>
<li>设置网卡驱动<ul>
<li><code>设备管理器</code>-&gt;<code>网络适配器</code>-&gt;选择有线网卡设备-&gt;右键<code>属性</code>-&gt;在<code>高级</code>和<code>电源管理</code>标签下-&gt;启用<code>唤醒模式``唤醒魔包``幻数据包``唤醒计算机</code>之类的选项</li>
</ul>
</li>
<li>配置 WIN10 WOL(Wake on Lan 远程唤醒) 最大的坑就是要关闭 “启用快速启动(推荐)”, 而默认是打开的. 另外,<ul>
<li><code>控制面板</code>-&gt;<code>硬件和声音</code>-&gt;<code>电源选项</code>-&gt;左边栏<code>选择电源按钮的功能</code>-&gt;弹出<code>系统设置</code>页面-&gt;<code>关机设置</code>-&gt;<del><code>启用快速启动(推荐)</code></del></li>
</ul>
</li>
<li>电脑非正常关机后, 是无法远程唤醒的.</li>
<li>建议分级测试.<ol>
<li>可以先确定bios配置正确. 配置好bios, 进入winPE之类的系统, 选择关机, 看WOL是否起作用.</li>
<li>然后进入win10配置网卡的相关选项, 然后让机器进入睡眠模式, 看WOL是否起作用.</li>
<li>最后win10关机, 测试WOL是否起作用.</li>
<li>“启用快速启动(推荐)”, 位于 控制面板\硬件和声音\电源选项\唤醒时需要密码(系统设置)\关机设置.</li>
<li>注意: bios设置内关于PCI节能的设置特别注意, 考虑全部关闭</li>
</ol>
</li>
<li>Android端WOL软件推荐. <code>Wake On LAN</code> 配置简单, 界面友好.</li>
<li>参考链接<ul>
<li><a href="https://www.teamviewer.com/zhCN/res/pdf/Teamviewer9-Manual-Wake-on-LAN-zhCN.pdf">TeamViewer手册-LAN唤醒</a></li>
<li><a href="http://www.iplaysoft.com/wol.html">WOL 网络唤醒远程开机设置方法教程 + 多款软件下载！(手机远程开启电脑)</a></li>
</ul>
</li>
</ul>
<h2 id="WAN远程唤醒"><a href="#WAN远程唤醒" class="headerlink" title="WAN远程唤醒"></a>WAN远程唤醒</h2><ul>
<li>WAN远程唤醒的前提是配置好LAN唤醒.</li>
<li>需要设置路由器, 设置过程非常复杂, 而且免费的不稳定.</li>
<li>我买了向日葵开机棒, 但实际体验不好. 一是向日葵的服务器不太稳定, 而是远程操作意义不大, 纯玩性质.</li>
<li>所以, 建议普通用户不用折腾这块了. 真有异地工作, 资料同步的需求, 用公共云, github, BitBucket都很好.</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>NFS</tag>
        <tag>Hyper-V</tag>
        <tag>NAS</tag>
        <tag>freefilesync</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows快捷键</title>
    <url>/2016/10/08/1607-CheatSheet-win/</url>
    <content><![CDATA[<h1 id="专用快捷键"><a href="#专用快捷键" class="headerlink" title="专用快捷键"></a>专用快捷键</h1><table>
<thead>
<tr>
<th>atom</th>
<th>备注</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ctrl-shift-p</code></td>
<td>palette</td>
<td>调出命令板</td>
</tr>
<tr>
<td><code>ctrl-alt-i</code></td>
<td>information</td>
<td>调用控制台</td>
</tr>
<tr>
<td><code>ctrl-,</code></td>
<td></td>
<td>打开设置面板</td>
</tr>
<tr>
<td><code>ctrl-.</code></td>
<td>非编辑区有效</td>
<td>调试快捷键</td>
</tr>
<tr>
<td>+<code>ctrl-f6</code></td>
<td>merge-conflicts</td>
<td>显示有冲突的文件</td>
</tr>
<tr>
<td>+<code>shift-f6</code></td>
<td>merge-conflicts</td>
<td>显示下一个冲突</td>
</tr>
<tr>
<td>+<code>ctrl-shift-f6</code></td>
<td>merge-conflicts</td>
<td>显示上一个冲突</td>
</tr>
<tr>
<td><strong>eclipse</strong></td>
<td><strong>备注</strong></td>
<td><strong>说明</strong></td>
</tr>
<tr>
<td><code>ctrl-o</code></td>
<td></td>
<td>显示函数列表</td>
</tr>
<tr>
<td><code>ctrl-shift-o</code></td>
<td></td>
<td>自动处理 include/import</td>
</tr>
<tr>
<td><code>alt-shift-s</code></td>
<td>source</td>
<td>显示代码常用操作</td>
</tr>
<tr>
<td><code>alt-/</code></td>
<td></td>
<td>代码提示</td>
</tr>
<tr>
<td>+ <code>ctrl \</code></td>
<td><del><code>ctrl-tab</code></del></td>
<td>切换<code>.c``.h</code>文件</td>
</tr>
<tr>
<td>+ <code>alt-\</code></td>
<td><code>alt-shift-a</code></td>
<td>列选模式</td>
</tr>
<tr>
<td>+ <code>ctrl-f3</code></td>
<td><code>ctrl-1</code></td>
<td>快速修复</td>
</tr>
<tr>
<td>+ <code>alt-shift-f</code></td>
<td><code>ctrl-shift-t</code></td>
<td>查找类</td>
</tr>
</tbody></table>
<h1 id="编辑器快捷键"><a href="#编辑器快捷键" class="headerlink" title="编辑器快捷键"></a>编辑器快捷键</h1><table>
<thead>
<tr>
<th>文件操作</th>
<th>助记</th>
<th>说明</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td><code>ctrl-n</code></td>
<td>new</td>
<td>创建文件</td>
<td>windows</td>
</tr>
<tr>
<td><code>ctrl-o</code></td>
<td>open</td>
<td>打开文件</td>
<td>windows</td>
</tr>
<tr>
<td><code>ctrl-s</code></td>
<td>save</td>
<td>保存</td>
<td>windows</td>
</tr>
<tr>
<td><code>ctrl-shift-s</code></td>
<td>save</td>
<td>保存所有</td>
<td>notepad++</td>
</tr>
<tr>
<td><code>ctrl-w</code></td>
<td>windows</td>
<td>关闭当前页</td>
<td>windows</td>
</tr>
<tr>
<td><code>ctrl-shift-w</code></td>
<td>windows</td>
<td>关闭其它页面</td>
<td>custom</td>
</tr>
<tr>
<td><code>ctrl-shift-t</code></td>
<td>tags</td>
<td>恢复关闭的文件</td>
<td>notepad++</td>
</tr>
<tr>
<td><code>ctrl-tab</code></td>
<td>tab</td>
<td>下一个标签</td>
<td>notepad++</td>
</tr>
<tr>
<td><code>ctrl-shift-tab</code></td>
<td>tab</td>
<td>上一个标签</td>
<td>notepad++</td>
</tr>
<tr>
<td><code>f1</code></td>
<td></td>
<td>help</td>
<td>windows</td>
</tr>
<tr>
<td><code>ctrl-f1</code></td>
<td></td>
<td>google搜索选定内容</td>
<td>custom</td>
</tr>
<tr>
<td><strong>文件编辑</strong></td>
<td><strong>助记</strong></td>
<td><strong>说明</strong></td>
<td><strong>来源</strong></td>
</tr>
<tr>
<td><code>ctrl-a</code></td>
<td>all</td>
<td>全部选中</td>
<td>windows</td>
</tr>
<tr>
<td><code>ctrl-c</code></td>
<td>copy</td>
<td>复制</td>
<td>windows</td>
</tr>
<tr>
<td><code>ctrl-shift-c</code></td>
<td>copy</td>
<td>复制文档路径</td>
<td>atom</td>
</tr>
<tr>
<td><code>ctrl-d</code></td>
<td>delete</td>
<td>删除</td>
<td>custom</td>
</tr>
<tr>
<td><code>ctrl-shift-d</code></td>
<td>delete</td>
<td>删除当前行</td>
<td>custom</td>
</tr>
<tr>
<td><code>ctrl-</code> <code>h</code> <code>j</code> <code>k</code> <code>l</code></td>
<td>vim</td>
<td>上下左右</td>
<td>custom</td>
</tr>
<tr>
<td><code>ctrl-shift-h</code> <code>ctrl-←</code></td>
<td>vim h</td>
<td>左移到词首</td>
<td>custom / sublime</td>
</tr>
<tr>
<td><code>ctrl-shift-l</code> <code>ctrl-→</code></td>
<td>vim l</td>
<td>右移到词尾</td>
<td>custom / sublime</td>
</tr>
<tr>
<td><code>ctrl-shift-j</code> <code>ctrl-↓</code></td>
<td>vim j</td>
<td>向下移行</td>
<td>custom / sublime</td>
</tr>
<tr>
<td><code>ctrl-shift-k</code> <code>ctrl-↑</code></td>
<td>vim k</td>
<td>向上移行</td>
<td>custom / sublime</td>
</tr>
<tr>
<td><code>alt-shift-j</code></td>
<td>vim J</td>
<td>合并行</td>
<td>custom</td>
</tr>
<tr>
<td><del><code>ctrl-t</code></del></td>
<td>禁用掉</td>
<td>避免<code>ctrl-y</code>失效</td>
<td>custom</td>
</tr>
<tr>
<td><code>ctrl-v</code></td>
<td>velcro</td>
<td>黏贴</td>
<td>windows</td>
</tr>
<tr>
<td><code>ctrl-shift-v</code></td>
<td>ctrl-v</td>
<td>复制当前行</td>
<td>custom</td>
</tr>
<tr>
<td><code>ctrl-x</code></td>
<td></td>
<td>剪切</td>
<td>windows</td>
</tr>
<tr>
<td><code>ctrl-shift-x</code></td>
<td>ctrl-x</td>
<td>剪切当前行</td>
<td>notepad++</td>
</tr>
<tr>
<td><code>ctrl-y</code> <code>ctrl-r</code></td>
<td>redo</td>
<td>恢复更改</td>
<td>windows / vim</td>
</tr>
<tr>
<td><code>ctrl-z</code> <code>ctrl-u</code></td>
<td>undo</td>
<td>撤销更改</td>
<td>windows / vim</td>
</tr>
<tr>
<td><code>ctrl-shift-y</code></td>
<td></td>
<td>下一个浏览记录</td>
<td>custom</td>
</tr>
<tr>
<td><code>ctrl-shift-z</code></td>
<td></td>
<td>上一个浏览记录</td>
<td>custom</td>
</tr>
<tr>
<td><code>alt-鼠标</code> <code>alt-\</code></td>
<td></td>
<td>列选模式</td>
<td>notepad++ / custom</td>
</tr>
<tr>
<td><code>ctrl-enter</code></td>
<td>enter</td>
<td>下面新增一行</td>
<td>sublime</td>
</tr>
<tr>
<td><code>ctrl-shift-enter</code></td>
<td>enter</td>
<td>上面新增一行</td>
<td>sublime</td>
</tr>
<tr>
<td><code>tab</code> <code>shift-tab</code></td>
<td></td>
<td>插入缩进/删除缩进</td>
<td>notepad++</td>
</tr>
<tr>
<td><code>ctrl-^</code></td>
<td>vim</td>
<td>移到行首</td>
<td>custom</td>
</tr>
<tr>
<td><code>ctrl-shift-^</code></td>
<td>vim</td>
<td>选到行首</td>
<td>custom</td>
</tr>
<tr>
<td><code>ctrl-$</code></td>
<td>vim</td>
<td>移到行尾</td>
<td>custom</td>
</tr>
<tr>
<td><code>ctrl-shift-$</code></td>
<td>vim</td>
<td>选到行尾</td>
<td>custom</td>
</tr>
<tr>
<td><strong>查找与替换</strong></td>
<td><strong>助记</strong></td>
<td><strong>说明</strong></td>
<td><strong>来源</strong></td>
</tr>
<tr>
<td><code>ctrl-f</code></td>
<td>find</td>
<td>查找</td>
<td>windows</td>
</tr>
<tr>
<td><code>ctrl-shift-f</code></td>
<td>find</td>
<td>多文件查找</td>
<td>sublime</td>
</tr>
<tr>
<td><code>f3</code> <code>shift-f3</code></td>
<td></td>
<td>查找下一个 / 查找上一个</td>
<td>windows</td>
</tr>
<tr>
<td><code>ctrl-f3</code></td>
<td></td>
<td>选中所有匹配的关键字</td>
<td>custom</td>
</tr>
<tr>
<td><code>ctrl-m</code></td>
<td>mark</td>
<td>打标记</td>
<td>custom</td>
</tr>
<tr>
<td><code>f2</code> <code>shift-f2</code></td>
<td>tag</td>
<td>下一个标记/上一个标记</td>
<td>notepad++</td>
</tr>
<tr>
<td><code>ctrl-f2</code></td>
<td>tag</td>
<td>显示所有标签</td>
<td>custom</td>
</tr>
<tr>
<td><code>ctrl-shift-f2</code></td>
<td>tag</td>
<td>清空所有标签</td>
<td>custom</td>
</tr>
<tr>
<td><code>ctrl-.</code></td>
<td>..</td>
<td>TAB转为空格</td>
<td>custom</td>
</tr>
<tr>
<td><code>ctrl-shift-.</code></td>
<td>&gt;&gt;</td>
<td>空格转为TAB</td>
<td>custom</td>
</tr>
<tr>
<td><strong>代码专用</strong></td>
<td><strong>助记</strong></td>
<td><strong>说明</strong></td>
<td><strong>来源</strong></td>
</tr>
<tr>
<td><code>ctrl-b</code></td>
<td>beautify</td>
<td>格式化代码</td>
<td>custom</td>
</tr>
<tr>
<td><code>ctrl-shift-m</code></td>
<td>markdown</td>
<td>markdown预览</td>
<td>atom</td>
</tr>
<tr>
<td><code>alt-0</code> <code>alt-shift-0</code></td>
<td>0-9</td>
<td>折叠代码/展开代码</td>
<td>notepad++</td>
</tr>
<tr>
<td><code>ctrl-[</code> <code>ctrl-]</code></td>
<td></td>
<td>移动/全选对应括号</td>
<td>custom</td>
</tr>
<tr>
<td><code>ctrl-鼠标</code> <code>shift-鼠标</code></td>
<td></td>
<td>跳转</td>
<td>eclipse / custom</td>
</tr>
<tr>
<td><code>f4</code> <code>shift-f4</code></td>
<td></td>
<td>跳转 / 跳回</td>
<td>custom</td>
</tr>
<tr>
<td><code>f5</code></td>
<td>run</td>
<td>运行</td>
<td>notepad++</td>
</tr>
<tr>
<td><code>f6</code></td>
<td></td>
<td>比较文件</td>
<td>custom</td>
</tr>
<tr>
<td><code>ctrl-/</code></td>
<td><code>//</code></td>
<td>单行注释翻转</td>
<td>eclipse</td>
</tr>
<tr>
<td><code>ctrl-shift-/</code></td>
<td><code>/*</code></td>
<td>多行注释</td>
<td>eclipse</td>
</tr>
<tr>
<td><code>ctrl-shift-\</code></td>
<td><code>/*</code></td>
<td>取消多行注释</td>
<td>eclipse</td>
</tr>
<tr>
<td><code>ctrl-~</code></td>
<td></td>
<td>打开终端</td>
<td>sublime</td>
</tr>
</tbody></table>
<h1 id="Win系统快捷键"><a href="#Win系统快捷键" class="headerlink" title="Win系统快捷键"></a>Win系统快捷键</h1><table>
<thead>
<tr>
<th>Listary</th>
<th>助记</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>win-~</code></td>
<td></td>
<td>打开Listary</td>
</tr>
<tr>
<td><code>enter</code></td>
<td>enter</td>
<td>打开文件</td>
</tr>
<tr>
<td><code>ctrl-enter</code></td>
<td>enter</td>
<td>打开路径</td>
</tr>
<tr>
<td><code>ctrl-c</code></td>
<td>copy</td>
<td>复制</td>
</tr>
<tr>
<td><code>ctrl-shift-c</code></td>
<td>copy</td>
<td>复制路径</td>
</tr>
<tr>
<td><code>ctrl+j</code> <code>ctrl+k</code></td>
<td>vim j,k</td>
<td>下一个 / 上一个(需设置)</td>
</tr>
<tr>
<td><strong>Ditto</strong></td>
<td><strong>助记</strong></td>
<td><strong>文件夹/应用</strong></td>
</tr>
<tr>
<td><code>ctrl-1</code></td>
<td>list</td>
<td>打开ditto面板</td>
</tr>
<tr>
<td><code>enter</code></td>
<td>enter</td>
<td>黏贴</td>
</tr>
<tr>
<td><code>shift-enter</code></td>
<td>enter</td>
<td>纯文本黏贴</td>
</tr>
<tr>
<td><strong>AHK</strong></td>
<td><strong>助记</strong></td>
<td><strong>功能</strong></td>
</tr>
<tr>
<td><code>鼠标中键</code></td>
<td></td>
<td>复制</td>
</tr>
<tr>
<td><code>shift-鼠标中键</code></td>
<td></td>
<td>剪切</td>
</tr>
<tr>
<td><code>ctrl-shift-鼠标中键</code></td>
<td></td>
<td>复制当前路径</td>
</tr>
<tr>
<td><code>鼠标右键</code></td>
<td></td>
<td>首次黏贴</td>
</tr>
<tr>
<td><code>ctrl-鼠标右键</code></td>
<td></td>
<td>黏贴</td>
</tr>
<tr>
<td><code>ctrl-~</code></td>
<td></td>
<td>打开终端 (关联路径)</td>
</tr>
<tr>
<td><code>alt-win-鼠标中键</code></td>
<td></td>
<td>复制屏幕颜色</td>
</tr>
<tr>
<td><code>alt-win-←↑↓→</code></td>
<td></td>
<td>单像素移动鼠标</td>
</tr>
<tr>
<td><code>alt-win-d</code></td>
<td>date</td>
<td>输入当前日期</td>
</tr>
<tr>
<td><strong>AHK快捷方式</strong></td>
<td><strong>助记</strong></td>
<td><strong>文件夹/应用</strong></td>
</tr>
<tr>
<td><code>alt-a</code> <code>win-a</code></td>
<td>all / audio</td>
<td>我的电脑 / 音频处理软件</td>
</tr>
<tr>
<td><code>alt-b</code> <code>win-b</code></td>
<td>backup</td>
<td>backup / FreeFileSync</td>
</tr>
<tr>
<td><code>alt-c</code> <code>win-c</code></td>
<td>c盘 / caculate</td>
<td>c盘 / 计算器</td>
</tr>
<tr>
<td><code>alt-d</code> <code>win-d</code></td>
<td>download</td>
<td>download / 迅雷</td>
</tr>
<tr>
<td><code>alt-e</code> <code>win-e</code></td>
<td>e盘 / editor</td>
<td>e盘 / 编辑器</td>
</tr>
<tr>
<td><code>alt-f</code> <code>win-f</code></td>
<td>f盘 / find</td>
<td>f盘 / everything</td>
</tr>
<tr>
<td><code>alt-g</code> <code>win-g</code></td>
<td>green / google</td>
<td>绿色软件 / 浏览器</td>
</tr>
<tr>
<td><code>win-h</code></td>
<td>help</td>
<td>zeal 文档帮助</td>
</tr>
<tr>
<td><code>win-i</code></td>
<td>ie</td>
<td>IE核浏览器</td>
</tr>
<tr>
<td><code>win-j</code></td>
<td>记账</td>
<td>MoneyHome</td>
</tr>
<tr>
<td><code>alt-l</code> <code>win-l</code></td>
<td>life / look</td>
<td>life / 视频搜索</td>
</tr>
<tr>
<td><code>alt-m</code> <code>win-m</code></td>
<td>music</td>
<td>music / mcool</td>
</tr>
<tr>
<td><code>win-n</code></td>
<td>notepad</td>
<td>notepad++</td>
</tr>
<tr>
<td><code>alt-p</code> <code>win-p</code></td>
<td>picture</td>
<td>picture / Paint.Net</td>
</tr>
<tr>
<td><code>alt-s</code> <code>win-s</code></td>
<td>study / ScreenShot</td>
<td>study / 截屏</td>
</tr>
<tr>
<td><code>alt-v</code> <code>win-v</code></td>
<td>video</td>
<td>video / PotPlayer</td>
</tr>
<tr>
<td><code>alt-w</code> <code>win-w</code></td>
<td>work / word</td>
<td>work / word</td>
</tr>
<tr>
<td><code>win-x</code></td>
<td>虚拟机</td>
<td>Hyper-V</td>
</tr>
<tr>
<td><code>alt-y</code> <code>win-y</code></td>
<td>移动硬盘 / 翻译</td>
<td>y盘 / 有道词典</td>
</tr>
<tr>
<td><code>win-z</code></td>
<td>证券</td>
<td>证券</td>
</tr>
</tbody></table>
<h1 id="大致原则"><a href="#大致原则" class="headerlink" title="大致原则"></a>大致原则</h1><ul>
<li><code>ctrl</code> 基本操作</li>
<li><code>shift</code> 反向操作/块操作</li>
<li><code>alt</code> 处理文件-AHK使用</li>
<li><code>win</code> 打开应用-AHK使用</li>
<li><code>alt-win</code> 特殊应用-AHK使用</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>cheat sheet</tag>
        <tag>notepad++</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 软件系列-自定义环境变量</title>
    <url>/2016/10/09/1608-WinSoft-path/</url>
    <content><![CDATA[<h1 id="自定义环境变量"><a href="#自定义环境变量" class="headerlink" title="自定义环境变量"></a>自定义环境变量</h1><ul>
<li>测试过几个例子, 简单的调用没问题, 但带参调用就会有各种无法预料的问题.</li>
<li><code>ConEmu.lnk</code> 后面不支持带参数, <code>git-cmd.lnk</code> 支持带参, 但有奇怪现象.</li>
<li><code>Typora.lnk</code> <code>zeal.lnk</code> 没有问题.</li>
<li>使用此方法可以配合 <code>win-r</code> 快速打开文件夹, 软件等功能! 我没有使用, 因为有更好的替代方案.</li>
<li>!!!注意!!!, 带参调用 <code>.lnk</code> 不完全等同于 <code>.exe</code>, 还是没有linux的链接来的便捷</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>做软件开发是绕不过环境变量 <code>PATH</code> 的设置的, 经常到后来 <code>PATH</code> 就变得非常长, 难以管理维护.</li>
<li>借助linux链接的概念, 实验了一下windows的快捷方式是否也可以用命令行执行, 发现是可行的!</li>
<li>譬如创建 <code>ConEmu.exe</code> 的快捷方式 <code>ConEmu.lnk</code> (.lnk不会显示). 此时, 在cmd内执行 <code>ConEmu.lnk</code> 等同于执行 <code>ConEmu.exe</code></li>
<li>这样, 就有办法简化自定义 <code>PATH</code> 的数量了, 只需添加一个用户路径到 <code>PATH</code> 中, 如<code>D:\Green\userpath\bin</code>, 然后把用户软件的 <code>.exe</code> 和 <code>.lnk</code> 放到这个目录下面就可以了.</li>
<li><strong>注意</strong>, <code>.lnk</code>的方法不可靠. 有些情况能用, 有些情况不可用. 带参数肯定不能用.</li>
</ul>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><ul>
<li>譬如, 配置 <code>D:\Green\cli\bin</code> 到环境变量中.</li>
<li><code>我的电脑</code>-&gt;右键<code>属性</code> 或者 <code>控制面板</code>-&gt;<code>系统和安全</code>-&gt;<code>系统</code>-&gt;<code>高级系统设置</code></li>
<li>弹出 <code>系统属性</code> 页面-&gt;<code>高级</code> 标签-&gt;最下面 <code>环境变量...</code>-&gt;<code>系统变量</code>-&gt;<code>Path</code>-&gt;加入自定义路径如 <code>D:\Green\cli\bin</code>, windows7的话需要分隔符<code>;</code></li>
<li><code>D:\Green\cli\bin</code> 只是个例子, 可以自己规定任意一个文件夹, 便于记忆即可.</li>
</ul>
<h2 id="添加软件"><a href="#添加软件" class="headerlink" title="添加软件"></a>添加软件</h2><ul>
<li>MinGW, windows下提供 gnu 工具链, 像linux下一样使用 make 编译即可<br>把 <code>.\MinGW\bin</code> 下的所有文件复制一份到 <code>D:\Green\cli\bin</code> 即可</li>
<li>Pandoc, 格式转换软件. 众多markdown编辑器需要此软件来转换格式<br>把 <code>pandoc.exe</code> 和 <code>pandoc-citeproc.exe</code> 复制一份到 <code>D:\Green\cli\bin</code> 即可</li>
<li>putty, ssh和串口终端软件, 多用于远程连接<br><del>putty所有文件复制一份到 <code>D:\Green\cli\bin</code></del>, 放个 <code>putty.exe</code> 即可</li>
<li>uncrustify, 编程语言格式化软件. 可格式化 c, c++, d, java 等众多语言<br>把 <code>uncrustify.exe</code> 复制到 <code>D:\Green\cli\bin</code> 即可</li>
<li>下述软件创建快捷方式, 然后放到 <code>D:\Green\cli\bin</code> 即可</li>
<li><del><code>ConEmu.lnk</code></del> 模拟终端软件, 可整合多种终端如cmd, shell, bash, putty</li>
<li><del><code>Cygwin.lnk</code></del> 模拟linux环境, 可以部分充当windows下的linux虚拟机使用</li>
<li><del><code>git-cmd.lnk</code></del> 启动git, 供ConEmu调用</li>
<li><code>Typora.lnk</code> 一款markdown编辑器</li>
<li><code>zeal.lnk</code> 软件API离线查询工具, windows下的dash</li>
</ul>
<h2 id="便捷性"><a href="#便捷性" class="headerlink" title="便捷性"></a>便捷性</h2><ul>
<li>上述软件主要是辅助作用, 我会在常用软件中调用上述软件. 如notepad++, atom, ConEmu中</li>
<li>以 notepad++ 调用 <code>zeal.lnk</code> 为例.</li>
<li><code>notepad++</code>-&gt;<code>Run</code>-&gt;<code>Run...</code>-&gt;输入 <code>zeal.lnk $(CURRENT_WORD)</code>-&gt;<code>Save...</code>-&gt;<code>Name:``help</code>, 快捷键<code>F1</code>-&gt;<code>OK</code></li>
<li>配置好以后, 写代码遇到需要查询的地方, 只要选中关键词, 按 <code>F1</code> 就会自动调用 zeal 了</li>
<li>以后环境变了, 只需要重新创建一下 <code>zeal.lnk</code> 然后放到 <code>D:\Green\userpath\bin</code> 即可.</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>path</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 软件系列-终端</title>
    <url>/2016/10/10/1609-WinSoft-terminal/</url>
    <content><![CDATA[<h1 id="ConEmu-简介"><a href="#ConEmu-简介" class="headerlink" title="ConEmu 简介"></a><a href="https://conemu.github.io/">ConEmu</a> 简介</h1><ul>
<li><a href="https://conemu.github.io/">ConEmu</a> 即 Console Emulate, 一款终端模拟器, 完全免费, 可以通过他加载多种终端如 cmd, shell, bash, putty 而且便于管理!</li>
<li>简而言之, 凡是喜欢用命令行方式的, windows就请使用这款软件, 分分钟变身geek或者hacker的感觉…</li>
<li>右键文件夹打开ConEmu就自动进入此文件夹, <code>ConEmu Inside</code> 甚至能嵌入到文件夹中.</li>
<li>顺便说一句, cmder就是他的马甲, 核心还是ConEmu.</li>
</ul>
<h2 id="我的ConEmu"><a href="#我的ConEmu" class="headerlink" title="我的ConEmu"></a>我的ConEmu</h2><ul>
<li>我希望的ConEmu, 就是想输命令行, 打开ConEmu就行!</li>
<li>本文的配置可以在ConEmu中执行:<ul>
<li><code>cmd</code> <code>shell</code> windows自带终端</li>
<li><code>git</code> windows下安装好git即可, 包含了<code>git-bash</code></li>
<li><code>mingw</code> windows下用gnu工具链编译c, c++</li>
<li><code>putty</code> ssh链接远程linux, 串口链接嵌入式linux</li>
<li><code>cygwin</code> windows下模拟linux运行环境 (目前尚未使用, 在用传统的虚拟机)</li>
<li>其它指令如: <code>hexo</code> 博客使用, <code>choco</code> 安装软件使用, <code>apm</code> atom下载插件使用.</li>
</ul>
</li>
<li>快速在指定文件夹下打开ConEmu, 可在 <code>Listary</code> 关联快捷键 <code>ctrl-~</code></li>
<li>快速在Notepad++下打开ConEmu, 关联快捷键 <code>ctrl-~</code></li>
</ul>
<h2 id="自制ConEmu绿色版"><a href="#自制ConEmu绿色版" class="headerlink" title="自制ConEmu绿色版"></a>自制ConEmu绿色版</h2><ul>
<li>下载 <a href="https://conemu.github.io/">ConEmu便携版</a><ul>
<li>解压后放在理想的文件夹中. 下面以 <code>D:\Green\ConEmu</code> 路径为例.</li>
</ul>
</li>
<li>下载 <a href="https://mridgers.github.io/clink/">clink便携版</a>, 用于增强终端操作, 如复制拷贝快捷键等<ul>
<li>解压后, 所有文件放入 <code>D:\Green\ConEmu\ConEmu\clink</code>, 这里面原来就有个 <code>Readme.txt</code>, 说的非常清楚了</li>
</ul>
</li>
<li>下载 <a href="https://git-scm.com/download/win">git便携版</a>, 版本管理软件<ul>
<li>解压后命名为 <code>Git</code> 放到 <code>D:\Green\ConEmu\plugins</code>,</li>
</ul>
</li>
<li>下载并使用默认设置安装 <a href="http://www.mingw.org/">mingw</a>, 用于在win下使用gnu工具编译<ul>
<li>只是装了 <code>MinGW Installation Manager</code> (实际上是个绿色软件). 打开后继续安装组件</li>
<li><code>Basic Setup</code>-&gt;<code>mingw32-base</code>和<code>mingw32-gcc-g++</code>-&gt;左上<code>Installation</code>-&gt;<code>Apply changes</code>-&gt;等待安装完成.</li>
<li>我只需要编译c和c++文件, <code>msys</code>也已经由git软件实现了, 因此无需安装其它组件了.</li>
<li>然后把整个 <code>MinGW</code> 文件夹放到 <code>D:\Green\ConEmu\plugins</code><br> - 复制一份 <code>mingw32-make.exe</code> 并重命名为 <code>make.exe</code>, 这样就能直接用 <code>make</code> 指令了</li>
</ul>
</li>
<li>下载 <a href="http://www.putty.org/">putty.zip</a>, ssh远程连接软件及串口软件<ul>
<li>解压后命名为 <code>putty</code> 放到 <code>D:\Green\ConEmu\plugins</code></li>
</ul>
</li>
<li>然后需要将上述软件加入环境变量, 这个可以在ConEmu设置中完成!!!<ul>
<li>打开ConEmu, <code>Setting</code>-&gt;<code>Startup</code>-&gt;<code>Environment</code>-&gt;<code>set PATH=%ConEmuBaseDir%\Scripts;%PATH%</code> 下面加上如下语句<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># git PATH</span><br><span class="line">set PATH&#x3D;%ConEmuDir%\plugins\Git;%PATH%</span><br><span class="line">set PATH&#x3D;%ConEmuDir%\plugins\Git\cmd;%PATH%</span><br><span class="line"># mingw PATH</span><br><span class="line">set PATH&#x3D;%ConEmuDir%\plugins\MinGW\bin;%PATH%</span><br><span class="line"># putty PATH%</span><br><span class="line">set PATH&#x3D;%ConEmuDir%\plugins\putty;%PATH%</span><br></pre></td></tr></table></figure></li>
<li>这样, ConEmu在启动时, 会自动加入上述软件到PATH中</li>
<li>如果使用 <strong>更通用的做法</strong>, 把上述环境变量删除或注释掉.</li>
</ul>
</li>
<li>自制ConEmu绿色版就初步完成, 下面只需要配置了.</li>
</ul>
<h2 id="更通用的做法"><a href="#更通用的做法" class="headerlink" title="更通用的做法"></a>更通用的做法</h2><ul>
<li>用上述方法有三个缺点<ul>
<li>git便携版不支持ssh或GPG免密远程同步, 每次都要求输入用户名和密码, 非常麻烦.</li>
<li>如果不用ConEmu, 那么其它终端, 如atom下的终端就无法使用上述软件.</li>
<li>发现putty会新打开一个窗口, 而不是嵌入到ConEmu中.</li>
</ul>
</li>
<li>下载 <a href="https://git-scm.com/download/win">git安装版</a>, 使用默认配置安装即可.<ul>
<li>为了便于使用, 建议把git的根目录也加入环境变量, 这样就能直接调用 <code>git-cmd.exe</code></li>
</ul>
</li>
<li>设置 <code>D:\Green\ConEmu\plugins\MinGW\bin</code> 文件夹到系统环境变量中</li>
<li>设置 <code>D:\Green\ConEmu\plugins\putty</code> 文件夹到系统环境变量中</li>
<li>还可以考虑下载安装 <a href="https://www.cygwin.com/">cygwin</a> 并加入ConEmu中, 这是一款Windows下的Linux模拟器. 注意安装和卸载都比较麻烦.<h2 id="ConEmu的设置"><a href="#ConEmu的设置" class="headerlink" title="ConEmu的设置"></a>ConEmu的设置</h2></li>
<li>所有设置都会存放在 <code>conEmu.xml</code> 里, 所以设置的备份很简单</li>
<li>首次打开会有设置向导 <code>fast configuration</code>, 用于生成 <code>conEmu.xml</code></li>
<li>可以在设置好环境变量, 安装好git后, 删除<code>conEmu.xml</code>重新运行, 这样ConEmu会自动检测加入<code>Git bash</code> 和 <code>putty</code>, 省心不少. clink放在指定路径后, 其功能也会自动启用.</li>
<li>配置过程如下, 需要图文版可参考 <a href="https://higoge.github.io/2015/07/22/tools02/">工具02：cmd的替代品ConEmu+Clink</a>, 配置上略有区别, 进入 <code>Settings</code> 后<ul>
<li><code>Main</code>-&gt;<code>Appearance</code>-&gt;<code>Generic</code>-&gt;<code>Single instance mode (...)</code></li>
<li><code>Main</code>-&gt;<code>Confirm</code>-&gt;<code>CLose confirmations</code>-&gt;<del><code>When running process was detected</code></del></li>
<li><code>Startup</code>-&gt;<code>Specified named task</code>-&gt;<code>Bash:: Git bash</code> 更改打开时默认使用的终端类型</li>
<li><code>Startup</code>-&gt;<code>Environment</code> 启动时, 会加载这里的环境变量. 配置好系统环境变量的话, 可以全部删除</li>
<li>注册鼠标右键 <code>ConEmu Here</code> 和 <code>ConEmu Inside</code>, 并设置为使用 <code>Git bash</code> 启动<ul>
<li><code>Integration</code>-&gt;<code>ConEmu Here</code>-&gt;<code>Command:</code>改为<code>&#123;Git Bash&#125; -cur_console:n</code>-&gt;<code>Register</code></li>
<li><code>Integration</code>-&gt;<code>ConEmu Inside</code>-&gt;<code>Command:</code>改为<code>&#123;Git Bash&#125; -cur_console:n</code>-&gt;<code>Register</code></li>
</ul>
</li>
<li><code>Integration</code>-&gt;<code>Default term</code>-&gt;<code>Force ConEmu as default terminal for console applications</code></li>
<li>添加 <code>tasks</code>. 选择 <code>Startup</code>-&gt;<code>Tasks</code>, 根据现有例子依样画葫芦即可.<ul>
<li><code>Bash::Git bash</code>: <code>git-cmd.lnk --no-cd --command=usr/bin/bash.exe -l -i</code> 也可以点击<code>File path...</code>使用绝对路径替代快捷方式.</li>
<li><code>Bash::Git bash(Admin)</code>: <code>*git-cmd.exe --no-cd --command=usr/bin/bash.exe -l -i</code> 最前面加个<code>*</code>就是管理员权限了.</li>
<li><code>Putty::default</code>: <code>putty.exe</code> 同样, 可能需要使用绝对路径, 点击<code>File path...</code>选择即可</li>
<li><code>Putty::Ubuntu</code>: <code>putty.exe -new_console -load &quot;ubuntu&quot;</code> 需要putty设置好名为<code>ubuntu</code>的session</li>
<li><code>Cygwin</code>: <code>set HOME=d:\cygwin\home\XXX &amp; &quot;d:\cygwin\bin\mintty.exe&quot; -i /Cygwin.ico -</code> 这条指令没有测试过.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Putty"><a href="#Putty" class="headerlink" title="Putty"></a><a href="http://www.putty.org/">Putty</a></h1><ul>
<li><a href="http://www.putty.org/">Putty</a> 可用于ssh连接远程主机, 也支持串口. 使用简单, 完全免费</li>
<li>putty的配置, 一个配置就是一个<code>Session</code>. 可以参考<a href="http://blog.csdn.net/tianlesoftware/article/details/5831605">Putty 工具 保存配置的 小技巧</a></li>
<li>putty免密登录, 没有尝试, 可以参考如下两篇文章.<ul>
<li><a href="https://segmentfault.com/a/1190000000639516">PuTTY的自动登录设置</a></li>
<li><a href="http://blog.csdn.net/hxg130435477/article/details/9960187">windows 上用程序putty使用 ssh自动登录linux</a></li>
</ul>
</li>
</ul>
<h2 id="设置Default"><a href="#设置Default" class="headerlink" title="设置Default"></a>设置Default</h2><ul>
<li><code>Window</code>-&gt;<code>Lines of scrollback</code>-<code>20000</code>  回看更多历史屏幕信息</li>
<li><code>Window</code>-&gt;<code>Apperance</code>-&gt;<code>Vertical line</code>, <code>Cursor blinks</code> 游标闪烁</li>
<li><code>Window</code>-&gt;<code>Colours</code>-&gt;<code>Default Backgroud</code>-&gt;<code>R0 G43 B54</code> 使用ConEmu背景色</li>
<li><code>Connection</code>-&gt;<code>Serial</code>-&gt;<code>Flow control</code>-&gt;<code>None</code> 默认串口不用流控制</li>
<li><code>Session</code>-&gt;<code>Saved Sessions</code>-&gt;输入 <code>Default Settings</code>-&gt;<code>Save</code> 默认值设置完成</li>
</ul>
<h2 id="设置ssh"><a href="#设置ssh" class="headerlink" title="设置ssh"></a>设置ssh</h2><ul>
<li><code>Session</code>-&gt;<code>Conncection type</code>选<code>SSH</code>-&gt;<code>Host Name (or IP address)</code>-&gt;<code>10.0.0.99</code> 或者  <code>username@10.0.0.99</code> 来指定登录名</li>
<li><code>Session</code>-&gt;<code>Saved Session</code> <code>Ubuntu</code>-&gt;<code>Save</code> 设置好配置名称, 保存即可.</li>
<li>如果需要免密登录, 明文的很简单, 调用 <code>putty.exe -load &quot;session_name&quot; -l &quot;username&quot; -pw &quot;password&quot;</code> 即可</li>
<li>如果需要密码加密, 稍微麻烦点. 参考 <a href="http://blog.csdn.net/hxg130435477/article/details/9960187">windows 上用程序putty使用 ssh自动登录linux</a>. 我不需要这个功能, 略过不表.</li>
</ul>
<h2 id="设置serial"><a href="#设置serial" class="headerlink" title="设置serial"></a>设置serial</h2><ul>
<li><code>Session</code>-&gt;<code>Conncection type</code>选<code>Serial</code>-&gt;<code>Serial line</code> <code>COM4</code>-&gt;<code>Speed</code> <code>9600</code> 即串口4, 波特率9600</li>
<li><code>Connection</code>-&gt;<code>Serial</code>-&gt;<code>Flow control</code> <code>None</code> 这里可以设置其它串口参数, 不支持自动回显.</li>
<li><code>Session</code>-&gt;<code>Saved Session</code> <code>COM4-9600</code>-&gt;<code>Save</code> 设置好配置名称, 保存即可.</li>
</ul>
<h2 id="配置的导入和导出"><a href="#配置的导入和导出" class="headerlink" title="配置的导入和导出"></a>配置的导入和导出</h2><ul>
<li>putty直接把配置存放在注册表中. 所以思路就是导入导出注册表</li>
<li>cmd下-&gt;<code>regedit</code>-&gt;打开注册表</li>
<li>找到 <code>HKEY_CURRENT_USER\Software\SimonTatham</code></li>
<li>在 <code>SimonTatham</code> 这个节点上点击右键, 选择导出, 保存为<code>config.reg</code>. 这里不单单是putty的配置</li>
<li>恢复时, 管理员权限执行 <code>config.reg</code> 即可</li>
</ul>
<h2 id="putty的调用"><a href="#putty的调用" class="headerlink" title="putty的调用"></a>putty的调用</h2><ul>
<li>基本用法 <code>putty.exe -load &quot;session_name&quot;</code></li>
<li>自动登录 <code>putty.exe -load &quot;session_name&quot; -l &quot;username&quot; -pw &quot;password&quot;</code></li>
<li>更多调用方式可查看 <code>PUTTY.CHM 3.8.x</code> 包含于下载的<code>putty.zip</code>中</li>
</ul>
<h2 id="对比TeraTerm"><a href="#对比TeraTerm" class="headerlink" title="对比TeraTerm"></a>对比<a href="https://ttssh2.osdn.jp/index.html.en">TeraTerm</a></h2><ul>
<li>TeraTerm相比于putty设置显得更复杂, 至少串口的功能比putty的要多一点</li>
<li>TeraTerm有自己的脚本语句, 可以实现比较复杂的自动化功能</li>
<li>TeraTerm在ConEmu字体显示有问题.</li>
<li>putty完全满足需求, 配置简单, 完美兼容ConEmu, 因此没有考虑TeraTerm</li>
</ul>
<h1 id="Cygwin"><a href="#Cygwin" class="headerlink" title="Cygwin"></a><a href="https://www.cygwin.com/">Cygwin</a></h1><ul>
<li>是windows下的unix仿真环境, 可以用来做交叉编译, 因此可替代虚拟机安装linux.</li>
<li>安装, 可以参考 <a href="http://velep.com/archives/747.html">cygwin介绍、安装及其使用</a></li>
<li>交叉编译, 可以参考<ul>
<li><a href="http://mazhijing.blog.51cto.com/215535/39539/">Cygwin 安装  基本使用 交叉编译vivi kernel</a></li>
<li><a href="http://www.360doc.com/content/12/0929/14/5013584_238783155.shtml">在cygwin中安装gcc编译器</a></li>
</ul>
</li>
<li>卸载, 因为权限问题, Cygwin卸载很麻烦. 可以参考两篇文章, 已经是最简单的方法了<ul>
<li><a href="http://blog.csdn.net/yelangjueqi/article/details/45199209">window 下完全卸载Cygwin最简单方法</a>, 就是在运行一次 <code>setup.exe</code> 来卸载</li>
<li><a href="http://blog.163.com/zhuandi_h/blog/static/180270288201282204521376/">Win7 完全删除cygwin（本人已删除成功）</a></li>
</ul>
</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>ConEmu</tag>
        <tag>mingw</tag>
        <tag>putty</tag>
        <tag>cygwin</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 软件系列-atom插件</title>
    <url>/2016/10/12/1610-WinSoft-atompack/</url>
    <content><![CDATA[<h1 id="已不用atom"><a href="#已不用atom" class="headerlink" title="已不用atom"></a>已不用atom</h1><ul>
<li>想通用的结果就是: 启动慢, 不稳定, 配置烦.</li>
</ul>
<h1 id="atom简介"><a href="#atom简介" class="headerlink" title="atom简介"></a><a href="https://atom.io/">atom</a>简介</h1><ul>
<li>界面简洁, 基本上手可用, 无需复杂设置</li>
<li>开源免费, 而且多平台支持, 有丰富的插件库</li>
<li>和git的整合度很好! 直观明了好用</li>
<li>启动相对较慢, 但可接受.</li>
<li>懒人不想折腾, atom无明显短板, 就作为主力代码编辑器了</li>
<li>定位是 Notepad++ 为快速处理文件, atom 处理项目</li>
<li>此篇重点介绍 atom 插件的选择和安装, 以及配置快捷键. 基础介绍见<a href="https://draapho.github.io/2016/09/30/1603-WinSoft-editor/">Windows 软件系列-文本编辑</a></li>
</ul>
<h1 id="atom-插件的安装方式"><a href="#atom-插件的安装方式" class="headerlink" title="atom 插件的安装方式"></a>atom 插件的安装方式</h1><ul>
<li><code>ctrl-,</code>-&gt;<code>Settings</code>-&gt;<code>Install</code>-&gt;选择要安装的插件</li>
<li>终端下使用命令行 <code>apm install</code>, 装完后需要重启atom.<br>有些插件只能通过这个方式安装. 譬如要安装 <code>linter</code>, 命令行输入<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apm install linter</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="atom-通用插件"><a href="#atom-通用插件" class="headerlink" title="atom 通用插件"></a>atom 通用插件</h1><ul>
<li><code>Sublime-Style-Column-Selection</code> 使用 <code>alt-鼠标左键</code> 进入列选模式</li>
<li><code>atom-beautify</code> 自动格式化代码,<ul>
<li>需设置 <code>ctrl-b</code> 美化</li>
</ul>
</li>
<li><del><code>autocomplete-paths</code></del> 辅助完成路径</li>
<li><code>block-comment-plus</code> 批量注释, 支持多种语言<ul>
<li>需设置 <code>ctrl-shift-/</code> 和 <code>ctrl-shift-\</code></li>
</ul>
</li>
<li><code>dash</code>  文档帮助, 配合 zeal (windows/linux) 或 dash(apple), 实现快速查询API<ul>
<li>需设置 <code>F1</code> 帮助</li>
</ul>
</li>
<li><del><code>disable-keybindings</code></del> 快速禁用atom的部分快捷键</li>
<li><code>docblockr</code> 注释辅助, 快速添加函数的注释<ul>
<li>支持 <code>tab</code> 键直接在参数间跳转</li>
<li><code>Align tags</code>-&gt;<code>deep</code></li>
<li><code>Auto add method tag</code></li>
<li><del><code>Extend double slash</code></del></li>
</ul>
</li>
<li><code>highlight-selected</code> 自动高亮匹配的词,</li>
<li><code>hyperclick</code> 快速跳转到定义处, 仅限单文件, 但可由别的插件扩展<ul>
<li><code>Trigger keys for Windows</code> <code>ctrl-shift-click</code>. 用ctrl键和系统多选冲突</li>
</ul>
</li>
<li><code>last-cursor-position</code> 浏览历史跳转<ul>
<li>需设置 <code>ctrl-shift-z</code> <code>ctrl-shift-y</code> 进行跳转</li>
</ul>
</li>
<li><code>linter</code> 语法检查基础包</li>
<li><code>minimap</code> 文件地图</li>
<li><code>minimap-highlight-selected</code> 在文件地图中显示匹配的词</li>
<li><code>platformio-ide-terminal</code> 终端软件<ul>
<li>支持 <code>ctrl-~</code> 快速打开, <code>ctrl-enter</code> 输入选中的文本</li>
<li><code>Close Terminal on Exit</code></li>
<li><code>Shell Override</code>-&gt;<code>git-cmd.exe</code> 没有配置环境变量则需要使用绝对路径</li>
<li><code>Shell Arguments</code>-&gt;<code>--no-cd --command=usr/bin/bash.exe -l -i</code></li>
<li><code>Working Directory</code>-&gt;<code>Project</code></li>
<li><code>Theme</code>-&gt;<code>homebrew</code> 黑底绿字</li>
</ul>
</li>
<li><del><code>Project Manager</code></del> 加入项目的概念, 纯快捷键操作. 与<code>project-viewer</code>二选一即可.</li>
<li><code>project-viewer</code> 加入项目的概念,  带UI. 与<code>Project Manager</code>二选一即可.<ul>
<li><code>Status Bar Visibility</code></li>
<li><code>Autohide</code></li>
<li><code>Positon of the panel</code>-&gt;<code>Left</code></li>
<li><del><code>Convert Old Data</code></del></li>
</ul>
</li>
<li><code>script</code> 一键执行, 支持多种代码, 不弹窗<ul>
<li>需设置 <code>F5</code> 执行</li>
</ul>
</li>
<li><code>symbols-tree-view</code> 显示类/变量/函数列表<ul>
<li><code>Auto Hide</code></li>
<li><code>Auto Toggle</code></li>
</ul>
</li>
<li><code>tabs-to-spaces</code> tab空格互相转换</li>
<li><del><code>vim-mode</code></del> vim操作方式. 需要屏蔽按键 <code>ctrl-f</code>, 恢复为搜索按键<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;atom-text-editor.vim-mode:not(.insert-mode)&#39;:</span><br><span class="line">  &#39;ctrl-f&#39;: &#39;unset!&#39;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="git-插件"><a href="#git-插件" class="headerlink" title="git 插件"></a>git 插件</h1><ul>
<li><code>git-time-machine</code> 查看单文件的git历史<ul>
<li>需设置 <code>f6</code> 查看比较</li>
</ul>
</li>
<li><del><code>git-plus</code></del> git辅助, 我是通过 <code>platformio-ide-terminal</code> 打开终端敲git命令.</li>
<li>merge-conflicts 查看git文件冲突<ul>
<li>需设置 <code>ctrl-f6</code> 查看冲突</li>
</ul>
</li>
</ul>
<h1 id="python-插件"><a href="#python-插件" class="headerlink" title="python 插件"></a>python 插件</h1><ul>
<li>配置 <code>atom-beautify</code> 之python语言<ul>
<li>安装 <a href="https://www.python.org/">python</a></li>
<li>安装 <a href="https://github.com/hhatto/autopep8">autopep8</a>, 调用 <code>pip install --upgrade autopep8</code></li>
<li>默认就是使用 <code>autopep8</code> 优化代码, 也推荐这个使用这个工具. <code>yapf</code>的优化结果无法满足<code>linter-flake8</code>的检查.</li>
<li>测试. 打开一个 <code>.py</code> 文件, 右键选择 <code>Beautify editor contents</code> 看是否成功了.</li>
</ul>
</li>
<li><del><code>atom-python-run</code></del> <code>F5</code>运行, 但是会弹cmd窗, 改用<code>script</code></li>
<li><code>autocomplete-python</code> python辅助, 配合 <code>hyperclick</code> 跳转很方便<ul>
<li>设置快捷键 <code>f4</code> 跳转</li>
<li><code>Show Descriptions</code></li>
<li><code>Autocomplete Function Parameters</code>-&gt;<code>all</code></li>
</ul>
</li>
<li><code>linter-flake8</code> 代码规范检查, 检查很严, 配合 autopep8 的自动格式化就很完美了.<ul>
<li>终端输入 <code>pip install flake8</code> python 安装 <code>flake8</code></li>
<li>终端输入 <code>apm install linter-flake8</code> atom 安装 <code>linter-flake8</code></li>
<li>插件配置 <code>Ignore Error</code>-&gt;<code>E501</code> 超过79列不要提示错误</li>
</ul>
</li>
</ul>
<h1 id="c-c-插件"><a href="#c-c-插件" class="headerlink" title="c/c++ 插件"></a>c/c++ 插件</h1><ul>
<li>配置 <code>atom-beautify</code> 之c/c++语言<ul>
<li>安装<a href="http://uncrustify.sourceforge.net/">uncrustify</a>, 可以自动美化多种语言的格式.<ul>
<li>下载<a href="https://sourceforge.net/projects/uncrustify/files/uncrustify/uncrustify-0.63/">uncrustify-0.63.0-g44ce0f1-win32.zip</a></li>
<li>解压后, 将uncrustify目录加入环境变量, 已 <code>D:\uncrustify\</code> 为例</li>
<li>终端内输入 <code>uncrustify -v</code>, 测试是否配置好 uncrustify</li>
</ul>
</li>
<li><code>atom-beautify</code> 插件的配置, 在c和c++下分别操作一次.<ul>
<li><code>Default Beautifier</code>-&gt;<code>Uncrustify</code> . <del>另一个选项 <code>clang-format</code> 需要安装clang, 里面带有指令<code>clang-format.exe</code></del></li>
<li><code>Config Path</code>-&gt;<code>D:\uncrustify\cfg\linux.cfg</code> 选择格式化模板</li>
</ul>
</li>
<li>测试, 打开一个 <code>.c</code> 文件, 右键选择 <code>Beautify editor contents</code> 看是否成功了.</li>
</ul>
</li>
<li><code>atom-gtags</code>, 能比较好的实现跳转<ul>
<li>设置快捷键 <code>f4</code> 跳转</li>
<li>右键项目根目录即可 <code>Build Gtags</code></li>
<li>放弃 <del><code>atom-ctags</code></del> 实测效果很差!</li>
<li>比较: <a href="https://github.com/OpenGrok/OpenGrok/wiki/Comparison-with-Similar-Tools">https://github.com/OpenGrok/OpenGrok/wiki/Comparison-with-Similar-Tools</a></li>
</ul>
</li>
<li>基于gcc编译的配置<ul>
<li>下载 <a href="http://www.mingw.org/">MinGW</a>, 安装并设置好环境变量<ul>
<li>安装好后, 只是 <code>MinGW Installation Manager</code>, 实际上是个绿色软件. 打开后继续安装组件</li>
<li><code>Basic Setup</code>-&gt;<code>mingw32-base</code> 和 <code>mingw32-gcc-g++</code>-&gt;左上 <code>Installation</code>-&gt;<code>Apply changes</code>-&gt;等待安装完成.</li>
<li>这里只需要编译c和c++文件, 无需安装其它组件了.</li>
<li>设置 <code>...\MinGW\bin</code> 文件夹到系统环境变量中</li>
<li>复制一份 <code>mingw32-make.exe</code> 并重命名为 <code>make.exe</code>, 这样就能直接用 <code>make</code> 指令了</li>
<li>测试. 终端中输入 <code>make -v</code> 和 <code>gcc -v</code>, 看是否可以识别到指令</li>
</ul>
</li>
<li><del><code>gpp-compiler</code></del> <code>f5</code>运行, 但会弹cmd窗, 决定使用内置终端</li>
<li><code>linter-gcc</code> 基于gcc进行语法检查<ul>
<li><code>GCC Excutable Path</code>-&gt;<code>gcc</code> 或 <code>g++</code>, 没有配置环境变量的话, 使用绝对路径, 注意斜杠!</li>
<li><code>GCC Include Paths</code>-&gt;<code>.../MinGW/include/*</code> 注意斜杠方向! 加入必要头文件.</li>
<li>只在保存时, 才会进行语法检查</li>
</ul>
</li>
</ul>
</li>
<li><del>基于clang编译的配置</del><ul>
<li>彻底放弃这个系列, 不用vs, 基于mingw的配置失败.</li>
<li>相关软件和参考如下</li>
<li><del><code>autocomplete-clang</code></del> 自动完成</li>
<li><del><code>linter-clang</code></del> 语法检查</li>
<li><a href="http://llvm.org/">clang官网</a>. 官网进入的链接是找不到windows下编译好的版本的.</li>
<li>下载特定版本的clang, 如 <code>LLVM-3.9.0</code>, 使用链接:<a href="http://llvm.org/releases/3.9.0/">http://llvm.org/releases/3.9.0/</a></li>
<li>参考 <a href="http://m.blog.csdn.net/article/details?id=49902519">解决llvm/clang在windows下编译时找不到头文件和Lib的问题</a></li>
</ul>
</li>
</ul>
<h1 id="markdown插件"><a href="#markdown插件" class="headerlink" title="markdown插件"></a>markdown插件</h1><ul>
<li>atom已经支持markdown, 使用<code>ctrl-shift-m</code>即可预览. 如果要增强功能, 可以使用插件</li>
<li><del><code>markdown-preview-enhanced</code></del> markdown, 导出为pdf时, 制图显示有问题<ul>
<li><code>Break On Single Newline</code></li>
<li><code>Enable Typographer</code></li>
<li><code>Math Rendering Option</code>-&gt;<code>MathJax</code></li>
<li><del><code>Enable Wiki Link Syntax</code></del></li>
<li><del><code>Use GitHub.com syntax theme</code></del></li>
<li><del><code>Print Background when generating pdf</code></del> 否则pdf不显示制图</li>
<li><del><code>Use Github style when generating pdf</code></del> 否则pdf不显示制图</li>
<li><del><code>Open preview pane automatically when opening a markdown file</code></del></li>
<li><code>Image Uploader</code>-&gt;<code>sm.ms</code> 建议这个. <code>imgur</code> 有时限</li>
<li><code>Mermaid Theme</code>-&gt;<code>mermaid.forest.css</code></li>
</ul>
</li>
</ul>
<h1 id="atom快捷键配置"><a href="#atom快捷键配置" class="headerlink" title="atom快捷键配置"></a>atom快捷键配置</h1><ul>
<li><p>使用 <code>ctrl-.</code> 查看按键冲突. 如果无效, 试试点到非编辑区(如目录树)试试.</p>
</li>
<li><p><code>ctrl-,</code>-&gt;<code>Settings</code>-&gt;<code>Keybindings</code>-&gt;<code>your keymap file</code>-&gt;打开<code>keymap.cson</code></p>
</li>
<li><p>自定义快捷键方式可参考 <a href="http://flight-manual.atom.io/using-atom/sections/basic-customization/#_customizing_keybindings">Basic Customization</a></p>
</li>
<li><p>很明显, 要备份自己的快捷键设置, 只需要保存这份 <code>keymap.cson</code> 文件</p>
</li>
<li><p>最后禁用插件里不需要的快捷键, 或者使用 <code>disable-keybindings</code>.</p>
<ul>
<li><code>Keybindings</code> -&gt; <del><code>Enable</code></del>. 屏蔽以下插件:</li>
<li><code>atom-beautify</code>, <code>atom-gtags</code>, <code>autocomplete-python</code></li>
<li><code>block-comment-plus</code>, <code>dash</code>, <code>git-time-machine</code></li>
<li><code>highlight-selected</code>, <code>hyperclick</code>,</li>
<li><code>script</code>, <code>symbols-tree-view</code>, <code>tabs-to-spaces</code></li>
</ul>
</li>
<li><p>我的 <code>keymap.cson</code> 配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># atom 大致原则是, 小窗口&gt;大窗口, 然后才是客户配置&gt;插件配置&gt;系统配置</span><br><span class="line"># 因此优先级 &#39;body&#39; &lt; &#39;atom-workspace&#39; &lt; &#39;atom-text-editor&#39; &lt; &#39;atom-text-editor:not([mini])&#39;</span><br><span class="line"></span><br><span class="line">&#39;atom-text-editor[data-grammar~&#x3D;python]:not(.mini)&#39;:</span><br><span class="line">  &#39;f4&#39;: &#39;autocomplete-python:go-to-definition&#39;</span><br><span class="line">  &#39;shift-f4&#39;: &#39;autocomplete-python:go-to-definition&#39;</span><br><span class="line">  &#39;alt-shift-s&#39;: &#39;autocomplete-python:override-method&#39;</span><br><span class="line"></span><br><span class="line">&#39;atom-text-editor[data-grammar~&#x3D;c]:not(.mini)&#39;:</span><br><span class="line">  &#39;f4&#39;: &#39;atom-gtags:get-definitions&#39;</span><br><span class="line">  &#39;shift-f4&#39;: &#39;atom-gtags:get-references&#39;</span><br><span class="line"></span><br><span class="line">&#39;.platform-win32 atom-workspace atom-text-editor:not([mini])&#39;:</span><br><span class="line"># character</span><br><span class="line">  &#39;ctrl-b&#39;: &#39;atom-beautify:beautify-editor&#39;</span><br><span class="line">  &#39;ctrl-d&#39;: &#39;core:delete&#39;</span><br><span class="line">  &#39;ctrl-shift-d&#39;: &#39;editor:delete-line&#39;</span><br><span class="line">  &#39;ctrl-j&#39;: &#39;core:move-down&#39;</span><br><span class="line">  &#39;ctrl-k&#39;: &#39;core:move-up&#39;</span><br><span class="line">  &#39;ctrl-l&#39;: &#39;core:move-right&#39;</span><br><span class="line">  &#39;ctrl-h&#39;: &#39;core:move-left&#39;</span><br><span class="line">  &#39;ctrl-shift-j&#39;: &#39;editor:move-line-down&#39;</span><br><span class="line">  &#39;ctrl-shift-k&#39;: &#39;editor:move-line-up&#39;</span><br><span class="line">  &#39;ctrl-shift-l&#39;: &#39;editor:move-to-end-of-word&#39;</span><br><span class="line">  &#39;ctrl-shift-h&#39;: &#39;editor:move-to-beginning-of-word&#39;</span><br><span class="line">  &#39;alt-shift-j&#39;: &#39;editor:join-lines&#39;</span><br><span class="line">  &#39;ctrl-m&#39;: &#39;bookmarks:toggle-bookmark&#39;</span><br><span class="line">  &#39;ctrl-r&#39;: &#39;core:redo&#39;</span><br><span class="line">  &#39;ctrl-u&#39;: &#39;core:undo&#39;</span><br><span class="line">  &#39;ctrl-shift-v&#39;: &#39;editor:duplicate-lines&#39;</span><br><span class="line">  &#39;ctrl-shift-W&#39;: &#39;tabs:close-other-tabs&#39;</span><br><span class="line">  &#39;ctrl-shift-x&#39;: &#39;editor:select-line&#39;</span><br><span class="line">  &#39;ctrl-shift-y&#39;: &#39;last-cursor-position:next&#39;</span><br><span class="line">  &#39;ctrl-shift-z&#39;: &#39;last-cursor-position:previous&#39;</span><br><span class="line"># special</span><br><span class="line">  &#39;ctrl-4&#39;: &#39;editor:move-to-end-of-screen-line&#39;         # ctrl-$</span><br><span class="line">  &#39;ctrl-6&#39;: &#39;editor:move-to-first-character-of-line&#39;    # ctrl-^</span><br><span class="line">  &#39;ctrl-$&#39;: &#39;editor:select-to-end-of-line&#39;              # ctrl-shift-$</span><br><span class="line">  &#39;ctrl-^&#39;: &#39;editor:select-to-first-character-of-line&#39;  # ctrl-shift-^</span><br><span class="line">  &#39;ctrl-?&#39;: &#39;block-comment-plus:toggle&#39;                 # ctrl-shift-&#x2F;</span><br><span class="line">  &#39;ctrl-|&#39;: &#39;block-comment-plus:toggle&#39;                 # ctrl-shift-\</span><br><span class="line">  &#39;ctrl-]&#39;: &#39;bracket-matcher:select-inside-brackets&#39;</span><br><span class="line">  &#39;ctrl-[&#39;: &#39;bracket-matcher:go-to-matching-bracket&#39;</span><br><span class="line">  &#39;ctrl-.&#39;: &#39;tabs-to-spaces:untabify-all&#39;</span><br><span class="line">  &#39;ctrl-&gt;&#39;: &#39;tabs-to-spaces:tabify&#39;                     # ctrl-shift-.</span><br><span class="line"># alt</span><br><span class="line">  &#39;alt-0&#39;: &#39;editor:fold-all&#39;</span><br><span class="line">  &#39;alt-)&#39;: &#39;editor:unfold-all&#39;                          # alt-shift-0</span><br><span class="line">  &#39;alt-!&#39;: &#39;editor:unfold-all&#39;                          # alt-shift-1</span><br><span class="line">  &#39;alt-1&#39;: &#39;editor:fold-at-indent-level-1&#39;</span><br><span class="line">  &#39;alt-2&#39;: &#39;editor:fold-at-indent-level-2&#39;</span><br><span class="line">  &#39;alt-3&#39;: &#39;editor:fold-at-indent-level-3&#39;</span><br><span class="line">  &#39;alt-4&#39;: &#39;editor:fold-at-indent-level-4&#39;</span><br><span class="line">  &#39;alt-5&#39;: &#39;editor:fold-at-indent-level-5&#39;</span><br><span class="line">  &#39;alt-6&#39;: &#39;editor:fold-at-indent-level-6&#39;</span><br><span class="line">  &#39;alt-7&#39;: &#39;editor:fold-at-indent-level-7&#39;</span><br><span class="line">  &#39;alt-8&#39;: &#39;editor:fold-at-indent-level-8&#39;</span><br><span class="line">  &#39;alt-9&#39;: &#39;editor:fold-at-indent-level-9&#39;</span><br><span class="line"># f1-f6</span><br><span class="line">  &#39;f1&#39;: &#39;dash:shortcut&#39;</span><br><span class="line">  &#39;ctrl-f2&#39;: &#39;bookmarks:view-all&#39;</span><br><span class="line">  &#39;ctrl-shift-f2&#39;: &#39;bookmarks:clear-bookmarks&#39;</span><br><span class="line">  &#39;ctrl-f3&#39;: &#39;find-and-replace:select-all&#39;</span><br><span class="line">  &#39;f5&#39;: &#39;script:run&#39;</span><br><span class="line">  &#39;ctrl-f5&#39;: &#39;script:run-with-profile&#39;</span><br><span class="line">  &#39;shift-f5&#39;: &#39;script:run-options&#39;</span><br><span class="line">  &#39;f6&#39;: &#39;git-time-machine:toggle&#39;</span><br><span class="line">  &#39;ctrl-f6&#39;: &#39;merge-conflicts:detect&#39;</span><br><span class="line">  &#39;shift-f6&#39;: &#39;merge-conflicts:next-unresolved&#39;</span><br><span class="line">  &#39;ctrl-shift-f6&#39;: &#39;merge-conflicts:previous-unresolved&#39;</span><br><span class="line"></span><br><span class="line">&#39;body&#39;:</span><br><span class="line">  &#39;ctrl-j&#39;: &#39;core:move-down&#39;</span><br><span class="line">  &#39;ctrl-k&#39;: &#39;core:move-up&#39;</span><br><span class="line">  &#39;ctrl-r&#39;: &#39;core:redo&#39;</span><br><span class="line">  &#39;ctrl-u&#39;: &#39;core:undo&#39;</span><br><span class="line">  &#39;ctrl-shift-S&#39;: &#39;window:save-all&#39;</span><br><span class="line"># unset ctrl-k *</span><br><span class="line">  &#39;ctrl-k up&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k down&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k left&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k right&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k ctrl-w&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k ctrl-alt-w&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k ctrl-p&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k ctrl-n&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k ctrl-up&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k ctrl-down&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k ctrl-left&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k ctrl-right&#39;: &#39;unset!&#39;</span><br><span class="line">&#39;atom-workspace atom-text-editor&#39;:</span><br><span class="line">  &#39;ctrl-k ctrl-u&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k ctrl-l&#39;: &#39;unset!&#39;</span><br><span class="line">&#39;atom-workspace atom-text-editor:not([mini])&#39;:</span><br><span class="line">  &#39;ctrl-k ctrl-0&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k ctrl-1&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k ctrl-2&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k ctrl-3&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k ctrl-4&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k ctrl-5&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k ctrl-6&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k ctrl-7&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k ctrl-8&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k ctrl-9&#39;: &#39;unset!&#39;</span><br><span class="line">&#39;.platform-win32, .platform-linux&#39;:</span><br><span class="line">  &#39;ctrl-k ctrl-b&#39;: &#39;unset!&#39;</span><br><span class="line">&#39;.platform-win32 .tree-view, .platform-linux .tree-view&#39;:</span><br><span class="line">  &#39;ctrl-k right&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k l&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k left&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k h&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k up&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k k&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k down&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-k j&#39;: &#39;unset!&#39;</span><br><span class="line">&#39;.platform-win32 atom-text-editor, .platform-linux atom-text-editor&#39;:</span><br><span class="line">  &#39;ctrl-k ctrl-d&#39;: &#39;unset!&#39;</span><br><span class="line">  &#39;ctrl-u&#39;: &#39;unset!&#39;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="参考和资料"><a href="#参考和资料" class="headerlink" title="参考和资料"></a>参考和资料</h1><ul>
<li><a href="http://flight-manual.atom.io/">Atom Flight Manual</a>, atom手册</li>
<li><a href="https://atom.io/packages">atom Packages</a>, atom插件中心</li>
<li>我的 <a href="https://draapho.github.io/2016/10/08/1607-CheatSheet-win/">Windows快捷键</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>atom</tag>
        <tag>mingw</tag>
        <tag>c</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 软件系列-开发软件</title>
    <url>/2016/10/16/1611-WinSoft-other/</url>
    <content><![CDATA[<h1 id="eclipse"><a href="#eclipse" class="headerlink" title="eclipse"></a><a href="https://eclipse.org/downloads/">eclipse</a></h1><ul>
<li><a href="https://eclipse.org/downloads/">eclipse</a> 就不做介绍了.</li>
<li>设置主题<ul>
<li><code>Window</code>-&gt;<code>Preferences</code>-&gt;<code>General</code>-&gt;<code>Appearance</code>-&gt;<code>Color Theme</code>-&gt;<code>Sublime Text 2</code></li>
</ul>
</li>
<li>设置编辑界面<ul>
<li><code>Window</code>-&gt;<code>Preferences</code>-&gt; <code>General</code>-&gt;<code>Editors</code>-&gt;<code>Text Editors</code>-&gt;<ul>
<li><code>Insert spaces for tabs</code></li>
<li><code>Show print margin</code></li>
<li><code>Show whitespace characters</code>-&gt;<code>configure visibility</code>-&gt;<del><code>Carriage Return</code></del> <del><code>Line Feed</code></del></li>
</ul>
</li>
<li><code>Window</code>-&gt;<code>Preferences</code>-&gt; <code>General</code>-&gt;<code>Editors</code>-&gt;<code>Text Editors</code>-&gt;<code>Quick Diff</code><ul>
<li><code>Enable Quick Diff</code></li>
<li><code>Use this reference source:</code>-&gt;<code>A Git Revision</code></li>
<li>需要装好git</li>
</ul>
</li>
</ul>
</li>
<li>设置路径<ul>
<li><code>Window</code>-&gt;<code>Preferences</code>-&gt;<code>Team</code>-&gt;<code>Git</code>-&gt;<code>Default repository folder:</code>-&gt;<code>$&#123;project_loc&#125;</code></li>
<li><code>Window</code>-&gt;<code>Preferences</code>-&gt;<code>Terminal</code>-&gt;<code>Local Terminal</code>-&gt;<code>Initial Working Directory</code>-&gt;<code>$&#123;project_loc&#125;</code></li>
<li>注意, 上述两项需要有git项目并编译后, 才可以成功设置</li>
</ul>
</li>
<li>设置快捷键<ul>
<li><code>Window</code>-&gt;<code>Preferences</code>-&gt;<code>General</code>-&gt;<code>Keys</code> 可设置快捷键</li>
<li>快捷键设置要求见 <a href="https://draapho.github.io/2016/10/08/1607-CheatSheet-win/">Windows快捷键</a></li>
<li>配置文件名为 <code>org.eclipse.ui.workbench.prefs</code>, 路径如下, $workspace$ 表示 eclipse 的工作路径.</li>
<li><code>$workspace$\.metadata\.plugins\org.eclipse.core.runtime\.settings</code>下</li>
<li>TrueSTUIDO版的快捷键见TureSTUDIO</li>
</ul>
</li>
</ul>
<h1 id="TrueSTUIDO-已改为-STM32CubeIDE"><a href="#TrueSTUIDO-已改为-STM32CubeIDE" class="headerlink" title="TrueSTUIDO, 已改为 STM32CubeIDE"></a><del><a href="http://atollic.com/truestudio/">TrueSTUIDO</a></del>, 已改为 <a href="https://www.st.com/en/development-tools/stm32cubeide.html#get-software">STM32CubeIDE</a></h1><ul>
<li><a href="http://atollic.com/truestudio/">TrueSTUIDO</a>是一款免费的ARM IDE, 基于eclipse. 免费版有5s广告.</li>
<li>快捷键配置文件<ul>
<li>我的配置文件 <a href="https://github.com/draapho/Blog/tree/master/_blog_stuff/TrueSTUIDIO/org.eclipse.ui.workbench.prefs">org.eclipse.ui.workbench.prefs</a></li>
<li>下载后直接覆盖放入 <code>$workspace$/.metadata/.plugins/org.eclipse.core.runtime/.settings/</code></li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=R2hfq4S_-B0">TrueSTUIDO Download and Reset (no debug)</a><ul>
<li><code>Run</code>-&gt;<code>Debug Configurations...</code>-&gt;<code>Embedded C/C++...</code>下的文件-&gt;<code>Startup Scripts</code></li>
<li>delete all context after <code>load</code> and input <code>quit</code></li>
<li><code>Window</code>-&gt;<code>Perspective</code>-&gt;<code>Customize Pespective...</code>-&gt;<code>Launch</code>-&gt;选择 <code>Debug</code> 和 <code>Run</code></li>
</ul>
</li>
<li>生成指定格式<ul>
<li>项目右键 <code>Properties</code>-&gt;<code>C/C++ Build</code>-&gt;<code>Settings</code>-&gt;<code>Tool Settings</code>-&gt;<code>Other</code>-&gt;<code>Output format</code>-&gt;<code>Convert build output</code>-&gt;<code>Intel Hex</code> or <code>Binary</code></li>
</ul>
</li>
</ul>
<h1 id="RealView-MDK"><a href="#RealView-MDK" class="headerlink" title="RealView MDK"></a>RealView MDK</h1><ul>
<li>RVMDK 设置成utf8格式. <code>Edit</code>-&gt;<code>Configuration</code>-&gt;<code>Editor</code>-&gt;<code>Encoding</code>-&gt;<code>UTF8</code></li>
</ul>
<h1 id="Source-Insight"><a href="#Source-Insight" class="headerlink" title="Source Insight"></a>Source Insight</h1><ul>
<li>添加完文件后, 需要同步. <code>Project</code>-&gt;<code>Synchronize Files...</code></li>
<li>添加文件类型. <code>Options</code>-&gt;<code>Document Options</code>-&gt;<code>Document Type</code>, 在file filter内增加文件类型即可</li>
</ul>
<h1 id="使用mingw编译C语言"><a href="#使用mingw编译C语言" class="headerlink" title="使用mingw编译C语言"></a>使用mingw编译C语言</h1><ul>
<li><p>主要用于写一些小程序用来验证或测试. 与linux开发习惯一致, 而且免费轻巧快捷.</p>
</li>
<li><p>下载 <a href="http://www.mingw.org/">MinGW</a>, 安装并设置好环境变量.</p>
<ul>
<li>安装好后, 只是 MinGW Installation Manager, 实际上是个绿色软件. 打开后继续安装组件</li>
<li><code>Basic Setup</code>-&gt;<code>mingw32-base</code> 和 <code>mingw32-gcc-g++</code>-&gt;左上 <code>Installation</code>-&gt;<code>Apply changes</code>-&gt;等待安装完成.</li>
<li>这里只需要编译c和c++文件, 无需安装其它组件了.</li>
<li>设置 <code>...\MinGW\bin</code> 文件夹到系统环境变量中</li>
<li>复制一份 <code>mingw32-make.exe</code> 并重命名为 <code>make.exe</code>, 这样就能直接用 make 指令了</li>
<li>测试. 终端中输入 <code>make -v</code> 和 <code>gcc -v</code>, 看是否可以识别到指令</li>
</ul>
</li>
<li><p>建立一个工作目录, 建立2个文件即可. 一个 <code>.c</code>, 另一个 <code>makefile</code> 即可</p>
<ul>
<li>创建并命名为 <code>main.c</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\nhello: %s\r\n&quot;</span>, <span class="string">&quot;DRA&amp;PHO&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建并命名为 <code>makefile</code><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">test:main.o</span></span><br><span class="line">    gcc -o hello main.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">    gcc -c main.c</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>打开终端, 切换到这个工作目录<ul>
<li>输入 <code>make</code> 即可编译, 会生成 <code>main.o</code> <code>hello.exe</code> 两个文件</li>
<li>输入 <code>./hello.exe</code> 执行, 终端就会输出 <code>hello: DRA&amp;PHO</code></li>
</ul>
</li>
<li>资料和参考<ul>
<li><a href="http://blog.csdn.net/zhanghan3/article/details/1334308">windows下使用makefile编译C语言</a></li>
</ul>
</li>
</ul>
<h1 id="Win10-Python-PyQt-PyCharm-开发环境搭建"><a href="#Win10-Python-PyQt-PyCharm-开发环境搭建" class="headerlink" title="Win10 + Python + PyQt + PyCharm 开发环境搭建"></a>Win10 + Python + PyQt + PyCharm 开发环境搭建</h1><p>此部分内容于2021年3月11日添加.</p>
<h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><ul>
<li>用Python开发项目, 环境配置和维护是个坑…</li>
<li>此文简要说明环境搭建过程, 重点说明用于环境维护的python虚拟环境.</li>
<li>已知的兼容性问题:<ul>
<li>Python2.7 无法正确安装 PyIntall. 解决方法如下:<ul>
<li>首先, 降低pip版本到18.1: <code>pip install pip==18.1</code></li>
<li>然后, 指定pyinstaller版本为3.4: <code>pip install pyinstaller==3.4</code></li>
<li>检查是否安装成功. <code>pyinstaller -v</code></li>
</ul>
</li>
<li>Python2.7 无法实用 <code>pip install pyqt4</code>. 解决方法:<ul>
<li>下载对应版本的 <a href="https://sourceforge.net/projects/pyqt/files/PyQt4/PyQt-4.11.4/">PyQt4-4.11.4-gpl-Py2.7-Qt4.8.7-xxx</a>, 运行安装即可.</li>
</ul>
</li>
<li>Python3.6 和 Python3.7 与最新版 PyQt5 兼容性问题.<ul>
<li>出错形式: 类似于 <code>from PyQt5 import QtCore</code> <code>from PyQt5.QtGui import *</code> 报错 <code>No module named &#39;PyQt5&#39;</code></li>
<li>解决方法: 我直接安装了 Python3.8.8, 然后 <code>pip install pyqt5-tools</code>, 就会自动下载最新版的pyqt5和关联文件.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>开发环境: <code>Win10 + Python 3.8.8 + PyQt5 + PyCharm社区版</code>. 另有历史项目适用 <code>Python 2.7 + PyQt4 4.11.4</code>.</li>
<li>运行安装 <a href="https://www.python.org/downloads/windows/">Python 3.8.8</a>, 记得勾选加入PATH, 确保环境变量的正确配置.</li>
<li><code>pip install pip install pyqt5-tools</code>, 会自动下载相关的包如pyqt5, sip.<ul>
<li>查了下, 当前版本是 <code>PyQt5 5.15.2</code>, 是能保证正常运行的.</li>
<li>指定版本安装的话, 使用<code>pip install pip install pyqt5-tools==5.15.2</code></li>
</ul>
</li>
<li><code>pip install xxx</code>, 安装其它常用包, 略过不表.</li>
<li>运行安装 <a href="https://www.jetbrains.com/pycharm/download/#section=windows">PyCharm社区版</a>, 略过不表</li>
<li>如下图, 将PyQt5的两个命令工具整合进PyCharm.<br><img src="https://draapho.github.io/images/1611/pycharm1.png" alt="external tools"></li>
<li>配置 <code>designer.exe</code>, 用于设计 GUI.<ul>
<li>Name: <code>Qt5 Designer</code>, 取个名字.</li>
<li>Group: <code>PyQt-cmd</code>. 用默认值 <code>External Tools</code> 也行. Group名称会出现在右键菜单里, 故单独分了个组.</li>
<li>Description: 爱填不填.</li>
<li>Program, 这是重点! 填入designer.exe的绝对路径. <code>xxx\Python38-32\Lib\site-packages\qt5_applications\Qt\bin\designer.exe</code></li>
<li>Working directory: <code>$FileDir</code>, 工作路径设置为文件所在为止</li>
<li><code>OK</code> 保存配置. 点击第5步的加号, 继续增加配置.</li>
</ul>
</li>
<li>配置 <code>pyuic</code>, 用于将 designer生成的<code>.ui</code> 文件转化为 python的<code>.py</code> 文件<ul>
<li>依样画葫芦, 填写 Name, Group, Description. 以下配置才是重点:</li>
<li>Program: 填入python.exe的绝对路径 <code>xxx\Python38-32\python.exe</code>, 其实直接填入 <code>python3.exe</code> 也可以, 因为已经加入环境变量了.</li>
<li>Arguments: <code>-m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py</code></li>
<li>Working directory: <code>$FileDir</code>, 工作路径设置为文件所在为止</li>
<li><code>OK</code>保持. 整个配置的意思就是在<code>$FileDir</code>目录下, 运行指令 <code>python -m PyQt5.uic.pyuic gui_file.ui -o gui.file.py</code></li>
</ul>
</li>
<li>一套简易的环境就搭好了, 但PyCharm这边还需要配置 <code>Python Interpreter</code>, 这是用来维护不同项目的Python虚拟环境用的.</li>
</ul>
<h2 id="虚拟环境搭建"><a href="#虚拟环境搭建" class="headerlink" title="虚拟环境搭建"></a>虚拟环境搭建</h2><ul>
<li>如下图, 配置pycharm的<code>Python Interpreter</code><br><img src="https://draapho.github.io/images/1611/pycharm2.png" alt="Python Interpreter"><ul>
<li>首先选中某个项目, 然后点击<code>File</code>-&gt;<code>Settings...</code>-&gt;<code>Python Interpreter</code>-<code>Show All...</code>. 即图中的步骤1到4.</li>
<li>然后在开发结束后选择新增虚拟环境(图中5), 弹出<code>Virtualenv Environment</code>的配置页面(图中6).</li>
<li>图中7 <code>Location:</code> python虚拟环境的工作目录. 默认会在所选项目文件夹下新建一个<code>venv</code>文件夹. 表示这是此项目的虚拟Python工作环境.<ul>
<li>我个人的做法是, 在PyCharm的上级目录下, 建立针对不同python版本的通用性虚拟环境. 如图中12, 为已经配置好的 <code>python3.8-32-Comm</code> 和 <code>python2.7-32-Comm</code>, 为开发阶段使用.</li>
<li>然后在开发结束后, 需要打包生成exe文件时, 或者只是想保存好这个开发环境时, 才会在项目文件夹下创建<code>venv</code>, 搭建好只针对该项目的虚拟环境, 并只安装必要的包.</li>
</ul>
</li>
<li>图中8 <code>Base Interpreter</code>, 选择本地安装好的一个python版本.</li>
<li>图中9 <code>Inherit global site-packages</code>, 是否继承所选python里的包. 对于通用性环境, 建议勾选, 便于开发. 对于专用性环境, 建议不选, 给项目创建一个完全隔离的虚拟工作环境.</li>
<li>图中10 <code>Make available to all projects</code>, 仅通用性环境建议勾选.</li>
<li>最后, 点击<code>OK</code>, 配置完成. 新建的虚拟环境会出现在图中12的位置. 选择后继续<code>OK</code>, 就为这个项目指定了Python虚拟工作环境, 可以写代码运行了.</li>
</ul>
</li>
<li>为完全隔离的专用虚拟环境, 安装Python包.<ul>
<li>方法1: 直接从Python系统目录下拷贝需要的包. 系统包路径类似于 <code>xxx\Python38-32\Lib\site-packages</code>, 直接拷贝到虚拟环境目录中, 类似于 <code>xxx_project\vevn\Lib\site-packages</code></li>
<li>方法2: 见图中绿色A处, 在<code>Setting</code>界面下, 选中专用虚拟环境, 点击这个<code>+</code>, 可以在弹出的界面里搜选需要的包, 然后 <code>Install Package</code> 即可.</li>
<li>要包含所有的Python运行环境, 包括但不限于 <code>PyInstaller</code>, <code>setuptools</code> 等等.</li>
</ul>
</li>
<li>不借助pycharm, python自身也可以搭建虚拟环境. 这里不介绍了. 只列出几条关键语句.<ul>
<li><code>pip3 install virtualenv</code> 安装工具. 建议指定python版本, 如pip2 或 pip3</li>
<li><code>virtualenv venv</code> 建立了新环境名为venv，在项目文件夹中可以看到增加的文件</li>
<li><code>xxx\venv\Scripts&gt;activate</code> 进入venv\Scripts下运行, 激活此虚拟环境</li>
<li><code>(venv) xxx\venv\Scripts&gt;activate</code> 出现(venv), 说明激活成功. 继续敲命令行即可</li>
</ul>
</li>
</ul>
<h2 id="PyInstaller"><a href="#PyInstaller" class="headerlink" title="PyInstaller"></a>PyInstaller</h2><ul>
<li>版本冲突问题.<ul>
<li>python和pip可以通过使用 python2/python3, pip2/pip3来解决.</li>
<li>PyInstaller可以通过指定python调用. 如: <code>python3 -m PyInstaller -v</code>. 注意大小写!</li>
</ul>
</li>
<li>也可以将PyInstaller加入到PyCharm的 <code>External Tools</code> 里. 由于参数组合多样, 我一般直接命令行.</li>
<li>建议在专用虚拟环境下打包. 也可以用参数 <code>-p</code> 指定路径. 如 <code>Pyinstaller -p xxx\venv\Lib\site-packages xxx.py</code></li>
<li>其它参数: <code>-F/--onefile</code> 单文件.  <code>-w/--windowed</code> 窗口模式. <code>--clean</code> 清空编译文件.</li>
<li>如果打包失败, 加入 <code>-d all</code> 调试信息. 不要用<code>-w</code> 窗口模式. 慢慢调试吧.<ul>
<li>出错的原因多种多样, 软件开发好, 无法生成exe文件非常让人抓狂!</li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.jianshu.com/p/1f002395a622">超详细Windows + Python + PyQt5 + Pycharm 环境搭建</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1568559">Python界面开发:（一）环境搭建</a></li>
<li><a href="https://blog.csdn.net/guying4875/article/details/80905472">pycharm配置本地python虚拟环境</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/35977093">pyinstaller使用（内含虚拟环境使用）</a></li>
<li><a href="https://www.jianshu.com/p/2656fbc01c54">Pyinstaller虚拟环境下打包python文件</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>eclipse</tag>
        <tag>mingw</tag>
        <tag>TrueSTUIDO</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt 的交互操作</title>
    <url>/2016/10/20/1612-python-pyqtui/</url>
    <content><![CDATA[<h1 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h1><ul>
<li>Windows</li>
<li><a href="https://www.python.org/downloads/">python 2.7</a></li>
<li><a href="https://riverbankcomputing.com/software/pyqt/download">PyQt 4.11.4</a></li>
</ul>
<h1 id="useful-guide-startup"><a href="#useful-guide-startup" class="headerlink" title="useful guide / startup"></a>useful guide / startup</h1><ul>
<li><a href="http://www.training.prace-ri.eu/uploads/tx_pracetmo/QtGuiIntro.pdf">Introduction to GUI development using Qt</a>, 简单明了的介绍了qt gui的基本特性</li>
<li><a href="https://www.tutorialspoint.com/pyqt/">PyQt Tutorial</a>, learn PyQt step by step.</li>
<li><a href="https://nikolak.com/pyqt-threading-tutorial/">PyQt: Threading Basics Tutorial</a>, 防止UI阻塞, 使用线程</li>
</ul>
<h1 id="Generate-basic-UI-file"><a href="#Generate-basic-UI-file" class="headerlink" title="Generate basic UI file"></a>Generate basic UI file</h1><ul>
<li>use <code>Qt Designer</code> to create basic UI<ul>
<li><code>New</code>-&gt;<code>Widget</code>-&gt;drag <code>PushButton</code> to <code>Form</code> Window</li>
<li>Save it, for example <code>demo.ui</code></li>
</ul>
</li>
<li>make sure <code>pyuic4.bat</code> is in the System PATH<ul>
<li>input <code>pyuic4.bat -h</code> in shell, check the response.</li>
</ul>
</li>
<li>change <code>.ui</code> to <code>.py</code> file<ul>
<li>run <code>pyuic4.bat -x -o demo.py demo.ui</code> in the working folder.</li>
<li><code>-o</code> means output, set the output filename.</li>
<li><code>-x</code> will generate <code>if __name__ == &#39;__main__&#39;:</code> then can run directly</li>
<li><code>pyuic4.bat demo.ui &gt; demo.py</code> is also OK.</li>
</ul>
</li>
<li><del>the sample of <code>demo.py</code>, generated automatically by pyuic4.bat</del></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Form implementation generated from reading ui file &#x27;demo.ui&#x27;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Created by: PyQt4 UI code generator 4.11.4</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># WARNING! All changes made in this file will be lost!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PyQt4 <span class="keyword">import</span> QtCore, QtGui</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _fromUtf8 = QtCore.QString.fromUtf8</span><br><span class="line"><span class="keyword">except</span> AttributeError:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_fromUtf8</span>(<span class="params">s</span>):</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _encoding = QtGui.QApplication.UnicodeUTF8</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_translate</span>(<span class="params">context, text, disambig</span>):</span></span><br><span class="line">        <span class="keyword">return</span> QtGui.QApplication.translate(context, text, disambig, _encoding)</span><br><span class="line"><span class="keyword">except</span> AttributeError:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_translate</span>(<span class="params">context, text, disambig</span>):</span></span><br><span class="line">        <span class="keyword">return</span> QtGui.QApplication.translate(context, text, disambig)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ui_Form</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setupUi</span>(<span class="params">self, Form</span>):</span></span><br><span class="line">        Form.setObjectName(_fromUtf8(<span class="string">&quot;Form&quot;</span>))</span><br><span class="line">        self.pushButton = QtGui.QPushButton(Form)</span><br><span class="line">        self.pushButton.setGeometry(QtCore.QRect(<span class="number">40</span>, <span class="number">40</span>, <span class="number">75</span>, <span class="number">23</span>))</span><br><span class="line">        self.pushButton.setObjectName(_fromUtf8(<span class="string">&quot;pushButton&quot;</span>))</span><br><span class="line"></span><br><span class="line">        self.retranslateUi(Form)</span><br><span class="line">        QtCore.QMetaObject.connectSlotsByName(Form)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">retranslateUi</span>(<span class="params">self, Form</span>):</span></span><br><span class="line">        Form.setWindowTitle(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;Form&quot;</span>, <span class="literal">None</span>))</span><br><span class="line">        self.pushButton.setText(_translate(<span class="string">&quot;Form&quot;</span>, <span class="string">&quot;PushButton&quot;</span>, <span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># using -x will generate the following code</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    app = QtGui.QApplication(sys.argv)</span><br><span class="line">    Form = QtGui.QWidget()</span><br><span class="line">    ui = Ui_Form()</span><br><span class="line">    ui.setupUi(Form)</span><br><span class="line">    Form.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>


<ul>
<li><del>run &amp; check the　UI</del><ul>
<li>run <code>python demo.py</code> in the working folder.</li>
<li>OR run directly in editor like atom.</li>
</ul>
</li>
</ul>
<h1 id="click-then-do-sth"><a href="#click-then-do-sth" class="headerlink" title="click then do sth"></a>click then do sth</h1><ul>
<li>create a new py file, for example <code>show.py</code>. input code like:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> demo  <span class="comment"># generated from xxx.ui</span></span><br><span class="line"><span class="keyword">from</span> PyQt4 <span class="keyword">import</span> QtGui</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span>(<span class="params">QtGui.QWidget, demo.Ui_Form</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(self.__class__, self).__init__()  <span class="comment"># QtGui.QWidget.__init__()</span></span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.pushButton.clicked.connect(</span><br><span class="line">            self.handleButton)  <span class="comment"># here is important line</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handleButton</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;hello, https://draapho.github.io/&quot;</span>)</span><br><span class="line">        <span class="comment"># size = self.geometry()</span></span><br><span class="line">        <span class="comment"># self.resize(size.width() + 2, size.height() + 2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = QtGui.QApplication(sys.argv)</span><br><span class="line">    form = MyForm()</span><br><span class="line">    form.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>

<ul>
<li>look at <code>self.ui.pushButton.clicked.connect(self.handleButton)</code><br>it links clicked event with handleButton function.</li>
<li>if you want to resize the window after clicked the button. change <code>handleButton</code> to</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleButton</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="comment"># print (&quot;hello, https://draapho.github.io/&quot;)</span></span><br><span class="line">    size = self.geometry()</span><br><span class="line">    self.resize(size.width() + <span class="number">2</span>, size.height() + <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h1 id="click-then-do-heavy-work"><a href="#click-then-do-heavy-work" class="headerlink" title="click then do heavy work"></a>click then do heavy work</h1><ul>
<li><p><del>bad code, UI totally dead</del></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt4 <span class="keyword">import</span> QtGui</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> demo</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span>(<span class="params">QtGui.QWidget, demo.Ui_Form</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(self.__class__, self).__init__()</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.pushButton.clicked.connect(self.startCount)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startCount</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pushButton.clicked.disconnect()</span><br><span class="line">        self.pushButton.clicked.connect(self.stopCount)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="number">15</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            self.pushButton.setText(<span class="built_in">str</span>(i))</span><br><span class="line">            <span class="built_in">print</span> i</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stopCount</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pushButton.clicked.disconnect()</span><br><span class="line">        self.pushButton.clicked.connect(self.startCount)</span><br><span class="line">        self.pushButton.setText(<span class="string">&quot;PushButton&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QtGui.QApplication(sys.argv)</span><br><span class="line">    form = MyForm()</span><br><span class="line">    form.show()</span><br><span class="line">    app.exec_()</span><br></pre></td></tr></table></figure></li>
<li><p>use thread, can do everything in UI</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt4 <span class="keyword">import</span> QtGui</span><br><span class="line"><span class="keyword">from</span> PyQt4.QtCore <span class="keyword">import</span> QThread, SIGNAL</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> demo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">getCountThread</span>(<span class="params">QThread</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        QThread.__init__(self)</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.wait()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.count &lt; <span class="number">15</span>:</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">            self.emit(SIGNAL(<span class="string">&#x27;showCount(int)&#x27;</span>), self.count)</span><br><span class="line">            <span class="built_in">print</span> self.count</span><br><span class="line">            self.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span>(<span class="params">QtGui.QWidget, demo.Ui_Form</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(self.__class__, self).__init__()</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.pushButton.clicked.connect(self.startCount)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startCount</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pushButton.clicked.disconnect()</span><br><span class="line">        self.get_thread = getCountThread()</span><br><span class="line">        self.connect(self.get_thread, SIGNAL(<span class="string">&quot;showCount(int)&quot;</span>), self.showCount)</span><br><span class="line">        self.connect(self.get_thread, SIGNAL(<span class="string">&quot;finished()&quot;</span>), self.done)</span><br><span class="line">        self.get_thread.start()</span><br><span class="line">        <span class="comment"># must be under the self.get_thread.start()</span></span><br><span class="line">        self.pushButton.clicked.connect(self.get_thread.terminate)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showCount</span>(<span class="params">self, count</span>):</span></span><br><span class="line">        self.pushButton.setText(<span class="built_in">str</span>(count))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">done</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pushButton.clicked.disconnect()</span><br><span class="line">        self.pushButton.setText(<span class="string">&quot;PushButton&quot;</span>)</span><br><span class="line">        self.pushButton.clicked.connect(self.startCount)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QtGui.QApplication(sys.argv)</span><br><span class="line">    form = MyForm()</span><br><span class="line">    form.show()</span><br><span class="line">    app.exec_()</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>explanation<ul>
<li><code>getCountThread</code> 子线程类, 执行繁重任务</li>
<li><code>MyForm</code>-&gt;<code>startCount</code> 点击按键后执行, 设置好信号, 启动子线程</li>
<li><code>self.connect(self.get_thread, SIGNAL(&quot;showCount(int)&quot;), self.showCount)</code><br>准备接收来自线程的信号, 并在 <code>showCount</code> 更新UI</li>
<li><code>self.connect(self.get_thread, SIGNAL(&quot;finished()&quot;), self.done)</code><br>准备接收来自线程的结束信号, 然后在 <code>done</code> 下更新标记和UI</li>
<li><code>self.get_thread.start()</code><br>启动子线程</li>
<li><code>self.pushButton.clicked.connect(self.get_thread.terminate)</code><br>将按键的功能设置为终止子线程, 必须放在 <code>self.get_thread.start()</code> 下面</li>
</ul>
</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pyqt</tag>
      </tags>
  </entry>
  <entry>
    <title>python调用命令行</title>
    <url>/2016/10/21/1613-python-cli/</url>
    <content><![CDATA[<h1 id="python调用CLI"><a href="#python调用CLI" class="headerlink" title="python调用CLI"></a>python调用CLI</h1><ul>
<li>CLI = Command Line Interface, 即命令行</li>
<li>方法有很多, 通用性和安全性最好的就是<code>subprocess.Popen</code>这个方法. 见文档<ul>
<li><a href="https://docs.python.org/2.7/library/subprocess.html#popen-constructor">Subprocess management</a></li>
<li><del><a href="https://docs.python.org/2.7/library/os.html#os.popen">os.popen</a></del></li>
<li><del><a href="https://docs.python.org/2/library/commands.html">Utilities for running commands</a></del></li>
</ul>
</li>
<li>example:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen, PIPE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># CLI: Command Line Interface</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runCLI</span>():</span></span><br><span class="line">    <span class="comment"># __cmd_link = self.cur_dir + &quot;\\stlink_cli\\ST-LINK_CLI.exe -c SWD SWJCLK=5 UR&quot;</span></span><br><span class="line">    __cmd_link = <span class="string">&quot;dir&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多用 shell=True. shell=False只能运行bat文件或直接在终端中执行. 此例中显示的内容也会有区别</span></span><br><span class="line">    _pp = Popen(__cmd_link, shell=<span class="literal">True</span>, stdout=PIPE, stderr=PIPE)</span><br><span class="line">    out, err = _pp.communicate()</span><br><span class="line"></span><br><span class="line">    logging.debug(<span class="string">&quot;cmd &gt; &quot;</span> + __cmd_link)</span><br><span class="line">    logging.debug(<span class="string">&quot;out &gt; &quot;</span> + out.rstrip())</span><br><span class="line">    logging.debug(<span class="string">&quot;err &gt; &quot;</span> + err.rstrip())</span><br><span class="line">    <span class="keyword">return</span> _pp.returncode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    logging.basicConfig(level=logging.DEBUG)</span><br><span class="line">    logging.debug(runCLI())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>cli</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 初始设置及常用命令</title>
    <url>/2016/10/24/1614-CheatSheet-git/</url>
    <content><![CDATA[<h1 id="git示意图"><a href="#git示意图" class="headerlink" title="git示意图"></a>git示意图</h1><p>  <img src="https://draapho.github.io/images/1614/git.jpg" alt="git"></p>
<h1 id="资料和参考"><a href="#资料和参考" class="headerlink" title="资料和参考"></a>资料和参考</h1><ul>
<li><a href="http://ndpsoftware.com/git-cheatsheet.html">Visual Git Cheat Sheet</a></li>
<li><a href="https://git-scm.com/book/zh/v2">Pro Git book</a></li>
<li>廖雪峰的 <a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程</a></li>
<li>设置SSH, 参考 <a href="https://help.github.com/categories/ssh/">GitHub Help - SSH</a></li>
<li>设置GPG, 参考 <a href="https://help.github.com/categories/gpg/">GitHub Help - GPG</a></li>
</ul>
<h1 id="一些理解"><a href="#一些理解" class="headerlink" title="一些理解"></a>一些理解</h1><ul>
<li>git的核心理解为指针即可, 包括 <code>workspace</code>, <code>index</code>, <code>commitHash</code><ul>
<li><code>repository</code>是基于<code>commitHash</code>管理版本的.</li>
<li><code>HEAD</code>, <code>HEAD^1</code>, <code>HEAD~3</code>, <code>branch</code>, <code>tags</code>都是<code>commitHash</code>的别名, 便于人们记忆和理解.</li>
<li>可以基于 <code>git reset</code> 来检测是否完全理解git基于指针的设计思路.</li>
<li><code>HEAD^1</code>基于父节点, <code>HEAD~1</code>基于层次. 单层结构下没有差别. 复杂多层结构建议直接用 <code>commitHash</code></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       A ---------------------  A &#x3D;      &#x3D; A^0</span><br><span class="line">      &#x2F; \</span><br><span class="line">     B   C                      B &#x3D; A^   &#x3D; A^1     &#x3D; A~1</span><br><span class="line">    &#x2F;|\  |                      C &#x3D; A^2  &#x3D; A^2</span><br><span class="line">   &#x2F; | \ |</span><br><span class="line">  D  E   F -------------------  D &#x3D; A^^  &#x3D; A^1^1   &#x3D; A~2</span><br><span class="line"> &#x2F; \    &#x2F; \                     E &#x3D; B^2  &#x3D; A^^2</span><br><span class="line">&#x2F;   \  &#x2F;   \                    F &#x3D; B^3  &#x3D; A^^3</span><br><span class="line">G   H  I   J -----------------  G &#x3D; A^^^ &#x3D; A^1^1^1 &#x3D; A~3</span><br><span class="line">                                H &#x3D; D^2  &#x3D; B^^2    &#x3D; A^^^2  &#x3D; A~2^2</span><br><span class="line">                                I &#x3D; F^   &#x3D; B^3^    &#x3D; A^^3^</span><br><span class="line">                                J &#x3D; F^2  &#x3D; B^3^2   &#x3D; A^^3^2</span><br></pre></td></tr></table></figure>

<ul>
<li>git的命令, 常见格式为 <code>git diff p1 p2 -- file</code>. 意为, 比较<code>p1</code>与<code>p2</code>两处指定file的区别<ul>
<li><code>p1</code> 缺省指向workspace, <code>p2</code> 缺省指向index.</li>
<li><code>--</code> 接文件或目录, 名字无歧义时可以省去<code>--</code>. (如 git checkout name 就可能有歧义, branch OR file?)</li>
<li><code>.</code> 表示所有的文件, 如 <code>git add .</code></li>
</ul>
</li>
<li>学会查看帮助, 加上 <code>-h</code> 即可. 如 <code>git checkout -h</code><ul>
<li><code>[]</code> 表示可选项, <code>&lt;&gt;</code> 表示必填项</li>
</ul>
</li>
</ul>
<h1 id="初始安装"><a href="#初始安装" class="headerlink" title="初始安装"></a>初始安装</h1><ul>
<li>新建git仓库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Create local repository</span><br><span class="line"># put &quot;.gitignore&quot; to project root direct.</span><br><span class="line">git init                        # create local repository</span><br><span class="line">git add README.md               # add somefiles</span><br><span class="line">git commit -m &quot;first commit&quot;    # commit to local repository</span><br><span class="line"></span><br><span class="line"># link with remote repository</span><br><span class="line">git remote add origin url       # add remote repository, &lt;url&gt; like https:&#x2F;&#x2F;... OR ssh:&#x2F;&#x2F;...</span><br><span class="line">git push -u origin master       # -u, 指定默认远程主机为 origin</span><br><span class="line"></span><br><span class="line"># Clone existing repository</span><br><span class="line">git clone url                   # &lt;url&gt; like https:&#x2F;&#x2F;... OR ssh:&#x2F;&#x2F;...</span><br><span class="line"></span><br><span class="line"># more cmd about config</span><br><span class="line">git config --list               # show config</span><br><span class="line">git config -e                   # edit local config file</span><br><span class="line">git config -e --global          # edit global config file</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>使用命令设置全局参数. (可跳过, 建议使用 <code>git config -e --global</code>)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># global setting</span><br><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br><span class="line"></span><br><span class="line"># alise setting</span><br><span class="line">git config --global alias.a &#39;add&#39;</span><br><span class="line">git config --global alias.aa &#39;add .&#39;</span><br><span class="line">git config --global alias.b &#39;branch&#39;</span><br><span class="line">git config --global alias.bb &#39;branch -a -v&#39;</span><br><span class="line">git config --global alias.co &#39;checkout&#39;</span><br><span class="line">git config --global alias.cm &#39;commit -m&#39;</span><br><span class="line">git config --global alias.lg &quot;log --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</span><br><span class="line">git config --global alias.ll &quot;log --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit -10&quot;</span><br><span class="line">git config --global alias.st &#39;status&#39;</span><br><span class="line">git config --global alias.diffname &#39;diff --name-status&#39;</span><br><span class="line"></span><br><span class="line"># set diff color</span><br><span class="line">git config --global color.diff.old &quot;red normal bold&quot;</span><br><span class="line">git config --global color.diff.new &quot;green normal bold&quot;</span><br><span class="line"></span><br><span class="line"># solve the warning, LF will be replaced by CRLF</span><br><span class="line">git config --global core.autocrlf false</span><br><span class="line">git config --global core.safecrlf false</span><br><span class="line"></span><br><span class="line"># set difftool mergetool (need p4merge)</span><br><span class="line">git config --global diff.tool p4merge</span><br><span class="line">git config --global difftool.p4merge.cmd &#39;&quot;D:\Program\Perforce\p4merge.exe&quot; &quot;$LOCAL&quot; &quot;$REMOTE&quot;&#39;</span><br><span class="line">git config --global difftool.prompt false</span><br><span class="line">git config --global merge.tool p4merge</span><br><span class="line">git config --global mergetool.p4merge.cmd &#39;&quot;D:\Program\Perforce\p4merge.exe&quot; &quot;$PWD&#x2F;$BASE&quot; &quot;$PWD&#x2F;$REMOTE&quot; &quot;$PWD&#x2F;$LOCAL&quot; &quot;$PWD&#x2F;$MERGED&quot;&#39;</span><br><span class="line">git config --global mergetool.p4merge.trustExitCode false</span><br><span class="line">git config --global mergetool.keepBackup false</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>使用 <code>git config -e --global</code> 打开全局配置文件, 设置全局参数.</li>
<li>安装 <a href="https://www.perforce.com/product/components/perforce-visual-merge-and-diff-tools">p4merge</a>, 用于支持 <code>difftool</code> 和 <code>mergetool</code></li>
<li>安装位置以 <code>D:\Program\Perforce\p4merge.exe</code> 为例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name &#x3D; https:&#x2F;&#x2F;draapho.github.io&#x2F;</span><br><span class="line">    email &#x3D; draapho@gmail.com</span><br><span class="line">[alias]</span><br><span class="line">    a &#x3D; add</span><br><span class="line">    aa &#x3D; add .</span><br><span class="line">    b &#x3D; branch</span><br><span class="line">    bb &#x3D; branch -a -v</span><br><span class="line">    co &#x3D; checkout</span><br><span class="line">    cm &#x3D; commit -m</span><br><span class="line">    lg &#x3D; log --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit</span><br><span class="line">    ll &#x3D; log --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit -10</span><br><span class="line">    st &#x3D; status</span><br><span class="line">    diffname &#x3D; diff --name-status</span><br><span class="line">[color &quot;diff&quot;]</span><br><span class="line">    old &#x3D; red normal bold</span><br><span class="line">    new &#x3D; green normal bold</span><br><span class="line">[core]</span><br><span class="line">    autocrlf &#x3D; false</span><br><span class="line">    safecrlf &#x3D; false</span><br><span class="line">[diff]</span><br><span class="line">    tool &#x3D; p4merge</span><br><span class="line">[difftool &quot;p4merge&quot;]</span><br><span class="line">    cmd &#x3D; \&quot;D:\\Program\\Perforce\\p4merge.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot;</span><br><span class="line">[difftool]</span><br><span class="line">    prompt &#x3D; false</span><br><span class="line">[merge]</span><br><span class="line">    tool &#x3D; p4merge</span><br><span class="line">[mergetool &quot;p4merge&quot;]</span><br><span class="line">    cmd &#x3D; \&quot;D:\\Program\\Perforce\\p4merge.exe\&quot; \&quot;$PWD&#x2F;$BASE\&quot; \&quot;$PWD&#x2F;$REMOTE\&quot; \&quot;$PWD&#x2F;$LOCAL\&quot; \&quot;$PWD&#x2F;$MERGED\&quot;</span><br><span class="line">    trustExitCode &#x3D; false</span><br><span class="line">[mergetool]</span><br><span class="line">    keepBackup &#x3D; false</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看信息</span><br><span class="line">git st                          # git status            # 显示工作区变更的文件</span><br><span class="line">git lg                          # git log 增强版        # 显示所有提交</span><br><span class="line">git ll                          # git lg -10            # 显示过去10次提交</span><br><span class="line">git shortlog -sn                                        # 显示所有提交过的用户</span><br><span class="line">git show --name-only commit                             # 显示某次提交发生变化的文件</span><br><span class="line"></span><br><span class="line"># stash                                                 # 少量且短时间的使用!</span><br><span class="line">git stash                                               # workspace-&gt;stash(藏匿处)</span><br><span class="line">git stash pop                                           # stash(不保存)-&gt;workspace</span><br><span class="line"></span><br><span class="line"># 提交文件</span><br><span class="line">git aa                          # git add .             # workspace-&gt;index</span><br><span class="line">git a *.c *.h                   # &lt;file | dir&gt;          # 添加指定文件</span><br><span class="line">git reset HEAD [file]           # discard file @index   # add的逆操作 HEAD-&gt;index</span><br><span class="line">git cm &quot;msg&quot;                    # git commit -m &quot;msg&quot;   # index-&gt;repository</span><br><span class="line">git commit --amend -m &quot;message&quot;                         # 修改&#x2F;替换之前的提交</span><br><span class="line"></span><br><span class="line"># 分支操作</span><br><span class="line">git b name                      # git branch name       # 创建分支</span><br><span class="line">git b name commit                                       # 基于指定 commit 创建分支</span><br><span class="line">git b -d name                   # branch delete         # 删除分支</span><br><span class="line">git b -dr origin&#x2F;name           # delete remote         # 删除远程分支</span><br><span class="line">git b -m new_name               # git branch --move     # 重命名分支</span><br><span class="line">git bb                          # git branch -a         # 查看所有分支</span><br><span class="line">git remote -v                                           # 查看远程分支</span><br><span class="line">git co name                     # git checkout name     # 切换分支</span><br><span class="line">git co -b name                  # checkout &amp; branch     # 创建并切换分支</span><br><span class="line"></span><br><span class="line"># 版本合并和回退</span><br><span class="line">git merge branch                # 合并branch到当前分支</span><br><span class="line">git mergetool                   # 已图形化工具处理文件冲突 (如 p4merge.exe)</span><br><span class="line">git cherry-pick commit          # 合并commit到当前分支</span><br><span class="line">git rebase -i HEAD~3            # 修改&#x2F;压缩多个提交, 根据提示操作, 第一行不能是squash!</span><br><span class="line">git revert commit               # 提交逆操作来实现版本恢复, 不影响任何历史记录!</span><br><span class="line">git push                                                # 推送到默认的远程主机</span><br><span class="line">git push -f                     # --force               # 忽略冲突, 强制推送</span><br><span class="line">git pull                        # fetch &amp; merge         # 合并远程分支到当前分支</span><br><span class="line"></span><br><span class="line"># tag                           # 用于标记一个版本, 可以替代 commitHash</span><br><span class="line">git tag                         # 查看版本</span><br><span class="line">git tag v100                    # 创建版本</span><br><span class="line">git tag -d v100                 # 删除版本</span><br><span class="line">git push --tags                 # 推送tag</span><br><span class="line"></span><br><span class="line"># 查看差异</span><br><span class="line">git diff                        # workspace VS index (p1缺省指向workspace, p2缺省指向index)</span><br><span class="line">git diff p1 p2                  # p1 VS p2, 可以是 HEAD~1, commitHash值, TAG, 分支名称</span><br><span class="line">git diff p1 p2 -- *.c *.h       # -- 指定文件或目录, 可省</span><br><span class="line">git diff --name-status p1 p2    # 获得变更的文件列表</span><br><span class="line">git diff --stat p1 p2           # 统计变更的数据</span><br><span class="line">git difftool p1 p2 -- file      # 使用图形化工具显示差异 (如 p4merge.exe)</span><br><span class="line"></span><br><span class="line"># 撤销</span><br><span class="line">git checkout p1 -- file         # p1-&gt;index-&gt;workspace  # p1缺省为index, --和file可省</span><br><span class="line">git reset p1 -- file            # p1-&gt;HEAD-&gt;index,      # p1缺省为HEAD, --和file可省</span><br><span class="line">git reset --soft p1             # p1-&gt;HEAD                      # p1缺省为HEAD, 不可带file参</span><br><span class="line">git reset --hard p1             # p1-&gt;HEAD-&gt;index &amp; workspace   # p1缺省为HEAD, 不可带file参</span><br><span class="line"></span><br><span class="line">git checkout .                  # index-&gt;workspace      # 清除工作区的变更(!!!危险操作)</span><br><span class="line">git checkout branch             # branch-&gt;index-&gt;workspace      # 切换分支</span><br><span class="line">git reset --hard                # HEAD-&gt;index &amp; workspace       # 恢复仓库到HEAD状态</span><br><span class="line">git reset HEAD^ file            # HEAD^-&gt;HEAD-&gt;index            # 指定file, 进行版本回滚</span><br><span class="line">git reset --soft HEAD~3         # HEAD~3-&gt;HEAD                  # 版本回滚</span><br></pre></td></tr></table></figure>


<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>cheat sheet</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>协程/进程/线程资料收集</title>
    <url>/2016/11/14/1615-software-thread/</url>
    <content><![CDATA[<p>协程(Coroutine), 多线程(Thread), 多进程(Multiprocessing)资料繁多, 学无止境, 就集中在这一篇收集贴中. 便于查阅学习</p>
<h1 id="自己的理解"><a href="#自己的理解" class="headerlink" title="自己的理解"></a>自己的理解</h1><ul>
<li>协程, 任务之间不是竞争关系, 而是协作关系, 需要每个任务都需要有一颗舍己为公的心!<ul>
<li>大家排队喝水, 喝到差不多就自己让给下一个人, 自己再去排队! 可按照优先级来插队的.</li>
<li>遇到不讲道理的人, 那这个机制就失效了. 因为没有抢占, 大家都只会默默等待…</li>
<li>优点, 任务切换的代价非常小. 由于没有抢占, 也就没有复杂的临界区问题. 锁的问题也变得简单.</li>
<li>缺点, 这个世界上总有不讲理的人, 所以, 大型任务和系统不敢这么用…</li>
<li>单片机开发是非常适合使用协程的! (资源有限, 需要减小任务切换的开销. 任务可控, 意味着易于协作)</li>
<li>python 下可用 gevent.</li>
</ul>
</li>
</ul>
<ul>
<li>多线程, 任务之间是竞争关系, 高优先级优先执行, 同时又有时间片限制, 避免高优先级任务霸占CPU<ul>
<li>谁强谁喝水, 不过旁边有个管理员, 哪个家伙喝水时间太久了, 就会把他给跩一边去, 大家重新来抢.</li>
<li>线程是共享内存的, 理解为这些水来自于同一个自来水厂(这个水厂有毒的话, 谁了逃不了),</li>
<li>多核就是多个水龙头, 同一时刻可以有多个人在喝水.</li>
<li>优点, 任务的开销比进程小(因为共享内存), 通讯方式多样. 加个水龙头和造个水厂的区别!!!</li>
<li>缺点, 一大帮自私又不讲理的人在一起总是很难管理的… 需要各种锁机制来维持和谐共处…</li>
<li>python的多线程, 由于GIL机制的存在, 是无法利用多核的. (意味着不适用于CPU密集型任务)</li>
<li>python有一个类进程版本的线程池 <code>multiprocessing.pool.ThreadPool</code>, 可以获取返回值<br>由于本质是线程, Windows下terminate方法是没有用的.</li>
</ul>
</li>
</ul>
<ul>
<li>多进程, 任务之间是竞争关系, 任务之间的数据全部隔离, 没有共享.<ul>
<li>进程是资源分配的基本单位. 进程包含线程, 线程共用进程的资源.</li>
<li>进程比线程安全性更高, 因为拥有独立的内存块(独立水厂供水)</li>
<li>进程的建立和调度比线程更费时间和资源</li>
<li>进程间的数据共享和交换很麻烦. (python例子中, 进程内 print 不会打印, 参数传递需要可以pickle)</li>
<li>python 下推荐使用 <code>multiprocessing.pool.Pool</code>. 可以获取返回值.</li>
</ul>
</li>
</ul>
<ul>
<li>进程和线程以及多核<ul>
<li>操作系统必须有一个进程, 创建进程时, 会分配好供这个进程使用的内存和上下文环境.</li>
<li>线程依赖于进程, 多线程运行于同一个进程下面, 会共享同一个进程的内存.</li>
<li>事实上, 线程是最难写好的一种多任务方式(因为共享内存).</li>
<li>以android为例,<ul>
<li>android的每一个应用就是一个linux进程, 所以写的再烂的应用也不会导致整个android系统崩溃.</li>
<li>应用内支持多线程, 也事实上都对应到linux的线程, 这些线程运行在分配好的linux进程中.</li>
</ul>
</li>
<li>进程和线程的概念和单核还是多核一点关系都没有! 先理解好单核再说, 真正涉及到CPU密集型任务时, 再考虑多核优化…</li>
</ul>
</li>
</ul>
<h1 id="优缺点比较"><a href="#优缺点比较" class="headerlink" title="优缺点比较"></a>优缺点比较</h1><ul>
<li>协程具有进程和线程各自的优点. 但其缺点是需要任务间自己来协作调度(很容易写成阻塞等待), 这一点直接导致了通用性很差.</li>
<li><a href="http://blog.csdn.net/lishenglong666/article/details/8557215">多线程还是多进程的选择及区别</a>, 比较全面的一篇文章!<ul>
<li>本文也有一个转字, 应该是综合了多种搜素结果写出来的一篇博文. 有结论, 有实验代码和过程</li>
<li>鱼还是熊掌：浅谈多进程多线程的选择</li>
<li>1.进程与线程</li>
<li>一、重复周丽论文实验步骤</li>
<li>二、增加并发数量的实验</li>
<li>三、增加每进程/线程的工作强度的实验</li>
<li>四、多进程和多线程在创建和销毁上的效率比较</li>
<li>五、双核系统重复周丽论文实验步骤</li>
<li>六、并发服务的不可测性</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>多进程</th>
<th>多线程</th>
<th>总结</th>
</tr>
</thead>
<tbody><tr>
<td>数据共享、同步</td>
<td>数据共享复杂，需要用IPC；数据是分开的，<strong>同步简单</strong></td>
<td>因为共享进程数据，<strong>数据共享简单</strong>，但也是因为这个原因导致同步复杂</td>
<td>各有优势</td>
</tr>
<tr>
<td>内存、CPU</td>
<td>占用内存多，切换复杂，CPU利用率低</td>
<td><strong>占用内存少，切换简单，CPU利用率高</strong></td>
<td>线程占优</td>
</tr>
<tr>
<td>创建销毁、切换</td>
<td>创建销毁、切换复杂，速度慢</td>
<td><strong>创建销毁、切换简单，速度很快</strong></td>
<td>线程占优</td>
</tr>
<tr>
<td>编程、调试</td>
<td><strong>编程简单，调试简单</strong></td>
<td>编程复杂，调试复杂</td>
<td>进程占优</td>
</tr>
<tr>
<td>可靠性</td>
<td><strong>进程间不会互相影响</strong></td>
<td>一个线程挂掉将导致整个进程挂掉</td>
<td>进程占优</td>
</tr>
<tr>
<td>分布式</td>
<td><strong>适应于多核、多机分布式</strong>；如果一台机器不够，扩展到多台机器比较简单</td>
<td>适应于多核分布式</td>
<td>进程占优</td>
</tr>
</tbody></table>
<h1 id="资料集"><a href="#资料集" class="headerlink" title="资料集"></a>资料集</h1><ul>
<li><p><a href="https://www.tutorialspoint.com/python/python_multithreading.htm">Python Multithreaded Programming</a></p>
<ul>
<li>Python多线程入门教程, 有详细的说明, 源代码及运行结果.</li>
<li>主要有3个示例, 多线程, 多线程同步, 使用Queue来通讯</li>
</ul>
</li>
<li><p><a href="http://www.jianshu.com/p/0e4ff7c856d3">Python 多线程</a></p>
<ul>
<li>介绍了Python多线程的状态, 类型</li>
<li>线程的创建, 合并(join), 同步, 锁(Lock, 死锁, RLock), 其它IPC</li>
<li>将子线程设置<strong>后台线程</strong>(setDaemon), 让子线程随主线程一起结束.</li>
<li>提了一下Python的GIL, 参考资料中的一篇对此做了很好的说明: <a href="http://zhuoqiang.me/python-thread-gil-and-ctypes.html">python 线程，GIL 和 ctypes</a></li>
</ul>
</li>
<li><p><a href="https://draapho.github.io/2016/11/03/1615-python-ipc/">Python线程同步机制: Locks, RLocks, Semaphores, Conditions, Events和Queues</a></p>
<ul>
<li>线程（Threading）</li>
<li>锁（Lock）</li>
<li>可重入锁（RLock）</li>
<li>条件（Condition）</li>
<li>信号量（Semaphore）</li>
<li>事件（Event）</li>
<li>队列（Queue）, 重点推荐</li>
</ul>
</li>
<li><p><a href="https://my.oschina.net/leejun2005/blog/179265">理解 Python 中的多线程</a></p>
<ul>
<li>示例1, 请求五个不同的url. 比较了单线程和多线程性能上的差别</li>
<li>示例2, 全局变量的线程安全问题（race condition）. BUG版和修改版</li>
<li>示例3, 多线程环境下的原子操作. BUG版和修改版</li>
<li>示例4, Python多线程简易版：线程池 threadpool</li>
<li>附上了很多参考和推荐阅读的资料!</li>
</ul>
</li>
<li><p>线程池 threadpool (需安装)</p>
<ul>
<li><a href="http://www.zhidaow.com/post/python-threadpool">Python多线程简易版 - 线程池threadpool</a>, 新手上路版</li>
<li><a href="http://chriskiehl.com/article/parallelism-in-one-line/">Parallelism in one line</a>, 比较了传统方案和线程池方案, 并给出了范例</li>
<li>这是<code>Parallelism in one line</code>的中文翻译版本, 并有遇到小坑和补充说明. <a href="https://my.oschina.net/leejun2005/blog/194270">Python 并行任务技巧</a></li>
<li><strong>注意： threadpool 是非线程安全的</strong>。<ul>
<li>关于线程安全, 可参考<a href="http://blog.csdn.net/xiao__gui/article/details/8934832">Java线程安全和非线程安全</a></li>
<li>个人理解, 对于python的非线程安全, 编程时需要特别注意 <code>可变对象</code> 和 <code>不可变对象</code>, 弄清楚Python到底是在<code>赋值</code>还是<code>引用</code>(相当于指针)</li>
<li>可以参考此文 <a href="https://my.oschina.net/leejun2005/blog/145911">python基础（5）：深入理解 python 中的赋值、引用、拷贝、作用域</a></li>
</ul>
</li>
<li>初步结论, 还是比较推崇线程池的: 比起经典的方式来说简单很多，效率高，易懂，而且没什么死锁的陷阱。</li>
</ul>
</li>
<li><p><a href="https://my.oschina.net/leejun2005/blog/398826">Python 多线程教程：并发与并行</a></p>
<ul>
<li>讲了多线程, 多进程, 以及分布式任务.</li>
<li>原作者已下载网络图片来说明问题, 转发者为了便于测试和理解, 简化了代码.</li>
<li>1, 单线程执行. 花了19.4秒去下载91张图片</li>
<li>2, 多线程. 下载时间变成了4.1秒. 并说明了为何有GIL的情况下, 多线程仍然是有效的(因为是IO密集型的任务)</li>
<li>3, 多进程. 优点, 避免了GIL, 适用于CPU密集型任务. 缺点, 耗内存!</li>
<li>4, 分布式任务. 提了一下<code>RQ</code>和<code>Celery</code></li>
<li>5, 总结: IO密集型，多线程或多进程. CPU密集型, 多进程. 网络应用, 分布式任务</li>
<li>6, 并发、并行区别与联系. 并发, 一个人按优先级处理多件事情(任一时刻只能做一件事情). 并行, 有多个人各自做事(多核多任务).</li>
</ul>
</li>
<li><p><strong>进程池 multiprocessing.Pool 以及 multiprocessing.pool.ThreadPool</strong></p>
<ul>
<li><a href="https://segmentfault.com/a/1190000003044986">Python 多进程实践</a><ul>
<li>Python多进程的实现入门级文章</li>
<li>创建子进程的方法: fork, multiprocessing, Pool 进程池</li>
<li>IPC(进程间通讯): Queue, Pipe</li>
</ul>
</li>
<li><a href="http://blog.csdn.net/seetheworld518/article/details/49639651">Python 多进程 multiprocessing.Pool类详解</a></li>
<li><a href="http://lucasb.eyer.be/snips/python-thread-pool.html">Python’s undocumented ThreadPool</a>, 提了一下 ThreadPool</li>
<li><a href="https://draapho.github.io/2016/11/28/1622-python-time/">python 延时及超时</a>, “学习过程中的例子” 中有尝试使用进程池</li>
<li><a href="http://www.eenot.com/thread-103459-1-1.html">Python 中 Ctrl+C 不能终止 Multiprocessing Pool 的解决方</a>, ThreadPool有同样的问题. 可以搜索关键字: Keyboard Interrupts multiprocessing Pool.</li>
<li><a href="http://bugs.python.org/issue17140">使用 multiprocessing.pool.ThreadPool 可能的潜在风险</a>, 本质是线程, 而且没有文档说明</li>
</ul>
</li>
<li><p><a href="https://my.oschina.net/leejun2005/blog/203148">浅谈 python multiprocessing（多进程）下如何共享变量</a></p>
<ul>
<li>1, 抛出了一个多进程的问题.</li>
<li>2, python 多进程共享变量的几种方式</li>
<li>3, 多进程的问题远不止这么多：数据的同步. (需要Lock)</li>
<li>4, 总结为: 多进程最好还是用IPC(message之类的). 如果一定要用共享变量, 那也是可以的…</li>
</ul>
</li>
<li><p><a href="https://liangxiansen.github.io/2016/08/08/python%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/">Python之路：(十五）进程、线程和协程</a></p>
<ul>
<li>Python线程, 线程锁(Lock, Rlock), 其它IPC, 线程池</li>
<li>Python进程, 进程数据共享, 进程IPC. (Python Windows下是可以用进程的, 只是不支持fork)</li>
<li>Python协程, greenlet(主动切换), gevent(遇到IO操作, 自动切换).</li>
</ul>
</li>
<li><p><strong><a href="http://xlambda.com/gevent-tutorial/">gevent程序员指南</a></strong></p>
<ul>
<li>核心部分, 较为详细的介绍了 gevent 的原理和使用方式.</li>
<li>数据结构, 介绍了协程之间的通讯工具</li>
<li>真实世界的应用, 几个实际应用的例子</li>
</ul>
</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>process</tag>
        <tag>ipc</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python实现BLE通讯</title>
    <url>/2016/11/15/1616-python-ble/</url>
    <content><![CDATA[<h1 id="环境与资源"><a href="#环境与资源" class="headerlink" title="环境与资源"></a>环境与资源</h1><ul>
<li>windows 开发环境</li>
<li>python 2.7</li>
<li><a href="https://github.com/peplin/pygatt">pygatt</a></li>
<li>Bluegiga 的 <a href="http://www.silabs.com/products/wireless/bluetooth/bluetooth-smart-modules/Pages/bled112-bluetooth-smart-dongle.aspx">BLED112 Bluetooth Smart Dongle</a></li>
</ul>
<h1 id="闲扯"><a href="#闲扯" class="headerlink" title="闲扯"></a>闲扯</h1><ul>
<li>背景, 需要在windows上做一款基于BLE通讯的软件. 第一反应, 痛苦.</li>
<li>使用的是 Bluegiga 的BLE方案, 协议栈芯片内置, 串口通讯即可, 并寻得 <a href="https://github.com/jrowberg/bglib">bglib</a> 这么一个python库, 还有范例!</li>
<li>不幸的是, 自己功力不够, 基于此函数库开发出的BLE通讯, 非常不稳定… 没有痛下决心自己写, 于是继续尝试寻找资源.</li>
<li>觅得 <a href="https://github.com/peplin/pygatt">pygatt</a> 方案, 三平台全支持! windows 和 mac 下正是基于bglib实现的!</li>
<li><a href="https://github.com/peplin/pygatt">pygatt</a> 是python的第三方库, 说明文档比较少, 测试了一下非常好用!</li>
</ul>
<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><ul>
<li>DEVICE_ADDRESS, 默认的需要connect的BLE地址</li>
<li>基于 Bluegiga 的 <code>cable_replacement</code> 范例, 其 characteristic uuid 为 <code>e7add780-b042-4876-aae1-112855353cc1</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygatt</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Many devices, e.g. Fitbit, use random addressing - this is required to connect.</span></span><br><span class="line">ADDRESS_TYPE = pygatt.BLEAddressType.random</span><br><span class="line">DEVICE_ADDRESS = <span class="string">&quot;00:07:80:BF:6A:73&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">indication_callback</span>(<span class="params">handle, value</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;indication, handle %d: %s &quot;</span> % (handle, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pytest</span>(<span class="params">address=DEVICE_ADDRESS, <span class="built_in">type</span>=pygatt.BLEAddressType.public</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        adapter = pygatt.BGAPIBackend()</span><br><span class="line">        adapter.start()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;===== adapter.scan() =====&quot;</span></span><br><span class="line">        devices = adapter.scan()</span><br><span class="line">        <span class="keyword">for</span> dev <span class="keyword">in</span> devices:</span><br><span class="line">            <span class="comment"># print dev</span></span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;address: %s, name: %s &quot;</span> % (dev[<span class="string">&#x27;address&#x27;</span>], dev[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;===== adapter.connect() =====&quot;</span></span><br><span class="line">        device = adapter.connect(address, address_type=<span class="built_in">type</span>)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;address: &quot;</span> + <span class="built_in">str</span>(device._address)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;handle : &quot;</span> + <span class="built_in">str</span>(device._handle)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;rssi   : &quot;</span> + <span class="built_in">str</span>(device.get_rssi())</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;====== device.discover_characteristics() =====&quot;</span></span><br><span class="line">        <span class="keyword">for</span> uuid <span class="keyword">in</span> device.discover_characteristics().keys():</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                print(<span class="string">&quot;Read UUID %s (handle %d): %s&quot;</span> %</span><br><span class="line">                      (uuid, device.get_handle(uuid), binascii.hexlify(device.char_read(uuid))))</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                print(<span class="string">&quot;Read UUID %s (handle %d): %s&quot;</span> %</span><br><span class="line">                      (uuid, device.get_handle(uuid), <span class="string">&quot;!deny!&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;====== device.char_read() / device.char_read_handle() =====&quot;</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;2a00: &quot;</span> + device.char_read(<span class="string">&quot;00002a00-0000-1000-8000-00805f9b34fb&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;2a00: &quot;</span> + device.char_read_handle(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;====== device.subscribe() =====&quot;</span></span><br><span class="line">        device.subscribe(<span class="string">&quot;e7add780-b042-4876-aae1-112855353cc1&quot;</span>,</span><br><span class="line">                         callback=indication_callback, indication=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># device.receive_notification(8, &quot;test&quot;)</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;====== device.char_write_handle() =====&quot;</span></span><br><span class="line">        in_buf = <span class="built_in">map</span>(<span class="built_in">ord</span>, <span class="string">&quot;hello world, hello BLE!!!&quot;</span>)</span><br><span class="line">        <span class="comment"># send via uuid &amp; handle, maximum is 20 bytes</span></span><br><span class="line">        device.char_write(<span class="string">&quot;e7add780-b042-4876-aae1-112855353cc1&quot;</span>, in_buf[:<span class="number">20</span>])</span><br><span class="line">        device.char_write_handle(<span class="number">0x08</span>, in_buf[<span class="number">20</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        adapter.stop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># logging.basicConfig()</span></span><br><span class="line">    <span class="comment"># logging.getLogger(&#x27;pygatt&#x27;).setLevel(logging.DEBUG)</span></span><br><span class="line">    pytest()</span><br></pre></td></tr></table></figure>

<h1 id="BleDevice-类"><a href="#BleDevice-类" class="headerlink" title="BleDevice 类"></a>BleDevice 类</h1><ul>
<li>为了方便使用, 自己基于 pygatt 再打包一层</li>
<li>遗憾的是没有disconnect的通知. 可以参考 <a href="https://github.com/peplin/pygatt/issues/72">Disconnect event not shown</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygatt</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BleDevice</span>(<span class="params">pygatt.BGAPIBackend</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.device = <span class="literal">None</span></span><br><span class="line">        self.adapter = pygatt.BGAPIBackend()</span><br><span class="line">        self.adapter.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.adapter.stop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scan</span>(<span class="params">self, timeout=<span class="number">5</span></span>):</span></span><br><span class="line">        self.devices = self.adapter.scan(timeout)</span><br><span class="line">        <span class="keyword">return</span> self.devices</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect_name</span>(<span class="params">self, name, devices=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> devices <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            devices = self.devices</span><br><span class="line">        <span class="keyword">for</span> dev <span class="keyword">in</span> self.devices:</span><br><span class="line">            <span class="keyword">if</span> name == dev[<span class="string">&#x27;name&#x27;</span>]:</span><br><span class="line">                <span class="keyword">return</span> self.connect(dev[<span class="string">&#x27;address&#x27;</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, address</span>):</span></span><br><span class="line">        self.device = self.adapter.connect(address)</span><br><span class="line">        <span class="keyword">return</span> self.device</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discover_characteristics</span>(<span class="params">self, device=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> device <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            device = self.device</span><br><span class="line">        characteristics = []</span><br><span class="line">        <span class="keyword">for</span> uuid <span class="keyword">in</span> device.discover_characteristics().keys():</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                device.char_read(uuid)</span><br><span class="line">                characteristics.append(</span><br><span class="line">                    &#123;<span class="string">&#x27;uuid&#x27;</span>: uuid, <span class="string">&#x27;handle&#x27;</span>: device.get_handle(uuid), <span class="string">&#x27;readable&#x27;</span>: <span class="literal">True</span>&#125;)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&quot;unable to read&quot;</span> <span class="keyword">in</span> <span class="built_in">str</span>(e).lower():</span><br><span class="line">                    characteristics.append(</span><br><span class="line">                        &#123;<span class="string">&#x27;uuid&#x27;</span>: uuid, <span class="string">&#x27;handle&#x27;</span>: device.get_handle(uuid), <span class="string">&#x27;readable&#x27;</span>: <span class="literal">False</span>&#125;)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">raise</span> e</span><br><span class="line">        <span class="keyword">return</span> characteristics</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_indication</span>(<span class="params">self, uuid, device=<span class="literal">None</span>, callback=<span class="literal">None</span>, indication=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> device <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            device = self.device</span><br><span class="line">        device.subscribe(uuid, callback, indication)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_characteristics</span>(<span class="params">self, uuid, device=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> device <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            device = self.device</span><br><span class="line">        <span class="keyword">return</span> device.char_read(uuid)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_characteristics_handle</span>(<span class="params">self, handle, device=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> device <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            device = self.device</span><br><span class="line">        <span class="keyword">return</span> device.char_read_handle(handle)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_characteristics</span>(<span class="params">self, <span class="built_in">str</span>, uuid, device=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> device <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            device = self.device</span><br><span class="line">        data = <span class="built_in">map</span>(<span class="built_in">ord</span>, <span class="built_in">str</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data), <span class="number">20</span>):</span><br><span class="line">            device.char_write(uuid, data[i:i + <span class="number">20</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_characteristics_handle</span>(<span class="params">self, <span class="built_in">str</span>, handle, device=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> device <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            device = self.device</span><br><span class="line">        data = <span class="built_in">map</span>(<span class="built_in">ord</span>, <span class="built_in">str</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data), <span class="number">20</span>):</span><br><span class="line">            device.char_write_handle(handle, data[i:i + <span class="number">20</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># logging.basicConfig()</span></span><br><span class="line">    <span class="comment"># logging.getLogger(&#x27;pygatt&#x27;).setLevel(logging.DEBUG)</span></span><br><span class="line">    ble = BleDevice()</span><br><span class="line">    <span class="built_in">print</span> ble.scan()</span><br><span class="line">    device = ble.connect_name(<span class="string">&quot;Bluegiga CR Demo&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> device._address</span><br><span class="line">    chars = ble.discover_characteristics(device)</span><br><span class="line">    <span class="built_in">print</span> chars</span><br><span class="line">    <span class="comment"># print chars[0][&#x27;uuid&#x27;]</span></span><br><span class="line">    <span class="built_in">print</span> ble.read_characteristics(chars[<span class="number">1</span>][<span class="string">&#x27;uuid&#x27;</span>])</span><br><span class="line">    ble.write_characteristics(<span class="string">&quot;hello world&quot;</span>, chars[<span class="number">0</span>][<span class="string">&#x27;uuid&#x27;</span>])</span><br></pre></td></tr></table></figure>


<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pygatt</tag>
        <tag>BLE</tag>
      </tags>
  </entry>
  <entry>
    <title>python的第一个小程序, 蓝牙及串口终端</title>
    <url>/2016/11/16/1617-python-terminal/</url>
    <content><![CDATA[<h1 id="环境与资源"><a href="#环境与资源" class="headerlink" title="环境与资源"></a>环境与资源</h1><ul>
<li>windows 开发环境</li>
<li>python 2.7</li>
<li>pywin32, windows support</li>
<li>pyserial, serial port, com</li>
<li>pygatt, ble</li>
<li>pyinstaller, generate exe file</li>
<li>qt 4.8 (pyqt 4.11), GUI</li>
<li>Bluegiga 的 <a href="http://www.silabs.com/products/wireless/bluetooth/bluetooth-smart-modules/Pages/bled112-bluetooth-smart-dongle.aspx">BLED112 Bluetooth Smart Dongle</a></li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul>
<li>略过 python 的安装++</li>
<li>实际做项目的话, 建议使用2.7版本, 32位(这样生成的exe文件是32位的, 能兼容所有机器)</li>
<li>安装 pywin32: <code>pip install pypiwin32</code></li>
<li>安装 pyserial: <code>pip install pyserial</code></li>
<li>安装 pygatt: <code>pip install pygatt</code>, 事实上, pygatt依赖于pyserial. 因此直接装pygatt也可以</li>
<li>安装 pyinstaller: <code>pip install pyinstaller</code></li>
<li>下载并安装 <a href="https://riverbankcomputing.com/software/pyqt/download">PyQt4-4.11.4-gpl-Py2.7-Qt4.8.7.exe</a><ul>
<li>注意匹配python版本和32位/64位window</li>
<li>pyqt5 仅支持 python3 以上版本. 我用 python2.7 是因为需要使用其它的库, 如 <a href="https://labjack.com/">LabJack</a></li>
<li><code>Qt Designer</code> 用于设计UI, 文件格式为<code>.ui</code>. 它一般位于 <code>C:\Python27\Lib\site-packages\PyQt4\designer.exe</code>. 最终取决于Python安装路径</li>
<li><code>pyuic4.bat</code> 用于将 <code>.ui</code> 文件转换为 <code>.py</code> 文件. 它一般位于 <code>C:\Python27\Lib\site-packages\PyQt4\</code></li>
<li>把 <code>pyuic4.bat</code> 的路径放入系统环境变量, 这样后续就能方便使用这个指令了</li>
</ul>
</li>
<li>windows平台需要借助 <a href="http://www.silabs.com/products/wireless/bluetooth/bluetooth-smart-modules/Pages/bled112-bluetooth-smart-dongle.aspx">BLED112 Bluetooth Smart Dongle</a> 这么一个设备才能实现BLE通讯</li>
</ul>
<h1 id="UI设计"><a href="#UI设计" class="headerlink" title="UI设计"></a>UI设计</h1><ul>
<li>可以参考我的另一篇文章 <a href="https://draapho.github.io/2016/10/20/1612-python-pyqtui/">PyQt 的交互操作</a></li>
</ul>
<h2 id="PyQt-入门"><a href="#PyQt-入门" class="headerlink" title="PyQt 入门"></a>PyQt 入门</h2><ul>
<li>为什么选择PyQt? (注意, 如果商用, PyQt是需要授权使用的)</li>
<li><a href="http://ojs.pythonpapers.org/index.php/tpp/article/view/61/57">PyGTK, PyQT, Tkinter and wxPython comparison</a></li>
<li>PyQt使用入门:</li>
<li><a href="https://www.tutorialspoint.com/pyqt/index.htm">PyQt Tutorial</a>, 新手上路, 建议看到 <code>Using Qt Designer</code> 即可</li>
<li><a href="http://www.training.prace-ri.eu/uploads/tx_pracetmo/QtGuiIntro.pdf">Introduction to GUI development using Qt</a>, 整体理解Qt设计思路</li>
<li><a href="http://www.qaulau.com/books/PyQt4_Tutorial/">PyQt4教程</a>, 中文版, 分类很细, 便于查阅范例</li>
</ul>
<h2 id="使用-Qt-Designer-设计GUI并生成-gui-py"><a href="#使用-Qt-Designer-设计GUI并生成-gui-py" class="headerlink" title="使用 Qt Designer 设计GUI并生成 gui.py"></a>使用 Qt Designer 设计GUI并生成 gui.py</h2><ul>
<li>使用 <code>Qt Designer</code> 设计 GUI 框架, 并保存<code>gui.ui</code>到项目路径, 如 <code>D:\ble terminal</code></li>
<li>打开cmd终端, 并切换到 <code>D:\ble terminal</code></li>
<li><code>pyuic4.bat -x -o gui.py gui.ui</code> 生成<code>gui.py</code>文件,<ul>
<li><code>-x</code> 表示可执行, 即包含<code>if __name__ == &quot;__main__&quot;</code>这部分代码</li>
<li><code>-o</code> 表示目标文件名</li>
<li>也可以使用命令行 <code>pyuic4.bat demo.ui &gt; demo.py</code>, 效果等同于 <code>pyuic4.bat -o gui.py gui.ui</code></li>
</ul>
</li>
<li>创建 <code>gui_action.py</code> 文件, 用于书写交互操作部分的代码, 基本格式如下<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> gui</span><br><span class="line"><span class="keyword">from</span> PyQt4.QtGui <span class="keyword">import</span> QApplication, QMainWindow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuiAction</span>(<span class="params">QMainWindow, gui.Ui_MainWindow</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(self.__class__, self).__init__()</span><br><span class="line">        self.ui.setupUi(self)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    gui_action = GuiAction()</span><br><span class="line">    gui_action.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="UI线程通讯"><a href="#UI线程通讯" class="headerlink" title="UI线程通讯"></a>UI线程通讯</h1><ul>
<li>可以参考我的另一篇文章 <a href="https://draapho.github.io/2016/10/20/1612-python-pyqtui/">PyQt 的交互操作</a></li>
<li>PyQt的信号和槽, 是一种通讯机制, 可以用于QObject之间的信息交互. 可以参考:<ul>
<li><a href="http://www.training.prace-ri.eu/uploads/tx_pracetmo/QtGuiIntro.pdf">Introduction to GUI development using Qt</a></li>
<li><a href="https://www.linuxzen.com/pyqt4-xin-hao-he-cao-xiang-jie.html">PyQt4 信号和槽详解</a></li>
</ul>
</li>
<li>参考 <a href="https://nikolak.com/pyqt-threading-tutorial/">PyQt: Threading Basics Tutorial</a></li>
<li>关于 QThread 高阶应用和注意事项, 可参考 <a href="http://blog.csdn.net/u011012932/article/details/52186626">Qt之QThread（深入理解）</a></li>
<li>本程序使用的线程通讯框架如下:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuiAction</span>(<span class="params">QMainWindow, gui.Ui_MainWindow</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># queue_ble 用于传递数据给ble线程 (这样用不好, 可能有风险)</span></span><br><span class="line">        self.queue_ble = Queue.Queue()</span><br><span class="line">        <span class="comment"># thread_ble 为 ble 处理线程</span></span><br><span class="line">        self.thread_ble = ThreadBleServer(self.queue_ble)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cmd_send</span>(<span class="params">self</span>):</span></span><br><span class="line">        cmd = self.lineEdit.text()</span><br><span class="line">        <span class="comment"># 通过 queue_ble 传递数据给ble线程</span></span><br><span class="line">        self.queue_ble.put(cmd)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ble_start</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 简单理解, 就是将 self.ble_handle 设置为 thread_ble 信号触发后的处理函数</span></span><br><span class="line">        <span class="comment"># 使用 PyQt_PyObject 作为参数类型具有更好的通用性, 可以传递任何数据.</span></span><br><span class="line">        self.connect(self.thread_ble, SIGNAL(</span><br><span class="line">            <span class="string">&quot;ble_handle(PyQt_PyObject, PyQt_PyObject)&quot;</span>), self.ble_handle)</span><br><span class="line">        <span class="comment"># 启动 ble 处理线程</span></span><br><span class="line">        self.thread_ble.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ble_stop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 用于终止 thread_ble 线程</span></span><br><span class="line">        self.thread_ble.stop_ble()</span><br><span class="line">        self.disconnect(self.thread_ble, SIGNAL(</span><br><span class="line">            <span class="string">&quot;ble_handle(PyQt_PyObject, PyQt_PyObject)&quot;</span>), self.ble_handle)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadBleServer</span>(<span class="params">QThread</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, queue</span>):</span></span><br><span class="line">        QThread.__init__(self)</span><br><span class="line">        self.stop = <span class="literal">False</span></span><br><span class="line">        self.queue = queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop_ble</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stop = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.stop:</span><br><span class="line">            <span class="comment"># 这是一个循环任务, 每100ms执行一次</span></span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment"># 非阻塞查询queue队列</span></span><br><span class="line">            command = <span class="built_in">str</span>(self.queue.get(<span class="literal">False</span>))</span><br><span class="line">            do something after get command ...</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment"># 发送信号给主线程</span></span><br><span class="line">            self.emit(SIGNAL(<span class="string">&quot;ble_handle(PyQt_PyObject, PyQt_PyObject)&quot;</span>), <span class="string">&quot;ble_rx_timeout&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<ul>
<li>上述代码有一个未知风险, 在 QThread 中用了属于 python threading 的 Queque. 更稳妥的方法应该使用 PyQt 的信号和槽解决这个问题, 即<br><code>self.connect(self.cmd_send, SIGNAL(&quot;send_cmd(PyQt_PyObject)&quot;), self.thread_ble)</code></li>
<li>关于 QThread 和 Threading, 简单而言, 如果需要和PyQt打交道, 那就用 QThread, 否则就用 python 自带的 Threading</li>
<li><a href="https://github.com/draapho/ble-terminal">全部源码</a> 在 github, 注意, 作为一个练习用程序, 上述错误我没有修改! 目前为止, 没看到不良影响.</li>
</ul>
<h1 id="生成exe文件"><a href="#生成exe文件" class="headerlink" title="生成exe文件"></a>生成exe文件</h1><ul>
<li>可以创建一个 <code>ble-terminal.bat</code> 文件, 点击即可运行. 但终究是显的不够专业, 没法给老板和客户交代. 内容如下:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">start pythonw gui_action.py</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<ul>
<li>windows下, 使用起来最简单的就是 <code>PyInstaller</code> 了. 基本一条指令, 然后需要的关联库全自动解决</li>
<li>其它方案有 <code>Py2Exe</code>, 需要自己配置dll之类的. <code>Py2App</code> 给Mac电脑用的. <code>cx_Freeze</code> 优点是跨平台, 看了下需要先做配置文件.</li>
<li>用一条指令即可生成 <code>.exe</code> 文件<br><code>pyinstaller.exe --windowed gui_action.py</code></li>
<li>另外还可以指定图标, 设置版本信息(需要写好<code>version.txt</code>), 将所有内容绑到单文件. 指令为:<br><code>pyinstaller.exe --onefile --windowed --icon=app.ico --version-file=version.txt gui_action.py</code></li>
<li>详情可参考 <a href="https://mborgerson.com/creating-an-executable-from-a-python-script">Creating an Executable from a Python Script</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pyqt</tag>
        <tag>BLE</tag>
        <tag>pyinstaller</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础： 深入理解 python 中的赋值、引用、拷贝、作用域</title>
    <url>/2016/11/21/1618-python-variable/</url>
    <content><![CDATA[<p><em><strong>转载自 <a href="https://my.oschina.net/leejun2005/blog/145911">python基础（5）：深入理解 python 中的赋值、引用、拷贝、作用域</a></strong></em></p>
<hr>
<h1 id="python的赋值"><a href="#python的赋值" class="headerlink" title="python的赋值"></a>python的赋值</h1><p>在 python 中赋值语句总是建立对象的引用值，而不是复制对象。因此，python 变量更像是指针，而不是数据存储区域，<br><img src="https://draapho.github.io/images/1618/python_point_1.jpg" alt="python_point"><br>这点和大多数 OO 语言类似吧，比如 C++、java 等 ~</p>
<h1 id="先来看个问题吧："><a href="#先来看个问题吧：" class="headerlink" title="先来看个问题吧："></a>先来看个问题吧：</h1><h2 id="一个赋值问题"><a href="#一个赋值问题" class="headerlink" title="一个赋值问题"></a>一个赋值问题</h2><p>在Python中，令<code>values=[0,1,2];values[1]=values</code>,为何结果是<code>[0,[...],2]</code>? <a href="http://www.zhihu.com/question/21000872">链接</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values[<span class="number">1</span>] = values</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values</span><br><span class="line">[<span class="number">0</span>, [...], <span class="number">2</span>]       <span class="comment"># 实际结果, 为何要赋值无限次?</span></span><br><span class="line">[<span class="number">0</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">2</span>]   <span class="comment"># 预想结果</span></span><br></pre></td></tr></table></figure>

<p>可以说 Python 没有赋值，只有引用。你这样相当于创建了一个引用自身的结构，所以导致了无限循环。为了理解这个问题，有个基本概念需要搞清楚。</p>
<p>Python 没有「变量」，我们平时所说的变量其实只是「标签」，是引用。</p>
<p>执行 <code>values = [0, 1, 2]</code> 的时候，Python 做的事情是首先创建一个列表对象 [0, 1, 2]，然后给它贴上名为 values 的标签。</p>
<p>如果随后又执行 <code>values = [3, 4, 5]</code> 的话，Python 做的事情是创建另一个列表对象 [3, 4, 5]，然后把刚才那张名为 values 的标签从前面的 [0, 1, 2] 对象上撕下来，重新贴到 [3, 4, 5] 这个对象上。</p>
<p>至始至终，并没有一个叫做 values 的列表对象容器存在，Python 也没有把任何对象的值复制进 values 去。过程如图所示：</p>
<p><img src="https://draapho.github.io/images/1618/python_point_2.jpg" alt="python_point"></p>
<p>执行 <code>values[1] = values</code> 的时候，Python 做的事情则是把 values 这个标签所引用的列表对象的第二个元素指向 values 所引用的列表对象本身。执行完毕后，values 标签还是指向原来那个对象，只不过那个对象的结构发生了变化，从之前的列表 [0, 1, 2] 变成了 [0, ?, 2]，而这个 ? 则是指向那个对象本身的一个引用。如图所示：</p>
<p><img src="https://draapho.github.io/images/1618/python_point_3.jpg" alt="python_point"></p>
<h2 id="浅复制及其风险"><a href="#浅复制及其风险" class="headerlink" title="浅复制及其风险"></a>浅复制及其风险</h2><p>要达到你所需要的效果，即得到 [0, [0, 1, 2], 2] 这个对象，你不能直接将 values[1] 指向 values 引用的对象本身，而是需要吧 [0, 1, 2] 这个对象「复制」一遍，得到一个新对象，再将 values[1] 指向这个复制后的对象。Python 里面复制对象的操作因对象类型而异，复制列表 values 的操作是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">values[:] <span class="comment">#生成对象的拷贝或者是复制序列，不再是引用和共享变量，但此法只能顶层复制</span></span><br></pre></td></tr></table></figure>

<p>所以你需要执行 <code>values[1] = values[:]</code></p>
<p>Python 做的事情是，先 dereference 得到 values 所指向的对象 [0, 1, 2]，然后执行 [0, 1, 2][:] 复制操作得到一个新的对象，内容也是 [0, 1, 2]，然后将 values 所指向的列表对象的第二个元素指向这个复制二来的列表对象，最终 values 指向的对象是 [0, [0, 1, 2], 2]。过程如图所示：</p>
<p><img src="https://draapho.github.io/images/1618/python_point_4.jpg" alt="python_point"></p>
<p>往更深处说，values[:] 复制操作是所谓的「浅复制」(shallow copy)，当列表对象有嵌套的时候也会产生出乎意料的错误，比如为何要赋值无限次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>]</span><br><span class="line">b = a[:]</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">8</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>问：此时 a 和 b 分别是多少？</p>
<p>正确答案是 a 为 [8, [1, 9], 3]，b 为 [0, [1, 9], 3]。发现没？b 的第二个元素也被改变了。想想是为什么？不明白的话看下图</p>
<p><img src="https://draapho.github.io/images/1618/python_point_5.jpg" alt="python_point"></p>
<h2 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h2><p>正确的复制嵌套元素的方法是进行「深复制」(deep copy)，方法是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = [<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>]</span><br><span class="line">b = copy.deepcopy(a)</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">8</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p><img src="https://draapho.github.io/images/1618/python_point_6.jpg" alt="python_point"></p>
<h1 id="引用-VS-拷贝："><a href="#引用-VS-拷贝：" class="headerlink" title="引用 VS 拷贝："></a>引用 VS 拷贝：</h1><ul>
<li>没有限制条件的分片表达式（L[:]）能够复制序列，但此法只能浅层复制。</li>
<li>字典 copy 方法，D.copy() 能够复制字典，但此法只能浅层复制</li>
<li>有些内置函数，例如 list，能够生成拷贝 list(L)</li>
<li>copy 标准库模块能够生成完整拷贝：deepcopy 本质上是递归 copy</li>
<li>对于不可变对象和可变对象来说，浅复制都是复制的引用，只是因为复制不变对象和复制不变对象的引用是等效的（因为对象不可变，当改变时会新建对象重新赋值）。所以看起来浅复制只复制不可变对象（整数，实数，字符串等），对于可变对象，浅复制其实是创建了一个对于该对象的引用，也就是说只是给同一个对象贴上了另一个标签而已。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">D = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line">A = L[:]</span><br><span class="line">B = D.copy()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;L, D&quot;</span></span><br><span class="line"><span class="built_in">print</span>  L, D</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;A, B&quot;</span></span><br><span class="line"><span class="built_in">print</span> A, B</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;--------------------&quot;</span></span><br><span class="line">A[<span class="number">1</span>] = <span class="string">&#x27;NI&#x27;</span></span><br><span class="line">B[<span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;L, D&quot;</span></span><br><span class="line"><span class="built_in">print</span>  L, D</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;A, B&quot;</span></span><br><span class="line"><span class="built_in">print</span> A, B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">L, D</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">A, B</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">--------------------</span><br><span class="line">L, D</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">A, B</span><br><span class="line">[<span class="number">1</span>, <span class="string">&#x27;NI&#x27;</span>, <span class="number">3</span>] &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<h1 id="增强赋值以及共享引用："><a href="#增强赋值以及共享引用：" class="headerlink" title="增强赋值以及共享引用："></a>增强赋值以及共享引用：</h1><p>x = x + y，x 出现两次，必须执行两次，性能不好，合并必须新建对象 x，然后复制两个列表合并</p>
<p>属于复制/拷贝</p>
<p>x += y，x 只出现一次，也只会计算一次，性能好，不生成新对象，只在内存块末尾增加元素。</p>
<p>当 x、y 为list时， += 会自动调用 extend 方法进行合并运算，in-place change。</p>
<p>属于共享引用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">M = L</span><br><span class="line">L = L + [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span> L, M</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;-------------------&quot;</span></span><br><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">M = L</span><br><span class="line">L += [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span> L, M</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">-------------------</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h1 id="python-从-2k-到-3k，语句变函数引发的变量作用域问题"><a href="#python-从-2k-到-3k，语句变函数引发的变量作用域问题" class="headerlink" title="python 从 2k 到 3k，语句变函数引发的变量作用域问题"></a>python 从 2k 到 3k，语句变函数引发的变量作用域问题</h1><p>先看段代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    a = <span class="literal">False</span></span><br><span class="line">    <span class="built_in">exec</span> (<span class="string">&quot;a = True&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line">b = <span class="literal">False</span></span><br><span class="line"><span class="built_in">exec</span> (<span class="string">&quot;b = True&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;b = &quot;</span>, b)</span><br></pre></td></tr></table></figure>

<p>在 python 2k 和 3k 下 你会发现他们的结果不一样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">2K：</span><br><span class="line">a =  <span class="literal">True</span></span><br><span class="line">b =  <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">3K：</span><br><span class="line">a =  <span class="literal">False</span></span><br><span class="line">b =  <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>这是为什么呢？</p>
<p>因为 3k 中 exec 由语句变成函数了，而在函数中变量默认都是局部的，也就是说<br>你所见到的两个 a，是两个不同的变量，分别处于不同的命名空间中，而不会冲突。</p>
<p>具体参考 《learning python》P331-P332</p>
<p>知道原因了，我们可以这么改改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    a = <span class="literal">False</span></span><br><span class="line">    ldict = <span class="built_in">locals</span>()</span><br><span class="line">    exec(<span class="string">&quot;a=True&quot;</span>,<span class="built_in">globals</span>(),ldict)</span><br><span class="line">    a = ldict[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line">b = <span class="literal">False</span></span><br><span class="line">exec(<span class="string">&quot;b = True&quot;</span>, <span class="built_in">globals</span>())</span><br><span class="line">print(<span class="string">&quot;b = &quot;</span>, b)</span><br></pre></td></tr></table></figure>

<p>这是一个典型的 python 2k 移植到 3k 不兼容的案例，类似的还有很多，也算是移植的坑吧~</p>
<p>具体的 2k 与 3k 有哪些差异可以看这里： <a href="http://woodpecker.org.cn/diveintopython3/porting-code-to-python-3-with-2to3.html"><strong>使用 2to3 将代码移植到 Python 3</strong></a></p>
<h1 id="深入理解-python-变量作用域及其陷阱"><a href="#深入理解-python-变量作用域及其陷阱" class="headerlink" title="深入理解 python 变量作用域及其陷阱"></a>深入理解 python 变量作用域及其陷阱</h1><h2 id="可变对象-amp-不可变对象"><a href="#可变对象-amp-不可变对象" class="headerlink" title="可变对象 &amp; 不可变对象"></a>可变对象 &amp; 不可变对象</h2><ul>
<li>在Python中，对象分为两种：可变对象和不可变对象，</li>
<li>不可变对象包括int，float，long，str，tuple等，可变对象包括list，set，dict等。</li>
<li>需要注意的是：这里说的不可变指的是值的不可变。对于不可变类型的变量，如果要更改变量，则会创建一个新值，把变量绑定到新值上，而旧值如果没有被引用就等待垃圾回收。另外，不可变的类型可以计算hash值，作为字典的key。</li>
<li>可变类型数据对对象操作的时候，不需要再在其他地方申请内存，只需要在此对象后面连续申请(+/-)即可，也就是它的内存地址会保持不变，但区域会变长或者变短。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;xianglong.me&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">140443303134352</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;1saying.com&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">140443303131776</span></span><br><span class="line"><span class="comment"># 重新赋值之后，变量a的内存地址已经变了</span></span><br><span class="line"><span class="comment"># &#x27;xianglong.me&#x27;是str类型，不可变，所以赋值操作知识重新创建了str &#x27;1saying.com&#x27;对象，然后将变量a指向了它</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a_list)</span><br><span class="line"><span class="number">140443302951680</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_list.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a_list)</span><br><span class="line"><span class="number">140443302951680</span></span><br><span class="line"><span class="comment"># list重新赋值之后，变量a_list的内存地址并未改变</span></span><br><span class="line"><span class="comment"># [1, 2, 3]是可变的，append操作只是改变了其value，变量a_list指向没有变</span></span><br></pre></td></tr></table></figure>

<h2 id="函数值传递"><a href="#函数值传递" class="headerlink" title="函数值传递"></a>函数值传递</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_int</span>(<span class="params">a</span>):</span></span><br><span class="line">    a += <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_list</span>(<span class="params">a_list</span>):</span></span><br><span class="line">    a_list[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">t = <span class="number">0</span></span><br><span class="line">func_int(t)</span><br><span class="line"><span class="built_in">print</span> t</span><br><span class="line"><span class="comment"># output: 0</span></span><br><span class="line"></span><br><span class="line">t_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">func_list(t_list)</span><br><span class="line"><span class="built_in">print</span> t_list</span><br><span class="line"><span class="comment"># output: [4, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>对于上面的输出，不少Python初学者都比较疑惑：第一个例子看起来像是传值，而第二个例子确实传引用。其实，解释这个问题也非常容易，主要是因为可变对象和不可变对象的原因：对于可变对象，对象的操作不会重建对象，而对于不可变对象，每一次操作就重建新的对象。</p>
<p>在函数参数传递的时候，Python其实就是把参数里传入的变量对应的对象的引用依次赋值给对应的函数内部变量。参照上面的例子来说明更容易理解，func_int中的局部变量”a”其实是全部变量”t”所指向对象的另一个引用，由于整数对象是不可变的，所以当func_int对变量”a”进行修改的时候，实际上是将局部变量”a”指向到了整数对象”1”。所以很明显，func_list修改的是一个可变的对象，局部变量”a”和全局变量”t_list”指向的还是同一个对象。</p>
<h2 id="为什么修改全局的dict变量不用global关键字"><a href="#为什么修改全局的dict变量不用global关键字" class="headerlink" title="为什么修改全局的dict变量不用global关键字"></a>为什么修改全局的dict变量不用global关键字</h2><p>为什么修改字典d的值不用global关键字先声明呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">d = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">    s = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">    d[<span class="string">&#x27;b&#x27;</span>] = <span class="number">2</span></span><br><span class="line">f()</span><br><span class="line"><span class="built_in">print</span> s  <span class="comment"># foo</span></span><br><span class="line"><span class="built_in">print</span> d  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p>这是因为，在s = ‘bar’这句中，它是“有歧义的“，因为它既可以是表示引用全局变量s，也可以是创建一个新的局部变量，所以在python中，默认它的行为是创建局部变量，除非显式声明global，global定义的本地变量会变成其对应全局变量的一个别名，即是同一个变量。</p>
<p>在d[‘b’]=2这句中，它是“明确的”，因为如果把d当作是局部变量的话，它会报KeyError，所以它只能是引用全局的d,故不需要多此一举显式声明global。</p>
<p>上面这两句赋值语句其实是不同的行为，一个是<strong>rebinding（不可变对象）</strong>, 一个是<strong>mutation（可变对象）</strong>.</p>
<p>但是如果是下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    d[<span class="string">&#x27;b&#x27;</span>] = <span class="number">2</span></span><br><span class="line">f()</span><br><span class="line"><span class="built_in">print</span> d  <span class="comment"># &#123;&#x27;a&#x27;: 1&#125;</span></span><br></pre></td></tr></table></figure>

<p>在d = {}这句，它是”有歧义的“了，所以它是创建了局部变量d，而不是引用全局变量d，所以d[‘b’]=2也是操作的局部变量。</p>
<p>推而远之，这一切现象的本质就是”它是否是明确的“。</p>
<p>仔细想想，就会发现不止dict不需要global，所有”明确的“东西都不需要global。因为int类型str类型之类的不可变对象，每一次操作就重建新的对象，他们只有一种修改方法，即x = y， 恰好这种修改方法同时也是创建变量的方法，所以产生了歧义，不知道是要修改还是创建。而dict/list/对象等可变对象，操作不会重建对象，可以通过dict[‘x’]=y或list.append()之类的来修改，跟创建变量不冲突，不产生歧义，所以都不用显式global。</p>
<h2 id="可变对象-list-的-和-append-extend-差别在哪？"><a href="#可变对象-list-的-和-append-extend-差别在哪？" class="headerlink" title="可变对象 list 的 = 和 append/extend 差别在哪？"></a>可变对象 list 的 = 和 append/extend 差别在哪？</h2><p>接上面 5.3 的理论，下面咱们再看一例常见的错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># 测试utf-8编码</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">list_a = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span>():</span></span><br><span class="line">    list_a = [<span class="number">1</span>]      <span class="comment">## 语句1</span></span><br><span class="line">a()</span><br><span class="line"><span class="built_in">print</span> list_a    <span class="comment"># []</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;======================&quot;</span></span><br><span class="line"></span><br><span class="line">list_b = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span>():</span></span><br><span class="line">    list_b.append(<span class="number">1</span>)    <span class="comment">## 语句2</span></span><br><span class="line">b()</span><br><span class="line"><span class="built_in">print</span> list_b    <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure>

<p>大家可以看到为什么 语句1 不能改变 list_a 的值，而 语句2 却可以？他们的差别在哪呢？</p>
<p><strong>因为 = 创建了局部变量，而 .append() 或者 .extend() 重用了全局变量。</strong></p>
<h2 id="陷阱：使用可变的默认参数"><a href="#陷阱：使用可变的默认参数" class="headerlink" title="陷阱：使用可变的默认参数"></a>陷阱：使用可变的默认参数</h2><p>我多次见到过如下的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">a, b, c=[]</span>):</span></span><br><span class="line"><span class="comment"># append to c</span></span><br><span class="line"><span class="comment"># do some more stuff</span></span><br></pre></td></tr></table></figure>

<p>永远不要使用可变的默认参数，可以使用如下的代码代替：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">a, b, c=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> c <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        c = []</span><br><span class="line">    <span class="comment"># append to c</span></span><br><span class="line">    <span class="comment"># do some more stuff</span></span><br></pre></td></tr></table></figure>

<p>‍‍与其解释这个问题是什么，不如展示下使用可变默认参数的影响：‍‍</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[<span class="number">2</span>]: <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">a, b, c=[]</span>):</span></span><br><span class="line"><span class="meta">... </span>       c.append(a)</span><br><span class="line"><span class="meta">... </span>       c.append(b)</span><br><span class="line"><span class="meta">... </span>       print(c)</span><br><span class="line">...</span><br><span class="line">In[<span class="number">3</span>]: foo(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">In[<span class="number">4</span>]: foo(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">In[<span class="number">5</span>]: foo(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>同一个变量c在函数调用的每一次都被反复引用。这可能有一些意想不到的后果。</p>
<h1 id="REF："><a href="#REF：" class="headerlink" title="REF："></a>REF：</h1><ul>
<li><a href="http://www.zhihu.com/question/21000872/answer/16856382">《learning python》：P130、P134、P202、P204 、P245</a></li>
<li><a href="http://blog.segmentfault.com/sunisdown/1190000000640834">理解 Python 的 LEGB</a></li>
<li><a href="http://cenalulu.github.io/python/default-mutable-arguments/">Python函数参数默认值的陷阱和原理深究</a></li>
<li><a href="http://python.jobbole.com/81564/">潜在的Python陷阱</a></li>
<li><a href="http://segmentfault.com/a/1190000000743526">陷阱！python参数默认值</a></li>
<li><a href="http://xianglong.me/article/python-variable-quote-copy-and-scope/">Python中的变量、引用、拷贝和作用域</a></li>
<li><a href="http://www.cnblogs.com/wanxsb/archive/2013/05/07/3064783.html">Python入门基础知识(1) :locals() 和globals()</a></li>
<li><a href="http://bit.ly/29vnLvz">Python程序员写代码时应该避免的16个“坑”</a></li>
</ul>
<hr>
<p><em><strong>转载自 <a href="https://my.oschina.net/leejun2005/blog/145911">python基础（5）：深入理解 python 中的赋值、引用、拷贝、作用域</a></strong></em></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构资料收集</title>
    <url>/2016/11/23/1620-software-data-struct/</url>
    <content><![CDATA[<h1 id="python各数据结构性能列表-TimeComplexity"><a href="#python各数据结构性能列表-TimeComplexity" class="headerlink" title="python各数据结构性能列表, TimeComplexity"></a>python各数据结构性能列表, <a href="https://wiki.python.org/moin/TimeComplexity">TimeComplexity</a></h1><ul>
<li>list</li>
</ul>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Average Case</th>
<th>Amortized Worst Case</th>
</tr>
</thead>
<tbody><tr>
<td>Copy</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Append[1]</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Insert</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Get Item</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Set Item</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Delete Item</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Iteration</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Get Slice</td>
<td>O(k)</td>
<td>O(k)</td>
</tr>
<tr>
<td>Del Slice</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Set Slice</td>
<td>O(k+n)</td>
<td>O(k+n)</td>
</tr>
<tr>
<td>Extend[1]</td>
<td>O(k)</td>
<td>O(k)</td>
</tr>
<tr>
<td>Sort</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
</tr>
<tr>
<td>Multiply</td>
<td>O(nk)</td>
<td>O(nk)</td>
</tr>
<tr>
<td>x in s</td>
<td>O(n)</td>
<td>-</td>
</tr>
<tr>
<td>min(s), max(s)</td>
<td>O(n)</td>
<td>-</td>
</tr>
<tr>
<td>Get Length</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<ul>
<li>collections.deque</li>
</ul>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Average Case</th>
<th>Amortized Worst Case</th>
</tr>
</thead>
<tbody><tr>
<td>Copy</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>append</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>appendleft</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>pop</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>popleft</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>extend</td>
<td>O(k)</td>
<td>O(k)</td>
</tr>
<tr>
<td>extendleft</td>
<td>O(k)</td>
<td>O(k)</td>
</tr>
<tr>
<td>rotate</td>
<td>O(k)</td>
<td>O(k)</td>
</tr>
<tr>
<td>remove</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<ul>
<li>dict</li>
</ul>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Average Case</th>
<th>Amortized Worst Case</th>
</tr>
</thead>
<tbody><tr>
<td>Copy[2]</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Get Item</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Set Item[1]</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Delete Item</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Iteration[2]</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h1 id="教科书风格的数据结构"><a href="#教科书风格的数据结构" class="headerlink" title="教科书风格的数据结构"></a><a href="http://sjjp.tjuci.edu.cn/sjjg/datastructure/ds/web/gailun/gailun1.1.1b.htm">教科书风格的数据结构</a></h1><ul>
<li>讲述了 <code>线性链表</code>, <code>字符串</code>, <code>栈和队列</code>, <code>多维数组</code>, <code>广义表</code>, <code>树</code>, <code>图</code>, <code>排序</code>, <code>查找</code>, <code>文件</code></li>
<li><strong>有较为详细的性能分析</strong>, 偏重理论细节, 还有习题可以做!<ul>
<li>平方阶(O(n^2))排序: 一般称为简单排序，例如直接插入、直接选择和冒泡排序</li>
<li>线性对数阶(O(nlgn))排序: 如快速、堆和归并排序</li>
<li>O(n^(1+￡))阶排序(0&lt;￡&lt;1): 如希尔排序</li>
<li>线性阶(O(n))排序: 如桶、箱和基数排序</li>
</ul>
</li>
<li>排序方法的选择<ul>
<li>简单排序中直接插入最好，快速排序最快，当文件为正序时，直接插入和冒泡均最佳。</li>
<li>若n较小(如n≤50)，可采用直接插入或直接选择排序。</li>
<li>若文件初始状态基本有序(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜；</li>
<li>若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。<ul>
<li>快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；</li>
<li>堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。</li>
<li>若要求排序稳定，则可选用归并排序。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="纸上谈兵-算法与数据结构"><a href="#纸上谈兵-算法与数据结构" class="headerlink" title="纸上谈兵: 算法与数据结构"></a><a href="http://www.cnblogs.com/vamei/archive/2013/03/22/2974052.html">纸上谈兵: 算法与数据结构</a></h1><ul>
<li>理论与实践相结合的讲述数据结构, <strong>配图很有意思, 并提供了C代码</strong>. 但没有对性能和特性做详细介绍.</li>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/03/30/2989930.html">纸上谈兵: 数学归纳法, 递归, 栈</a></li>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/03/12/2948847.html">纸上谈兵: 排序算法简介及其C实现</a></li>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/03/14/2958940.html">纸上谈兵: 表 (list)</a></li>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/03/14/2960201.html">纸上谈兵: 栈 (stack)</a></li>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/03/15/2961729.html">纸上谈兵: 队列 (queue)</a></li>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/03/17/2962290.html">纸上谈兵: 树, 二叉树, 二叉搜索树</a><ul>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/03/21/2964092.html">纸上谈兵: AVL树</a></li>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/03/24/2976545.html">纸上谈兵: 伸展树 (splay tree)</a></li>
</ul>
</li>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/03/20/2966612.html">纸上谈兵: 堆 (heap)</a><ul>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/04/19/2978555.html">纸上谈兵: 左倾堆 (leftist heap)</a></li>
</ul>
</li>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/03/24/2970339.html">纸上谈兵: 哈希表 (hash table)</a></li>
<li><a href="http://www.cnblogs.com/vamei/p/3113912.html">纸上谈兵: 图 (graph)</a><ul>
<li><a href="http://www.cnblogs.com/vamei/p/3232432.html">纸上谈兵: 拓扑排序</a></li>
<li><a href="http://www.cnblogs.com/vamei/p/3604629.html">纸上谈兵: 最短路径与贪婪</a></li>
</ul>
</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>data struct</tag>
      </tags>
  </entry>
  <entry>
    <title>python 字符串处理</title>
    <url>/2016/11/24/1621-python-string/</url>
    <content><![CDATA[<h1 id="进制转换-编码转换"><a href="#进制转换-编码转换" class="headerlink" title="进制转换 / 编码转换"></a>进制转换 / 编码转换</h1><ul>
<li><a href="https://docs.python.org/2/library/functions.html#hex">hex</a>, 十进制-&gt;十六进制字符串</li>
<li><a href="https://docs.python.org/2/library/functions.html#oct">oct</a>, 十进制-&gt;八进制字符串</li>
<li><a href="https://docs.python.org/2/library/functions.html#oct">oct</a>, 十进制-&gt;八进制字符串</li>
<li><a href="https://docs.python.org/2/library/functions.html#chr">chr</a>, 十进制-&gt;ASCII码字符</li>
<li><a href="https://docs.python.org/2/library/functions.html#unichr">unichr</a>,  十进制-&gt;unicode编码</li>
<li><a href="https://docs.python.org/2/library/functions.html#ord">ord</a>,  ascii码/unicode编码-&gt;十进制</li>
<li><a href="https://docs.python.org/2/library/binascii.html">binascii</a>, 字符串&lt;-&gt;字节流</li>
<li><a href="https://docs.python.org/2/library/struct.html">struct</a>, 字符串&lt;-&gt;字节流<ul>
<li>struct中的 <a href="https://docs.python.org/2/library/struct.html#format-characters">fmt</a> 详解</li>
</ul>
</li>
</ul>
<ul>
<li><a href="https://docs.python.org/2/library/stdtypes.html#string-methods">str.decode / str.encode</a>, 基于unicode的编码转换</li>
<li><a href="https://docs.python.org/2/library/codecs.html#standard-encodings">Standard Encodings</a>, python支持的编码表<ul>
<li>常用的有 <code>hex</code>, <code>utf-8</code>, <code>unicode_escape</code></li>
</ul>
</li>
<li><a href="http://blog.csdn.net/pipisorry/article/details/44136297">python字符串编码及乱码解决方案</a><ul>
<li>解释了unicode与str在python2.7 和 python3下的区别. <code>str.decode</code>和<code>str.encode</code>的含义</li>
<li>python2.7, 默认str编码为ascii, 需要使用<code>s=u&quot;人生苦短&quot;</code>来表示unicode编码字符串(便于跨平台统一)</li>
<li><strong>终极原则： decode early, unicode everywhere, encode late</strong></li>
</ul>
</li>
</ul>
<ul>
<li><a href="https://docs.python.org/2/library/functions.html">更多的python内置函数</a>如下<ul>
<li>int(x [,base ]), 将x转换为一个整数</li>
<li>long(x [,base ]), 将x转换为一个长整数</li>
<li>float(x), 将x转换到一个浮点数</li>
<li>complex(real [,imag ]), 创建一个复数</li>
<li>str(x) , 将对象 x 转换为字符串</li>
<li>repr(x), 将对象 x 转换为表达式字符串</li>
<li>eval(str), 用来计算在字符串中的有效Python表达式,并返回一个对象</li>
<li>tuple(s), 将序列 s 转换为一个元组</li>
<li>list(s), 将序列 s 转换为一个列表</li>
</ul>
</li>
</ul>
<h2 id="十进制-lt-gt-十六进制字符串"><a href="#十进制-lt-gt-十六进制字符串" class="headerlink" title="十进制&lt;-&gt;十六进制字符串"></a>十进制&lt;-&gt;十六进制字符串</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">255</span>)</span><br><span class="line"><span class="string">&#x27;0xff&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">float</span>.<span class="built_in">hex</span>(<span class="number">1.0</span>)</span><br><span class="line"><span class="string">&#x27;0x1.0000000000000p+0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以有前缀 0b/0B(二进制), 0o/0O/0(八进制), or 0x/0X(十六进制),</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;0xff&#x27;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="number">255</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;ff&#x27;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="number">255</span></span><br></pre></td></tr></table></figure>

<h2 id="二进制字符串-lt-gt-十六进制字符串"><a href="#二进制字符串-lt-gt-十六进制字符串" class="headerlink" title="二进制字符串&lt;-&gt;十六进制字符串"></a>二进制字符串&lt;-&gt;十六进制字符串</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="built_in">int</span>(<span class="string">&#x27;0xff&#x27;</span>, <span class="number">16</span>))</span><br><span class="line"><span class="string">&#x27;0b11111111&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="built_in">int</span>(<span class="string">&#x27;0b1010&#x27;</span>,<span class="number">2</span>))</span><br><span class="line"><span class="string">&#x27;0xa&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="十进制-lt-gt-unicode字符串-lt-gt-utf8编码"><a href="#十进制-lt-gt-unicode字符串-lt-gt-utf8编码" class="headerlink" title="十进制&lt;-&gt;unicode字符串&lt;-&gt;utf8编码"></a>十进制&lt;-&gt;unicode字符串&lt;-&gt;utf8编码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="string">u&#x27;ñ&#x27;</span>            <span class="comment"># u表示使用unicode编码存储.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c                   <span class="comment"># 显示c在电脑中的值</span></span><br><span class="line"><span class="string">u&#x27;\xf1&#x27;</span>                 <span class="comment"># 即 u&#x27;\u00f1&#x27;, \u需要2byte!</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(c)</span><br><span class="line"><span class="number">241</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unichr(<span class="number">241</span>)</span><br><span class="line"><span class="string">u&#x27;\xf1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u&#x27;\u00f1&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)       <span class="comment"># unicode-&gt;utf-8</span></span><br><span class="line"><span class="string">&#x27;\xc3\xb1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;\xc3\xb1&#x27;</span>.decode(<span class="string">&#x27;utf-8&#x27;</span>)      <span class="comment"># utf-8-&gt;unicode</span></span><br><span class="line"><span class="string">u&#x27;\xf1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">u&#x27;\u00f1&#x27;</span>                 <span class="comment"># 打印显示</span></span><br><span class="line">ñ</span><br></pre></td></tr></table></figure>

<h2 id="字节流-lt-gt-整数"><a href="#字节流-lt-gt-整数" class="headerlink" title="字节流&lt;-&gt;整数"></a>字节流&lt;-&gt;整数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 struct</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字节流-&gt;整数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>struct.unpack(<span class="string">&#x27;&lt;hh&#x27;</span>, <span class="built_in">bytes</span>(<span class="string">b&#x27;\x01\x00\x00\x00&#x27;</span>))    <span class="comment"># 转义为short型整数</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>struct.unpack(<span class="string">&#x27;&lt;L&#x27;</span>, <span class="built_in">bytes</span>(<span class="string">b&#x27;\x01\x00\x00\x00&#x27;</span>))     <span class="comment"># 转义为long型整数</span></span><br><span class="line">(<span class="number">1</span>,)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整数-&gt;字节流</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>struct.pack(<span class="string">&#x27;&lt;HH&#x27;</span>, <span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="string">&#x27;\x01\x00\x02\x00&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>struct.pack(<span class="string">&#x27;&lt;LL&#x27;</span>, <span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="string">&#x27;\x01\x00\x00\x00\x02\x00\x00\x00&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="几个实用的例子"><a href="#几个实用的例子" class="headerlink" title="几个实用的例子"></a>几个实用的例子</h2><ul>
<li>去掉字符串中的跳脱符, 生成标准的unicode字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u&#x27;\\u4f60\\u4f60&#x27;</span>.decode(<span class="string">&#x27;unicode_escape&#x27;</span>)</span><br><span class="line"><span class="string">u&#x27;\u4f60\u4f60&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解码16进制字符串：也可以直接 print 出来</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="string">&#x27;\xd1\xee\xba\xea\xc1\xc1\n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> unicode(b, <span class="string">&#x27;gbk&#x27;</span>).encode(<span class="string">&#x27;utf8&#x27;</span>) <span class="comment"># 等同于 print b.decode(&#x27;gbk&#x27;).encode(&#x27;utf8&#x27;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>bin &lt;-&gt; ascii</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串-&gt;ASCII编码串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;1234&#x27;</span>.encode(<span class="string">&quot;hex&quot;</span>)</span><br><span class="line"><span class="string">&#x27;31323334&#x27;</span></span><br><span class="line"><span class="comment"># ASCII编码串-&gt;字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;3031&#x27;</span>.decode(<span class="string">&quot;hex&quot;</span>)</span><br><span class="line"><span class="string">&#x27;01&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 binascii</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> binascii</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binascii.hexlify(<span class="string">&quot;1234&quot;</span>)    <span class="comment"># 或者 binascii.b2a_hex(&quot;1234&quot;)</span></span><br><span class="line"><span class="string">&#x27;31323334&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binascii.unhexlify(<span class="string">&quot;3031&quot;</span>)  <span class="comment"># 或者 binascii.a2b_hex(&quot;3031&quot;)</span></span><br><span class="line"><span class="string">&#x27;01&#x27;</span></span><br></pre></td></tr></table></figure>



<h1 id="字符串-lt-gt-数值-列表-字典"><a href="#字符串-lt-gt-数值-列表-字典" class="headerlink" title="字符串&lt;-&gt;数值/列表/字典"></a>字符串&lt;-&gt;数值/列表/字典</h1><h2 id="字符串-lt-gt-数值"><a href="#字符串-lt-gt-数值" class="headerlink" title="字符串&lt;-&gt;数值"></a>字符串&lt;-&gt;数值</h2><ul>
<li>int(x [,base ]), 将x转换为一个整数</li>
<li>long(x [,base ]), 将x转换为一个长整数</li>
<li>float(x), 将x转换到一个浮点数</li>
<li><strong>使用re正则表达式, 实用范例</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span> = <span class="string">&quot;test: 12a345 to 325.-123.34&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># this can get the number from str like &quot;good456sdg78&quot;, return [&#x27;456&#x27;, &#x27;78&#x27;]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> re.findall(<span class="string">r&#x27;\d+&#x27;</span>, <span class="built_in">str</span>)</span><br><span class="line">[<span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;345&#x27;</span>, <span class="string">&#x27;325&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;34&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># this can get the number seperate in str like &quot;good12sd 45 78 &quot;, return [&#x27;45&#x27;, &#x27;78&#x27;]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> re.findall(<span class="string">r&#x27;\b\d+\b&#x27;</span>, <span class="built_in">str</span>)</span><br><span class="line">[<span class="string">&#x27;325&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;34&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># more complicated, can recognize and return [30, -10, 34.12, -12.34, 67.56E+3, -14.23e-2]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> re.findall(<span class="string">&quot;[-+]?\d+[\.]?\d+[eE]?[-+]?\d*&quot;</span>, <span class="built_in">str</span>)</span><br><span class="line">[<span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;345&#x27;</span>, <span class="string">&#x27;325&#x27;</span>, <span class="string">&#x27;-123.34&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="字符串-gt-列表-字典-去掉引号"><a href="#字符串-gt-列表-字典-去掉引号" class="headerlink" title="字符串-&gt;列表/字典 (去掉引号)"></a>字符串-&gt;列表/字典 (去掉引号)</h2><ul>
<li>eval(), 将str当成有效的表达式来求值并返回计算结果. 在确保str源安全的情况下可用.<ul>
<li><a href="http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html">Eval really is dangerous</a></li>
<li><a href="http://blog.csdn.net/zhanh1218/article/details/37562167">Python:eval的妙用和滥用</a></li>
</ul>
</li>
<li><a href="https://docs.python.org/2/library/ast.html#ast-helpers">ast.literal_eval()</a>, eval的替代品, 更安全</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串-&gt;列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&quot;[1,2,3]&quot;</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串-&gt;字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&quot;&#123;&#x27;one&#x27;:1, &#x27;two&#x27;:2&#125;&quot;</span>)</span><br><span class="line">&#123;<span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串-lt-gt-列表"><a href="#字符串-lt-gt-列表" class="headerlink" title="字符串&lt;-&gt;列表"></a>字符串&lt;-&gt;列表</h2><ul>
<li>str.join(), 列表-&gt;字符串</li>
<li>str.split(), 字符串-&gt;列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串-&gt;列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst = <span class="built_in">list</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表-&gt;字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#x27;</span>.join(lst)</span><br><span class="line"><span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串-&gt;列表 (指定分隔符, 如空格, 逗号)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>season = <span class="string">&#x27;spring, summer, autumn, winter&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>season.split (<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;spring&#x27;</span>, <span class="string">&#x27; summer&#x27;</span>, <span class="string">&#x27; autumn&#x27;</span>, <span class="string">&#x27; winter&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表-&gt;字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="string">&quot;spring&quot;</span>, <span class="string">&quot;summer&quot;</span>, <span class="string">&quot;autumn&quot;</span>, <span class="string">&quot;winter&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;, &#x27;</span>.join(lst)</span><br><span class="line"><span class="string">&#x27;spring, summer, autumn, winter&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 整数列表-&gt;字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(e) <span class="keyword">for</span> e <span class="keyword">in</span> lst)</span><br><span class="line"><span class="string">&#x27;123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串-&gt;hex格式列表-&gt;hex格式字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">map</span>(<span class="built_in">ord</span>, <span class="string">&quot;1234&quot;</span>) <span class="comment"># [0x31, 0x32, 0x33 0x34]</span></span><br><span class="line">[<span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#x27;</span>.join([<span class="string">&quot;%02x&quot;</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">map</span>(<span class="built_in">ord</span>, <span class="string">&quot;1234&quot;</span>)])</span><br><span class="line"><span class="string">&#x27;31323334&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><h2 id="操作基础"><a href="#操作基础" class="headerlink" title="操作基础"></a>操作基础</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 去前后空格及特殊符号</span></span><br><span class="line">s.strip().lstrip().rstrip(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找字符</span></span><br><span class="line">sStr1.index(sStr2)  <span class="comment"># 返回所在位置, 不存在则报错</span></span><br><span class="line">sStr2 <span class="keyword">in</span> sStr1      <span class="comment"># 返回 True or False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较字符串</span></span><br><span class="line">cmp(sStr1,sStr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串长度</span></span><br><span class="line"><span class="built_in">len</span>(sStr1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串中的大小写转换</span></span><br><span class="line">sStr1.upper().lower()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩充到指定长度</span></span><br><span class="line"><span class="built_in">str</span>(01).zfill(<span class="number">5</span>) <span class="comment"># “00001”</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻转字符串</span></span><br><span class="line">sStr1[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割字符串</span></span><br><span class="line">s.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串切片</span></span><br><span class="line"><span class="built_in">str</span> = ’0123456789′</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[<span class="number">0</span>:<span class="number">3</span>]      <span class="comment"># 截取第一位到第三位的字符</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[:]        <span class="comment"># 截取字符串的全部字符</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[<span class="number">6</span>:]       <span class="comment"># 截取第七个字符到结尾</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[:-<span class="number">3</span>]      <span class="comment"># 截取从头开始到倒数第三个字符之前</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[<span class="number">2</span>]        <span class="comment"># 截取第三个字符</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[-<span class="number">1</span>]       <span class="comment"># 截取倒数第一个字符</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[::-<span class="number">1</span>]     <span class="comment"># 创造一个与原字符串顺序相反的字符串</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[-<span class="number">3</span>:-<span class="number">1</span>]    <span class="comment"># 截取倒数第三位与倒数第一位之前的字符</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[-<span class="number">3</span>:]      <span class="comment"># 截取倒数第三位到结尾</span></span><br></pre></td></tr></table></figure>

<h2 id="查看手册及高阶使用"><a href="#查看手册及高阶使用" class="headerlink" title="查看手册及高阶使用"></a>查看手册及高阶使用</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/chapters/p02_strings_and_text.html">cookbook-第二章：字符串和文本</a>, 实用范例<ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p01_split_string_on_multiple_delimiters.html">2.1 使用多个界定符分割字符串</a>, split(), re.split()</li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p02_match_text_at_start_end.html">2.2 字符串开头或结尾匹配</a>, startswith(), endswith()</li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p03_match_strings_with_shell_wildcard.html">2.3 用Shell通配符匹配字符串</a>, fnmatch(), fnmatchcase()</li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p04_match_and_search_text.html">2.4 字符串匹配和搜索</a>, find(), findall(), match(), re.match()</li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p05_search_and_replace_text.html">2.5 字符串搜索和替换</a>, replace(), re.sub()</li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p06_search_replace_case_insensitive.html">2.6 字符串忽略大小写的搜索替换</a>, re.IGNORECASE</li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p07_specify_regexp_for_shortest_match.html">2.7 最短匹配模式</a>, 解决成对符号的问题, 避免贪婪算法</li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p08_regexp_for_multiline_partterns.html">2.8 多行匹配模式</a>, 解决回车换行的问题</li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p09_normalize_unicode_text_to_regexp.html">2.9 将Unicode文本标准化</a></li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p10_work_with_unicode_in_regexp.html">2.10 在正则式中使用Unicode</a></li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p11_strip_unwanted_characters.html">2.11 删除字符串中不需要的字符</a>, strip(), replace(), re.sub()</li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p12_sanitizing_clean_up_text.html">2.12 审查清理文本字符串</a></li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p13_aligning_text_strings.html">2.13 字符串对齐</a>, ljust(), rjust(), center(), format()</li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p14_combine_and_concatenate_strings.html">2.14 合并拼接字符串</a>, join()</li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p15_interpolating_variables_in_strings.html">2.15 字符串中插入变量</a>, format()的高阶使用</li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p16_reformat_text_to_fixed_number_columns.html">2.16 以指定列宽格式化字符串</a>, textwrap</li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p17_handle_html_xml_in_text.html">2.17 在字符串中处理html和xml</a></li>
<li><del><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p18_tokenizing_text.html">2.18 字符串令牌解析</a>, 语法的解析</del></li>
<li><del><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p19_writing_recursive_descent_parser.html">2.19 实现一个简单的递归下降分析器</a>, 语法的解析</del></li>
<li><del><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p20_perform_text_operations_on_byte_string.html">2.20 字节字符串上的字符串操作</a>, bytearray</del></li>
</ul>
</li>
</ul>
<ul>
<li><a href="https://docs.python.org/2/library/stdtypes.html#string-methods">String Methods</a>, string提供的方法/函数<ul>
<li><a href="https://docs.python.org/2/library/stdtypes.html#string-formatting-operations">String Formatting Operations</a>, 格式化显示, 建议使用format替代</li>
</ul>
</li>
</ul>
<ul>
<li><a href="https://docs.python.org/2/library/string.html">string — Common string operations</a>, python官方手册之字符串操作<ul>
<li><a href="https://docs.python.org/2/library/string.html#string-constants">String constants</a>, 字符串常量, 如字母, 数字</li>
<li><a href="https://docs.python.org/2/library/string.html#format-examples">Format examples</a>, 格式化显示</li>
<li><del><a href="https://docs.python.org/2/library/string.html#template-strings">Template strings</a>, 模板显示</del>, 建议使用format代替.</li>
</ul>
</li>
</ul>
<h2 id="使用正则表达式的一些例子"><a href="#使用正则表达式的一些例子" class="headerlink" title="使用正则表达式的一些例子"></a>使用正则表达式的一些例子</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 去掉所有的空格和tab</span></span><br><span class="line">re.sub(<span class="string">&#x27;[\s+]&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换小写下划线格式变化为驼峰格式</span></span><br><span class="line">re.sub(<span class="string">&#x27;^\w|_\w&#x27;</span>, <span class="keyword">lambda</span> x:x.group()[-<span class="number">1</span>].upper(), <span class="string">&#x27;blog_view&#x27;</span>) <span class="comment"># 输出 &#x27;BlogView&#x27;。</span></span><br></pre></td></tr></table></figure>


<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>python 延时及超时</title>
    <url>/2016/11/28/1622-python-time/</url>
    <content><![CDATA[<h1 id="实用的例子"><a href="#实用的例子" class="headerlink" title="实用的例子"></a>实用的例子</h1><h2 id="time-sleep-单线程阻塞延时"><a href="#time-sleep-单线程阻塞延时" class="headerlink" title="time.sleep 单线程阻塞延时"></a><code>time.sleep</code> 单线程阻塞延时</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_sleep</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span> i</span><br><span class="line">        time.sleep(<span class="number">1</span>)       <span class="comment"># delay 1s, not that accurate</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    time_sleep()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;run time: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(end - start)</span><br></pre></td></tr></table></figure>

<h2 id="time-time-单线程非阻塞延时-超时"><a href="#time-time-单线程非阻塞延时-超时" class="headerlink" title="time.time 单线程非阻塞延时/超时"></a><code>time.time</code> 单线程非阻塞延时/超时</h2><p>通过比较时间戳实现, 多用于循环中的延时/超时判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_compare</span>():</span></span><br><span class="line">    timeout = time.time() + <span class="number">10</span>  <span class="comment"># 10s delay</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        <span class="built_in">print</span> i</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> timeout &lt; time.time(): <span class="comment"># compare the timestamps</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;time out !&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    time_compare()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;run time: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(end - start)</span><br></pre></td></tr></table></figure>

<h2 id="threading-Timer-多线程非阻塞延时"><a href="#threading-Timer-多线程非阻塞延时" class="headerlink" title="threading.Timer 多线程非阻塞延时"></a><code>threading.Timer</code> 多线程非阻塞延时</h2><p>这个例子中, 会先执行完 <code>threading_main</code>. 5s后, 才会执行 <code>threading_sub</code><br>子线程函数可以带参 <code>threading.Timer(interval, function, args=[], kwargs=&#123;&#125;)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threading_main</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;main thread: start&quot;</span></span><br><span class="line">    thrd = threading.Timer(<span class="number">5.0</span>, threading_sub, args = [<span class="string">&quot;sub thread&quot;</span>])</span><br><span class="line">    thrd.start()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;main thread: end&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threading_sub</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span> name + <span class="string">&quot;: hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    threading_main()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;run time: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(end - start)</span><br></pre></td></tr></table></figure>

<h2 id="threading-Timer-threading-join-多线程阻塞延时"><a href="#threading-Timer-threading-join-多线程阻塞延时" class="headerlink" title="threading.Timer + threading.join 多线程阻塞延时"></a><code>threading.Timer</code> + <code>threading.join</code> 多线程阻塞延时</h2><p>使用 <code>join</code> 语句, 让主线程等待子线程完成后才继续执行<br>子线程函数可以带参 <code>threading.Timer(interval, function, args=[], kwargs=&#123;&#125;)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threading_main</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;main thread: start&quot;</span></span><br><span class="line">    thrd = threading.Timer(<span class="number">5.0</span>, threading_sub, args = [<span class="string">&quot;sub thread&quot;</span>])</span><br><span class="line">    thrd.start()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;main thread: wait&quot;</span></span><br><span class="line">    thrd.join()     <span class="comment"># add this line</span></span><br><span class="line">    <span class="comment"># thrd.join(timeout=2)  # just wait 2s then continue</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;main thread: end&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threading_sub</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span> name + <span class="string">&quot;: hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    threading_main()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;run time: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(end - start)</span><br></pre></td></tr></table></figure>

<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h2 id="装饰器-使用KThread-localtrace结束线程-通用性最好-性能较低"><a href="#装饰器-使用KThread-localtrace结束线程-通用性最好-性能较低" class="headerlink" title="装饰器, 使用KThread,.localtrace结束线程. (通用性最好, 性能较低)"></a>装饰器, 使用<code>KThread,.localtrace</code>结束线程. (通用性最好, 性能较低)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timeout</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;function run timeout&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KThread</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        threading.Thread.__init__(self, *args, **kwargs)</span><br><span class="line">        self.killed = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Start the thread.&quot;&quot;&quot;</span></span><br><span class="line">        self.__run_backup = self.run</span><br><span class="line">        <span class="comment"># Force the Thread to install our trace.</span></span><br><span class="line">        self.run = self.__run</span><br><span class="line">        threading.Thread.start(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Hacked run function, which installs the trace.&quot;&quot;&quot;</span></span><br><span class="line">        sys.settrace(self.globaltrace)</span><br><span class="line">        self.__run_backup()</span><br><span class="line">        self.run = self.__run_backup</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">globaltrace</span>(<span class="params">self, frame, why, arg</span>):</span></span><br><span class="line">        <span class="keyword">if</span> why == <span class="string">&#x27;call&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> self.localtrace</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">localtrace</span>(<span class="params">self, frame, why, arg</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.killed:</span><br><span class="line">            <span class="keyword">if</span> why == <span class="string">&#x27;line&#x27;</span>:</span><br><span class="line">                <span class="keyword">raise</span> SystemExit()</span><br><span class="line">        <span class="keyword">return</span> self.localtrace</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kill</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.killed = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeout</span>(<span class="params">timeout, default=<span class="literal">None</span>, try_except=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Timeout decorator, parameter in timeout.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">timeout_decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">new_func</span>(<span class="params">oldfunc, result, oldfunc_args, oldfunc_kwargs</span>):</span></span><br><span class="line">            result.append(oldfunc(*oldfunc_args, **oldfunc_kwargs))</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Wrap the original function.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func_wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            result = []</span><br><span class="line">            <span class="comment"># create new args for _new_func, because we want to get the func</span></span><br><span class="line">            <span class="comment"># return val to result list</span></span><br><span class="line">            new_kwargs = &#123;</span><br><span class="line">                <span class="string">&#x27;oldfunc&#x27;</span>: func,</span><br><span class="line">                <span class="string">&#x27;result&#x27;</span>: result,</span><br><span class="line">                <span class="string">&#x27;oldfunc_args&#x27;</span>: args,</span><br><span class="line">                <span class="string">&#x27;oldfunc_kwargs&#x27;</span>: kwargs</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            thd = KThread(target=new_func, args=(), kwargs=new_kwargs)</span><br><span class="line">            thd.start()</span><br><span class="line">            thd.join(timeout)</span><br><span class="line">            <span class="comment"># timeout or finished?</span></span><br><span class="line">            isAlive = thd.isAlive()</span><br><span class="line">            thd.kill()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> isAlive:</span><br><span class="line">                <span class="keyword">if</span> try_except <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                    <span class="keyword">raise</span> Timeout(<span class="string">&quot;&#123;&#125; Timeout: &#123;&#125; seconds.&quot;</span>.<span class="built_in">format</span>(func, timeout))</span><br><span class="line">                <span class="keyword">return</span> default</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        func_wrapper.__name__ = func.__name__</span><br><span class="line">        func_wrapper.__doc__ = func.__doc__</span><br><span class="line">        <span class="keyword">return</span> func_wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> timeout_decorator</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="meta">    @timeout(<span class="params"><span class="number">5</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">name</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            print(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(name, i))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;finished&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> count(<span class="string">&quot;thread1&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span> count(<span class="string">&quot;thread2&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Timeout <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span> e</span><br></pre></td></tr></table></figure>

<p>将上面的例子, 改为函数调用模式, 这样timeout参数可灵活设置!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timeout</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;function run timeout&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KThread</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        threading.Thread.__init__(self, *args, **kwargs)</span><br><span class="line">        self.killed = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Start the thread.&quot;&quot;&quot;</span></span><br><span class="line">        self.__run_backup = self.run</span><br><span class="line">        <span class="comment"># Force the Thread to install our trace.</span></span><br><span class="line">        self.run = self.__run</span><br><span class="line">        threading.Thread.start(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Hacked run function, which installs the trace.&quot;&quot;&quot;</span></span><br><span class="line">        sys.settrace(self.globaltrace)</span><br><span class="line">        self.__run_backup()</span><br><span class="line">        self.run = self.__run_backup</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">globaltrace</span>(<span class="params">self, frame, why, arg</span>):</span></span><br><span class="line">        <span class="keyword">if</span> why == <span class="string">&#x27;call&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> self.localtrace</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">localtrace</span>(<span class="params">self, frame, why, arg</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.killed:</span><br><span class="line">            <span class="keyword">if</span> why == <span class="string">&#x27;line&#x27;</span>:</span><br><span class="line">                <span class="keyword">raise</span> SystemExit()</span><br><span class="line">        <span class="keyword">return</span> self.localtrace</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kill</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.killed = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeout_call</span>(<span class="params">timeout, func, args=(<span class="params"></span>), kwargs=<span class="literal">None</span>, default=<span class="literal">None</span>, try_except=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_func</span>(<span class="params">oldfunc, result, oldfunc_args, oldfunc_kwargs</span>):</span></span><br><span class="line">            result.append(oldfunc(*oldfunc_args, **oldfunc_kwargs))</span><br><span class="line"></span><br><span class="line">    result = []</span><br><span class="line">    kwargs = &#123;&#125; <span class="keyword">if</span> kwargs <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> kwargs</span><br><span class="line">    <span class="comment"># create new args for _new_func, because we want to get the func</span></span><br><span class="line">    <span class="comment"># return val to result list</span></span><br><span class="line">    new_kwargs = &#123;</span><br><span class="line">        <span class="string">&#x27;oldfunc&#x27;</span>: func,</span><br><span class="line">        <span class="string">&#x27;result&#x27;</span>: result,</span><br><span class="line">        <span class="string">&#x27;oldfunc_args&#x27;</span>: args,</span><br><span class="line">        <span class="string">&#x27;oldfunc_kwargs&#x27;</span>: kwargs</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    thd = KThread(target=new_func, args=(), kwargs=new_kwargs)</span><br><span class="line">    thd.start()</span><br><span class="line">    thd.join(timeout)</span><br><span class="line">    <span class="comment"># timeout or finished?</span></span><br><span class="line">    isAlive = thd.isAlive()</span><br><span class="line">    thd.kill()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> isAlive:</span><br><span class="line">        <span class="keyword">if</span> try_except <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">raise</span> Timeout(<span class="string">&quot;&#123;&#125; Timeout: &#123;&#125; seconds.&quot;</span>.<span class="built_in">format</span>(func, timeout))</span><br><span class="line">        <span class="keyword">return</span> default</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">name</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            print(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(name, i))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;finished&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> timeout_call(<span class="number">5</span>, count, [<span class="string">&quot;thread1&quot;</span>])</span><br><span class="line">        <span class="built_in">print</span> timeout_call(<span class="number">5</span>, count, [<span class="string">&quot;thread2&quot;</span>])</span><br><span class="line">    <span class="keyword">except</span> Timeout <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span> e</span><br></pre></td></tr></table></figure>


<h2 id="装饰器-使用thread-interrupt-main-结束线程-仅可用于主线程"><a href="#装饰器-使用thread-interrupt-main-结束线程-仅可用于主线程" class="headerlink" title="装饰器, 使用thread.interrupt_main()结束线程. (仅可用于主线程)"></a>装饰器, 使用<code>thread.interrupt_main()</code>结束线程. (仅可用于主线程)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> thread</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeout_quit</span>(<span class="params">fn_name</span>):</span></span><br><span class="line">    thread.interrupt_main()     <span class="comment"># raises KeyboardInterrupt</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeout</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    use as decorator to exit process if</span></span><br><span class="line"><span class="string">    function takes longer than s seconds</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">outer</span>(<span class="params">fn</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            timer = threading.Timer(s, timeout_quit, args=[fn.__name__])</span><br><span class="line">            timer.start()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = fn(*args, **kwargs)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                timer.cancel()</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line">    <span class="keyword">return</span> outer</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="meta">    @timeout(<span class="params"><span class="number">5</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processNum</span>(<span class="params">num</span>):</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> processNum(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;timeout&quot;</span></span><br></pre></td></tr></table></figure>


<h1 id="学习过程中的例子"><a href="#学习过程中的例子" class="headerlink" title="学习过程中的例子"></a>学习过程中的例子</h1><h2 id="threading-Timer-threading-join-多线程阻塞延时-1"><a href="#threading-Timer-threading-join-多线程阻塞延时-1" class="headerlink" title="threading.Timer + threading.join 多线程阻塞延时"></a><code>threading.Timer</code> + <code>threading.join</code> 多线程阻塞延时</h2><p>使用 <code>join</code> 语句, 让主线程等待子线程完成后才继续执行<br>子线程函数可以带参 <code>threading.Timer(interval, function, args=[], kwargs=&#123;&#125;)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threading_main</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;main thread: start&quot;</span></span><br><span class="line">    thrd = threading.Timer(<span class="number">5.0</span>, threading_sub, args = [<span class="string">&quot;sub thread&quot;</span>])</span><br><span class="line">    thrd.start()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;main thread: wait&quot;</span></span><br><span class="line">    thrd.join()     <span class="comment"># add this line</span></span><br><span class="line">    <span class="comment"># thrd.join(timeout=2)  # just wait 2s then continue</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;main thread: end&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threading_sub</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span> name + <span class="string">&quot;: hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    threading_main()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;run time: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(end - start)</span><br></pre></td></tr></table></figure>

<h2 id="join-timeout-10-多进程超时判断"><a href="#join-timeout-10-多进程超时判断" class="headerlink" title="join(timeout=10) 多进程超时判断"></a><code>join(timeout=10)</code> 多进程超时判断</h2><p><code>multiprocessing</code>的本质是进程, 但是提供了类似于<code>threading</code>的一系列方法.<br>使用 <code>multiprocessing.terminate</code> 语句, 让主线程可以杀死子线程<br>子进程函数可以带参 multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs={})<br>multiprocessing 没有 <code>Timer()</code> 方法的, 无法方便的延时执行.</p>
<p>注意, 这里没有办法使用 threading 类来实现. 因为没有 <code>terminate()</code> 方法,<br>而如果用<code>signal</code>方法来结束线程, 有两个限制. 1, windows不支持. 2, 子线程不支持</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processing_main</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;main process: start&quot;</span></span><br><span class="line">    prcs = multiprocessing.Process(</span><br><span class="line">        target=processing_sub, args=[<span class="string">&quot;sub process&quot;</span>])</span><br><span class="line">    prcs.start()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;main process: wait&quot;</span></span><br><span class="line">    prcs.join(timeout=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If thread is still active</span></span><br><span class="line">    <span class="keyword">if</span> prcs.is_alive():</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;main process: kill&quot;</span></span><br><span class="line">        prcs.terminate()</span><br><span class="line">        prcs.join()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;main process: end&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processing_sub</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        <span class="comment"># if use print, can not show immediately in the console.</span></span><br><span class="line">        logging.error(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(name, i))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    processing_main()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;run time: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(end - start)</span><br></pre></td></tr></table></figure>


<h2 id="multiprocessing-pool-实现超时判断"><a href="#multiprocessing-pool-实现超时判断" class="headerlink" title="multiprocessing.pool 实现超时判断"></a><code>multiprocessing.pool</code> 实现超时判断</h2><p>说说python下的 thread 和 process.<br>thread, 提供了signal结束方式, 但是windows不支持, 仅主线程可用! 换句话说, 终止线程很繁琐<br>process, 提供了terminate结束方式, 但是参数传递限制条件很多, (必须可以是pickle的…)</p>
<p><strong>下面的代码是有问题的!!!</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing.pool</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeout</span>(<span class="params">timeout, default=<span class="literal">None</span>, try_except=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Timeout decorator, parameter in seconds.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">timeout_decorator</span>(<span class="params">item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Wrap the original function.&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">item</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func_wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;Closure for function.&quot;&quot;&quot;</span></span><br><span class="line">            pool = multiprocessing.pool.ThreadPool(processes=<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># pool = multiprocessing.pool.Pool(processes=1) ## raise error about pickle problem!!!</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                async_result = pool.apply_async(item, args, kwargs)</span><br><span class="line">                val = async_result.get(timeout)</span><br><span class="line">            <span class="keyword">except</span> multiprocessing.TimeoutError:</span><br><span class="line">                pool.terminate() <span class="comment">## not work here, because it is acutally thread, not process!!!</span></span><br><span class="line">                val = default</span><br><span class="line">                <span class="keyword">if</span> try_except <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                    <span class="keyword">raise</span> multiprocessing.TimeoutError</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pool.close()</span><br><span class="line">                pool.join()</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        <span class="keyword">return</span> func_wrapper</span><br><span class="line">    <span class="keyword">return</span> timeout_decorator</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="meta">    @timeout(<span class="params"><span class="number">5</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">name</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            print(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(name, i))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;finished&quot;</span></span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="built_in">print</span> count(<span class="string">&quot;thread1&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> count(<span class="string">&quot;thread2&quot;</span>)  <span class="comment">## you can find problem here, thread1 is still running...</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;run time: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(end - start)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeout_call</span>(<span class="params">timeout, func, args=(<span class="params"></span>), kwargs=<span class="literal">None</span>, default=<span class="literal">None</span>, try_except=<span class="literal">False</span></span>):</span></span><br><span class="line">    kwargs = &#123;&#125; <span class="keyword">if</span> kwargs <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> kwargs</span><br><span class="line">    pool = multiprocessing.Pool(processes=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        async_result = pool.apply_async(func, args, kwargs)</span><br><span class="line">        val = async_result.get(timeout)</span><br><span class="line">    <span class="keyword">except</span> multiprocessing.TimeoutError:</span><br><span class="line">        pool.terminate()</span><br><span class="line">        val = default</span><br><span class="line">        <span class="keyword">if</span> try_except <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">raise</span> multiprocessing.TimeoutError</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pool.close()</span><br><span class="line">        pool.join()</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"><span class="comment">################### example ##########</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        logging.error(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(name, i))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;finished&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">## if count function is here, will raise error!!!</span></span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="built_in">print</span> timeout_call(<span class="number">5</span>, count, [<span class="string">&quot;process1&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span> timeout_call(<span class="number">5</span>, count, [<span class="string">&quot;process2&quot;</span>])</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;run time: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(end - start)</span><br></pre></td></tr></table></figure>

<h2 id="第三方方案"><a href="#第三方方案" class="headerlink" title="第三方方案"></a>第三方方案</h2><ul>
<li><a href="https://pypi.python.org/pypi/timeoutcontext/1.1.1">timeoutcontext 1.1.1</a><ul>
<li>基于signal实现, 不支持windows系统, 不支持子线程</li>
</ul>
</li>
<li><a href="https://pypi.python.org/pypi/timeout-decorator/0.3.2">timeout-decorator 0.3.2</a><ul>
<li>signal或Multithreading可选</li>
<li>使用signal时, 不支持windows, 不支持子线程</li>
<li>使用Multithreading时, 无法返回不能pickle的数据(因为需要通过pickle来跨进程交换数据)</li>
</ul>
</li>
<li><a href="https://pypi.python.org/pypi/stopit#stopit-threading-timeoutable">stopit 1.1.1</a><ul>
<li>threading或signal可选</li>
<li>计时误差太大, 不可接受(翻倍的误差)</li>
</ul>
</li>
</ul>
<h2 id="使用gevent协程"><a href="#使用gevent协程" class="headerlink" title="使用gevent协程"></a>使用gevent协程</h2><p>参考 <a href="http://xlambda.com/gevent-tutorial/#_6">gevent程序员指南之超时</a><br>参考 <a href="https://my.oschina.net/1123581321/blog/208671">gevent 延时、定时、超时、io等待、动态添加任务</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> Timeout</span><br><span class="line"></span><br><span class="line">time_to_wait = <span class="number">5</span> <span class="comment"># seconds</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TooLong</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Timeout(time_to_wait, TooLong):</span><br><span class="line">    gevent.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>




<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://stackoverflow.com/questions/492519/timeout-on-a-function-call">Timeout on a function call</a>, 关于此问题的讨论(signal / multiprocessing)</li>
<li><a href="https://my.oschina.net/leejun2005/blog/607741">论 Python 装饰器控制函数 Timeout 的正确姿势</a>, 装饰器方式, 性能较低</li>
<li><a href="http://xlambda.com/gevent-tutorial/">gevent程序员指南</a></li>
<li><a href="https://my.oschina.net/1123581321/blog/208671">gevent 延时、定时、超时、io等待、动态添加任务</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>timeout</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 调试及测试</title>
    <url>/2016/12/13/1623-python-debug/</url>
    <content><![CDATA[<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>常用的方法有:</p>
<ul>
<li>print, 仅作临时测试, 而且还要删除.</li>
<li>assert, 同print, 无明显优势.</li>
<li>logging, 推荐使用. 可选级别, 可选输出方式, 适用于各种情况的调试.</li>
<li>pdb 以及 基于pdb的图形化工具.</li>
<li>python的IDE, 如PyCharm(推荐), eclipse+PyDev</li>
</ul>
<h2 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;默认日志输出为终端, 设置日志等级, DEBUG=LEVEL10, 优先级最低&#x27;&#x27;&#x27;</span></span><br><span class="line">    logging.basicConfig(level=logging.DEBUG)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;更多设置&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># logging.basicConfig(level=logging.DEBUG,</span></span><br><span class="line">    <span class="comment">#                     format=&#x27;%(asctime)s %(filename)-s[%(lineno)d] %(levelname)-8s: %(message)s&#x27;)</span></span><br><span class="line"></span><br><span class="line">    logging.debug(<span class="string">&#x27;DEBUG message&#x27;</span>)</span><br><span class="line">    logging.info(<span class="string">&#x27;INFO message&#x27;</span>)</span><br><span class="line">    logging.warn(<span class="string">&#x27;WARN message&#x27;</span>)</span><br><span class="line">    logging.error(<span class="string">&#x27;ERROR message&#x27;</span>)</span><br><span class="line">    logging.critical(<span class="string">&#x27;CRITICAL message&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="自定义显示格式"><a href="#自定义显示格式" class="headerlink" title="自定义显示格式"></a>自定义显示格式</h3><p>日志输出到 <code>logger.log</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;设置显示格式, 日志输出到文件&#x27;&#x27;&#x27;</span></span><br><span class="line">    logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                        <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s %(filename)-s[%(lineno)d] %(levelname)-8s: %(message)s&#x27;</span>,</span><br><span class="line">                        filename=<span class="string">&#x27;logger.log&#x27;</span>,</span><br><span class="line">                        filemode=<span class="string">&#x27;w&#x27;</span>) <span class="comment"># default is &#x27;a&#x27;=append, &#x27;w&#x27;=overwrite</span></span><br><span class="line"></span><br><span class="line">    logging.debug(<span class="string">&#x27;This is debug message&#x27;</span>)</span><br><span class="line">    logging.info(<span class="string">&#x27;This is info message&#x27;</span>)</span><br><span class="line">    logging.warning(<span class="string">&#x27;This is warning message&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p>日志输出到 <code>logger.log</code> 以及终端</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                        <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s %(filename)s[%(lineno)d] %(levelname)-8s: %(message)s&#x27;</span>,</span><br><span class="line">                        filename=<span class="string">&#x27;logger.log&#x27;</span>,</span><br><span class="line">                        filemode=<span class="string">&#x27;w&#x27;</span>) <span class="comment"># default is &#x27;a&#x27;=append, &#x27;w&#x27;=overwrite</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    定义一个StreamHandler，将INFO级别或更高的日志信息打印到标准错误，并将其添加到当前的日志处理对象</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    console = logging.StreamHandler()</span><br><span class="line">    console.setLevel(logging.INFO)</span><br><span class="line">    formatter = logging.Formatter(<span class="string">&#x27;%(levelname)-8s: %(message)s&#x27;</span>)</span><br><span class="line">    console.setFormatter(formatter)</span><br><span class="line">    logging.getLogger(<span class="string">&#x27;&#x27;</span>).addHandler(console)</span><br><span class="line"></span><br><span class="line">    logging.debug(<span class="string">&#x27;This is debug message&#x27;</span>)</span><br><span class="line">    logging.info(<span class="string">&#x27;This is info message&#x27;</span>)</span><br><span class="line">    logging.warning(<span class="string">&#x27;This is warning message&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="使用文件配置"><a href="#使用文件配置" class="headerlink" title="使用文件配置"></a>使用文件配置</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#logging.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################</span></span><br><span class="line">[loggers]</span><br><span class="line">keys=root</span><br><span class="line"></span><br><span class="line">[logger_root]</span><br><span class="line">level=DEBUG</span><br><span class="line">handlers=hand01,hand02</span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################</span></span><br><span class="line">[handlers]</span><br><span class="line">keys=hand01,hand02,hand03</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入终端</span></span><br><span class="line">[handler_hand01]</span><br><span class="line">class=StreamHandler</span><br><span class="line">level=DEBUG</span><br><span class="line">formatter=form01</span><br><span class="line">args=(sys.stderr,)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入文件, &#x27;w&#x27;覆写, &#x27;a&#x27;追加</span></span><br><span class="line">[handler_hand02]</span><br><span class="line">class=FileHandler</span><br><span class="line">level=INFO</span><br><span class="line">formatter=form01</span><br><span class="line">args=(<span class="string">&#x27;logging.log&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最多备份5个日志文件，每个日志文件最大10M</span></span><br><span class="line">[handler_hand03]</span><br><span class="line">class=handlers.RotatingFileHandler</span><br><span class="line">level=INFO</span><br><span class="line">formatter=form01</span><br><span class="line">args=(<span class="string">&#x27;logging.log&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################</span></span><br><span class="line">[formatters]</span><br><span class="line">keys=form01</span><br><span class="line"></span><br><span class="line">[formatter_form01]</span><br><span class="line"><span class="built_in">format</span>=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)-8s: %(message)s</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">from</span> logging.config <span class="keyword">import</span> fileConfig</span><br><span class="line">    fileConfig(<span class="string">&quot;logging.conf&quot;</span>)</span><br><span class="line"></span><br><span class="line">    logging.debug(<span class="string">&#x27;This is debug message&#x27;</span>)</span><br><span class="line">    logging.info(<span class="string">&#x27;This is info message&#x27;</span>)</span><br><span class="line">    logging.warning(<span class="string">&#x27;This is warning message&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="更多应用参考手册"><a href="#更多应用参考手册" class="headerlink" title="更多应用参考手册"></a>更多应用参考手册</h3><ul>
<li><a href="https://docs.python.org/3.1/library/logging.html">15.6. logging — Logging facility for Python</a><ul>
<li>15.6.11. Sending and receiving logging events across a network</li>
<li>15.6.20.2. Configuration file format</li>
<li>15.6.20.3. Configuration server example</li>
<li>15.6.21. More examples</li>
</ul>
</li>
</ul>
<h2 id="pdb"><a href="#pdb" class="headerlink" title="pdb"></a>pdb</h2><p>进入调试模式 <code>python -m pdb example.py</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python -m pdb example.py</span></span><br><span class="line">(Pdb)</span><br></pre></td></tr></table></figure>

<p>pdb 常用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 断点</span><br><span class="line">(Pdb) b 10          # 断点设置在当前文件的第10行</span><br><span class="line">(Pdb) tbreak 10     # temp  break, 临时断点, 执行后会自动删除</span><br><span class="line">(Pdb) b my.py:20    # 断点设置到 my.py第20行</span><br><span class="line">(Pdb) b             # break, 查看断点编号</span><br><span class="line">(Pdb) cl 2          # clear, 删除第2个断点</span><br><span class="line">(Pdb) disable 2     # 禁用第2个断点</span><br><span class="line">(Pdb) enable 2      # 使能第2个断点</span><br><span class="line">(Pdb) ignore 2 10   # 略过第2个断点10次, 循环调试特别有用!</span><br><span class="line">(Pdb) condition 2 (i&gt;10)    # 条件为真时,使能断点</span><br><span class="line"></span><br><span class="line"># 运行</span><br><span class="line">(Pdb) n             # next, 单步运行</span><br><span class="line">(Pdb) s             # step, 进入方法</span><br><span class="line">(Pdb) r             # return, 返回上级方法</span><br><span class="line">(Pdb) c             # continue, 跳到下个断点</span><br><span class="line"></span><br><span class="line"># 查看</span><br><span class="line">(Pdb) p param       # print, 查看当前 变量值</span><br><span class="line">(Pdb) l             # list, 查看运行到某处代码</span><br><span class="line">(Pdb) a             # args, 查看全部栈内变量</span><br><span class="line">(Pdb) w             # where, 堆栈信息</span><br><span class="line"></span><br><span class="line"># 其它</span><br><span class="line">(Pdb) h             # help, 帮助</span><br><span class="line">(Pdb) q             # quit, 退出调试</span><br></pre></td></tr></table></figure>

<p>使用alias设置别名, 可大大提高调试速度!<br><strong>将下述文件存储为 <code>.pdbrc</code>, 然后放在系统目录 <code>~</code> 或 项目目录下, pdb会自动加载.</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># name it as &quot;.pdbrc&quot;, then put into ~ or project folder</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Print a dictionary, sorted. %1 is the dict, %2 is the prefix for the names.</span></span><br><span class="line">alias p_ <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">sorted</span>(%<span class="number">1.</span>keys()): <span class="built_in">print</span> <span class="string">&quot;%s%-15s= %-80.80s&quot;</span> % (<span class="string">&quot;%2&quot;</span>,k,<span class="built_in">repr</span>(%<span class="number">1</span>[k]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the instance variables of a thing.</span></span><br><span class="line">alias pi p_ %<span class="number">1.</span>__dict__ %<span class="number">1.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the instance variables of self.</span></span><br><span class="line">alias ps pi self</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the locals.</span></span><br><span class="line">alias pl p_ <span class="built_in">locals</span>() local:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Next and list, and step and list.</span></span><br><span class="line">alias nl n;;l</span><br><span class="line">alias sl s;;l</span><br><span class="line"></span><br><span class="line"><span class="comment"># go to line</span></span><br><span class="line">alias gl tbreak %*;;c %*;;l</span><br><span class="line"></span><br><span class="line"><span class="comment"># go to next</span></span><br><span class="line">alias g1 n;;l</span><br><span class="line">alias g2 n;;n;;l</span><br><span class="line">alias g3 n;;n;;n;;l</span><br><span class="line">alias g4 n;;n;;n;;n;;l</span><br><span class="line">alias g5 n;;n;;n;;n;;n;;l</span><br><span class="line">alias g6 n;;n;;n;;n;;n;;n;;nl</span><br><span class="line">alias g7 n;;n;;n;;n;;n;;n;;n;;l</span><br><span class="line">alias g8 n;;n;;n;;n;;n;;n;;n;;n;;l</span><br><span class="line">alias g9 n;;n;;n;;n;;n;;n;;n;;n;;n;;l</span><br><span class="line"></span><br><span class="line"><span class="comment"># Short cuts for walking up and down the stack</span></span><br><span class="line">alias uu u;;u</span><br><span class="line">alias uuu u;;u;;u</span><br><span class="line">alias uuuu u;;u;;u;;u</span><br><span class="line">alias uuuuu u;;u;;u;;u;;u</span><br><span class="line">alias dd d;;d</span><br><span class="line">alias ddd d;;d;;d</span><br><span class="line">alias dddd d;;d;;d;;d</span><br><span class="line">alias ddddd d;;d;;d;;d;;d</span><br></pre></td></tr></table></figure>


<h2 id="查看函数调用"><a href="#查看函数调用" class="headerlink" title="查看函数调用"></a>查看函数调用</h2><p>使用如下的装饰器, 即可观察该函数被调用的情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findcaller</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        f = sys._getframe()</span><br><span class="line">        filename = f.f_back.f_code.co_filename</span><br><span class="line">        lineno = f.f_back.f_lineno</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;######################################&#x27;</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;&#123;&#125;, args: &#123;&#125;, &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(func, args, kwargs)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;called by &#123;&#125;, line &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(filename, lineno)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;######################################&#x27;</span></span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@findcaller</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">name=<span class="string">&#x27;world&#x27;</span></span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;hello&quot;</span>, name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    hello(<span class="string">&#x27;DRA&amp;PHO&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="doctest"><a href="#doctest" class="headerlink" title="doctest"></a>doctest</h2><p>简单的函数测试个人比较喜欢使用doctest, 因为一举两得, 即可以做测试案例, 又是极好的代码注释和范例<br>输出和预期一致时, 没有任何提醒. 输出和预期不一致时, 就会弹出错误.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">name=<span class="string">&#x27;world&#x27;</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; hello()</span></span><br><span class="line"><span class="string">    hello world</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; hello(&#x27;DRA&amp;PHO&#x27;)</span></span><br><span class="line"><span class="string">    hello, DRA&amp;PHO</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;hello&quot;</span>, name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></table></figure>

<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00140137128705556022982cfd844b38d050add8565dcb9000">unittest</a>, 更专业的一种测试方法, 可批量执行</li>
<li><a href="http://pythonguidecn.readthedocs.io/zh/latest/writing/tests.html">Python指南-测试你的代码</a><ul>
<li>单元测试(unittest)</li>
<li>文档测试(doctest)</li>
<li>测试工具: py.test, nose, tox, Unittest2, mock</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="http://blog.csdn.net/yatere/article/details/6655445">python 的日志logging模块学习</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/feb86c06c4f4">python logging模块使用教程</a></p>
</li>
<li><p><a href="https://docs.python.org/3.1/library/logging.html">15.6. logging — Logging facility for Python</a></p>
</li>
<li><p><a href="https://pythonconquerstheuniverse.wordpress.com/category/python-debugger/">Debugging in Python</a></p>
</li>
<li><p><a href="http://www.onlamp.com/pub/a/python/2005/09/01/debugger.html">Interactive Debugging in Python</a></p>
</li>
<li><p><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00140137128705556022982cfd844b38d050add8565dcb9000">廖雪峰的官方网站-单元测试</a></p>
</li>
<li><p><a href="http://pythonguidecn.readthedocs.io/zh/latest/writing/tests.html">Python 指南-测试你的代码</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/ae5bc6093337">python笔记_查看函数调用栈的一个小技巧</a></p>
</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中Activity、Service和线程之间的通信</title>
    <url>/2016/12/14/1624-android-ipc/</url>
    <content><![CDATA[<p><em><strong>转载自<a href="http://blog.sina.com.cn/s/blog_3fe961ae0100xkyt.html">Android中Activity、Service和线程之间的通信</a></strong></em></p>
<hr>
<h1 id="我的说明"><a href="#我的说明" class="headerlink" title="我的说明"></a>我的说明</h1><p>很全面的总结了几种通讯方式. 是Android深入学习的必经阶段.<br>其实 Activity 和 Activity 间也就下面一些通讯方式,<br>只是从软件结构上讲, 较为复杂的通讯机制是分层的, 一般采用 Activity 纯显示UI, Service后台处理及开线程, Broadcast辅助通讯.</p>
<p>先转载此文作为备忘, 有时间自己在总结一下范例.</p>
<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>Activity、Service和线程应该是Android编程中最常见的几种类了，几乎大多数应用程序都会涉及到这几个类的编程，<br>自然而然的，也就会涉及到三者之间的相互通信，本文就试图简单地介绍一下这三者通信的方式。</p>
<p>想写这篇文章的起因是，笔者跟几个同学在做一个Android上的应用，起初代码写得很凌乱，因为我在Activity中直接创建了线程，去执行某些任务。<br>但是我们知道线程可能需要运行的时间比较长，而Android在内存不足的时候，会将一些Activity销毁，<br>这样线程就会失去了管理的对象，从而使程序发生意想不到的结果。<br>此外，在Activity中创建线程，线程跟Activity的通信也比较麻烦，一般借助Handler类来进行通信</p>
<p>与Activity相比，Service一般“默默”地运行在后台，生命周期比较长，所以它更合适去为主程序提供某些服务，创建线程并管理线程。<br>因此，笔者将原程序改成三层架构，从高到低分别为：Activity层–Service层–Thread层。<br>Activity将需要的服务“告诉”Service层，Service层创建Thread去完成服务。<br>Thread将任务的进度、状态、错误信息反馈给Service，Service将这些消息反馈给相关的Activity，<br>并且还可以利用Notification更新通知栏消息。大体的结构就是这样。</p>
<h1 id="Activity和Service之间的通信"><a href="#Activity和Service之间的通信" class="headerlink" title="Activity和Service之间的通信"></a>Activity和Service之间的通信</h1><h2 id="利用Handler通信"><a href="#利用Handler通信" class="headerlink" title="利用Handler通信"></a>利用Handler通信</h2><p>参考 <a href="http://blog.sina.com.cn/s/blog_3fe961ae0100mvc5.html">Android在子线程中更新Activity中UI的方法</a></p>
<h2 id="Activity调用startService"><a href="#Activity调用startService" class="headerlink" title="Activity调用startService"></a>Activity调用startService</h2><p>Activity调用startService (Intent service)方法，将消息添加到Intent对象中，<br>这样Service对象可以在调用onStartCommand (Intent intent, int flags, int startId)的时候可以得到这些消息。<br>这种方法很简单，但如果有大量的信息要传递的话，就很麻烦了。因为Service端还要判断一下消息是什么，才能作进一步的动作。</p>
<h2 id="Activity调用bindService"><a href="#Activity调用bindService" class="headerlink" title="Activity调用bindService"></a>Activity调用bindService</h2><p>Activity调用bindService (Intent service, ServiceConnection conn, int flags)方法，<br>得到Service对象的一个引用，这样Activity可以直接调用到Service中的方法。<br>参考 <a href="http://blog.csdn.net/liuhe688/article/details/6623924">Notification使用详解之三：通过服务更新进度通知&amp;在Activity中监听服务进度</a></p>
<h2 id="Service发送广播通知Activity"><a href="#Service发送广播通知Activity" class="headerlink" title="Service发送广播通知Activity"></a>Service发送广播通知Activity</h2><p>Service向Activity发送消息，除了可以利用Handler外，还可以使用广播，当然Activity要注册相应的接收器<br>比如Service要向多个Activity发送同样的消息的话，用这种方法就更好。具体方法可以看一下这篇文章：<br>参考 <a href="http://blog.csdn.net/liuhe688/article/details/6641806">Notification使用详解之四：由后台服务向Activity发送进度信息</a></p>
<h1 id="Service跟Thread之间的通信"><a href="#Service跟Thread之间的通信" class="headerlink" title="Service跟Thread之间的通信"></a>Service跟Thread之间的通信</h1><p>Service创建Thread后，如果要对线程进行控制（启动，暂停，停止等），那么Service中应该保留线程的引用，这不用多说。<br>那么有了这个引用，Service就可以直接调用Thread的其它方法了。运行的线程要向Service发送消息的话，通常使用Handler就可以了：<br>参考 <a href="http://blog.sina.com.cn/s/blog_3fe961ae0100mvc5.html">Android在子线程中更新Activity中UI的方法</a></p>
<h1 id="Activity和Thread之间的通信"><a href="#Activity和Thread之间的通信" class="headerlink" title="Activity和Thread之间的通信"></a>Activity和Thread之间的通信</h1><p>不用多想了，直接使用Handler吧。不推荐Activity直接去创建线程，因为不好管理线程。</p>
<hr>
<p><em><strong>转载自<a href="http://blog.sina.com.cn/s/blog_3fe961ae0100xkyt.html">Android中Activity、Service和线程之间的通信</a></strong></em></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>ipc</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 系统文件及磁盘指令</title>
    <url>/2016/12/15/1625-linux-cmd-disk/</url>
    <content><![CDATA[<h1 id="linux-系统文件简要说明"><a href="#linux-系统文件简要说明" class="headerlink" title="linux 系统文件简要说明"></a>linux 系统文件简要说明</h1><p>FHS是Filesystem Hierarchy Standard的简称.FHS定义了两层规范:<br>第一层是/目录下各个主要目录应该放什么文件数据, 例如/etc应该放配置文件,/bin与/sbin则应该放置可执行文件等.<br>第二层则是针对/usr和/var这两个目录的子目录来定义,例如/var/log放置系统登录文件,/usr/share放置共享数据等.<br>单一文件或目录的最大允许文件名为255个字符,包含完整路径的文件名或目录名最大允许为4096个字符.</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
<th>文件内容</th>
</tr>
</thead>
<tbody><tr>
<td><code>/</code></td>
<td>root, 根目录</td>
<td>一般建议只有目录,不要直接放文件. <code>/etc</code> <code>/bin</code> <code>/sbin</code> <code>/dev</code> <code>/lib</code> 必须与 <code>/</code> 同一分区</td>
</tr>
<tr>
<td><code>/bin</code>, <code>/usr/bin</code>, <code>/usr/local/bin</code></td>
<td>Essential command <strong>bin</strong>aries, 普通用户可执行的二进制文件</td>
<td>如 <code>ls</code> <code>mv</code> <code>cat</code> 等指令</td>
</tr>
<tr>
<td><code>/boot</code></td>
<td>Static files of the <strong>boot</strong> loader,  启动时用到的文件</td>
<td>包括 vmlinuz (就是kernel), grub (开机管理)</td>
</tr>
<tr>
<td><code>/dev</code></td>
<td><strong>Dev</strong>ice files, 设备文件</td>
<td>任何设备与接口都是以文件的型态存放在此目录下. 分为<code>字符设备</code>和<code>块设备</code></td>
</tr>
<tr>
<td></td>
<td><code>/dev/null</code></td>
<td>空设备</td>
</tr>
<tr>
<td></td>
<td><code>/dev/tty*</code></td>
<td>串口设备</td>
</tr>
<tr>
<td></td>
<td><code>/dev/hd[a-d][1-63]</code></td>
<td>IDE 硬盘</td>
</tr>
<tr>
<td></td>
<td><code>/dev/sd[a-p][1-20]</code></td>
<td>SCSI硬盘,U盘</td>
</tr>
<tr>
<td></td>
<td><code>/dev/cdrom</code></td>
<td>CDROM</td>
</tr>
<tr>
<td></td>
<td><code>/dev/fd[0-1]</code></td>
<td>软盘</td>
</tr>
<tr>
<td></td>
<td><code>/dev/lp[0-2]</code></td>
<td>并口打印机</td>
</tr>
<tr>
<td></td>
<td><code>/dev/mouse</code></td>
<td>鼠标</td>
</tr>
<tr>
<td></td>
<td>常见<code>sda1-3</code>(主分区),<del><code>sda4</code></del>(扩展分区),<code>sda5..</code>(逻辑分区)</td>
<td>分析:硬盘支持4个主分区,1个扩展分区(占用主分区),16个逻辑分区(SCSI硬盘). 扩展分区文件名不显示.</td>
</tr>
<tr>
<td><code>/etc</code></td>
<td><strong>Etc</strong>etera, 杂项都在此处! 偏系统设置</td>
<td>系统启动(<code>/etc/init</code> <code>/etc/init.d</code>), 账号密码(<code>/etc/passwd</code> <code>/etc/shadow</code>), 开机预设值(<code>/etc/sysconfig/*</code>)</td>
</tr>
<tr>
<td><code>/home</code></td>
<td>User <strong>home</strong> directories, 用户的家目录</td>
<td>放置用户自有的数据, 如音乐图片等</td>
</tr>
<tr>
<td><code>/lib</code> <code>/usr/lib</code> <code>/usr/local/lib</code></td>
<td>Essential shared <strong>lib</strong>raries and kernel modules, 系统使用的函式库的目录</td>
<td><code>/lib/modules</code> 放着kernel的相关模块</td>
</tr>
<tr>
<td><code>/lost+found</code></td>
<td>系统异常时,会将一些遗失的片段放于此目录</td>
<td></td>
</tr>
<tr>
<td><code>/mnt</code></td>
<td><strong>Mount</strong> point for mounting a file system temporarily, 默认挂载点文件的目录</td>
<td>通常软盘挂在<code>/mnt/floppy</code>下,光盘挂在<code>/mnt/cdrom</code>下</td>
</tr>
<tr>
<td><code>/media</code></td>
<td>Contains mount points for replaceable <strong>media</strong></td>
<td><code>/media</code>目录功能与<code>/mnt</code>类似</td>
</tr>
<tr>
<td><code>/opt</code></td>
<td>Add-on application software packages, 主机自行安装软件默认放置的目录</td>
<td>以前较多情况放置在<code>/usr/local</code>目录下</td>
</tr>
<tr>
<td><code>/proc</code></td>
<td>Virtual directory for system information, 虚拟档案系统. 数据都在内存当中,不占用硬盘空间.</td>
<td>主要包括系统核心,接口设备状态,网络状态. 比较重要的档案例: <code>/proc/cpuinfo</code> <code>/proc/dma</code> <code>/proc/interrupts</code> <code>/proc/ioports</code> <code>/proc/net/*</code> 等</td>
</tr>
<tr>
<td><code>/root</code></td>
<td>Home directory for the <strong>root</strong> user 系统管理员的家目录。</td>
<td>一般与根目录<code>/</code>在同一分区下</td>
</tr>
<tr>
<td><code>/sbin</code>, <code>/usr/sbin</code>, <code>/usr/local/sbin</code></td>
<td>Essential system binaries,<strong>S</strong>uper user <strong>bin</strong>aries, 放置系统管理员才会动用到的执行指令</td>
<td>如： <code>fdisk</code> <code>mke2fs</code> <code>fsck</code> <code>mkswap</code> <code>mount</code> 等</td>
</tr>
<tr>
<td><code>/sys</code></td>
<td>Virtual directory for system information (2.6 kernels)</td>
<td></td>
</tr>
<tr>
<td><code>/srv</code></td>
<td>Data for <strong>services</strong> provided by the system, 一些服务启动之后，这些服务所需要取用的数据目录</td>
<td>如WWW 服务器需要的网页就可放在<code>/srv/www</code>内</td>
</tr>
<tr>
<td><code>/tmp</code></td>
<td><strong>Temp</strong>orary files, 这是让一般用户或是正在执行的程序暂时放置文件的目录</td>
<td>这个目录任何人都能够存取的，所以需要定期清理</td>
</tr>
<tr>
<td><code>/usr</code></td>
<td><strong>U</strong>nix <strong>S</strong>hared <strong>R</strong>esources</td>
<td>此目录下包含系统的主要程序,图形界面文件,额外的函式库、本机自行安装的软件，以及共享的目录与文件等</td>
</tr>
<tr>
<td></td>
<td><code>/usr/bin,/usr/sbin</code></td>
<td>可执行的档案放置目录</td>
</tr>
<tr>
<td></td>
<td><code>/usr/include</code></td>
<td>c/c++等程序语言的头文件放置目录</td>
</tr>
<tr>
<td></td>
<td><code>/usr/lib</code></td>
<td>各应用软件的函数库档案放置目录</td>
</tr>
<tr>
<td></td>
<td><code>/usr/local</code></td>
<td>本机自行安装及升级软件默认放置的目录</td>
</tr>
<tr>
<td></td>
<td><code>/usr/local/bin</code></td>
<td>自行安装及升级软件后的可执行文件目录</td>
</tr>
<tr>
<td></td>
<td><code>/usr/share</code></td>
<td>共享文件放置的目录, 如帮助文档(doc,man)</td>
</tr>
<tr>
<td></td>
<td><code>/usr/src</code></td>
<td>Linux系统相关的程序代码放置目录</td>
</tr>
<tr>
<td></td>
<td><code>/usr/src/linux</code></td>
<td>为Linux Kernel的源码</td>
</tr>
<tr>
<td></td>
<td><code>/usr/X11R6</code></td>
<td>X Window System 所需的执行文件放置目录</td>
</tr>
<tr>
<td><code>/var</code></td>
<td><strong>Var</strong>iable data</td>
<td>主要放置系统执行过程中经常变化的文件</td>
</tr>
<tr>
<td></td>
<td><code>/var/cache</code></td>
<td>程序文件在运作过程中的一些缓存数据</td>
</tr>
<tr>
<td></td>
<td><code>/var/lib</code></td>
<td>程序执行中，使用到的数据库文件放置的目录</td>
</tr>
<tr>
<td></td>
<td><code>/var/log</code></td>
<td>登录文件放置的目录(如/var/log/messages)</td>
</tr>
<tr>
<td></td>
<td><code>/var/run</code></td>
<td>某些程序或是服务启动后,会放置PID在此处</td>
</tr>
<tr>
<td></td>
<td><code>/var/spool</code></td>
<td>是一些数据队列存放的目录,作用为缓冲</td>
</tr>
</tbody></table>
<p><img src="https://draapho.github.io/images/1625/LinuxFileSystem.jpg" alt="LinuxFileSystem"></p>
<h1 id="linux系统分区建议"><a href="#linux系统分区建议" class="headerlink" title="linux系统分区建议"></a>linux系统分区建议</h1><table>
<thead>
<tr>
<th>挂载目录</th>
<th>说明</th>
<th>类型</th>
<th>台式机</th>
<th>嵌入式</th>
</tr>
</thead>
<tbody><tr>
<td><code>/boot</code></td>
<td>启动程序等</td>
<td>ext4</td>
<td>100MB</td>
<td>50MB</td>
</tr>
<tr>
<td><code>/</code></td>
<td>根目录</td>
<td>ext4</td>
<td>1GB-5GB</td>
<td>150-250MB</td>
</tr>
<tr>
<td><code>swap</code></td>
<td>虚拟内存</td>
<td>swap</td>
<td>0/2*ram</td>
<td>看情况</td>
</tr>
<tr>
<td><code>/usr</code></td>
<td>放置系统应用程序</td>
<td>ext4</td>
<td>5GB-20GB</td>
<td>1-5GB</td>
</tr>
<tr>
<td><code>/opt</code></td>
<td>放置大型或测试软件, <strong>建议用户软件都放此处</strong></td>
<td>ext4</td>
<td>10-50GB</td>
<td>使用<code>/usr/local</code></td>
</tr>
<tr>
<td><code>/tmp</code></td>
<td>临时文件</td>
<td>ext4</td>
<td>500M</td>
<td>50-100M</td>
</tr>
<tr>
<td><code>/var</code></td>
<td>放置经常变化的文件</td>
<td>ext4</td>
<td>1GB</td>
<td>300-500M</td>
</tr>
<tr>
<td><code>/home</code></td>
<td>用户家目录</td>
<td>ext4</td>
<td>100G/自定义</td>
<td>看情况</td>
</tr>
</tbody></table>
<h1 id="linux磁盘常用指令"><a href="#linux磁盘常用指令" class="headerlink" title="linux磁盘常用指令"></a>linux磁盘常用指令</h1><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>df</code></td>
<td><strong>disk free</strong>, 查看磁盘相关信息</td>
</tr>
<tr>
<td>…… <strong><code>df -Th</code></strong></td>
<td>查看磁盘容量信息</td>
</tr>
<tr>
<td>…… <strong><code>df -iTh</code></strong></td>
<td>查看磁盘inode信息</td>
</tr>
<tr>
<td><code>du</code></td>
<td><strong>disk usage</strong>, 查看磁盘文件使用情况</td>
</tr>
<tr>
<td>…… <strong><code>du -h</code></strong></td>
<td>列出当前文件夹下所有文件的容量</td>
</tr>
<tr>
<td>…… <strong><code>du -sh file_dir</code></strong></td>
<td>列出指定文件的容量</td>
</tr>
<tr>
<td><code>fdisk</code></td>
<td><strong>format disk</strong>, 磁盘查看及分区</td>
</tr>
<tr>
<td>…… <strong><code>fdisk -l</code></strong></td>
<td>查看整个系统的分区情况</td>
</tr>
<tr>
<td>…… <strong><code>fdisk /dev/sda6</code></strong></td>
<td>对指定磁盘进行配置(进入fdisk命令行模式)</td>
</tr>
<tr>
<td><code>mkfs</code></td>
<td><strong>make filesystem</strong>, 分区格式化</td>
</tr>
<tr>
<td>…… <strong><code>mkfs -t ext4 /dev/sda6</code></strong></td>
<td>格式化sda6分区格式为ext4</td>
</tr>
<tr>
<td><code>fsck</code></td>
<td><strong>filesystem check</strong>, 分区检验和修复</td>
</tr>
<tr>
<td>…… <strong><code>unmount /dev/sda6</code></strong></td>
<td>要检查的分区必须先umount</td>
</tr>
<tr>
<td>…… <strong><code>fsck -y -t ext4 /dev/sda6</code></strong></td>
<td>对sda6分区进行检验和修复</td>
</tr>
<tr>
<td><code>mount</code></td>
<td><strong>mount</strong> 查看和挂载分区</td>
</tr>
<tr>
<td>…… <strong><code>mkdir /mnt/sda_data</code></strong></td>
<td>必须先创建挂载点文件夹</td>
</tr>
<tr>
<td>…… <strong><code>mount -t ext4 /dev/sda6 /mnt/sda_data</code></strong></td>
<td>挂载指定设备sda6到文件夹</td>
</tr>
<tr>
<td><code>umount</code></td>
<td><strong>umount</strong>, 取消挂载点</td>
</tr>
<tr>
<td>…… **<code>umount /dev/sda6</code> **</td>
<td>两种写法都可以</td>
</tr>
<tr>
<td>…… <strong><code>umount /mnt/sda_data</code></strong></td>
<td>两种写法都可以</td>
</tr>
<tr>
<td><code>quato</code></td>
<td><strong>quato</strong>, 管理普通用户的分区配额,多用于服务器.</td>
</tr>
</tbody></table>
<h1 id="mount常见用法及开机自动挂载"><a href="#mount常见用法及开机自动挂载" class="headerlink" title="mount常见用法及开机自动挂载"></a>mount常见用法及开机自动挂载</h1><h2 id="挂载U盘"><a href="#挂载U盘" class="headerlink" title="挂载U盘"></a>挂载U盘</h2><ul>
<li>插入U盘, 用 <code>fdisk -l</code> 或 <code>ll /dev/</code> 下查看U盘的硬件名称, 如 <code>sda11</code></li>
<li>在mnt下建立usb目录 <code>mkdir /mnt/usb</code></li>
<li>挂载U盘  <code>mount -t vfat /dev/sda11 /mnt/usb</code></li>
<li>卸载U盘  <code>umount /mnt/usb</code></li>
<li>拔出U盘</li>
<li>删除mnt目录  <code>rm -fr /mnt/usb</code></li>
</ul>
<h2 id="挂载fat32分区"><a href="#挂载fat32分区" class="headerlink" title="挂载fat32分区"></a>挂载fat32分区</h2><p><code>mount -t vfat -o iocharset=cp936 /dev/sda6 /mnt/fat32</code></p>
<h2 id="挂载ntfs分区"><a href="#挂载ntfs分区" class="headerlink" title="挂载ntfs分区"></a>挂载ntfs分区</h2><p><code>mount -t ntfs -o iocharset=uft8 /dev/sda6 /mnt/ntfs</code></p>
<h2 id="挂载光驱"><a href="#挂载光驱" class="headerlink" title="挂载光驱"></a>挂载光驱</h2><p><code>mount -t iso9660 /dev/hdc /mnt/cdrom</code></p>
<h2 id="重载分区为可读写"><a href="#重载分区为可读写" class="headerlink" title="重载分区为可读写"></a>重载分区为可读写</h2><p>将根目录改为可读写,系统维护时使用<br><code>mount -n -o remount,rw /</code></p>
<h2 id="自动挂载分区"><a href="#自动挂载分区" class="headerlink" title="自动挂载分区"></a>自动挂载分区</h2><p>通过修改 <code>/etc/fstab</code> 实现. 根据规则自行添加行即可.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &lt;file system&gt;   &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;</span><br><span class="line"># &lt;分区&gt;           &lt;挂载点&gt;      &lt;类型&gt;  &lt;配置&gt;     &lt;备份&gt;  &lt;检查&gt;</span><br><span class="line"></span><br><span class="line"># 以下是通过分区唯一的uuid进行挂载,优点是可绑定指定分区</span><br><span class="line"># 获取uuid指令: &#96;ll &#x2F;dev&#x2F;disk&#x2F;by-uuid&#x2F;&#96;</span><br><span class="line">  UUID&#x3D;xxxx-xxxx  &#x2F;             ext4   errors&#x3D;..  0     1</span><br><span class="line">  UUID&#x3D;xxxx-xxxx  &#x2F;boot         ext4   defaults   0     2</span><br><span class="line">  UUID&#x3D;xxxx-xxxx  &#x2F;home         ext4   defaults   0     2</span><br><span class="line"></span><br><span class="line"># 以下是通过设备文件名进行挂载,优点是直观</span><br><span class="line"># 查看设备文件名指令: &#96;sudo fdisk -l&#96;  (sudo,获取管理员权限)</span><br><span class="line">  &#x2F;dev&#x2F;sda5       &#x2F;mnt&#x2F;data     ext4   defaults   0     2</span><br></pre></td></tr></table></figure>







<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>linux文件与目录相关指令</title>
    <url>/2016/12/16/1626-linux-cmd-file/</url>
    <content><![CDATA[<h1 id="linux-文件基础"><a href="#linux-文件基础" class="headerlink" title="linux 文件基础"></a>linux 文件基础</h1><h2 id="特殊符号代表的目录"><a href="#特殊符号代表的目录" class="headerlink" title="特殊符号代表的目录:"></a>特殊符号代表的目录:</h2><table>
<thead>
<tr>
<th>特殊符号</th>
<th>目录</th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code></td>
<td>代表此层目录</td>
</tr>
<tr>
<td><code>..</code></td>
<td>代表上一层目录</td>
</tr>
<tr>
<td><code>~</code></td>
<td>代表<strong>目前使用者</strong>所在的家目录</td>
</tr>
<tr>
<td><code>~account</code></td>
<td>代表<strong>account</strong>这个使用者的家目录</td>
</tr>
<tr>
<td><code>~+</code></td>
<td>当前的工作目录, 等同于<code>pwd</code></td>
</tr>
<tr>
<td><code>~-</code></td>
<td>上次的工作目录</td>
</tr>
</tbody></table>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><table>
<thead>
<tr>
<th>bit9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>r</td>
<td>w</td>
<td>x</td>
<td>r</td>
<td>-</td>
<td>x</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>bit</th>
<th>字母</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>9</td>
<td></td>
<td>文件类型</td>
</tr>
<tr>
<td></td>
<td><code>d</code></td>
<td>目录(dir)</td>
</tr>
<tr>
<td></td>
<td><code>-</code></td>
<td>文件</td>
</tr>
<tr>
<td></td>
<td><code>l</code></td>
<td>链接文件(link)</td>
</tr>
<tr>
<td></td>
<td><code>b</code></td>
<td>块设备文件(block)</td>
</tr>
<tr>
<td></td>
<td><code>c</code></td>
<td>字符设备文件(character)</td>
</tr>
<tr>
<td></td>
<td><code>s</code></td>
<td>网络接口文件(sockets)</td>
</tr>
<tr>
<td></td>
<td><code>p</code></td>
<td>管道文件(FIFO, pipe)</td>
</tr>
<tr>
<td>876</td>
<td><code>rwx</code></td>
<td>拥有人的权限, r为可读, w为可写, x为可执行</td>
</tr>
<tr>
<td>543</td>
<td><code>r-x</code></td>
<td>同群组的权限, r为可读, -为不可写, x为可执行</td>
</tr>
<tr>
<td>210</td>
<td><code>---</code></td>
<td>其它群组权限, 不可读, 不可写, 不可执行</td>
</tr>
</tbody></table>
<h1 id="文件与目录常用指令"><a href="#文件与目录常用指令" class="headerlink" title="文件与目录常用指令"></a>文件与目录常用指令</h1><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>cd</code></td>
<td><strong>Change Directory</strong>, 变换目录</td>
</tr>
<tr>
<td><code>pwd</code></td>
<td><strong>Print Working Directory</strong>, 显示目前的目录</td>
</tr>
<tr>
<td>…… <strong><code>pwd -P</code></strong></td>
<td>显示真实路径, 而非link路径</td>
</tr>
<tr>
<td><code>mkdir dir</code></td>
<td>Make Directory, 建立一个新的目录</td>
</tr>
<tr>
<td>…… <strong><code>mkdir -p dir1/dir2</code></strong></td>
<td>递归建立所有目录</td>
</tr>
<tr>
<td>…… <strong><code>mkdir -m 711 dir</code></strong></td>
<td>建立目录时,设定权限</td>
</tr>
<tr>
<td><code>rmdir dir</code></td>
<td><strong>Remove Directory</strong>, 删除一个空的目录</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ls</code></td>
<td><strong>List Files</strong>, 显示文件与目录</td>
</tr>
<tr>
<td>…… <strong><code>ls -h</code></strong></td>
<td>以KB,GB显示容量.</td>
</tr>
<tr>
<td>…… <strong><code>ls -R</code></strong></td>
<td>Recursive, 递归显示子目录信息</td>
</tr>
<tr>
<td>…… <strong><code>ls -t</code></strong></td>
<td>以时间排序</td>
</tr>
<tr>
<td>…… <strong><code>ls -S</code></strong></td>
<td>以容量大小排序</td>
</tr>
<tr>
<td>…… <strong><code>ll</code></strong></td>
<td><code>ls –al</code>, List All, 显示所有文件及信息</td>
</tr>
<tr>
<td><code>cp src dst</code></td>
<td>copy</td>
</tr>
<tr>
<td>…… <strong><code>cp -a src dst</code></strong></td>
<td>即<code>cp -pdr</code>, 递归复制目录.不会改变属性和权限</td>
</tr>
<tr>
<td>…… <strong><code>cp -f src dst</code></strong></td>
<td>Force, 强制复制,不询问使用者</td>
</tr>
<tr>
<td>…… <strong><code>cp -u src dst</code></strong></td>
<td>若 src比dst新,才进行复制工作,多用于备份</td>
</tr>
<tr>
<td>…… <strong><code>cp src1 src2 src3 dir</code></strong></td>
<td>将多个原文件拷贝到指定目录</td>
</tr>
<tr>
<td><code>mv src dst</code></td>
<td><strong>move</strong>, 移动目录和文件</td>
</tr>
<tr>
<td><code>rm file_dir</code></td>
<td><strong>remove</strong>, 移除文件</td>
</tr>
<tr>
<td>…… <strong><code>rm -fr dir</code></strong></td>
<td>强制递归删除dir下的所有文件和目录</td>
</tr>
<tr>
<td><code>ln -s src dst</code></td>
<td><strong>Symbolic Link</strong>, 创建一个符号链接</td>
</tr>
<tr>
<td>…… <strong><code>ln file hardLink</code></strong></td>
<td>实际链接, 仅支持同区块下的文件,不占用inode</td>
</tr>
<tr>
<td>…… <strong><code>ln -s dir symbolicLink</code></strong></td>
<td>符号链接, 同快捷方式,为一个文件,占用inode</td>
</tr>
<tr>
<td><code>basename /dir/dir/file</code></td>
<td>结果为<code>file</code>, 路径中取得文件名称</td>
</tr>
<tr>
<td><code>dirname /dir/dir/file</code></td>
<td>结果为<code>/dir/dir</code>, 路径中取得目录名称</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>cat file</code></td>
<td><strong>Concatenate</strong> (连续), 连续显示文件内容</td>
</tr>
<tr>
<td>…… <strong><code>cat -n file</code></strong></td>
<td>在前面加上行号</td>
</tr>
<tr>
<td>…… <strong><code>cat -A</code></strong></td>
<td>即 <code>cat -vET</code>, 可显示一些特殊符号</td>
</tr>
<tr>
<td><code>more</code> <code>less</code> <code>head</code> <code>tail</code></td>
<td>都用于显示文件内容, <code>less</code>功能最强大</td>
</tr>
<tr>
<td><code>od -t x1 file</code></td>
<td>按1byte 十六进制显示文件.若x2则为2byte.</td>
</tr>
<tr>
<td><code>touch file</code></td>
<td>建立一个空文件, 修改文件时间(mtime和atime)</td>
</tr>
<tr>
<td><code>file file</code></td>
<td>读取文件类型</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>umask</code></td>
<td>读取和设置当前默认权限, 数字是被取消的默认权限</td>
</tr>
<tr>
<td>…… <strong><code>umask 022</code></strong></td>
<td>新建文档权限为 777-022 = 755权限</td>
</tr>
<tr>
<td><code>chgrp -R group file_dir</code></td>
<td>递归改变file_dir文件/目录的群组(group必须存在)</td>
</tr>
<tr>
<td><code>chown owner file_dir</code></td>
<td>改变文件或目录的所有者(owner必须存在)</td>
</tr>
<tr>
<td>…… <strong><code>chown -R owner:group dir</code></strong></td>
<td>递归改变dir的所有者和组群</td>
</tr>
<tr>
<td>…… <strong><code>chmod -R 755 file_dir</code></strong></td>
<td>递归改名文件或目录的权限 (7=0b111=rwx)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>which -a cmd</code></td>
<td>搜索执行文件完整路径</td>
</tr>
<tr>
<td><code>whereis file</code></td>
<td>快速搜索文件(用数据库),实测下来没啥用</td>
</tr>
<tr>
<td><code>find dir -name file</code></td>
<td>搜索文件(整个硬盘),很强大的一个指令</td>
</tr>
<tr>
<td>…… <strong><code>-name</code></strong></td>
<td>表示按文件名搜索. 类似的参数有很多.有需要在查.</td>
</tr>
<tr>
<td><code>grep pattern files</code></td>
<td>在files中寻找 pattern项,支持正则表达式</td>
</tr>
<tr>
<td>…… <strong><code>grep -r “hello” ./*</code></strong></td>
<td>在当前文件夹下的所有文件下搜索 “hello”</td>
</tr>
<tr>
<td>…… <strong><code>grep -n “Test” *</code></strong></td>
<td>在当前文件夹下搜索 “hello”, 并显示行号</td>
</tr>
<tr>
<td>…… <strong><code>grep -i “Bye” *</code></strong></td>
<td>在当前文件夹下忽略大小写搜索 ”Bye”</td>
</tr>
<tr>
<td>…… <strong><code>grep -w “Test” aa bb</code></strong></td>
<td>在aa, bb文件内,只匹配整个单词搜索 “Test”</td>
</tr>
<tr>
<td>…… <strong><code>grep -nd skip 100ask24x0 *</code></strong></td>
<td>仅在当前目录查找, 不显示子目录信息</td>
</tr>
<tr>
<td><code>find ./ -name &quot;*&quot; l(竖杠) xargs grep --color &quot;key&quot;</code></td>
<td>在当前文件夹下查找包含 “key” 内容的文件</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>tar -cvf file.tar /dir</code></td>
<td>将/dir打包为file.tar,没有压缩</td>
</tr>
<tr>
<td><code>tar -zcvf file.tar.gz /dir</code></td>
<td>将/dir打包为file.tar.gz,用gzip压缩</td>
</tr>
<tr>
<td><code>tar -jcvf file.tar.bz2 /dir</code></td>
<td>将/dir打包为file.tar.gz2,用bzip2压缩</td>
</tr>
<tr>
<td><code>tar -xvf file.tar</code></td>
<td>还原file.tar到当前目录</td>
</tr>
<tr>
<td><code>tar -zxvf file.tar.gz</code></td>
<td>解压file.tar.gz到当前目录</td>
</tr>
<tr>
<td><code>tar -jxvf file.tar.bz2</code></td>
<td>解压file.tar.bz2到当前目录</td>
</tr>
<tr>
<td><code>tar -N ‘2005/06/01’ -zcvffile.tar.gz /dir</code></td>
<td>将/dir下比2005/06/01新的文件备份</td>
</tr>
<tr>
<td><code>cpio</code></td>
<td>文件/设备的输入输出, 多配合find进行备份</td>
</tr>
</tbody></table>
<ul>
<li><strong><code>find ./ -name &quot;*&quot; | xargs grep --color &quot;key&quot;</code></strong> 在当前文件夹下查找包含 “key” 内容的文件</li>
<li><strong><code>find / -print | cpio -covB &gt; /dev/st0</code></strong> , 将系统数据全部写入磁带机</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>Bash Shell及环境变量</title>
    <url>/2016/12/17/1627-linux-cmd-bash/</url>
    <content><![CDATA[<h1 id="入门教程"><a href="#入门教程" class="headerlink" title="入门教程"></a>入门教程</h1><p>推荐 <a href="http://c.biancheng.net/cpp/shell/">C语言中文网-Shell教程</a></p>
<ul>
<li><a href="http://c.biancheng.net/cpp/view/6998.html">第一个shell脚本</a></li>
<li><a href="http://c.biancheng.net/cpp/view/6999.html">shell变量</a></li>
<li><a href="http://c.biancheng.net/cpp/view/2739.html">shell特殊变量</a></li>
<li><a href="http://c.biancheng.net/cpp/view/2737.html">shell替换</a></li>
<li><a href="http://c.biancheng.net/cpp/view/2736.html">shell运算符</a></li>
<li><a href="http://c.biancheng.net/cpp/view/7000.html">shell注释</a></li>
<li><a href="http://c.biancheng.net/cpp/view/7001.html">shell字符串</a></li>
<li><a href="http://c.biancheng.net/cpp/view/7002.html">shell数组</a></li>
<li><a href="http://c.biancheng.net/cpp/view/7003.html">shell echo命令</a></li>
<li><a href="http://c.biancheng.net/cpp/view/1499.html">shell printf命令</a></li>
<li><a href="http://c.biancheng.net/cpp/view/7005.html">shell if else语句</a></li>
<li><a href="http://c.biancheng.net/cpp/view/7006.html">shell case esac语句</a></li>
<li><a href="http://c.biancheng.net/cpp/view/7007.html">shell for循环</a></li>
<li><a href="http://c.biancheng.net/cpp/view/7008.html">shell while循环</a></li>
<li><a href="http://c.biancheng.net/cpp/view/7009.html">shell until循环</a></li>
<li><a href="http://c.biancheng.net/cpp/view/7010.html">shell跳出循环</a></li>
<li><a href="http://c.biancheng.net/cpp/view/7011.html">shell函数</a></li>
<li><a href="http://c.biancheng.net/cpp/view/2491.html">shell函数参数</a></li>
<li><a href="http://c.biancheng.net/cpp/view/2738.html">shell输入输出重定向</a></li>
<li><a href="http://c.biancheng.net/cpp/view/2740.html">shell文件包含</a></li>
</ul>
<h1 id="Bash-Shell基础操作"><a href="#Bash-Shell基础操作" class="headerlink" title="Bash Shell基础操作"></a>Bash Shell基础操作</h1><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[Tab]</code></td>
<td>指令或文件名自动补齐</td>
</tr>
<tr>
<td><code>[Tab][Tab]</code></td>
<td>连按两下[Tab], 列出所有可补齐的指令或档案</td>
</tr>
<tr>
<td><code>[ctrl]-c</code></td>
<td>中断指令</td>
</tr>
<tr>
<td><code>[ctrl]-d</code></td>
<td>EOF,表示输入结束</td>
</tr>
<tr>
<td><code>[↑]</code> <code>[↓]</code></td>
<td>浏览历史指令</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>stty</code></td>
<td>查看和设置终端按键参数</td>
</tr>
<tr>
<td>…… <strong><code>stty -a</code></strong></td>
<td>查看终端所有的按键参数</td>
</tr>
<tr>
<td><code>history</code></td>
<td>查询历史指令, 建议将其设置别名<code>alias h=’history’</code></td>
</tr>
<tr>
<td><code>!</code></td>
<td>执行历史指令, 后接数字或字母</td>
</tr>
<tr>
<td>…… <strong><code>!!</code></strong></td>
<td>执行上一个指令</td>
</tr>
<tr>
<td>…… <strong><code>!al</code></strong></td>
<td>执行以al为开头的最后一个指令</td>
</tr>
<tr>
<td>…… <strong><code>!12</code></strong></td>
<td>执行第12条历史指令(先用history查看历史指令号)</td>
</tr>
<tr>
<td><code>alias cmd=’command’</code></td>
<td>设置指令别名, command为指令字符串</td>
</tr>
<tr>
<td>…… <strong><code>alias h=history</code></strong></td>
<td>设置指令history的别名为h.不用引号,单双引号皆可</td>
</tr>
<tr>
<td><code>unalias cmd</code></td>
<td>取消指令别名</td>
</tr>
<tr>
<td><code>type -a command</code></td>
<td>查询指令类型(file外部指令; alias别名指令;builtin内建指令)</td>
</tr>
<tr>
<td><code>command --help</code></td>
<td>获取command内置的帮助信息,较为简短</td>
</tr>
<tr>
<td><code>man command</code></td>
<td>获取command的帮助文件. <code>j</code> <code>k</code>上下移动, <code>q</code>退出</td>
</tr>
<tr>
<td><code>sh file</code></td>
<td>创建一个子shell, 执行file内的指令</td>
</tr>
<tr>
<td><code>source file</code></td>
<td>在当前shell内,执行file内的指令</td>
</tr>
<tr>
<td><code>. file</code></td>
<td>等同于source file</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>su -l user</code></td>
<td>切换用户, -l表示环境变量一起变</td>
</tr>
<tr>
<td>…… <strong><code>su</code></strong></td>
<td>切换为管理员账户</td>
</tr>
<tr>
<td><code>sudo command</code></td>
<td>赋予用户临时的管理员权限 (<code>/etc/sudoers</code>决定是否支持)</td>
</tr>
<tr>
<td><code>exit</code></td>
<td>退出当前用户的终端环境</td>
</tr>
<tr>
<td><code>shutdown -h now</code></td>
<td>立刻关机</td>
</tr>
<tr>
<td><code>sync; sync; shutdown -r now</code></td>
<td>立刻重启, 重启前需要存储一下数据</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>date</code></td>
<td>时间</td>
</tr>
<tr>
<td><code>cal</code></td>
<td>日期</td>
</tr>
<tr>
<td><code>bc</code></td>
<td>计算器, 输入quit退出</td>
</tr>
<tr>
<td><code>apt-get</code></td>
<td>ubuntu deb包软件管理</td>
</tr>
<tr>
<td>…… <strong><code>sudo apt-get install packagename</code></strong></td>
<td>安装指定软件包</td>
</tr>
<tr>
<td>…… <strong><code>sudo apt-get autoremovepackagename</code></strong></td>
<td>删除指定软件包 (包括配置文件)</td>
</tr>
</tbody></table>
<h1 id="变量与环境变量"><a href="#变量与环境变量" class="headerlink" title="变量与环境变量"></a>变量与环境变量</h1><ul>
<li>系统变量一般大写, 如MAIL</li>
<li>用户变量一般小写, 如myhome</li>
<li>普通变量(也称shell变量)作用范围: 当前的shell</li>
<li>环境变量(也称用户变量)作用范围: 当前的shell及其子shell</li>
<li>环境变量开机设置文档<ul>
<li><code>~/.bashrc</code>, <code>~/.profile</code>, <code>/etc/profile</code>, <code>/etc/bash.bashrc</code>,等等</li>
<li>首先读取 <code>/etc/profile</code>, 最后读取 <code>~/.bashrc</code></li>
<li>个人设定建议放在<code>~/.bashrc</code>内,并做如下修改:</li>
<li>修改<code>HISTSIZE=50</code>  (减少记录的历史指令,安全)</li>
<li>加入<code>alias h=&#39;history&#39;</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>myhome=/home/my/</code></td>
<td>无空格字符串,注意等号左右不要有空格</td>
</tr>
<tr>
<td><code>myhome=’/home/my/’</code></td>
<td>单引号内可包含任意字符串, 无特殊含义</td>
</tr>
<tr>
<td><code>myname=”my name is”</code></td>
<td>双引号内某些字符有特殊作用, 如 $</td>
</tr>
<tr>
<td><code>read variable</code></td>
<td>键盘输入变量, 回车表示结束输入</td>
</tr>
<tr>
<td>…… <strong><code>read -p “Input name:” -t 30 myname</code></strong></td>
<td>提示输入变量给myname, 30秒输入时间</td>
</tr>
<tr>
<td><code>echo $myhome</code></td>
<td>变量名前加上$, 即可读取该变量的值</td>
</tr>
<tr>
<td><code>echo “$myhome”</code></td>
<td>“$变量名”,无歧义. 注意不能单引号</td>
</tr>
<tr>
<td><code>echo $&#123;myhome&#125;</code></td>
<td>${变量名},无歧义</td>
</tr>
<tr>
<td><code>unset myhome</code></td>
<td>删除变量</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>let val=10*10</code></td>
<td>加上let后, val值为100,而非10*10. 用的比declare多!</td>
</tr>
<tr>
<td><code>readonly VAL=’read only’</code></td>
<td>将VAL为只读变量,不可更改和unset (等同 declare -r)</td>
</tr>
<tr>
<td><code>declare -ai array</code></td>
<td>将array声明为整数数组 (不加参数a,效果一样)</td>
</tr>
<tr>
<td><code>array[1]=10*10</code></td>
<td>数组的赋值, array定义为整数,因此array[1]值为100</td>
</tr>
<tr>
<td><code>echo $&#123;array[1]&#125;</code></td>
<td>使用”$array[1]”没用.若无{}, 会认为是”$array”[1]</td>
</tr>
<tr>
<td><code>unset array</code></td>
<td>将array数组变量删除</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>PATH=/home:$PATH</code></td>
<td>新增”/home:”在PATH变量最前面</td>
</tr>
<tr>
<td><code>PATH=”$PATH””:/home”</code></td>
<td>前后都加”双引号”,无歧义. 建议这样书写</td>
</tr>
<tr>
<td><code>PATH=$&#123;PATH&#125;’:/home’</code></td>
<td>变量名用{大括号}指明,无歧义. 新增变量也可用’单引号’</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>echo $?</code></td>
<td>?为特殊变量,为上一指令传回的值. 0成功, !0失败</td>
</tr>
<tr>
<td><code>echo $$</code></td>
<td>获取并显示当前shell的 PID (process ID)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>#</code> <code>##</code> <code>%</code> <code>%%</code> <code>/</code> <code>//</code></td>
<td>变量的截取和替换. 以<code>myhome=/home/test/test.sh</code>为例</td>
</tr>
<tr>
<td>…… <strong><code>echo $&#123;myhome#/*/&#125;</code></strong></td>
<td><code>test/test.sh</code>,从头比较, 单次删除,故<del><code>/home/</code></del></td>
</tr>
<tr>
<td>…… <strong><code>echo $&#123;myhome##/*/&#125;</code></strong></td>
<td><code>test.sh</code>, 从头比较, 全部删除,获得文件名</td>
</tr>
<tr>
<td>…… <strong><code>echo $&#123;myhome%/*&#125;</code></strong></td>
<td><code>/home/test</code>,从尾比较, 单次删除,获得路径</td>
</tr>
<tr>
<td>…… <strong><code>echo $&#123;myhome%%/*&#125;</code></strong></td>
<td>从尾比较, 全部删除,故全部被删掉</td>
</tr>
<tr>
<td>…… <strong><code>echo $&#123;myhome/test/TEST&#125;</code></strong></td>
<td><code>/home/TEST/test.h</code>, 从头比较, 单次替换</td>
</tr>
<tr>
<td>…… <strong><code>echo $&#123;myhome//test/TEST&#125;</code></strong></td>
<td><code>/home/TEST/TEST.h</code>,从头比较, 全部替换</td>
</tr>
<tr>
<td><code>-</code> <code>:-</code> <code>+</code> <code>:+</code> <code>=</code> <code>:=</code> <code>?</code> <code>:?</code></td>
<td>变量的比较和判断. 常用于判断和确保变量有效</td>
</tr>
<tr>
<td>…… <strong><code>var=$&#123;str-expr&#125;</code></strong></td>
<td>var为目标变量, str为已有变量, expr为变量值</td>
</tr>
<tr>
<td>…… <strong><code>myname=$&#123;myname:-root&#125;</code></strong></td>
<td>若myname不存在或为空,则myname=root</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>env</code></td>
<td>enviroment, 显示当前环境变量,用的最多!</td>
</tr>
<tr>
<td><code>set</code></td>
<td>显示所有变量(环境变量,普通变量)</td>
</tr>
<tr>
<td><code>export</code></td>
<td>显示已成为当前环境变量的普通变量</td>
</tr>
<tr>
<td>…… <strong><code>export variable</code></strong></td>
<td>将variable设为环境变量, 等同 <code>declare -x variable</code></td>
</tr>
<tr>
<td><code>locale</code></td>
<td>查看当前语言的环境变量</td>
</tr>
<tr>
<td>…… <strong><code>locale -a</code></strong></td>
<td>查看系统支持的语言</td>
</tr>
</tbody></table>
<h1 id="Bash-Shell特殊符号"><a href="#Bash-Shell特殊符号" class="headerlink" title="Bash Shell特殊符号"></a>Bash Shell特殊符号</h1><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>万用字符, 表示0或多个字符</td>
</tr>
<tr>
<td><code>?</code></td>
<td>万用字符, 表示一个字符</td>
</tr>
<tr>
<td><code>!</code></td>
<td>逻辑非, 通常在<code>[中括号]</code>内使用</td>
</tr>
<tr>
<td><code>\</code></td>
<td>转义字符, 需要转义的字符 <code>&quot;</code> <code>&#39;</code> <code>$</code> <code>\</code> <code> </code> `</td>
</tr>
<tr>
<td>…… <strong><code>\n</code></strong></td>
<td>换行</td>
</tr>
<tr>
<td>…… <strong><code>\r</code></strong></td>
<td>回车</td>
</tr>
<tr>
<td>…… <strong><code>\t</code></strong></td>
<td>水平制表符</td>
</tr>
<tr>
<td>…… <strong><code>\v</code></strong></td>
<td>垂直制表符</td>
</tr>
<tr>
<td>…… <strong><code>\b</code></strong></td>
<td>后退</td>
</tr>
<tr>
<td>…… <strong><code>\a</code></strong></td>
<td>蜂鸣</td>
</tr>
<tr>
<td>…… <strong><code>\077</code></strong></td>
<td>八进制字符</td>
</tr>
<tr>
<td>…… <strong><code>\xff</code></strong></td>
<td>十六进制</td>
</tr>
<tr>
<td><code>#</code></td>
<td>批注</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>$variable</code></td>
<td>变量名</td>
</tr>
<tr>
<td><code>$&#123;variable&#125;</code></td>
<td>大括号. 中间为命令区块组合,限定变量名范围</td>
</tr>
<tr>
<td>…… <strong><code>echo $&#123;array[1]&#125;</code></strong></td>
<td>显示<code>array[1]</code> 变量值, array为数组,需用<code>&#123;大括号&#125;</code>包含变量名</td>
</tr>
<tr>
<td><code>[a-f], [35], [!a-z]</code></td>
<td>中括号. 中间为字符组合, <code>[仅代表一个字符]</code></td>
</tr>
<tr>
<td>…… <strong><code>ls -d ~/*[0-9]*</code></strong></td>
<td>列出用户home目录下所有包含数字的文件和目录</td>
</tr>
<tr>
<td><code>$(command)</code></td>
<td>小括号. 中间为子shell,此命令等同于`command`</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&#39;$string&#39;</code></td>
<td>单引号, 特殊符号无效,变量不置换, 显示为$string</td>
</tr>
<tr>
<td><code>&quot;$variable&quot;</code></td>
<td>双引号, 特殊符号有用,变量置换</td>
</tr>
<tr>
<td>`command`</td>
<td>`(键盘1左边的字符),需要优先执行的指令</td>
</tr>
<tr>
<td>…… <strong>cd /usr/src/linux-headers-`uname -r`</strong></td>
<td>进入当前linux的内核源码目录</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>cmd1 l cmd2 和 cm1 ll cmd2</td>
<td>hexo解析问题, 无法再表格中正确显示<code>丨</code>, <strong>故放到表格的最后</strong></td>
</tr>
<tr>
<td><code>cut</code> <code>grep</code> <code>split</code></td>
<td>截取分割, 通常配合 <code>pipe</code>使用</td>
</tr>
<tr>
<td><code>sort</code> <code>wc</code> <code>uniq</code></td>
<td>排序命令, 通常配合 <code>pipe</code>使用</td>
</tr>
<tr>
<td><code>tr</code> <code>col</code> <code>join</code> <code>paste</code> <code>expand</code></td>
<td>字符转换, 通常配合 <code>pipe</code>使用</td>
</tr>
<tr>
<td><code>cmd1;cmd2; cmd3</code></td>
<td>可以一行写多个指令</td>
</tr>
<tr>
<td><code>cmd1 &amp;&amp; cmd2</code></td>
<td>cmd1执行正确($?为0),则继续执行cmd2, 否则不执行</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&gt;</code> <code>2&gt;</code> <code>&gt;&gt;</code> <code>2&gt;&gt;</code></td>
<td>输出到文件 (&gt;写入, &gt;&gt;累加, 2错误信息)</td>
</tr>
<tr>
<td>…… <strong><code>ll &gt; list.txt</code></strong></td>
<td>将当前目录下的文件详细信息存储到list.txt文件中</td>
</tr>
<tr>
<td>…… <strong><code>ls / &gt;&gt; list.txt</code></strong></td>
<td>将根目录下的文件信息追加到list.txt文件中</td>
</tr>
<tr>
<td>…… <strong><code>find /home -name test &gt; ok 2&gt; error</code></strong></td>
<td>将正确信息写到ok中,错误的写到error中</td>
</tr>
<tr>
<td>…… <strong><code>find /home -name test &gt; list 2&gt;&amp;1</code></strong></td>
<td>将所有信息都写到list中 (&amp;1是数字一)</td>
</tr>
<tr>
<td>…… <strong><code>find /home -name test &gt; /dev/null 2&gt; err</code></strong></td>
<td><code>/dev/null</code>相当于黑洞.只将错误写到err中</td>
</tr>
<tr>
<td><code>&lt;</code> <code>&lt;&lt;</code></td>
<td>输入信息(&lt;从文件获取, &lt;&lt;结束的输入字符)</td>
</tr>
<tr>
<td>…… <strong><code>cat &gt; catfile</code></strong></td>
<td>从键盘获取文本并写到catfile中 (键盘按[ctrl]+d结束输入)</td>
</tr>
<tr>
<td>…… <strong><code>cat &gt; catfile &lt;&lt; end</code></strong></td>
<td>从键盘获取文本并写到catfile中(键盘输入end结束输入)</td>
</tr>
<tr>
<td>…… <strong><code>cat &gt; catfile &lt; input</code></strong></td>
<td>导入input文件信息再写到catfile中</td>
</tr>
</tbody></table>
<ul>
<li><code>cmd1 | cmd2</code>  <code>pipe</code>管线命令,将cmd1的处理结果传给cmd2继续处理</li>
<li>譬如 <code>ll | more</code>  将ll获得的数据传给more进一步处理</li>
<li><code>cmd1 || cmd2</code>  cmd1执行错误($?为!0),则继续执行cmd2, 否则不执行</li>
<li>譬如 <code>ls /tmp/test &amp;&amp; echo &quot;exist&quot; || echo &quot;nofile&quot;</code> 如果<code>/tmp/test</code>存在显示<code>exist</code>,否则<code>nofile</code></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2016/12/18/1628-soft-regular/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li><a href="https://draapho.github.io/2016/12/18/1628-soft-regular/">正则表达式</a></li>
<li><a href="https://draapho.github.io/2017/09/19/1726-soft-easyre/">人人都看得懂的正则表达式教程</a></li>
<li><a href="https://draapho.github.io/2017/10/07/1727-soft-reexample/">最全的常用正则表达式大全</a></li>
</ul>
<p>本文详细介绍了正则表达式的基础内容</p>
<h1 id="正则表达式基础内容"><a href="#正则表达式基础内容" class="headerlink" title="正则表达式基础内容"></a>正则表达式基础内容</h1><table>
<thead>
<tr>
<th>RE 字符/范例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>\</code></td>
<td>跳脱/转义字符</td>
</tr>
<tr>
<td><strong>占位符</strong></td>
<td>表示一个字符</td>
</tr>
<tr>
<td><code>^word</code></td>
<td><code>^</code>表<strong>行首</strong>, 待匹配的字符串<code>word</code>在行首！</td>
</tr>
<tr>
<td>…… <code>grep -n &#39;^#&#39; re.txt</code></td>
<td>显示行首为 <code>#</code> 的行</td>
</tr>
<tr>
<td><code>word$</code></td>
<td><code>$</code>表<strong>行尾</strong>, 待匹配的字符串<code>word</code>在行尾！</td>
</tr>
<tr>
<td>…… <code>grep -n &#39;!$&#39; re.txt</code></td>
<td>显示行尾为 <code>!</code> 的行</td>
</tr>
<tr>
<td><code>.</code></td>
<td>代表<strong>任意一个</strong>字符, 必须有一个字符</td>
</tr>
<tr>
<td>…… <code>grep -n &#39;e.e&#39; re.txt</code></td>
<td>结果为 <code>eve</code> <code>eee</code> <code>e e</code>, 但不能是 <code>ee</code></td>
</tr>
<tr>
<td><code>[]</code></td>
<td>字符集合. <strong>除<code>^</code> <code>\</code> <code>-</code>外, 其它特殊字符在中括号被认为是普通字符</strong>. 系统字符集可以包含其中如<code>[\d]</code></td>
</tr>
<tr>
<td><code>[^]</code></td>
<td>中括号内的第一个<code>^</code>表示补集, <del>而不是行尾</del>, 也可以理解为非. 非第一个则为普通字符</td>
</tr>
<tr>
<td>…… <code>grep -n &#39;[(+*)]&#39; re.txt</code></td>
<td>匹配 <code>(</code> <code>+</code> <code>*</code> <code>)</code> 中的一个字符.</td>
</tr>
<tr>
<td>…… <code>grep -n &#39;[0-9]&#39; re.txt</code></td>
<td>搜寻含有任意数字的那一行.  中括号内的<code>-</code>表连续(由编码决定),</td>
</tr>
<tr>
<td>…… <code>grep -n &#39;oo[^0-9]&#39; re.txt</code></td>
<td>排除结果 <code>oo0-oo9</code>, 可以是 <code>ooa</code> <code>oog</code>等等</td>
</tr>
<tr>
<td><strong>数量符</strong></td>
<td>跟在一个字符或组的后面, 重复该RE字符或组若干次</td>
</tr>
<tr>
<td><code>*</code></td>
<td><strong>零个或多个</strong>的前一RE字符</td>
</tr>
<tr>
<td>…… <code>grep -n &#39;ess*&#39; re.py</code></td>
<td>结果为 <code>es</code>(0次s), <code>ess</code>, <code>esss</code></td>
</tr>
<tr>
<td>…… <code>.*</code></td>
<td>表示任意字符</td>
</tr>
<tr>
<td><code>&#123;m,n&#125;</code></td>
<td><strong>连续m到n个</strong>的前一RE字符</td>
</tr>
<tr>
<td>…… <code>&#123;m,&#125;</code></td>
<td><strong>连续m个及以上</strong>的前一RE字符</td>
</tr>
<tr>
<td>…… <code>&#123;m&#125;</code></td>
<td><strong>连续m个</strong>的前一RE字符</td>
</tr>
<tr>
<td>…… <code>grep -n &#39;go\&#123;2,3\&#125;g&#39; re.txt</code></td>
<td>结果为 <code>goog</code>(2次o), <code>gooog</code>(3次o).</td>
</tr>
<tr>
<td><code>?</code></td>
<td><strong>零个或一个</strong>的前一RE字符, 等同于<code>&#123;0,1&#125;</code></td>
</tr>
<tr>
<td>…… <code>egrep -n &#39;go?d&#39; re.txt</code></td>
<td>只能匹配<code>gd</code>和<code>god</code></td>
</tr>
<tr>
<td><code>+</code></td>
<td>重复<strong>一个或以上</strong>的前一RE字符, 等同于<code>&#123;1,&#125;</code></td>
</tr>
<tr>
<td>…… <code>egrep -n &#39;go+d&#39; re.txt</code></td>
<td>匹配<code>god</code> <code>good</code>等, <del>但不能匹配<code>gd</code></del></td>
</tr>
<tr>
<td><code>*?</code> <code>+?</code> <code>??</code> <code>&#123;m,n&#125;?</code></td>
<td>让 <code>*</code> <code>+</code> <code>?</code> <code>&#123;m,n&#125;</code> 变得非贪婪, 即匹配尽可能少的字符</td>
</tr>
<tr>
<td>…… <code>&lt;.*&gt;</code>匹配<code>&#39;&lt;H1&gt;title&lt;/H1&gt;&#39;</code></td>
<td>会得到 <code>&#39;&lt;H1&gt;title&lt;/H1&gt;&#39;</code> 整个字符串, <del>而不是预想的<code>&#39;&lt;H1&gt;&#39;</code></del></td>
</tr>
<tr>
<td>…… <code>&lt;.*?&gt;</code>匹配<code>&#39;&lt;H1&gt;title&lt;/H1&gt;&#39;</code></td>
<td><code>*?</code>变得非贪婪, 会得到 <code>&#39;&lt;H1&gt;&#39;</code> 字符串</td>
</tr>
<tr>
<td><strong>逻辑分组</strong></td>
<td>对字符进行分组和判断</td>
</tr>
<tr>
<td><code>()</code></td>
<td>分组字符串</td>
</tr>
<tr>
<td>…… <code>egrep &#39;A(xyz)+C&#39;</code></td>
<td>匹配A开头, C结尾, 中间有一个以上”xyz”的字符串, 如 <code>AxyzC</code> <code>AxyzxyzxyzC</code></td>
</tr>
<tr>
<td><code>\number</code></td>
<td>反向引用, 引用编号为<code>number</code>的分组<code>()</code>匹配到字符串</td>
</tr>
<tr>
<td>…… <code>(\d)abc\1</code></td>
<td>匹配结果 <code>1abc1</code> 或 <code>5abc5</code></td>
</tr>
</tbody></table>
<ul>
<li><code>|</code> 理解为或即可, 用来隔开多个正则表达式.</li>
<li>譬如 <code>egrep -n &#39;gd|good&#39; re.txt</code>   只能匹配<code>gd</code>和<code>good</code></li>
<li>譬如 <code>egrep -n &#39;g(la|oo)d&#39; re.txt</code> 只能匹配<code>glad</code>和<code>good</code></li>
</ul>
<h1 id="正则表达式的兼容性问题"><a href="#正则表达式的兼容性问题" class="headerlink" title="正则表达式的兼容性问题"></a>正则表达式的兼容性问题</h1><h2 id="PCRE"><a href="#PCRE" class="headerlink" title="PCRE"></a>PCRE</h2><p>即 Perl Compatible Regular Expression<br>常见的正则表达式记法,其实都源于Perl.<br>实际上，正则表达式是从Perl衍生出一个显赫的流派, 称为PCRE<br><code>\d</code> <code>\w</code> <code>\s</code> 之类的记法，就是这个流派的特征.</p>
<p>Python 的re库就是使用的PCRE. 其系统字符集如下:</p>
<table>
<thead>
<tr>
<th>系统字符集</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>\d</code></td>
<td>digital, 数字字符, <code>[0-9]</code></td>
</tr>
<tr>
<td><code>\D</code></td>
<td>非数字字符, <code>[^\d]</code></td>
</tr>
<tr>
<td><code>\s</code></td>
<td>space, 空白字符, <code>[ \t\r\n\f\v]</code></td>
</tr>
<tr>
<td><code>\S</code></td>
<td>非空白字符, <code>[^\s]</code></td>
</tr>
<tr>
<td><code>\w</code></td>
<td>word, 单词字符, <code>[A-Za-z0-9_]</code></td>
</tr>
<tr>
<td><code>\W</code></td>
<td>非单词字符, <code>[^\w]</code></td>
</tr>
<tr>
<td><code>\A</code></td>
<td>仅匹配字符串开头</td>
</tr>
<tr>
<td><code>\Z</code></td>
<td>仅匹配字符串结尾</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>提取指定的<code>\w</code>串</td>
</tr>
<tr>
<td>… <code>\bfoo\b</code></td>
<td>匹配 <code>foo</code> <code>foo.</code> <code>(foo)</code> <code>b foo z</code>, <del>不匹配 <code>foobar</code></del></td>
</tr>
<tr>
<td><code>\B</code></td>
<td><code>[^\b]</code>, 指定部分内容提取<code>\w</code>串</td>
</tr>
<tr>
<td>… <code>py\B</code></td>
<td>匹配 <code>python</code> <code>py3</code>, <del>不匹配 <code>py</code> <code>py.</code> <code>py!</code></del></td>
</tr>
</tbody></table>
<h2 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h2><p>linux是遵循POSIX标准的, 因此在linux下使用正则表达式时, 系统字符集如下:</p>
<table>
<thead>
<tr>
<th>系统字符集</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>[:alnum:]</code></td>
<td>单词字符, <code>[A-Za-z0-9_]</code></td>
</tr>
<tr>
<td><code>[:alpha:]</code></td>
<td>字母字符, <code>[A-Za-z]</code></td>
</tr>
<tr>
<td><code>[:ascii:]</code></td>
<td>ASCII字符, <code>[\x00-\x7F]</code></td>
</tr>
<tr>
<td><code>[:blank:]</code></td>
<td>空格字符, <code>[ \t]</code></td>
</tr>
<tr>
<td><code>[:cntrl:]</code></td>
<td>控制键字符, <code>[\x00-\x1F\x7F]</code></td>
</tr>
<tr>
<td><code>[:digit:]</code></td>
<td>数字字符, <code>[0-9]</code></td>
</tr>
<tr>
<td><code>[:graph:]</code></td>
<td>非空字符, <code>[\x21-\x7E]</code>, <code>[:blank:]</code>的补集</td>
</tr>
<tr>
<td><code>[:lower:]</code></td>
<td>小写字母, <code>[a-z]</code></td>
</tr>
<tr>
<td><code>[:print:]</code></td>
<td>可被打印的字符, <code>[\x20-\x7E]</code></td>
</tr>
<tr>
<td><code>[:punct:]</code></td>
<td>所有标点符号, <code>[][!&quot;#$%&amp;&#39;()*+,./:;&lt;=&gt;?@\</code>^_{}~-]丨`</td>
</tr>
<tr>
<td><code>[:upper:]</code></td>
<td>大写字母 <code>[A-Z]</code></td>
</tr>
<tr>
<td><code>[:space:]</code></td>
<td>空白字符 <code>[ \t\r\n\v\f]</code></td>
</tr>
<tr>
<td><code>[:word:]</code></td>
<td>字母字符 <code>[A-Za-z_]</code></td>
</tr>
<tr>
<td><code>[:xdigit:]</code></td>
<td>16进制类型 <code>[0-9A-Fa-f]</code></td>
</tr>
</tbody></table>
<h2 id="BRE-基础RE"><a href="#BRE-基础RE" class="headerlink" title="BRE, 基础RE"></a>BRE, 基础RE</h2><p>即, Basic Regular Expression<br>BRE只定义了6组元字符：</p>
<ul>
<li><code>[]</code>, 用于在多个字符中选定一个字符进行匹配</li>
<li><code>.</code>,  用于匹配任意字符</li>
<li><code>^</code>,  用于匹配时表示“非”的含义，还有一个用法是匹配行首</li>
<li><code>$</code>,  用于匹配行尾</li>
<li><code>*</code>,  零个或多个的前一RE字符</li>
<li><code>\</code>,  跳脱/转义字符</li>
</ul>
<p>在Linux/Unix常用工具中, grep vi sed都属于BRE这一派,<br>为了向前兼容并使用RE的一些新特性, 导致它的语法看起来比较奇怪. <code>()</code> <code>&#123;&#125;</code> 需要使用 <code>\</code> 转义后才有特殊含义.<br>如果直接使用 <code>a&#123;1,2&#125;</code>, 只能去匹配 <code>a&#123;1,2&#125;</code> 字符串. 只有使用 <code>a\&#123;1,2\&#125;</code> 才能匹配为 <code>a</code>和<code>aa</code>.<br>另外, BRE一般不支持 <del><code>+</code> <code>?</code> <code>(...|...)</code> <code>\number</code></del></p>
<h2 id="ERE-扩展RE"><a href="#ERE-扩展RE" class="headerlink" title="ERE, 扩展RE"></a>ERE, 扩展RE</h2><p>即, Extention Regular Expression<br>ERE在BRE上增加了3组元字符的定义：</p>
<ul>
<li><code>&#123;&#125;</code> 用于表示重复匹配的次数. BRE中将<code>&#123;&#125;</code>当作普通字符对待，必须加<code>\</code>进行转义, 即<code>\&#123;\&#125;</code></li>
<li><code>()</code>, 用于分组。BRE中只将<code>()</code>当作普通字符对待，必须加<code>\</code>进行转义，即<code>\(\)</code></li>
<li><code>|</code>, 完全为ERE新增的多项匹配能力定义的，BRE无多项匹配能力，只将<code>|</code>作普通字符对待</li>
<li><code>\number</code>, ERE没有明确规定需要支持反向引用, 但不少工具都支持此功能</li>
</ul>
<h2 id="linux-unix下的RE表达式汇总"><a href="#linux-unix下的RE表达式汇总" class="headerlink" title="linux/unix下的RE表达式汇总"></a>linux/unix下的RE表达式汇总</h2><table>
<thead>
<tr>
<th>PCRE记法</th>
<th>vi/vim</th>
<th>grep</th>
<th>egrep</th>
<th>awk</th>
<th>sed</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td><code>*</code></td>
<td><code>*</code></td>
<td><code>*</code></td>
<td><code>*</code></td>
<td><code>*</code></td>
</tr>
<tr>
<td><code>+</code></td>
<td><code>\+</code></td>
<td><code>\+</code></td>
<td><code>+</code></td>
<td><code>+</code></td>
<td><code>\+</code></td>
</tr>
<tr>
<td><code>?</code></td>
<td><code>\=</code></td>
<td><code>\?</code></td>
<td><code>?</code></td>
<td><code>?</code></td>
<td><code>\?</code></td>
</tr>
<tr>
<td><code>&#123;m,n&#125;</code></td>
<td><code>\&#123;m,n&#125;</code></td>
<td><code>\&#123;m,n\&#125;</code></td>
<td><code>&#123;m,n&#125;</code></td>
<td><code>&#123;m,n&#125;</code></td>
<td><code>\&#123;m,n\&#125;</code></td>
</tr>
<tr>
<td><code>\b</code></td>
<td><code>\&lt;</code> <code>\&gt;</code></td>
<td><code>\&lt;</code> <code>\&gt;</code></td>
<td><code>\&lt;</code> <code>\&gt;</code></td>
<td><code>\&lt;</code> <code>\&gt;</code></td>
<td><code>\y</code> <code>\&lt;</code> <code>\&gt;</code></td>
</tr>
<tr>
<td><code>(…)</code></td>
<td><code>\(…\)</code></td>
<td><code>\(…\)</code></td>
<td><code>(…)</code></td>
<td><code>(…)</code></td>
<td><code>(…)</code></td>
</tr>
<tr>
<td><code>\1</code> <code>\2</code></td>
<td><code>\1</code> <code>\2</code></td>
<td><code>\1</code> <code>\2</code></td>
<td><code>\1</code> <code>\2</code></td>
<td>不支持</td>
<td><code>\1</code> <code>\2</code></td>
</tr>
</tbody></table>
<p>注意:</p>
<ul>
<li>PCRE中常用<code>\b</code>来表示<strong>单词的起始或结束位</strong>,</li>
<li>Linux工具中, 通常用<code>\&lt;</code>来匹配<strong>单词的起始位置</strong>, 用<code>\&gt;</code>来匹配<strong>单词的结束位置</strong></li>
<li><code>sed</code>中的<code>\y</code>可以同时匹配这两个位置。</li>
</ul>
<h1 id="与bash-shell的一些容易弄混的区别"><a href="#与bash-shell的一些容易弄混的区别" class="headerlink" title="与bash shell的一些容易弄混的区别"></a>与bash shell的一些容易弄混的区别</h1><table>
<thead>
<tr>
<th>特殊字符</th>
<th>bash shell中的含义</th>
<th>RE中的含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>零个到多个任意字符</td>
<td>重复零个或多个前一RE字符</td>
</tr>
<tr>
<td><code>?</code></td>
<td>一个任意字符</td>
<td>重复零个或一个前一RE字符</td>
</tr>
<tr>
<td><code>.</code></td>
<td>运行代码 <code>source</code></td>
<td>一个任意字符</td>
</tr>
<tr>
<td><code>[0-9a-z]</code></td>
<td>list内的一个字符</td>
<td>list内的一个字符</td>
</tr>
<tr>
<td><code>[0-9]</code>的补集</td>
<td><code>[!0-9]</code> ()</td>
<td><code>[^range]</code> (<code>!</code>在RE里是普通字符)</td>
</tr>
<tr>
<td><code>&#123;&#125;</code></td>
<td><code>&#123;123,abc&#125;</code> 字符串匹配</td>
<td><code>&#123;m,n&#125;</code> 重复m到n个前一RE字符</td>
</tr>
</tbody></table>
<ul>
<li>匹配<code>a</code>开头的任意文件<ul>
<li>bash下 <code>ls a*</code></li>
<li>re下 <code>ls | grep &quot;^a.*&quot;</code></li>
</ul>
</li>
<li>匹配string1或string2或更多之一字符串<ul>
<li>bash下 <code>&#123;string1,string2,string3&#125;</code>. 如 <code>touch a&#123;xyz,123&#125;.txt</code>, 结果为 <code>axyz.txt</code> <code>a123.txt</code></li>
<li>re下 <code>(string1|string2|string3)</code>. 如 <code>ls | egrep &#39;g(la|oo)d&#39;</code>, 结果为 <code>glad</code> <code>good</code></li>
</ul>
</li>
<li>连续字符匹配<ul>
<li>bash下, 有两种连续字符表示法 <code>&#123;0..9&#125;</code> 和 <code>[0-9]</code>, 支持<code>[1-3a-z]</code>, <del>不支持<code>&#123;1..3a..z&#125;</code></del>,</li>
<li>bash下 <code>touch &#123;ex&#123;1..3&#125;,ex4&#125;.sh</code>或<code>touch &#123;ex&#123;1..3&#125;,ex4&#125;.sh</code>, 结果为 <code>ex1.sh</code> <code>ex2.sh</code> <code>ex3.sh</code> <code>ex4.sh</code></li>
<li>re下 <code>ls | egrep &quot;(ex[1-3]|ex4).sh&quot;</code>, 结果为 <code>ex1.sh</code> <code>ex2.sh</code> <code>ex3.sh</code> <code>ex4.sh</code></li>
</ul>
</li>
<li>简单总结, RE的功能远比bash自带的匹配符功能强大. 特别容易弄混的也就是 <code>*</code> <code>?</code> <code>[^range]</code></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://python.usyiyi.cn/documents/python_278/library/re.html">python标准库 7.2 re — 正则表达式操作</a></li>
<li><a href="http://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html">Python正则表达式指南</a></li>
<li><a href="http://linux.vbird.org/linux_basic/0330regularex.php">鸟哥的私房菜 第十一章、正規表示法與文件格式化處理</a></li>
<li><a href="http://www.infoq.com/cn/news/2011/07/regular-expressions-6-POSIX">Linux/Unix工具与正则表达式的POSIX规范</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>cheat sheet</tag>
        <tag>python</tag>
        <tag>linux</tag>
        <tag>software</tag>
        <tag>regular</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 列表和字典的常见操作</title>
    <url>/2017/01/03/1701-python-list-dict/</url>
    <content><![CDATA[<h1 id="list"><a href="#list" class="headerlink" title="list []"></a>list <code>[]</code></h1><p>list是一种有序的集合，可以随时添加和删除其中的元素。 形式和特性都像C语言的数组</p>
<h2 id="赋值修改及取值"><a href="#赋值修改及取值" class="headerlink" title="赋值修改及取值"></a>赋值修改及取值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># list 赋值</span></span><br><span class="line">l = <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>)   <span class="comment"># l = [1,3,5,7]      9是不包含在里面的</span></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">3</span>]*<span class="number">3</span>        <span class="comment"># l = [1,3,1,3,1,3]  *表示重复次数</span></span><br><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用切片 (同字符串用法)</span></span><br><span class="line">l[<span class="number">0</span>]        <span class="comment"># 1                 显示第一个元素</span></span><br><span class="line">l[-<span class="number">1</span>]       <span class="comment"># 5                 显示最后一个元素</span></span><br><span class="line">l[<span class="number">0</span>:<span class="number">2</span>]      <span class="comment"># [1, 2]            显示0,1两个元素</span></span><br><span class="line">l[-<span class="number">2</span>:]      <span class="comment"># [4, 5]            显示最后二个元素</span></span><br><span class="line">l[::-<span class="number">1</span>]     <span class="comment"># [5, 4, 3, 2, 1]   步进-1, 就是倒序了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用切片修改元素</span></span><br><span class="line">l[<span class="number">0</span>] = <span class="number">3</span>        <span class="comment"># [3, 2, 3, 4, 5]       修改l[0]的值</span></span><br><span class="line"><span class="comment"># l[1] = [7,8]  # [3, [7, 8], 3, 4, 5]  修改为list表, 存储其指针. 注意和 l[1:2] = [7,8] 的本质区别!</span></span><br><span class="line">l[<span class="number">1</span>:<span class="number">2</span>] = [<span class="number">7</span>,<span class="number">8</span>]  <span class="comment"># [3, 7, 8, 3, 4, 5]    将l[1]修改为元素[7,8]</span></span><br><span class="line">l[<span class="number">1</span>:<span class="number">3</span>] = []     <span class="comment"># [3, 2, 3, 4, 5]       删除1-2的元素</span></span><br><span class="line">l[<span class="number">1</span>:<span class="number">1</span>] = [<span class="number">7</span>,<span class="number">8</span>,<span class="number">2</span>]<span class="comment"># [3, 7, 8, 2, 3, 4, 5] 在l[1]处插入元素[7,8,2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取长度</span></span><br><span class="line"><span class="built_in">len</span>(l)      <span class="comment"># 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line">l.sort()    <span class="comment"># l=[2, 3, 3, 4, 5, 7, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取元素出现的个数</span></span><br><span class="line">l.count(<span class="number">3</span>)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for循环取索引和值, 使用enumerate</span></span><br><span class="line"><span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(l):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;&#123;&#125;: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i, x)         <span class="comment"># i为index, x为list的值</span></span><br></pre></td></tr></table></figure>


<h2 id="增减元素"><a href="#增减元素" class="headerlink" title="增减元素"></a>增减元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增减元素</span></span><br><span class="line">l.append(<span class="string">&#x27;Adam&#x27;</span>)    <span class="comment"># 追加元素到末尾,    l=[&#x27;John&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]</span></span><br><span class="line">l.insert(<span class="number">1</span>, <span class="string">&#x27;Jack&#x27;</span>) <span class="comment"># 在索引1处插入元素, l=[&#x27;John&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]</span></span><br><span class="line">l[<span class="number">1</span>:<span class="number">1</span>]=[<span class="string">&quot;Jack&quot;</span>]     <span class="comment"># 在索引1处插入元素, l=[&#x27;John&#x27;, &#x27;Jack&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删减元素</span></span><br><span class="line">l.remove(<span class="string">&quot;Jack&quot;</span>)    <span class="comment"># 删除第一次出现的该元素, l=[&#x27;John&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]</span></span><br><span class="line">l.pop()             <span class="comment"># 返回并删除末尾的元素,   l=[&#x27;John&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span></span><br><span class="line">l.pop(<span class="number">1</span>)            <span class="comment"># 返回并删除索引1的元素,  l=[&#x27;John&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span></span><br><span class="line"><span class="keyword">del</span> l[<span class="number">0</span>]            <span class="comment"># 删除索引0的元素,       l=[&#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span></span><br><span class="line"><span class="keyword">del</span> l[<span class="number">0</span>:<span class="number">2</span>]          <span class="comment"># 删除多个元素,          l=[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表扩展/叠加</span></span><br><span class="line">l1=[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]; l2=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">l=<span class="built_in">list</span>(<span class="built_in">set</span>(l1+l2))  <span class="comment"># l=[1,2,3,4,5], 避免了重复元素, 但会丢失原有的排序!</span></span><br><span class="line">l=l1+l2             <span class="comment"># l=[3,2,1,3,4,5], 简单的叠加, 非常直观!</span></span><br></pre></td></tr></table></figure>


<h2 id="拷贝-浅拷贝-深拷贝"><a href="#拷贝-浅拷贝-深拷贝" class="headerlink" title="拷贝(浅拷贝, 深拷贝)"></a>拷贝(浅拷贝, 深拷贝)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [[<span class="string">&#x27;a&#x27;</span>], [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 别名及浅拷贝</span></span><br><span class="line">l1 = l              <span class="comment"># l1为l的别名/指针, 指向相同的地址. (l is l1 = True)</span></span><br><span class="line">l1 = l[:]           <span class="comment"># 浅拷贝(只拷贝一维的数据). (l is l1 = False. l[0] is l1[0] = True)</span></span><br><span class="line"><span class="comment"># 在此例中, 由于是浅拷贝, 因此修改元素如 l[0][0]=&#x27;z&#x27; 后, l1显示内容会和l一样.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 深拷贝</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">l1 = copy.deepcopy(l)   <span class="comment"># 深拷贝(遇到指针类型继续深挖). (l is l1 = False. l[0] is l1[0] = False)</span></span><br><span class="line"><span class="comment"># 在此例中, l1 和 l 再无任何关联</span></span><br></pre></td></tr></table></figure>


<h1 id="tuple"><a href="#tuple" class="headerlink" title="tuple ()"></a>tuple <code>()</code></h1><p>理解为list的常量形式即可, 赋值后就不可增减和修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 赋值</span></span><br><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>)   <span class="comment"># 赋值2个元素</span></span><br><span class="line">t = (<span class="number">1</span>,)    <span class="comment"># 赋值1个元素时, 必须加上逗号, 避免误解</span></span><br><span class="line">t = (<span class="number">1</span>,<span class="number">3</span>)*<span class="number">3</span>        <span class="comment"># t = (1,3,1,3,1,3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取值, 使用切片即可</span></span><br><span class="line">t[-<span class="number">1</span>]       <span class="comment"># 取最后一个值, 3</span></span><br><span class="line">t[<span class="number">0</span>::<span class="number">2</span>]     <span class="comment"># 跳着取值, (1,1,1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取长度</span></span><br><span class="line"><span class="built_in">len</span>(t)      <span class="comment"># 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取元素出现的个数</span></span><br><span class="line">t.count(<span class="number">1</span>)  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># list 与 tuple 互相转换</span></span><br><span class="line">l = <span class="built_in">list</span>(t) <span class="comment"># 把tuple变为list</span></span><br><span class="line">t = <span class="built_in">tuple</span>(l)<span class="comment"># 把list变为tuple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝的问题同list</span></span><br></pre></td></tr></table></figure>



<h1 id="dict"><a href="#dict" class="headerlink" title="dict {}"></a>dict <code>&#123;&#125;</code></h1><p>dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p>
<h2 id="赋值及取值"><a href="#赋值及取值" class="headerlink" title="赋值及取值"></a>赋值及取值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dict 赋值</span></span><br><span class="line">d = &#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Bob&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取值</span></span><br><span class="line">d[<span class="string">&#x27;Thomas&#x27;</span>]             <span class="comment"># 不存在会报错</span></span><br><span class="line">d.get(<span class="string">&#x27;Thomas&#x27;</span>, -<span class="number">1</span>)     <span class="comment"># 不存在返回设定的默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断键值</span></span><br><span class="line"><span class="string">&#x27;Michael&#x27;</span> <span class="keyword">in</span> d          <span class="comment"># in方法即可, 返回True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 键值个数</span></span><br><span class="line"><span class="built_in">len</span>(d)                  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取key和value</span></span><br><span class="line">d.keys()                <span class="comment"># 关键字列表, [&#x27;Bob&#x27;, &#x27;Michael&#x27;, &#x27;Tracy&#x27;]</span></span><br><span class="line">d.values()              <span class="comment"># 字典值列表, [75, 95, 85]</span></span><br><span class="line">d.items()               <span class="comment"># 转换为列表, [(&#x27;Bob&#x27;, 75), (&#x27;Michael&#x27;, 95), (&#x27;Tracy&#x27;, 85)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for循环取索引和值, 使用iteritems</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.iteritems():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;&#123;&#125;: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(k, v)         <span class="comment"># k为key, v为value值</span></span><br></pre></td></tr></table></figure>

<h2 id="增减及修改字典"><a href="#增减及修改字典" class="headerlink" title="增减及修改字典"></a>增减及修改字典</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Bob&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改值 (如果key不存在, 变成增加元素)</span></span><br><span class="line">d[<span class="string">&#x27;Michael&#x27;</span>] = <span class="number">88</span>       <span class="comment"># d=&#123;&#x27;Bob&#x27;: 75, &#x27;Michael&#x27;: 88, &#x27;Tracy&#x27;: 85&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加值</span></span><br><span class="line">d[<span class="number">0</span>] = <span class="number">0</span>                <span class="comment"># d=&#123;0: 0, &#x27;Bob&#x27;: 75, &#x27;Michael&#x27;: 88, &#x27;Tracy&#x27;: 85&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个键值</span></span><br><span class="line">d.pop(<span class="number">0</span>)                <span class="comment"># 返回value并删除键值    d=&#123;&#x27;Bob&#x27;: 75, &#x27;Michael&#x27;: 95, &#x27;Tracy&#x27;: 85&#125;</span></span><br><span class="line">d.popitem()             <span class="comment"># 返回value并删除首键值  d=&#123;&#x27;Michael&#x27;: 95, &#x27;Tracy&#x27;: 85&#125;</span></span><br><span class="line"><span class="keyword">del</span> d[<span class="number">0</span>]                <span class="comment"># 删除键值              d=&#123;&#x27;Michael&#x27;: 95, &#x27;Tracy&#x27;: 85&#125;</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> <span class="keyword">in</span> d: <span class="keyword">del</span> d[<span class="number">0</span>]     <span class="comment"># 避免报错的写法         d=&#123;&#x27;Michael&#x27;: 95, &#x27;Tracy&#x27;: 85&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除整个字典</span></span><br><span class="line">d.clear()               <span class="comment"># 清空字典, d变成空字典   d=&#123;&#125;</span></span><br><span class="line"><span class="keyword">del</span> d                   <span class="comment"># 删除了d这个字典</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并字典</span></span><br><span class="line">x = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;; y = &#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line">z = x.copy()            <span class="comment"># 字典拷贝              z = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span></span><br><span class="line">z.update(y)             <span class="comment"># 字典合并(新值覆盖旧值)  z = &#123;&#x27;a&#x27;: 1, &#x27;c&#x27;: 4, &#x27;b&#x27;: 3&#125;</span></span><br><span class="line"><span class="comment"># z = &#123;**x, **y&#125;        # python 3.5以上, 可以直接使用</span></span><br></pre></td></tr></table></figure>


<h2 id="拷贝-浅拷贝-深拷贝-1"><a href="#拷贝-浅拷贝-深拷贝-1" class="headerlink" title="拷贝(浅拷贝, 深拷贝)"></a>拷贝(浅拷贝, 深拷贝)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="number">0</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="number">1</span>:&#123;<span class="string">&#x27;k1&#x27;</span>: <span class="string">&#x27;v1&#x27;</span>, <span class="string">&#x27;k2&#x27;</span>: <span class="string">&#x27;v2&#x27;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意, d.update(), d.copy() 都是浅拷贝!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 别名及浅拷贝</span></span><br><span class="line">d1 = d                  <span class="comment"># l1为l的别名/指针, 指向相同的地址. (d is d1 = True)</span></span><br><span class="line">d1 = d.copy()           <span class="comment"># 浅拷贝(只拷贝一维的数据). (d is d1 = False. d[0] is d1[0] = True)</span></span><br><span class="line"><span class="comment"># 设置 d[0][0] = 3; d[1][&quot;k2&quot;]=2 后, 会发现d1的值也跟着变了. 因为浅拷贝值拷贝一维的数据(指针).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 深拷贝</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">d1 = copy.deepcopy(d)   <span class="comment"># 深拷贝(遇到指针类型继续深挖). (d is d1 = False. d[0] is d1[0] = False)</span></span><br><span class="line"><span class="comment"># d 和 d1 再无任何瓜葛</span></span><br></pre></td></tr></table></figure>


<h1 id="set-set"><a href="#set-set" class="headerlink" title="set {} set([])"></a>set <code>&#123;&#125;</code> <code>set([])</code></h1><p>set即集合, 是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。<br>集合不可放入可变对象, 如list(报<code>unhashable type</code>的错)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 赋值</span></span><br><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;               <span class="comment"># s = set([1, 2, 3])</span></span><br><span class="line">s = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>&#125;      <span class="comment"># s = set([1, 2, 3]), 重复元素会被过滤掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查元素是否存在</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> s                      <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加元素</span></span><br><span class="line">s.add(<span class="number">4</span>)                    <span class="comment"># s = set([1, 2, 3, 4])</span></span><br><span class="line">s.add(<span class="number">4</span>)                    <span class="comment"># 重复增加不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除元素</span></span><br><span class="line">s.remove(<span class="number">4</span>)                 <span class="comment"># s = set([1, 2, 3])</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">4</span> <span class="keyword">in</span> s: s.remove(<span class="number">4</span>)      <span class="comment"># 避免报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合的运算符号</span></span><br><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; s2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s1 &amp; s2                     <span class="comment"># 交集    set([2, 3])</span></span><br><span class="line">s1 | s2                     <span class="comment"># 并集    set([1, 2, 3, 4])</span></span><br><span class="line">s1 ^ s2                     <span class="comment"># 补集    set([1, 4])</span></span><br><span class="line">s1 - s2                     <span class="comment"># 减法    set([1])</span></span><br><span class="line">s2 - s1                     <span class="comment"># 减法    set([4])</span></span><br></pre></td></tr></table></figure>



<h1 id="collections模块的使用"><a href="#collections模块的使用" class="headerlink" title="collections模块的使用"></a>collections模块的使用</h1><h2 id="numedtuple-给tuple命名"><a href="#numedtuple-给tuple命名" class="headerlink" title="numedtuple 给tuple命名"></a>numedtuple 给tuple命名</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> collections</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Point = collections.namedtuple(<span class="string">&#x27;Point&#x27;</span>, [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.x; p.y; p             <span class="comment"># 也可以使用p[0], p[1]</span></span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="number">2.0</span></span><br><span class="line">Point(x=<span class="number">1.0</span>, y=<span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = p._replace(x = <span class="number">1.5</span>, y= <span class="number">1.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p[<span class="number">0</span>]; p[<span class="number">1</span>]              <span class="comment"># 等同于 p.x; p.y</span></span><br><span class="line"><span class="number">1.5</span></span><br><span class="line"><span class="number">1.1</span></span><br></pre></td></tr></table></figure>

<h2 id="deque-双向队列"><a href="#deque-双向队列" class="headerlink" title="deque 双向队列"></a>deque 双向队列</h2><p>英文全称 <code>Double-ended queue</code>, 特性近似于双向链表, 适用于队列和栈</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> collections</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = collections.deque([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">1</span>)             <span class="comment"># q=deque([&#x27;a&#x27;, &#x27;c&#x27;, 1])</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.appendleft(<span class="number">2</span>)         <span class="comment"># q=deque([2, &#x27;a&#x27;, &#x27;c&#x27;, 1])</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.extend([<span class="number">3</span>, <span class="number">4</span>])        <span class="comment"># q=deque([2, &#x27;a&#x27;, &#x27;c&#x27;, 1, 3, 4])</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.extendleft([<span class="number">5</span>, <span class="number">6</span>])    <span class="comment"># q=deque([6, 5, 2, &#x27;a&#x27;, &#x27;c&#x27;, 1, 3, 4])</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.pop()                 <span class="comment"># q=deque([6, 5, 2, &#x27;a&#x27;, &#x27;c&#x27;, 1, 3])</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.popleft()             <span class="comment"># q=deque([5, 2, &#x27;a&#x27;, &#x27;c&#x27;, 1, 3])</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.rotate(<span class="number">1</span>)             <span class="comment"># q=deque([3, 5, 2, &#x27;a&#x27;, &#x27;c&#x27;, 1])</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.rotate(-<span class="number">2</span>)            <span class="comment"># q=deque([2, &#x27;a&#x27;, &#x27;c&#x27;, 1, 3, 5])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 限长的双向队列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>last_three = collections.deque([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], maxlen=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>last_three</span><br><span class="line">que([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], maxlen=<span class="number">3</span>)    <span class="comment"># 队列长度最多为3.</span></span><br></pre></td></tr></table></figure>

<h2 id="defaultdict-带默认键值的dict"><a href="#defaultdict-带默认键值的dict" class="headerlink" title="defaultdict 带默认键值的dict"></a>defaultdict 带默认键值的dict</h2><p>使用<code>dict</code>时，如果引用的Key不存在，就会抛出<code>KeyError</code>。如果希望key不存在时，返回一个默认值，就可以用<code>defaultdict</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 普通字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = <span class="built_in">dict</span>()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> collections</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = collections.defaultdict(<span class="built_in">str</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = collections.defaultdict(<span class="keyword">lambda</span>: <span class="string">&#x27;N/A&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;N/A&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="OrderedDict-可排序的dict"><a href="#OrderedDict-可排序的dict" class="headerlink" title="OrderedDict 可排序的dict"></a>OrderedDict 可排序的dict</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 普通字典, key是无需的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>([(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可排序字典, 按照key插入的顺序排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> collections</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od = collections.OrderedDict([(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od</span><br><span class="line">OrderedDict([(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)])</span><br></pre></td></tr></table></figure>


<p>实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FifoDict</span>(<span class="params">OrderedDict</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(LastUpdatedOrderedDict, self).__init__()</span><br><span class="line">        self._capacity = capacity</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        containsKey = <span class="number">1</span> <span class="keyword">if</span> key <span class="keyword">in</span> self <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self) - containsKey &gt;= self._capacity:</span><br><span class="line">            last = self.popitem(last=<span class="literal">False</span>)</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;remove:&#x27;</span>, last</span><br><span class="line">        <span class="keyword">if</span> containsKey:</span><br><span class="line">            <span class="keyword">del</span> self[key]</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;set:&#x27;</span>, (key, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;add:&#x27;</span>, (key, value)</span><br><span class="line">        OrderedDict.__setitem__(self, key, value)</span><br></pre></td></tr></table></figure>

<h2 id="Counter-计数类"><a href="#Counter-计数类" class="headerlink" title="Counter 计数类"></a>Counter 计数类</h2><p><code>Counter</code>实际上是<code>dict</code>的一个子类, 是一个简单的计数器.</p>
<h3 id="应用一-多重集合-显示元素个数"><a href="#应用一-多重集合-显示元素个数" class="headerlink" title="应用一: 多重集合(显示元素个数)"></a>应用一: 多重集合(显示元素个数)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> collections</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = collections.Counter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = collections.Counter([<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A; B</span><br><span class="line">Counter(&#123;<span class="number">2</span>: <span class="number">2</span>, <span class="number">1</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A | B</span><br><span class="line">Counter(&#123;<span class="number">2</span>: <span class="number">2</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A &amp; B</span><br><span class="line">Counter(&#123;<span class="number">2</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A + B</span><br><span class="line">Counter(&#123;<span class="number">2</span>: <span class="number">4</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A - B</span><br><span class="line">Counter(&#123;<span class="number">1</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B - A</span><br><span class="line">Counter(&#123;<span class="number">3</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="应用二-统计最常出现的元素"><a href="#应用二-统计最常出现的元素" class="headerlink" title="应用二: 统计最常出现的元素"></a>应用二: 统计最常出现的元素</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = collections.Counter(<span class="built_in">list</span>(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A</span><br><span class="line">Counter(&#123;<span class="string">&#x27;l&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;h&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;o&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.most_common(<span class="number">1</span>)</span><br><span class="line">[(<span class="string">&#x27;l&#x27;</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>


<h1 id="高阶应用"><a href="#高阶应用" class="headerlink" title="高阶应用"></a>高阶应用</h1><h2 id="list-加入索引值"><a href="#list-加入索引值" class="headerlink" title="list 加入索引值"></a>list 加入索引值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seasons = [<span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>, <span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">&#x27;Spring&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;Summer&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;Fall&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;Winter&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons, start=<span class="number">1</span>))</span><br><span class="line">[(<span class="number">1</span>, <span class="string">&#x27;Spring&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;Summer&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;Fall&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;Winter&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="list的压缩和解压-以及转换为dict"><a href="#list的压缩和解压-以及转换为dict" class="headerlink" title="list的压缩和解压, 以及转换为dict"></a>list的压缩和解压, 以及转换为dict</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; b = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = <span class="built_in">zip</span>(a, b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z</span><br><span class="line">[(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(z)     <span class="comment"># 转换为dict</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">zip</span>(*z)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="list相邻元素压缩器-升维"><a href="#list相邻元素压缩器-升维" class="headerlink" title="list相邻元素压缩器, 升维"></a>list相邻元素压缩器, 升维</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Using iterators / 使用迭代器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent = <span class="keyword">lambda</span> a, k: <span class="built_in">zip</span>(*([<span class="built_in">iter</span>(a)] * k))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">3</span>)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">2</span>)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">1</span>)</span><br><span class="line">[(<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,), (<span class="number">4</span>,), (<span class="number">5</span>,), (<span class="number">6</span>,)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Using slices / 使用切片</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent = <span class="keyword">lambda</span> a, k: <span class="built_in">zip</span>(*(islice(a, i, <span class="literal">None</span>, k) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)))</span><br><span class="line"><span class="comment"># 该lambda函数展开形式如下:</span></span><br><span class="line"><span class="comment"># def n_grams(a, n):</span></span><br><span class="line"><span class="comment">#     z = (islice(a, i, None) for i in range(n))</span></span><br><span class="line"><span class="comment">#     return zip(*z)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">3</span>)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">2</span>)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">1</span>)</span><br><span class="line">[(<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,), (<span class="number">4</span>,), (<span class="number">5</span>,), (<span class="number">6</span>,)]</span><br></pre></td></tr></table></figure>

<h2 id="list展开-降维"><a href="#list展开-降维" class="headerlink" title="list展开, 降维"></a>list展开, 降维</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐使用 itertools.chain.from_iterable</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(itertools.chain.from_iterable(a))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐使用 sum</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(a, [])</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># for 循环</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> l <span class="keyword">in</span> a <span class="keyword">for</span> x <span class="keyword">in</span> l]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], [[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> l1 <span class="keyword">in</span> a <span class="keyword">for</span> l2 <span class="keyword">in</span> l1 <span class="keyword">for</span> x <span class="keyword">in</span> l2]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], [[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flatten = <span class="keyword">lambda</span> x: [y <span class="keyword">for</span> l <span class="keyword">in</span> x <span class="keyword">for</span> y <span class="keyword">in</span> flatten(l)] <span class="keyword">if</span> <span class="built_in">type</span>(x) <span class="keyword">is</span> <span class="built_in">list</span> <span class="keyword">else</span> [x]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flatten(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<h2 id="快速查找list的若干最值"><a href="#快速查找list的若干最值" class="headerlink" title="快速查找list的若干最值"></a>快速查找list的若干最值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> heapq, random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [random.randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> __ <span class="keyword">in</span> xrange(<span class="number">100</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.nsmallest(<span class="number">5</span>, a)</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>]             <span class="comment"># a中最小的5个数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.nlargest(<span class="number">5</span>, a)</span><br><span class="line">[<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">98</span>, <span class="number">95</span>]      <span class="comment"># a中最大的5个数</span></span><br></pre></td></tr></table></figure>

<h2 id="dict和list互换"><a href="#dict和list互换" class="headerlink" title="dict和list互换"></a>dict和list互换</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dict-&gt;list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.keys()</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.values()</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.items()</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># list-&gt;dict</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l=[(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(l)</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>names = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]; scores = [<span class="number">95</span>, <span class="number">75</span>, <span class="number">85</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">zip</span>(names, scores)</span><br><span class="line">[(<span class="string">&#x27;Michael&#x27;</span>, <span class="number">95</span>), (<span class="string">&#x27;Bob&#x27;</span>, <span class="number">75</span>), (<span class="string">&#x27;Tracy&#x27;</span>, <span class="number">85</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(<span class="built_in">zip</span>(names, scores))</span><br><span class="line">&#123;<span class="string">&#x27;Bob&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dict内key和value互换"><a href="#dict内key和value互换" class="headerlink" title="dict内key和value互换"></a>dict内key和value互换</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># using zip</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">zip</span>(m.values(), m.keys())</span><br><span class="line">[(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;d&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(<span class="built_in">zip</span>(m.values(), m.keys()))</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;c&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># using a dictionary comprehension</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.items()</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> m.items()&#125;</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;c&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速生成规律性字典"><a href="#快速生成规律性字典" class="headerlink" title="快速生成规律性字典"></a>快速生成规律性字典</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x: x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)&#125;</span><br><span class="line">&#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="number">3</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x: <span class="string">&#x27;A&#x27;</span> + <span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;</span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;A0&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;A1&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;A2&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;A3&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;A4&#x27;</span>, <span class="number">5</span>: <span class="string">&#x27;A5&#x27;</span>, <span class="number">6</span>: <span class="string">&#x27;A6&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;A7&#x27;</span>, <span class="number">8</span>: <span class="string">&#x27;A8&#x27;</span>, <span class="number">9</span>: <span class="string">&#x27;A9&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串与列表字典的互换"><a href="#字符串与列表字典的互换" class="headerlink" title="字符串与列表字典的互换"></a>字符串与列表字典的互换</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串-&gt;列表 (去掉引号)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&quot;[1,2,3]&quot;</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 如果输入数据不安全, 使用ast.literal_eval(), eval的替代品, 更安全</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串-&gt;字典 (去掉引号)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&quot;&#123;&#x27;one&#x27;:1, &#x27;two&#x27;:2&#125;&quot;</span>)</span><br><span class="line">&#123;<span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment"># 如果输入数据不安全, 使用ast.literal_eval(), eval的替代品, 更安全</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串-&gt;列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst = <span class="built_in">list</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表-&gt;字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#x27;</span>.join(lst)</span><br><span class="line"><span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串-&gt;列表 (指定分隔符, 如空格, 逗号)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>season = <span class="string">&#x27;spring, summer, autumn, winter&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>season.split (<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;spring&#x27;</span>, <span class="string">&#x27; summer&#x27;</span>, <span class="string">&#x27; autumn&#x27;</span>, <span class="string">&#x27; winter&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表-&gt;字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="string">&quot;spring&quot;</span>, <span class="string">&quot;summer&quot;</span>, <span class="string">&quot;autumn&quot;</span>, <span class="string">&quot;winter&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;, &#x27;</span>.join(lst)</span><br><span class="line"><span class="string">&#x27;spring, summer, autumn, winter&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 整数列表-&gt;字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(e) <span class="keyword">for</span> e <span class="keyword">in</span> lst)</span><br><span class="line"><span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure>



<h1 id="参考和资料"><a href="#参考和资料" class="headerlink" title="参考和资料"></a>参考和资料</h1><ul>
<li><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001411031239400f7181f65f33a4623bc42276a605debf6000">廖雪峰的官方网站之python教程</a></li>
<li><a href="http://sahandsaba.com/thirty-python-language-features-and-tricks-you-may-not-know.html">30 Python Language Features and Tricks You May Not Know About</a></li>
<li><a href="http://codingpy.com/article/the-idiomatic-way-to-merge-dicts-in-python/">怎样合并字典最符合Python语言习惯？</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>list</tag>
        <tag>dict</tag>
        <tag>tuple</tag>
        <tag>set</tag>
        <tag>collections</tag>
      </tags>
  </entry>
  <entry>
    <title>Embedded Linux 入门有感</title>
    <url>/2017/01/18/1702-linux-hard/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Embedded Linux 是自我学习过程中, 走的最不顺的一条路.<br>而学习android和python时, 基本自学一个月左右, 就能开始独立做项目了.<br>应该说, Embedded Linux的入门确实比较困难一点.</p>
<p>自己是从底层往上走的, 系统的学过硬件, 嵌入式, 操作系统,<br>但在没有具体项目要求的情况下, 学习Embedded Linux的过程充满了痛苦和不解, 始终没有坚持下来.</p>
<p>如今, 打算再次开始系统的学习Embedded Linux, 因而在此记录一下之前的学习感受, 分析一下困难之所在, 并制定好学习规则和方式.</p>
<h1 id="为何困难"><a href="#为何困难" class="headerlink" title="为何困难"></a>为何困难</h1><h2 id="linux上手困难"><a href="#linux上手困难" class="headerlink" title="linux上手困难"></a>linux上手困难</h2><p>对新手而言, linux的学习曲线很陡峭. 相信刚上手的话, 如何安装软件, 如何使用编辑器都是问题!</p>
<p>一个, 二个问题或者一层二层问题, 还能较为容易的解决. 但面对蜂拥而至的疑问和困惑, 能坚持下去就很不容易了, 何况途中还充满了陷阱和争论.</p>
<p>随便举几个例子:</p>
<ol>
<li><p>用哪个版本的linux好? Ubuntu? Feroda? Redhat? CentOS? 服务器版? 桌面版? 然后图形界面居然还分 KDE/Gnome…<br>为了弄清上面这个问题, 看看文章, 翻翻论坛, 结果就是更迷糊了… 甚至忘了初衷是要奔着 <code>Embedded Linux</code> 去的啊!</p>
</li>
<li><p>我的硬盘分区呢? 去哪里找文件呢? 文件权限的概念等等. (linux下一切皆文件!)</p>
</li>
<li><p>用哪个文本编辑器好? 大家都会说Vim, 然后和vim斗就能斗你一个月, 结果还是自己败下阵来, 回归熟悉的文本编辑器!</p>
</li>
<li><p><code>bash shell</code> 是精华啊, 不能不学! 得, 捧着鸟哥的私房菜, 随便翻翻也得几星期才知道个大概吧…<br>(学习指令时, 需要有<code>工作路径</code>这么一个概念. 知道这个指令现在在哪里工作, 是非常重要的一个概念!)</p>
</li>
<li><p>唉呀妈呀, 好不容易装好了虚拟机, 装好了精挑细选的linux版本. 尝试装软件了! 一阵搜索, 还算顺利. 突然出了个依赖关系错误…<br>耐着性子google, 百度, 似乎略微看懂了一二, 就是在装这个软件之前, 需要另外一个软件的特定版本么.<br>尝试用安装指令装另外一个软件, 居然这个软件不存在了!!! 继续? 还是放弃?<br>我继续过, 翻墙, 找到软件源码. 还要自己编译? 编译还要装编译软件… 彻底放弃…</p>
</li>
</ol>
<h2 id="缺乏合适的入门书籍"><a href="#缺乏合适的入门书籍" class="headerlink" title="缺乏合适的入门书籍"></a>缺乏合适的入门书籍</h2><p>市面上大多数的Embedded Linux入门教程只讲应该如何做, 不说基础知识, 不讲前因后果.<br>读起来枯燥无味, 索然无趣. 学起来一头雾水, 不知其所以然.</p>
<p>譬如很多教程会详细的写出, 第一步, 第二步, 第三步… 但经常的, 只要系统环境稍微变化一点点(如linux版本不同, 软件版本不同), 上述的步骤就会失效.<br>喜欢刨根问底的我就开始纠结这些第一步, 第二步, 第三步到底再干吗? 为什么按照自己的理解在新的环境下就不工作了?<br>而遇到这些具体的困难时, 如何解决困难真的是一头雾水. 教程书籍类基本不会讲你可能遇到的问题! 基本只能到网络上去找解决办法…然后就是进一步的困惑…</p>
<p>而更专业的书籍根本不适合入门者去阅读, 那都是对特定领域进行深入分析学习的! 过早的接触自己完全不懂的东西, 只会打击学习的积极性.<br>譬如推崇度很高的鸟哥的私房菜, 实际是一本很好的运维方面的书籍, 用它来初学<code>bash shell</code>就太重了.<br>可以看一下鸟哥自己的经历, 就能明白了 <a href="http://linux.vbird.org/new_linux.php">Linux 的學習曲線，一個老人家的建議！</a><br>体验最深的就是这句了: <strong>只要一出现问题, 自己完全无法解决时, 只好重新安装, 选择设定与书本教的内容完全一模一样, 不过即使如此, 很多时候仍然会遇到问题</strong></p>
<p>因此, 建议自己通过网络和书籍总结归纳一下最基本的指令和用法, 加之自己的理解, 做成笔记. 一来帮助记忆, 二来便于日后查阅.<br>但不用刻意的去背这些东西, 要用的时候知道去哪里查阅就可以了, 用多了既然就记住了.<br>在真正深入学习后, 觉得有需要自然会更有针对性的选择专业书籍来看!</p>
<p>这样, 才能避免淹死在知识的海洋里!</p>
<h2 id="缺乏硬性目标"><a href="#缺乏硬性目标" class="headerlink" title="缺乏硬性目标:"></a>缺乏硬性目标:</h2><p>之前都是跟着教程的自学, 属于漫无目的的囫囵吞枣, 学到哪忘到哪.<br>然后, <strong>缺乏硬性目标最大的问题就是: 容易放弃!</strong><br>因为遇到的困难太多了, 在没有硬性目标的情况下, 不断的打击最终导致的就是放弃!</p>
<p>如果能定一个最终目标, 譬如基于开发板做一款视频识别系统, 那在学习过程中就会有侧重点.<br>这样对问题的处理就能起到抓大放小, 不纠结于所有的细节. 在解决实际问题的过程中, 逐步深入学习linux.</p>
<h1 id="解决之道"><a href="#解决之道" class="headerlink" title="解决之道"></a>解决之道</h1><p>个人认为, 学习linux, embedded linux的终极解决之道就是定下一个<strong>硬性目标</strong>, 有这么一个压力在的话, 在学习过程中不断试错, 一知半解都不是问题!</p>
<p>正所谓有压力才有动力! 回到鸟哥的个人经历, 见<a href="http://linux.vbird.org/new_linux.php">Linux 的學習曲線，一個老人家的建議！</a>.<br>正是有项目压力的情况下, 才能忍受无数次的重装系统, 才能忍无可忍痛下决心系统的学习linux(此时已经不是初学者了, 知道了很多基础, 也知道自己想解决什么问题!)<br>在此压力下, 搭建环境的过程就不会过于纠结我到底在干吗? 为什么要这么做?的困惑; 使用编辑器时, 也会直接挑个最顺手的用着再说; shell的使用也会因为时间压力只学最基本的.</p>
<p>初期, 在一定要完成这个硬性目标, 在不求甚解, 能用就好的心态下, 至少能帮助自己摸一遍linux, 知道一个大概的流程和遇到的问题.<br>这样也能很大程度上避免自己陷入到底用哪个linux版本好, 用哪个桌面系统好, 用哪种编辑好的争论中! 在不知道具体需求的情况下, 这些都是无意义之事!<br>这个时期, 坚持学下来, 用下来, 就是胜利! 工具的选择上, 顺手的, 上手快的就是好的!</p>
<p>然后, 在完成一二个项目后, 虽然心中的疑惑越积越多, 但潜移默化中, 已经对linux有了相当程度的理解, 常用指令也都会用了!<br>此时, 再根据自己的具体疑惑去查阅更专业的书籍, 更系统的学习, 其效果会远好于上来就拿着本专业书籍看!</p>
<h1 id="自我要求"><a href="#自我要求" class="headerlink" title="自我要求"></a>自我要求</h1><p>我目前的情况也不能算linux初学者, 但也确实没有在embedded linux下开发的经验.<br>自己的感觉是, 虽然对某些方面还一知半解, 但背景知识的储备已经够了, 是时候定个小目标, 完成系统的学习了!<br>毕业已10年, 我学习linux的初学期和倦怠期也着实太长了一点… 好在, 任何时候开始都不晚么.</p>
<p>陆续了解过的背景知识有: linux基础概念, ubuntu的基础使用, bash shell, 硬件原理图, 嵌入式C开发, 操作系统原理, 阅读linux0.11源码.<br>总的来说, 感觉自己就差临门一脚… 能坚持做一二个项目后, 自己就有能力做嵌入式linux开发了.</p>
<ul>
<li>定个小目标: 跟着教程, 在2440开发板上, 完成音视频对讲功能. 细分为实现摄像头功能, 搭建服务器, 实现可视对讲功能.</li>
<li>开发环境搭建: 最困难的就是环境搭建, 走了很多弯路, 不过目前已经走通了.</li>
<li>不求甚解: 学习过程中, 注意连续性, 有些专业知识先不求甚解, 有个基础概念, 简单做下笔记即可. 如makefile的书写, 编译器原理等等.</li>
<li>勤做笔记: 好记性不如烂笔头. 我相信即便linux高度使用者, 能记住的也就几条常用指令. 自己做好笔记就便于日后查阅, 做笔记的同时也加深了印象!</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Unix/Linux 命令参考</title>
    <url>/2017/01/19/1703-linux-command/</url>
    <content><![CDATA[<p><em><strong>转载自 <a href="https://linuxtoy.org/pages/download.html">Unix/Linux 命令速查表</a></strong></em></p>
<hr>
<h1 id="搜索指令-find-grep"><a href="#搜索指令-find-grep" class="headerlink" title="搜索指令 find grep"></a>搜索指令 <code>find</code> <code>grep</code></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find -name april*                   <span class="comment"># 当前目录下查找以april开始的文件</span></span><br><span class="line">find -iname april*                  <span class="comment"># 忽略大小写</span></span><br><span class="line">find /home -size +512k              <span class="comment"># 查大于512k的文件</span></span><br><span class="line">find /home -size -512k              <span class="comment"># 查小于512k的文件</span></span><br><span class="line">find /home -links +2                <span class="comment"># 查硬连接数大于2的文件或目录</span></span><br><span class="line">find /home -perm 0700               <span class="comment"># 查权限为700的文件或目录</span></span><br><span class="line"></span><br><span class="line">find -name tom.txt -user kim        <span class="comment"># 查找名称为tom.txt且用户为kim的文件</span></span><br><span class="line">find -name ap* -or -name may*       <span class="comment"># 查找以ap或may开头的文件</span></span><br><span class="line">find -name wa* -not -<span class="built_in">type</span> l         <span class="comment"># 查找名为wa开头且类型不为符号链接的文件</span></span><br><span class="line">find -name wa* ! -<span class="built_in">type</span> l            <span class="comment"># 查找名为wa开头且类型不为符号链接的文件</span></span><br><span class="line"><span class="comment"># 对于 -type, 有 b=block, d=dictory, c=character, p=pipe, l=link, f=file</span></span><br><span class="line"></span><br><span class="line">find / -iname <span class="string">&quot;MyCProgram.c&quot;</span> -<span class="built_in">exec</span> md5sum &#123;&#125; \; <span class="comment"># 对所有找到的文件进行MD5验证</span></span><br><span class="line">find / -name filename -ok rm -rf &#123;&#125; \;          <span class="comment"># 确认删除找到的文件</span></span><br><span class="line">find . -mtime +3 | xargs rm -rf                 <span class="comment"># 删除3天以前的文件</span></span><br><span class="line">find . -size +3000k -<span class="built_in">exec</span> ls -ld &#123;&#125; \;          <span class="comment"># 查找大于3M的文件</span></span><br><span class="line">find . -size -3000k | xargs <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt;./file.log <span class="comment"># 查找小于3M的文件并写入file.log</span></span><br><span class="line">find . -<span class="built_in">type</span> f | xargs grep <span class="string">&quot;hostname&quot;</span>          <span class="comment"># 在普通文件中搜索hostname这个词</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -l | grep <span class="string">&#x27;^a&#x27;</span>                   <span class="comment"># 只显示以a开头的文件名。</span></span><br><span class="line">grep <span class="string">&#x27;test&#x27;</span> d*                      <span class="comment"># 显示所有以d开头的文件中包含test的行。</span></span><br><span class="line">grep <span class="string">&#x27;test&#x27;</span> aa bb cc                <span class="comment"># 显示在aa，bb，cc文件中匹配test的行。</span></span><br><span class="line">grep -i pattern files               <span class="comment"># 不区分大小写地搜索。默认情况区分大小写</span></span><br><span class="line">grep -l pattern files               <span class="comment"># 只列出匹配的文件名，</span></span><br><span class="line">grep -L pattern files               <span class="comment"># 列出不匹配的文件名，</span></span><br><span class="line">grep -w pattern files               <span class="comment"># 只匹配整个单词(如匹配‘magic’，而不是‘magical’)</span></span><br><span class="line">grep -C number pattern files        <span class="comment"># 匹配的上下文分别显示[number]行，</span></span><br><span class="line">grep pattern1 | pattern2 files      <span class="comment"># 显示匹配 pattern1 或 pattern2 的行，</span></span><br><span class="line">grep pattern1 files | grep pattern2 <span class="comment"># 显示既匹配 pattern1 又匹配 pattern2的行</span></span><br></pre></td></tr></table></figure>

<h1 id="常用命令表"><a href="#常用命令表" class="headerlink" title="常用命令表"></a>常用命令表</h1><table>
<thead>
<tr>
<th>文件命令</th>
<th>指令说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ls</code></td>
<td>列出目录</td>
</tr>
<tr>
<td><code>ls -al</code></td>
<td>使用格式化列出隐藏文件</td>
</tr>
<tr>
<td><code>cd dir</code></td>
<td>更改目录到 dir</td>
</tr>
<tr>
<td><code>cd</code></td>
<td>更改到 home 目录</td>
</tr>
<tr>
<td><code>pwd</code></td>
<td>显示当前目录</td>
</tr>
<tr>
<td><code>mkdir dir</code></td>
<td>创建目录 dir</td>
</tr>
<tr>
<td><code>rm file</code></td>
<td>删除 file</td>
</tr>
<tr>
<td><code>rm -r dir</code></td>
<td>删除目录 dir</td>
</tr>
<tr>
<td><code>rm -f file</code></td>
<td>强制删除 file</td>
</tr>
<tr>
<td><code>rm -rf dir</code></td>
<td>强制删除整个目录 dir (小心使用)</td>
</tr>
<tr>
<td><code>cp file1 file2</code></td>
<td>将 file1 复制到 file2</td>
</tr>
<tr>
<td><code>cp -r dir1 dir2</code></td>
<td>将 dir1 复制到 dir2; 如果 dir2 不存在则创建它</td>
</tr>
<tr>
<td><code>mv file1 file2</code></td>
<td>将 file1 重命名或移动到 file2;</td>
</tr>
<tr>
<td><code>ln -s file link</code></td>
<td>创建 file 的符号连接 link</td>
</tr>
<tr>
<td><code>touch file</code></td>
<td>创建 file</td>
</tr>
<tr>
<td><code>cat &gt; file</code></td>
<td>将标准输入添加到 file</td>
</tr>
<tr>
<td><code>more file</code></td>
<td>查看 file 的内容</td>
</tr>
<tr>
<td><code>head file</code></td>
<td>查看 file 的前 10 行</td>
</tr>
<tr>
<td><code>tail file</code></td>
<td>查看 file 的后 10 行</td>
</tr>
<tr>
<td><code>tail -f file</code></td>
<td>从后 10 行开始查看 file 的内容</td>
</tr>
<tr>
<td><strong>进程管理</strong></td>
<td><strong>指令说明</strong></td>
</tr>
<tr>
<td><code>ps</code></td>
<td>显示当前的活动进程</td>
</tr>
<tr>
<td><code>top</code></td>
<td>显示所有正在运行的进程</td>
</tr>
<tr>
<td><code>kill pid</code></td>
<td>杀掉进程 id pid</td>
</tr>
<tr>
<td><code>killall proc</code></td>
<td>杀掉所有名为 proc 的进程 (小心使用)</td>
</tr>
<tr>
<td><code>bg</code></td>
<td>列出已停止或后台的作业</td>
</tr>
<tr>
<td><code>fg</code></td>
<td>将最近的作业带到前台</td>
</tr>
<tr>
<td><code>fg n</code></td>
<td>将作业 n 带到前台</td>
</tr>
<tr>
<td><strong>文件权限</strong></td>
<td><strong>指令说明</strong></td>
</tr>
<tr>
<td><code>chmod rwxrwxrwx file</code></td>
<td>更改 file 的权限</td>
</tr>
<tr>
<td><code>chmod 777</code></td>
<td>为所有用户添加 rwx 权限</td>
</tr>
<tr>
<td><code>chmod 755</code></td>
<td>为所有者添加 rwx 权限, 为组和其他用户添加 rx 权限</td>
</tr>
<tr>
<td><strong>SSH</strong></td>
<td><strong>指令说明</strong></td>
</tr>
<tr>
<td><code>ssh user@host</code></td>
<td>以 user 用户身份连接到 host</td>
</tr>
<tr>
<td><code>ssh -p port user@host</code></td>
<td>在端口 port 以 user 用户身份连接到 host</td>
</tr>
<tr>
<td><code>ssh-copy-id user@host</code></td>
<td>将密钥添加到 host 以实现无密码登录</td>
</tr>
<tr>
<td><strong>系统信息</strong></td>
<td><strong>指令说明</strong></td>
</tr>
<tr>
<td><code>date</code></td>
<td>显示当前日期和时间</td>
</tr>
<tr>
<td><code>cal</code></td>
<td>显示当月的日历</td>
</tr>
<tr>
<td><code>uptime</code></td>
<td>显示系统从开机到现在所运行的时间</td>
</tr>
<tr>
<td><code>w</code></td>
<td>显示登录的用户</td>
</tr>
<tr>
<td><code>whoami</code></td>
<td>查看你的当前用户名</td>
</tr>
<tr>
<td><code>finger user</code></td>
<td>显示 user 的相关信息</td>
</tr>
<tr>
<td><code>uname -a</code></td>
<td>显示内核信息</td>
</tr>
<tr>
<td><code>cat /proc/cpuinfo</code></td>
<td>查看 cpu 信息</td>
</tr>
<tr>
<td><code>cat /proc/meminfo</code></td>
<td>查看内存信息</td>
</tr>
<tr>
<td><code>man command</code></td>
<td>显示 command 的说明手册</td>
</tr>
<tr>
<td><code>df</code></td>
<td>显示磁盘占用情况</td>
</tr>
<tr>
<td><code>du</code></td>
<td>显示目录空间占用情况</td>
</tr>
<tr>
<td><code>free</code></td>
<td>显示内存及交换区占用情况</td>
</tr>
<tr>
<td><strong>压缩</strong></td>
<td><strong>指令说明</strong></td>
</tr>
<tr>
<td><code>tar cf file.tar files</code></td>
<td>创建包含 files 的 tar 文件 file.tar</td>
</tr>
<tr>
<td><code>tar xf file.tar</code></td>
<td>从 file.tar 提取文件</td>
</tr>
<tr>
<td><code>tar czf file.tar.gz files</code></td>
<td>使用 Gzip 压缩创建 tar 文件</td>
</tr>
<tr>
<td><code>tar xzf file.tar.gz</code></td>
<td>使用 Gzip 提取 tar 文件</td>
</tr>
<tr>
<td><code>tar cjf file.tar.bz2</code></td>
<td>使用 Bzip2 压缩创建 tar 文件</td>
</tr>
<tr>
<td><code>tar xjf file.tar.bz2</code></td>
<td>使用 Bzip2 提取 tar 文件</td>
</tr>
<tr>
<td><code>gzip file</code></td>
<td>压缩 file 并重命名为 file.gz</td>
</tr>
<tr>
<td><code>gzip -d file.gz</code></td>
<td>将 file.gz 解压缩为 file</td>
</tr>
<tr>
<td><strong>网络</strong></td>
<td><strong>指令说明</strong></td>
</tr>
<tr>
<td><code>ping host</code></td>
<td>ping host 并输出结果</td>
</tr>
<tr>
<td><code>whois domain</code></td>
<td>获取 domain 的 whois 信息</td>
</tr>
<tr>
<td><code>dig domain</code></td>
<td>获取 domain 的 DNS 信息</td>
</tr>
<tr>
<td><code>dig -x host</code></td>
<td>逆向查询 host</td>
</tr>
<tr>
<td><code>wget file</code></td>
<td>下载 file</td>
</tr>
<tr>
<td><code>wget -c file</code></td>
<td>断点续传</td>
</tr>
<tr>
<td><strong>安装</strong></td>
<td><strong>指令说明</strong></td>
</tr>
<tr>
<td><code>./configure</code> <code>make</code> <code>make install</code></td>
<td>从源码安装</td>
</tr>
<tr>
<td><code>dpkg -i pkg.deb</code></td>
<td>安装包 (Debian)</td>
</tr>
<tr>
<td><code>rpm -Uvh pkg.rpm</code></td>
<td>安装包 (RPM)</td>
</tr>
<tr>
<td><code>yum install package</code></td>
<td>安装包 (CentOS)</td>
</tr>
<tr>
<td><code>sudo apt-get install package</code></td>
<td>安装包 (Ubuntu)</td>
</tr>
<tr>
<td><strong>快捷键</strong></td>
<td><strong>指令说明</strong></td>
</tr>
<tr>
<td><code>Ctrl+C</code></td>
<td>停止当前命令</td>
</tr>
<tr>
<td><code>Ctrl+Z</code></td>
<td>停止当前命令，并使用 fg 恢复</td>
</tr>
<tr>
<td><code>Ctrl+D</code></td>
<td>注销当前会话，与 exit 相似</td>
</tr>
<tr>
<td><code>Ctrl+W</code></td>
<td>删除当前行中的字</td>
</tr>
<tr>
<td><code>Ctrl+U</code></td>
<td>删除整行</td>
</tr>
<tr>
<td><code>!!</code></td>
<td>重复上次的命令</td>
</tr>
<tr>
<td><code>exit</code></td>
<td>注销当前会话</td>
</tr>
</tbody></table>
<hr>
<p><em><strong>转载自 <a href="https://linuxtoy.org/pages/download.html">Unix/Linux 命令速查表</a></strong></em></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>cheat sheet</tag>
        <tag>linux</tag>
        <tag>embedded</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 0.11 源码阅读笔记-总览</title>
    <url>/2017/01/23/1704-linux-source/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/01/23/1704-linux-source/">Linux 0.11 源码阅读笔记-总览</a></li>
<li><a href="https://draapho.github.io/2017/01/26/1704-linux-source1/">Linux 0.11 源码阅读笔记-内存的基础概念</a></li>
<li><a href="https://draapho.github.io/2017/01/28/1704-linux-source2/">Linux 0.11 源码阅读笔记-启动程序</a></li>
<li><a href="https://draapho.github.io/2017/01/31/1704-linux-source3/">Linux 0.11 源码阅读笔记-内核代码</a></li>
<li><a href="https://draapho.github.io/2017/02/01/1704-linux-source4/">Linux 0.11 源码阅读笔记-设备驱动程序</a></li>
<li><a href="https://draapho.github.io/2017/02/13/1704-linux-source5/">Linux 0.11 源码阅读笔记-文件系统</a></li>
<li><a href="https://draapho.github.io/2017/02/15/1704-linux-source6/">Linux 0.11 源码阅读笔记-内存管理</a></li>
</ul>
<h2 id="Linux-发展背景"><a href="#Linux-发展背景" class="headerlink" title="Linux 发展背景"></a>Linux 发展背景</h2><p>Linux操作系统的诞生(1991年),发展和成长过程依赖于以下五个重要支柱</p>
<ol>
<li>UNIX操作系统 (诞生于1969年, 版权和专利问题不断, 大公司不愿公开操作系统原理和源码)</li>
<li>MINIX操作系统 (诞生于1987年, 意为 Mini UNIX. 教学使用是开源免费的! linus从中学习了操作系统的工作原理)</li>
<li>GNU计划 (诞生于1984年, 意为 GNU’s Not Unix 递归缩写. 宗旨是开发一个类Unix的自由软件操作系统)<br>有名的免费软件有: emacs, bash shell, gcc 编译程序, gdb 调试程序<br>因此, 目前许多人将Linux操作系统称之为 <a href="http://www.gnu.org/gnu/gnu-linux-faq.html#why">GNU/Linux 操作系统</a>.</li>
<li>POSIX标准 (V1诞生于1988年, Portable Operating System Interface for Computing Systems)<br>描述了操作系统的调用服务接口标准, 便于应用程序在不同操作系统上的移植.<br>这为linux系统对应用程序的兼容提供了一套标准. 也是linux能流行起来的基础条件之一.</li>
<li>Internet网络 (确保了linux系统由众人开发维护, 其发展和推广都离不开Internet!)</li>
</ol>
<h2 id="Linux-GNU-POSIX-的关系"><a href="#Linux-GNU-POSIX-的关系" class="headerlink" title="Linux, GNU, POSIX 的关系"></a>Linux, GNU, POSIX 的关系</h2><p><img src="https://draapho.github.io/images/1704/0-Linux_kernel_System_Call_Interface_and_glibc.png" alt="Linux_kernel_System_Call_Interface_and_glibc"></p>
<h2 id="内核代码框图"><a href="#内核代码框图" class="headerlink" title="内核代码框图"></a>内核代码框图</h2><p><img src="https://draapho.github.io/images/1704/0-kernal-struct.png" alt="kernal-struct"></p>
<h2 id="内核函数关系图"><a href="#内核函数关系图" class="headerlink" title="内核函数关系图"></a>内核函数关系图</h2><p><img src="https://draapho.github.io/images/1704/0-linux-kernal-map.png" alt="kernal-fucntion"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://oldlinux.org/download/linux-devel.pdf">Linux 诞生和发展的五个重要支柱 - 赵炯</a></li>
<li><a href="http://www.gnu.org/gnu/gnu-linux-faq.html#why">GNU Operating System</a>.)</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 0.11 源码阅读笔记-内存的基础概念</title>
    <url>/2017/01/26/1704-linux-source1/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/01/23/1704-linux-source/">Linux 0.11 源码阅读笔记-总览</a></li>
<li><a href="https://draapho.github.io/2017/01/26/1704-linux-source1/">Linux 0.11 源码阅读笔记-内存的基础概念</a></li>
<li><a href="https://draapho.github.io/2017/01/28/1704-linux-source2/">Linux 0.11 源码阅读笔记-启动程序</a></li>
<li><a href="https://draapho.github.io/2017/01/31/1704-linux-source3/">Linux 0.11 源码阅读笔记-内核代码</a></li>
<li><a href="https://draapho.github.io/2017/02/01/1704-linux-source4/">Linux 0.11 源码阅读笔记-设备驱动程序</a></li>
<li><a href="https://draapho.github.io/2017/02/13/1704-linux-source5/">Linux 0.11 源码阅读笔记-文件系统</a></li>
<li><a href="https://draapho.github.io/2017/02/15/1704-linux-source6/">Linux 0.11 源码阅读笔记-内存管理</a></li>
</ul>
<h1 id="Linux-内存的基础概念"><a href="#Linux-内存的基础概念" class="headerlink" title="Linux 内存的基础概念"></a>Linux 内存的基础概念</h1><h2 id="内存条的分配"><a href="#内存条的分配" class="headerlink" title="内存条的分配"></a>内存条的分配</h2><p><em>Linux0.11 对物理内存条的分配</em><br><img src="https://draapho.github.io/images/1704/1-memory.jpg" alt="memory"></p>
<ul>
<li><code>内核模块</code>, Linux Kernel的代码</li>
<li><code>高速缓冲 Buffer</code>, 缓存内核对硬盘的读写操作. 仅部分内核函数可用</li>
<li><code>主内存 Memory</code>, 应用程序可用的内存区. 虚拟内存也是针对这一块区域而言的.</li>
</ul>
<h2 id="内存的几个概念"><a href="#内存的几个概念" class="headerlink" title="内存的几个概念"></a>内存的几个概念</h2><ul>
<li>Virtual Memory<br>linux 0.11内核中, 每个程序都划分了总容量为64Mb的虚拟内存空间</li>
<li>Logical Address<br>程序在虚拟内存空间的偏移量就是逻辑地址, 范围是0x0000000-0x4000000</li>
<li>Linear Address<br>在内存分段机制中, 把相应的段基址加上逻辑地址就是线性地址. 若没有开启分页功能, 直接就是物理地址.<br>分段机制虽然保证了程序内存的相互隔离, 但是对内存的使用效率是非常低的!<br>80x86 实时模式下, 寻址采用的是段和偏移值. 无分页机制.<br>80x86 保护模式下, 会启用分页机制, 需要使用描述表(Descriptor Table)</li>
<li>Physical Address<br>真正的内存物理地址, 从逻辑地址到物理地址, 需要经过分段和分页两次转换.</li>
<li>分段机制<ul>
<li>相关概念有, GDT(全局描述符表), LDT(局部描述符表)</li>
<li>Linux基本忽略了分段机制, 通过”欺骗”, 使得逻辑地址与线性地址是一致的! (用GDT, 基地址为0)</li>
</ul>
</li>
<li>分页机制<ul>
<li>相关概念有 Page Directory(页目录), Page Table(页表)</li>
<li>新版的linux, 为了提高兼容性, 直接采用了4级分页机制:</li>
<li>页全局目录, Page Global Directory, 对应80x86的 Page Directory</li>
<li>页上级目录, Page Upper Directory,  长度设为0即可</li>
<li>页中间目录, Page Middle Directory, 长度设为0即可</li>
<li>页表, Page Table, 对应80x86的 Page Table</li>
</ul>
</li>
<li>任务状态段<ul>
<li>TSS (Task State Segment)</li>
<li>TSS包含了所有硬件切换任务时, 需要保存的寄存器信息.</li>
<li>TSS存放于GDT内</li>
</ul>
</li>
</ul>
<h2 id="内存地址的转换"><a href="#内存地址的转换" class="headerlink" title="内存地址的转换"></a>内存地址的转换</h2><p><em>从逻辑地址变换为物理地址的过程</em><br><img src="https://draapho.github.io/images/1704/1-address-convert.jpg" alt="address-convert"></p>
<p><em>从逻辑地址变化为物理地址的框图</em><br><img src="https://draapho.github.io/images/1704/1-address-convert-detail.jpg" alt="address-convert-detail"></p>
<p><em>逻辑地址转换为线性地址的过程</em><br><img src="https://draapho.github.io/images/1704/1-logical2linear.jpg" alt="logical2linear"></p>
<p><em>线性地址(页目录项, 页表项)在内存中位置</em><br><img src="https://draapho.github.io/images/1704/1-linear2physical.jpg" alt="linear2physical"></p>
<p><em>页目录(Page Directory), 页表(Page Table)和物理内存的关系图</em><br><img src="https://draapho.github.io/images/1704/1-address-pdpt.jpg" alt="address-pdpt"></p>
<p><em>进程代码和数据在其逻辑地址空间中的分布 (在物理地址中的分布是随机)</em><br><img src="https://draapho.github.io/images/1704/1-code-address.jpg" alt="code-address"></p>
<p><em>linux 使用描述符表的示意图</em><br><img src="https://draapho.github.io/images/1704/1-gdt-ldt-memory.jpg" alt="gdt-ldt-memory"></p>
<p><em>任务1在三种地址空间中的关系</em><br><img src="https://draapho.github.io/images/1704/1-address-relationship.jpg" alt="address-relationship"></p>
<h2 id="80x86-多任务"><a href="#80x86-多任务" class="headerlink" title="80x86 多任务"></a>80x86 多任务</h2><ul>
<li>Intel 80x86分为4个保护级别, Linux 0.11只使用了0和3两个保护级别.</li>
<li>0为最高优先级, 对应于Linux内核态</li>
<li>3为最低优先级, 对应于Linux用户态</li>
<li>这样划分主要是为了安全考虑进行的系统级别的隔离.</li>
<li>用户态无权直接使用硬件资源, 必须通过调用内核函数.</li>
<li>多任务间, 内存是完全隔离的, 因此任务之间不会相互影响.</li>
</ul>
<p><em>linux 的多任务及保护方式</em><br><img src="https://draapho.github.io/images/1704/1-mulit-process.jpg" alt="mulit-process"></p>
<p><em>linux 任务切换操作示意图</em><br><img src="https://draapho.github.io/images/1704/1-switch-process.jpg" alt="switch-process"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://oldlinux.org/download/clk011c-3.0-toc.pdf">Linux 内核完全注释 内核版本0.11 - 赵炯</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 0.11 源码阅读笔记-启动程序</title>
    <url>/2017/01/28/1704-linux-source2/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/01/23/1704-linux-source/">Linux 0.11 源码阅读笔记-总览</a></li>
<li><a href="https://draapho.github.io/2017/01/26/1704-linux-source1/">Linux 0.11 源码阅读笔记-内存的基础概念</a></li>
<li><a href="https://draapho.github.io/2017/01/28/1704-linux-source2/">Linux 0.11 源码阅读笔记-启动程序</a></li>
<li><a href="https://draapho.github.io/2017/01/31/1704-linux-source3/">Linux 0.11 源码阅读笔记-内核代码</a></li>
<li><a href="https://draapho.github.io/2017/02/01/1704-linux-source4/">Linux 0.11 源码阅读笔记-设备驱动程序</a></li>
<li><a href="https://draapho.github.io/2017/02/13/1704-linux-source5/">Linux 0.11 源码阅读笔记-文件系统</a></li>
<li><a href="https://draapho.github.io/2017/02/15/1704-linux-source6/">Linux 0.11 源码阅读笔记-内存管理</a></li>
</ul>
<h1 id="启动程序-boot"><a href="#启动程序-boot" class="headerlink" title="启动程序 boot"></a>启动程序 boot</h1><p><em>启动引导时内核在内存中的位置和移动情况</em><br><img src="https://draapho.github.io/images/1704/2-bios-boot.jpg" alt="bios-boot"></p>
<ol>
<li>80x86结构的CPU开机后, 从0xFFFF0开始自动执行代码, 通常是 ROM-BIOS中的地址.<br>BIOS在内存地址0处初始化中断向量, 然后将可启动设备的第一个扇区(磁盘引导扇区, 512字节)读入内存地址0x7C00处.</li>
<li>bootsect.s 被BIOS读入到内存地址 0x7C00(31Kb) 处开始运行后, 立刻把自己移到 0x90000(576Kb) 处.</li>
<li>接着, bootsect.s 把 setup.s 读入到 0x90200 处, system模块(即内核)读入到 0x10000 处.<ul>
<li>此版本内核模块不会超过 0x80000, 即512K大小, 因此不会覆盖掉0x90000处的内容</li>
<li>setup.s 需要一些 ROM BIOS 保留下来的一些系统参数(如显卡模式, 硬盘参数等), 这些参数被BIOS放在内存起始处, 大小为1Kb.</li>
<li>因而 bootsect.s 只能先把内核放到 0x10000 处而不是直接放到 0x0000 处!</li>
</ul>
</li>
<li>bootsect.s 把执行权交给 setup.s.</li>
<li>然后, setup.s 把BIOS预留在内存起始处的参数存储到0x90000处(覆盖了bootsect.s), 再把system模块移到内存起始处 (0x0000)</li>
<li>setup.s 把执行权交给 head.s, linux系统代码加载过程完成, linux开始启动!</li>
</ol>
<p>备注:</p>
<ul>
<li>启动过程涉及到很多80x86的硬件知识, 没必要深究, 重点是理解启动过程和思路!</li>
<li>因为目录linux早已支持arm体系结构, 嵌入式也以arm为主. 涉及到硬件的部分需要时再深入了解即可.</li>
</ul>
<h2 id="bootsect-s"><a href="#bootsect-s" class="headerlink" title="bootsect.s"></a>bootsect.s</h2><ul>
<li>bootsect.s 是磁盘引导块程序, 放在磁盘的一个扇区中(引导扇区).</li>
<li>PC上电, BIOS自检后, BIOS会把引导扇区bootsect加载到内存地址0x7C00处并执行.</li>
<li>bootsect 立刻把自己挪到 0x90000 处并继续执行</li>
<li>利用BISO中断0x13获取启动引导盘参数, 准备读取1.44MB启动磁盘内的后续部分(setup.s + system模块)</li>
<li>加载 setup.s 到 0x90200 处</li>
<li>在屏幕上显示 “Loading system…”</li>
<li>把system模块加载到0x10000处</li>
<li>长跳到 setup.s, 执行 setup.s</li>
</ul>
<h2 id="setup-s"><a href="#setup-s" class="headerlink" title="setup.s"></a>setup.s</h2><ul>
<li>setup.s 是一个操作系统加载程序. 主要作用读取BIOS保留的系统参数, 移动system模块到内存0x0000处, 并执行head.s代码</li>
<li>setup.s 首先是把BIOS预留在内存0x0000处的参数保存到内存 0x90000 处, 会覆盖掉已经没有用的 bootsect.s 代码</li>
<li>主要参数有: 光标位置, 扩展内存数, 显示页面, 显示模式, 字符列数, 显示内存, 显示状态, 显卡特性, 硬盘参数, 根设备号</li>
<li>接着 setup.s 将system模块从 0x10000-0x8ffff 整体向下移动到 0x0000 处.</li>
<li>然后 setup.s 加载 idtr 和 gdtr (中断/全局描述符表寄存器), 重设中断号, 设置CPU进入32位保护模式运行</li>
<li>跳转到 system模块的 head.s 继续运行(运行在32位保护模式下)</li>
</ul>
<p><em>setup.s 结束后内中的程序示意图</em><br><img src="https://draapho.github.io/images/1704/2-setup-memory.jpg" alt="setup-memory"></p>
<h2 id="head-s"><a href="#head-s" class="headerlink" title="head.s"></a>head.s</h2><ul>
<li>head.s 位于整个linux操作系统最前面, 主要功能就是为linux的执行检测和初始化系统环境</li>
<li>设置系统堆栈</li>
<li>设置idt(中断描述符表) 和 gdt(全局表述符表)</li>
<li>检测A20地址线是否已真的开启 (就是能读取1M以上的内存地址)</li>
<li>将页目录表放在内存地址0处 (会覆盖自己idt部分的内容)</li>
<li>最后, heads利用返回指令, 弹出main.c的入口地址, 运行main()程序</li>
</ul>
<p><em>head.s 结束后, system模块在内存中的示意图</em><br><img src="https://draapho.github.io/images/1704/2-head-memory.jpg" alt="head-memory"></p>
<h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><p><em>main初始化完成后, 内存功能示意图</em><br><img src="https://draapho.github.io/images/1704/2-main-memory.jpg" alt="maim-memory"></p>
<p><em>内核初始化程序流程示意图</em><br><img src="https://draapho.github.io/images/1704/2-main-flow.jpg" alt="maim-flow"></p>
<p><em>调用fork创建新进程</em><br><img src="https://draapho.github.io/images/1704/2-fork-function.jpg" alt="fork-function"></p>
<p><em>进程(process), 进程组(process group) 和 会话期(session) 的关系图</em><br><img src="https://draapho.github.io/images/1704/2-session-process.jpg" alt="session-process"></p>
<ul>
<li>一般一个用户登录后, 其所有程序属于同一个session. 用途很多, 譬如便于发出终止信号结束所有进程.</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://oldlinux.org/download/clk011c-3.0-toc.pdf">Linux 内核完全注释 内核版本0.11 - 赵炯</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 0.11 源码阅读笔记-内核代码</title>
    <url>/2017/01/31/1704-linux-source3/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/01/23/1704-linux-source/">Linux 0.11 源码阅读笔记-总览</a></li>
<li><a href="https://draapho.github.io/2017/01/26/1704-linux-source1/">Linux 0.11 源码阅读笔记-内存的基础概念</a></li>
<li><a href="https://draapho.github.io/2017/01/28/1704-linux-source2/">Linux 0.11 源码阅读笔记-启动程序</a></li>
<li><a href="https://draapho.github.io/2017/01/31/1704-linux-source3/">Linux 0.11 源码阅读笔记-内核代码</a></li>
<li><a href="https://draapho.github.io/2017/02/01/1704-linux-source4/">Linux 0.11 源码阅读笔记-设备驱动程序</a></li>
<li><a href="https://draapho.github.io/2017/02/13/1704-linux-source5/">Linux 0.11 源码阅读笔记-文件系统</a></li>
<li><a href="https://draapho.github.io/2017/02/15/1704-linux-source6/">Linux 0.11 源码阅读笔记-内存管理</a></li>
</ul>
<h1 id="内核代码"><a href="#内核代码" class="headerlink" title="内核代码"></a>内核代码</h1><p><img src="https://draapho.github.io/images/1704/3-kernel-function.jpg" alt="kernel-function"></p>
<h2 id="硬件中断程序"><a href="#硬件中断程序" class="headerlink" title="硬件中断程序"></a>硬件中断程序</h2><p>处理系统硬件中断. 多为故障处理, 直接打印出堆栈信息帮助排错.</p>
<h2 id="系统调用程序"><a href="#系统调用程序" class="headerlink" title="系统调用程序"></a>系统调用程序</h2><p>本质是调用中断 int 0x80. 由于是用户发起的, 也称之为软中断.</p>
<ul>
<li>system_call.s 会根据 <code>sys_call_table[]</code> (在sys.h内) 去调用相应的C函数. sys_xxx函数则很分散.</li>
<li>signal.c 用于处理内核的信号. (<code>signal()</code>可能丢失信号, <code>sigaction()</code>更可靠)</li>
</ul>
<p><em>信号处理程序的调用方式</em><br><img src="https://draapho.github.io/images/1704/3-signal.jpg" alt="signal"></p>
<h2 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h2><p>linux 0.11的调度思路结合<code>时间片</code>和<code>优先权</code>调度.</p>
<p><em>调用fork创建新进程</em><br><img src="https://draapho.github.io/images/1704/2-fork-function.jpg" alt="fork-function"></p>
<ul>
<li>调度过程: count大, 就优先调度! 计算公式为: <code>count = counter/2 + priotiry</code>.<br>对于以及运行完成的任务, count 直接为 priotiry<br>对于被阻塞的任务, 由于公式内包含有 count/2 的权重, 即使优先级再低, 也会被照顾到.</li>
<li><code>switch_to()</code> 一段汇编宏定义, 用于切换到指定任务(加载TSS).</li>
<li><code>schedule()</code> 调度函数, 每10ms判断各任务的信号位图以及比较<code>counter</code>值. 需要切换任务时, 调用 <code>switch_to(next)</code></li>
<li><code>do_timer()</code> 在 system_call.s 中 <code>_timer_interrupt</code> 被调用, 每10ms调用一次 <code>schedule()</code></li>
<li><code>sleep_on()</code> 当进程所请求的资源暂时不可用时, 等待一段时间. 等切换回来后再继续运行. 调用 <code>schedule()</code></li>
<li><code>wake_up()</code> 把正在等待可用资源的指定任务值为就绪状态, 就如字面意义, 是一个唤醒函数. 但实现比较搞脑子!</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://oldlinux.org/download/clk011c-3.0-toc.pdf">Linux 内核完全注释 内核版本0.11 - 赵炯</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 0.11 源码阅读笔记-设备驱动程序</title>
    <url>/2017/02/01/1704-linux-source4/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/01/23/1704-linux-source/">Linux 0.11 源码阅读笔记-总览</a></li>
<li><a href="https://draapho.github.io/2017/01/26/1704-linux-source1/">Linux 0.11 源码阅读笔记-内存的基础概念</a></li>
<li><a href="https://draapho.github.io/2017/01/28/1704-linux-source2/">Linux 0.11 源码阅读笔记-启动程序</a></li>
<li><a href="https://draapho.github.io/2017/01/31/1704-linux-source3/">Linux 0.11 源码阅读笔记-内核代码</a></li>
<li><a href="https://draapho.github.io/2017/02/01/1704-linux-source4/">Linux 0.11 源码阅读笔记-设备驱动程序</a></li>
<li><a href="https://draapho.github.io/2017/02/13/1704-linux-source5/">Linux 0.11 源码阅读笔记-文件系统</a></li>
<li><a href="https://draapho.github.io/2017/02/15/1704-linux-source6/">Linux 0.11 源码阅读笔记-内存管理</a></li>
</ul>
<h1 id="0-11源码设备驱动程序"><a href="#0-11源码设备驱动程序" class="headerlink" title="0.11源码设备驱动程序"></a>0.11源码设备驱动程序</h1><h2 id="字符设备驱动程序"><a href="#字符设备驱动程序" class="headerlink" title="字符设备驱动程序"></a>字符设备驱动程序</h2><p><img src="https://draapho.github.io/images/1704/4-char-driver.jpg" alt="char-driver"></p>
<ul>
<li><code>read_q</code> tty读队列</li>
<li><code>write_q</code> tty写队列, 调用 <code>copy_to_cooked()</code> 后放入 <code>secondary</code></li>
<li><code>secondary</code> tty辅助队列(存放规范模式字符序列)</li>
</ul>
<h2 id="块设备驱动程序"><a href="#块设备驱动程序" class="headerlink" title="块设备驱动程序"></a>块设备驱动程序</h2><p><img src="https://draapho.github.io/images/1704/4-block-driver.jpg" alt="block-driver"></p>
<ul>
<li><code>ll_rw_block()</code>添加完请求项后(使用了链表, 并使用电梯算法改善硬盘访问时间), 真正的操作通过调用<code>request_fn()</code>完成</li>
<li>操作硬盘 <code>do_hd_request()</code>, 操作软盘 <code>do_fd_request()</code>, 操作虚拟盘 <code>do_re_request()</code></li>
</ul>
<h1 id="linux-设备和模块的分类"><a href="#linux-设备和模块的分类" class="headerlink" title="linux 设备和模块的分类"></a>linux 设备和模块的分类</h1><h2 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h2><p>一个字符( char ) 设备是一种可以当作一个字节流来存取的设备( 如同一个文件 ); 一个字符驱动负责实现这种行为.<br>这样的驱动常常至少实现 <code>open</code>, <code>close</code>, <code>read</code>, 和 <code>write</code> 系统调用.</p>
<p>文本控制台 <code>/dev/console</code> 和串口 <code>/dev/ttyS0</code> 是字符设备的例子, 因为它们很好地展现了流的抽象.<br>字符设备通过文件系统结点来存取, 例如 <code>/dev/tty1</code> 和 <code>/dev/lp0</code>.</p>
<p>在一个字符设备和一个普通文件之间唯一有关的不同就是, 你经常可以在普通文件中移来移去, 但是大部分字符设备仅仅是数据通道, 你只能顺序存取.<br>然而, 存在看起来象数据区的字符设备, 你可以在里面移来移去. 例如, frame grabber 经常这样, 应用程序可以使用 mmap 或者 lseek 存取整个要求的图像.</p>
<h2 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h2><p>如同字符设备, 块设备通过位于 <code>/dev</code> 目录的文件系统结点来存取. 一个块设备(例如一个磁盘)应该是可以驻有一个文件系统的.</p>
<p>Linux, 允许应用程序像一个字符设备一样读写一个块设备, 允许一次传送任意数目的字节.<br>如同一个字符设备, 每个块设备都通过一个文件系统结点被存取的, 它们之间的区别对用户是透明的.<br>因此块和字符设备的区别仅仅在内核在内部管理数据的方式上, 并且因此在内核/驱动的软件接口上不同.</p>
<p>注意, 在大部分的 Unix 系统, 一个块设备只能处理这样的 I/O 操作, 传送一个或多个长度经常是 512 字节的整块(或更大如1024字节)</p>
<h2 id="网络接口"><a href="#网络接口" class="headerlink" title="网络接口"></a>网络接口</h2><p>任何网络事务都通过一个接口来进行, 就是说, 一个能够与其他主机交换数据的设备.<br>通常, 一个接口是一个硬件设备, 但是它也可能是一个纯粹的软件设备, 比如环回接口.</p>
<p>一个网络接口负责发送和接收数据报文, 在内核网络子系统的驱动下, 不必知道单个事务是如何映射到实际的被发送的报文上的.<br>虽然很多网络连接(特别那些使用 TCP 的)是面向流的, 但网络设备却常常设计成处理报文的发送和接收.</p>
<p>网络设备驱动的实现与字符和块设备驱动完全不同. <del>不用 <code>read</code> 和 <code>write</code></del>, 需要使用和报文传递相关的函数.</p>
<h2 id="硬件和驱动的关系"><a href="#硬件和驱动的关系" class="headerlink" title="硬件和驱动的关系"></a>硬件和驱动的关系</h2><p>以 USB 设备为例, USB可以虚拟成串口(字符设备), 也可以是USB硬盘(块设备), 或者USB wifi(网络接口)<br>因此, 使用何种Linux的驱动和硬件无关, 而和与硬件的通讯方式有关.</p>
<p>一般地, 字节流使用字符设备驱动, 大量并发数据的传输使用块设备驱动. 网络接口驱动仅针对网络通讯.</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://oldlinux.org/download/clk011c-3.0-toc.pdf">Linux 内核完全注释 内核版本0.11 - 赵炯</a></li>
<li><a href="http://www.deansys.com/doc/ldd3/ch01s03.html">设备和模块的分类</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 0.11 源码阅读笔记-文件系统</title>
    <url>/2017/02/13/1704-linux-source5/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><p><a href="https://draapho.github.io/2017/01/23/1704-linux-source/">Linux 0.11 源码阅读笔记-总览</a></p>
</li>
<li><p><a href="https://draapho.github.io/2017/01/26/1704-linux-source1/">Linux 0.11 源码阅读笔记-内存的基础概念</a></p>
</li>
<li><p><a href="https://draapho.github.io/2017/01/28/1704-linux-source2/">Linux 0.11 源码阅读笔记-启动程序</a></p>
</li>
<li><p><a href="https://draapho.github.io/2017/01/31/1704-linux-source3/">Linux 0.11 源码阅读笔记-内核代码</a></p>
</li>
<li><p><a href="https://draapho.github.io/2017/02/01/1704-linux-source4/">Linux 0.11 源码阅读笔记-设备驱动程序</a></p>
</li>
<li><p><a href="https://draapho.github.io/2017/02/13/1704-linux-source5/">Linux 0.11 源码阅读笔记-文件系统</a></p>
</li>
<li><p><a href="https://draapho.github.io/2017/02/15/1704-linux-source6/">Linux 0.11 源码阅读笔记-内存管理</a></p>
</li>
<li><p>推荐阅读 <a href="https://mp.weixin.qq.com/s?__biz=MzI5ODExMDQzNw==&mid=2650737282&idx=1&sn=07a3fc491dbd06ea61afe4c7108cf7b9&chksm=f4a17608c3d6ff1e7bb2b1168efa53f39db5c77b474296ba6086c1cf6612a452a6d234766b52&scene=0&key=7b81aac53bd2393d2edc7d94c6241745fd19b9a63b96f3683b767fbe2d367bd483fac89816919a23882f7bb13be77dc2&ascene=7&uin=MTUzODYxOTg2MQ==&devicetype=android-19&version=26031933&nettype=live.vodafone.com&pass_ticket=MhcadpuflaJvGcaLNh0HQ3y1Ae/L2WCKStoj0RjDWXVN6c001WFeoX4HFyF1KE51">我是一块硬盘-码农翻身-刘欣</a><br>通俗易懂的介绍了硬盘及文件系统的管理方式, 也简单提了一下inode. 可以作为此部分的入门.</p>
</li>
</ul>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>本人手工制作的 <strong>Linux 0.11 文件系统图解</strong><br><img src="https://draapho.github.io/images/1704/5-fs-map.jpg" alt="fs"></p>
<p>几个核心点:</p>
<ul>
<li>Linux下<strong>一切皆文件, 文件即i节点!</strong></li>
<li>文件名和i节点的关联, 在目录项结构中实现.<br>索引过程为: <strong>目录inode-&gt;目录名/文件名-&gt;对应inode-&gt;具体内容</strong></li>
<li>任何读写硬盘的过程都是通过内存的buffer(高速缓冲)实现的, 系统不能直接读写硬盘! 由此产生同步问题.<br>调用过程为: <strong>系统函数-&gt;buffer-&gt;硬盘</strong></li>
<li>Linux对内存条的分配和使用. <code>Buffer</code> <code>Memory</code> 的概念和用途. <code>Buffer Head</code> <code>Buffer Hash List</code>.<br><code>Buffer</code> 介于高速的CPU指令和低速的硬盘之间, 用于缓存CPU对硬盘的读写内容, 提高CPU执行效率.<br><code>Memory</code> 是系统可用的内存. 系统变量, <code>malloc</code> 都是用的这块空间.<br><code>虚拟内存</code> 把使用频率低的 <code>Memory</code> 暂时搬到硬盘, 以便存放使用频率更高的内存数据. 依赖于硬盘读写操作!</li>
</ul>
<h2 id="硬盘设备分区"><a href="#硬盘设备分区" class="headerlink" title="硬盘设备分区"></a>硬盘设备分区</h2><p>硬盘设备上的分区和文件系统<br><img src="https://draapho.github.io/images/1704/5-fs-hard-disk.jpg" alt="hard disk"></p>
<ul>
<li>主引导扇区: 存放硬盘引导程序和分区表信息.</li>
<li>分区表: 标明了每个分区的类型, 起止位置以及占用的扇区数.</li>
<li>相关文件: <code>kernel/blk_drv/hd.c</code></li>
</ul>
<p>下面, 将以MINIX1.0为例说明文件系统的基本概念.<br>Linux使用的其它的文件系统核心概念都是一样的! 只是支持的大小, 寻址速度, 文件上限有区别.</p>
<h2 id="MINIX1-0-文件系统"><a href="#MINIX1-0-文件系统" class="headerlink" title="MINIX1.0 文件系统"></a>MINIX1.0 文件系统</h2><p>MINIX1.0 文件系统布局示意图<br><img src="https://draapho.github.io/images/1704/5-fs-minix.jpg" alt="minix"></p>
<ul>
<li>引导块: 上电时, BISO自动读入的部分. 有了引导块内引导程序, BIOS才能启动系统</li>
<li>Super Block(超级块): 存放文件系统的结构信息, 说明各部分的大小. <code>super_block[8]</code>, 可加载8个文件系统</li>
<li>Inode Bitmap(i节点位图): 记录i节点的使用情况, 1bit代表一个i节点. <code>s_imap[8]</code>, 占用8个块, 可表示8191个i节点情况</li>
<li>Zone Bitmap(逻辑块位图): 记录数据区的使用情况, 1bit代表一个盘块(block). <code>s_zmap[8]</code>, 占用8个块, 最大支持64M的硬盘</li>
<li>Inode(i节点): 每个文件或目录名唯一对应一个i节点, 在i节点中, 储存 id信息, 文件长度, 时间信息, 实际数据所在位置等等</li>
<li>Zone Data(数据区): <code>8 (bit/byte)  * 1024 (byte/block) * 8(zmap blocks) * 1024 (byte/block)= 64M byte</code></li>
</ul>
<p>MINIX1.0 的超级块数据结构<br><img src="https://draapho.github.io/images/1704/5-fs-super-block.jpg" alt="super block"></p>
<h1 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h1><h2 id="inode-详解"><a href="#inode-详解" class="headerlink" title="inode 详解"></a>inode 详解</h2><p>MINIX1.0 的i节点数据结构<br><img src="https://draapho.github.io/images/1704/5-fs-inode.jpg" alt="inode"></p>
<ul>
<li><code>i_nlinks</code>: <strong>硬链接</strong>计数器. 因此硬连接具有相同的inode号, 硬连接不能跨文件系统!</li>
</ul>
<p>命令 <code>ls -l</code> 显示的文件信息, 多数信息读取i节点就可获得<br><img src="https://draapho.github.io/images/1704/5-fs-file-info.jpg" alt="file info"></p>
<ul>
<li>符号连接 <code>s</code>: 就是常说的<strong>软连接</strong>, 类似于windows下的快捷方式, 占用i节点, 在对应的数据块内存放路径</li>
</ul>
<p><code>i_zone[9]</code> i节点的逻辑块数组功能.<br><img src="https://draapho.github.io/images/1704/5-fs-izone.jpg" alt="izone"></p>
<ul>
<li><code>i_zone[0-6]</code> 直接块号: 存放文件开始的7个磁盘块号. 此时文件大小: <code>7*1024(byte/block)=7K byte</code></li>
<li><code>i_zone[7]</code> 一次间接块号: 地址占用2byte, 因此一个数据块可存放512个地址. 此时可寻块 <code>7+512 blocks</code></li>
<li><code>i_zone[8]</code> 二次间接块号: 此时可寻块 <code>7+512+512*512 blocks</code>, 文件的最大可达 <code>512M byte</code></li>
<li><code>/dev/</code>下设备文件的 <code>i_zone[0]</code>: 设备文件不占用硬盘, 因此i节点仅保存设备的属性和设备号.</li>
</ul>
<h2 id="文件名的存储及查找"><a href="#文件名的存储及查找" class="headerlink" title="文件名的存储及查找"></a>文件名的存储及查找</h2><p>Linux 0.11 的目录项结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义在 include/linux/fs.h 文件中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_LEN 14                 <span class="comment">// 名字长度值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROOT_INO 1                  <span class="comment">// 根i节点</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件目录项结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> inode;           <span class="comment">// i节点号</span></span><br><span class="line">    <span class="keyword">char</span> name[NAME_LEN];            <span class="comment">// 文件名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>可见, linux下的文件名称都存在了目录项的数据里面, 并且唯一关联其i节点号.</li>
<li>每个目录项占用16字节, 因此, 一个盘块可以存放 <code>1024/16=64</code> 个目录项</li>
<li>对于空目录, 也至少会有名称未 <code>.</code> 和 <code>..</code> 两项, 指向 <code>当前目录inode</code> 和 <code>上级目录inode</code></li>
<li>因此, 空目录的硬连接计数值<code>i_nlinks</code>为2, 每多一个文件, <code>i_nlinks</code>再加1.</li>
</ul>
<p>通过文件名最终找到对应文件盘块位置的示意图<br><img src="https://draapho.github.io/images/1704/5-fs-inode-find.jpg" alt="inode find"></p>
<p>整个搜索过程是根据<code>目录项结构</code>及对应的<code>inode 号</code>, 逐步深入路径的过程.<br>以路径名 <code>/usr/bin/vi</code> 搜索对应的i节点, 然后读取文件内容为例:</p>
<ol>
<li>根目录 <code>/</code> 具有固定的 inode号 <code>1</code>.</li>
<li>读取<code>inode 1</code>的数据块, 搜索名为<code>usr</code>的目录项, 从而得到<code>/usr</code>的inode号, 假设为 <code>23</code></li>
<li>读取<code>inode 23</code>的数据块, 搜索名为<code>bin</code>的目录项, 假设<code>/usr/bin</code>的inode号为 <code>61</code></li>
<li>读取<code>inode 61</code>的数据块, 搜索名为<code>vi</code>的文件名, 假设获得<code>/usr/bin/vi</code>的inode号 <code>98</code></li>
<li>读取<code>inode 98</code>的数据块, 根据i节点信息, 如 <code>i_size</code> <code>i_zone[9]</code>, 最终读取文件内容</li>
</ol>
<h1 id="高速缓存-buffer-c"><a href="#高速缓存-buffer-c" class="headerlink" title="高速缓存 buffer.c"></a>高速缓存 <code>buffer.c</code></h1><p><code>buffer_head</code> 的数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> * b_data;                      <span class="comment">// 指向该缓冲块中数据区(1024字节)的指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> b_blocknr;            <span class="comment">// 块号</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> b_dev;               <span class="comment">// 数据源的设备号(0=free)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> b_uptodate;           <span class="comment">// 更新标记: 表示数据是否已更新</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> b_dirt;               <span class="comment">// 修改标记: 0-未修改(clean), 1-已修改(dirty)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> b_count;              <span class="comment">// 使用该块的用户数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> b_lock;               <span class="comment">// 缓冲区是否被锁定. 0-ok, 1-locked</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">b_wait</span>;</span>        <span class="comment">// 指向等待该缓冲区解锁的任务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev</span>;</span>        <span class="comment">// hash 队列的前一块. (这四个指针用于缓冲区管理)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next</span>;</span>        <span class="comment">// hash 队列的下一块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev_free</span>;</span>   <span class="comment">// 空闲表上前一块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next_free</span>;</span>   <span class="comment">// 空闲表上下一块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>buffer的初始化<br><img src="https://draapho.github.io/images/1704/5-fs-buffer-init.jpg" alt="inode find"></p>
<p>buffer的双向循环链表<br><img src="https://draapho.github.io/images/1704/5-fs-buffer-list.jpg" alt="inode find"></p>
<ul>
<li>该双向链表是最近最少使用LRU链表(Least Recently Used), <code>free_list</code> 指向最为空闲的缓冲块指针</li>
</ul>
<p>buffer的hash表<br><img src="https://draapho.github.io/images/1704/5-fs-buffer-hash.jpg" alt="inode find"></p>
<ul>
<li>Linux 0.11 使用的hash函数是 <code>设备号^逻辑块号 Mod 307</code>, 因此共有307项hash表</li>
<li>hash的功能类似于字典, 先预先归类, 然后可以按类查找, 加快了查找速度.</li>
</ul>
<p>缓冲区管理函数关系图<br><img src="https://draapho.github.io/images/1704/5-fs-buffer-function.jpg" alt="inode find"></p>
<p>详解 <code>getblk()</code> 函数. 用于寻找最为空闲的buffer缓冲块.<br><img src="https://draapho.github.io/images/1704/5-fs-getblk.jpg" alt="inode find"></p>
<ul>
<li>首先调用 <code>get_hash_table()</code>, 查看搜索的指定缓冲块是否已经存在于buffer中. 存在就立刻返回该buffer指针.</li>
<li>不存在时, 从空闲链表头开始扫描, 寻找最合适的空闲块(没有被使用, 没有被上锁, 没有被修改). 实现LRU</li>
<li>因为可能别的进程已经加入了所需的缓冲块, 因此再调用一遍 <code>get_hash_table()</code></li>
<li>此时, 可以将块应用计数置1, 把该缓冲块移到空闲队列末尾.</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://oldlinux.org/download/clk011c-3.0-toc.pdf">Linux 内核完全注释 内核版本0.11 - 赵炯</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI5ODExMDQzNw==&mid=2650737282&idx=1&sn=07a3fc491dbd06ea61afe4c7108cf7b9&chksm=f4a17608c3d6ff1e7bb2b1168efa53f39db5c77b474296ba6086c1cf6612a452a6d234766b52&scene=0&key=7b81aac53bd2393d2edc7d94c6241745fd19b9a63b96f3683b767fbe2d367bd483fac89816919a23882f7bb13be77dc2&ascene=7&uin=MTUzODYxOTg2MQ==&devicetype=android-19&version=26031933&nettype=live.vodafone.com&pass_ticket=MhcadpuflaJvGcaLNh0HQ3y1Ae/L2WCKStoj0RjDWXVN6c001WFeoX4HFyF1KE51">我是一块硬盘-码农翻身-刘欣</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 0.11 源码阅读笔记-内存管理</title>
    <url>/2017/02/15/1704-linux-source6/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/01/23/1704-linux-source/">Linux 0.11 源码阅读笔记-总览</a></li>
<li><a href="https://draapho.github.io/2017/01/26/1704-linux-source1/">Linux 0.11 源码阅读笔记-内存的基础概念</a></li>
<li><a href="https://draapho.github.io/2017/01/28/1704-linux-source2/">Linux 0.11 源码阅读笔记-启动程序</a></li>
<li><a href="https://draapho.github.io/2017/01/31/1704-linux-source3/">Linux 0.11 源码阅读笔记-内核代码</a></li>
<li><a href="https://draapho.github.io/2017/02/01/1704-linux-source4/">Linux 0.11 源码阅读笔记-设备驱动程序</a></li>
<li><a href="https://draapho.github.io/2017/02/13/1704-linux-source5/">Linux 0.11 源码阅读笔记-文件系统</a></li>
<li><a href="https://draapho.github.io/2017/02/15/1704-linux-source6/">Linux 0.11 源码阅读笔记-内存管理</a></li>
</ul>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>本人手工制作的 <strong>Linux 0.11 内存管理图解</strong><br><img src="https://draapho.github.io/images/1704/6-mm-map.jpg" alt="mm"></p>
<ul>
<li>虚拟内存的实现, 使用的是页面出错异常处理. 然后调用 <code>do_no_page()</code> 来读取硬盘数据(必要时先回写), 腾出内存空间.</li>
<li>写时复制 (copy on write) 机制, 新建进程时, linux不会立刻复制进程数据.<br>只有某个进程需要进行数据写操作时, 才真正开始执行复制操作.<br>好处是, 节约内存, 加快创建进程的速度.</li>
<li>Linux 0.11版本的内存管理的主要文件 <code>/mm/memory.c</code></li>
<li>内存的一些基础概念请参考 <a href="https://draapho.github.io/2017/01/26/1704-linux-source1/">Linux 0.11 源码阅读笔记-内存的基础概念</a></li>
</ul>
<h1 id="进程的内存空间"><a href="#进程的内存空间" class="headerlink" title="进程的内存空间"></a>进程的内存空间</h1><p>进程代码和数据在其逻辑地址空间中的分布<br><img src="https://draapho.github.io/images/1704/6-mm-process.jpg" alt="mm"></p>
<ul>
<li>Linux 0.11 每个进程只能有64M byte的逻辑内存.</li>
<li>环境参数块最多128K</li>
<li>堆栈指针是在逻辑地址的高位, 向下增长</li>
<li>bss是进程未初始化的数据段, 第一页会被初始化为0</li>
<li>使用需求加载机制 (Load on demand), 因此在加载运行文件时, 只是分配64M的线性地址空间, 没有分配任何真正的物理内存.</li>
<li>此时, 内核在执行代码或加载数据时, 会触发缺页异常中断, 此时才调用 <code>do_no_page</code> 加载内容到物理内存.</li>
</ul>
<h1 id="内存的分配-malloc"><a href="#内存的分配-malloc" class="headerlink" title="内存的分配 malloc"></a>内存的分配 <code>malloc</code></h1><p>使用存储桶原理进行内存的分配管理<br><img src="https://draapho.github.io/images/1704/6-mm-malloc.jpg" alt="mm"></p>
<ul>
<li>实现很巧妙. 指针应用的出神入化</li>
<li>仅内核代码可以调用.</li>
<li>基本思想: 对申请的不同的内存块大小, 使用存储桶分别进行处理.</li>
<li>提高内存利用率, 可有效避免内存碎片化.</li>
<li>源码文件 <code>/lib/malloc.c</code></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://oldlinux.org/download/clk011c-3.0-toc.pdf">Linux 内核完全注释 内核版本0.11 - 赵炯</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式linux环境搭建-主机端</title>
    <url>/2017/02/16/1705-linux-env/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/02/16/1705-linux-env/">嵌入式linux环境搭建-主机端</a></li>
<li><a href="https://draapho.github.io/2017/02/21/1707-jz2440-env/">嵌入式linux环境搭建-jz2440开发板</a></li>
<li><a href="https://draapho.github.io/2017/11/28/1738-dhcp-env/">基于DHCP建立嵌入式Linux开发环境</a></li>
</ul>
<h1 id="嵌入式linux开发环境搭建思路"><a href="#嵌入式linux开发环境搭建思路" class="headerlink" title="嵌入式linux开发环境搭建思路"></a>嵌入式linux开发环境搭建思路</h1><p>学习过大半, 总结经验后, 得出如下环境搭建的最新思路:</p>
<ul>
<li>使用32位桌面版Ubuntu, 推荐使用 <a href="http://releases.ubuntu.com/16.04/ubuntu-16.04.3-desktop-i386.iso">ubuntu-16.04.3-desktop-i386.iso</a></li>
<li>linux源码必须放在Linux文件系统下. 如果放在windows下再通过nfs共享给linux, 搜索和编译的速度太慢!</li>
<li>可以纯linux环境工作. 如果基于windows, 虚拟机linux的话, 可以让linux使用samba与windows实现文件共享.</li>
<li>虚拟机强烈推荐使用 vmware, 可以直接在主机和虚拟机之间复制黏贴. 不推荐 Hyper-V!</li>
<li>Embedded linux 固化uboot, kernel, 使用nfs加载文件系统. 这样所需工具最少, 开发最灵活方便.</li>
<li>烧录的话, 使用usb, 基于uboot和linux下dnw, 还是挺方便的.</li>
<li>源码阅读和驱动开发使用 <a href="https://sourceforge.net/projects/linkplustest/">LinK+</a>, 一款linux下基于eclipse开发的Linux内核开发IDE!</li>
</ul>
<p>配置步骤见如下文章:</p>
<ul>
<li><a href="https://draapho.github.io/2017/07/06/1718-linux-samba/">Ubuntu下配置支持Windows访问的samba共享</a></li>
<li><a href="https://draapho.github.io/2017/11/29/1739-ubuntu-nfs/">Ubuntu 16.04安装配置NFS</a></li>
<li><a href="https://draapho.github.io/2017/11/27/1737-linux-ide/">LinK+, 一款Linux内核开发IDE</a></li>
<li><a href="https://draapho.github.io/2017/02/20/1706-linux-ubuntu16/">嵌入式linux环境搭建1-Ubuntu16</a></li>
</ul>
<p>Windows下用虚拟机安装Ubuntu的话, 虚拟机网络类型需要选择为Briged模式. 区别如下:</p>
<ul>
<li>Bridged(桥接模式), 虚拟机在局域网中可见, IP和主机处于同一网段</li>
<li>NAT(网络地址转换模式), 主机为双网卡主机, 会建立一个虚拟局域网和虚拟机通讯. 局域网看不到虚拟机的存在</li>
<li>Host-only(主机模式), 主机建立一个网络用于和虚拟机通讯, 此网络和真实网络无关. 所以虚拟机无法上外网!</li>
</ul>
<p><strong>此文到此结束了, 下面的都是历史遗留产物…</strong></p>
<h2 id="历史思路"><a href="#历史思路" class="headerlink" title="历史思路"></a><del>历史思路</del></h2><ol>
<li>PC windows 所有资料存在windows目录下, 所有操作在windows环境下. NFS设置可参考:<ul>
<li><a href="https://draapho.github.io/2016/10/03/1606-WinSoft-cloud/">Windows NFS 环境搭建</a></li>
</ul>
</li>
<li>PC linux 装在虚拟机里, 提供交叉编译环境. 其环境搭建可参考:<ul>
<li>第一次尝试, 失败告终, <del><a href="https://draapho.github.io/2017/02/18/1706-linux-ubuntu14/">嵌入式linux环境搭建1-Ubuntu14</a></del></li>
<li>第二次尝试, 失败告终, <del><a href="https://draapho.github.io/2017/02/19/1706-linux-centos7/">嵌入式linux环境搭建2-CentOS7</a></del></li>
<li>第三次尝试, 成功! <a href="https://draapho.github.io/2017/02/20/1706-linux-ubuntu16/">嵌入式linux环境搭建3-Ubuntu16</a></li>
</ul>
</li>
<li>Embedded linux 固化uboot, kernel, 使用nfs加载文件系统. 其参数设置可参考:<ul>
<li><a href="https://draapho.github.io/2017/02/21/1707-jz2440-env/">嵌入式linux环境搭建-jz2440开发板</a></li>
</ul>
</li>
</ol>
<p>整个环境的搭建思路基于尽可能少的文件传输, 系统切换操作, 以便提高效率. 可以选择的方案有NFS方案, windows文件共享方案.<br>细化下去有:</p>
<ul>
<li>windows做NFS服务器</li>
<li>ubuntu做NFS服务器</li>
<li>ubuntu使用samba来支持windows文件共享</li>
<li>交叉使用上述方案.</li>
</ul>
<p>一些列折腾之后, 最后顺利基于hanewin, win10作为NFS服务器. 两个linux作为NFS客户端, 三者文件共享.<br>而且使用这个方案还有一个好处, 开发文件都存放在熟悉的windows环境下, 修改/维护/备份都很方便.</p>
<h2 id="PC-windows-win10"><a href="#PC-windows-win10" class="headerlink" title="PC windows, win10"></a><del>PC windows, win10</del></h2><p>ip addr: <code>10.0.0.98</code><br>gateway: <code>10.0.0.138</code></p>
<ol>
<li>配置为静态IP. <code>10.0.0.98</code></li>
<li>当NFS服务器, 向PC linux和Embedded linux, u-boot提供NFS服务.<br>使用了hanewin, 注意使能 nfs version2 以及权限设置 (-mapall:0:0)</li>
<li>虚拟机安装 PC linux</li>
<li>烧录工具, jlink, OpenJtag, dnw, 网络传输.<br>早期需要使用. 开发到应用层就可以不用了.<br>用基于nfs的网络传输, 放弃使用dnw.</li>
<li>使用putty, 远程登录控制 PC linux.<br>文本编辑器建议用vim</li>
<li>使用串口, 可用putty 或 TeraTerm, 远程登录控制 Embedded linux,<br>文本编辑器只能用vi</li>
<li>PC windows的环境搭建可参考:<br>设置IP, 安装虚拟机属于常规内容, 按下不表.<br>NFS服务器 HaneWIN 的配置见 <strong><a href="https://draapho.github.io/2016/10/03/1606-WinSoft-cloud/">Windows 软件系列-基于NFS的家庭网</a></strong><br>其中 <code>Exports</code> 内容如下:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for linux</span></span><br><span class="line">E:\My_Study\linux -name:study -mapall:0:0 10.0.0.100</span><br><span class="line">E:\My_Work\linux -name:work -mapall:0:0 10.0.0.100</span><br><span class="line"></span><br><span class="line"><span class="comment"># for embedded linux.</span></span><br><span class="line">E:\My_Study\linux\jz2440\ -name:jz2440 -mapall:0:0 -range 10.0.0.1 10.0.0.111</span><br><span class="line"></span><br><span class="line"><span class="comment"># for loading file system, should be no limit, root account</span></span><br><span class="line"><span class="comment"># E:\My_Study\linux\jz2440\nfs\fs_qtopia -name:fs -mapall:0:0 10.0.0.111</span></span><br><span class="line"><span class="comment"># E:\My_Study\linux\jz2440\nfs\fs_mini_mdev -name:fs -mapall:0:0 10.0.0.111</span></span><br><span class="line"><span class="comment"># E:\My_Study\linux\jz2440\nfs\fs_mini -name:fs -mapall:0:0 10.0.0.111</span></span><br><span class="line"><span class="comment"># please choose one:</span></span><br><span class="line"></span><br><span class="line">E:\My_Study\linux\jz2440\nfs\fs_mini_mdev -name:fs -mapall:0:0 10.0.0.111</span><br></pre></td></tr></table></figure>


<h2 id="PC-linux-ubuntu-serve-16-04-32bit"><a href="#PC-linux-ubuntu-serve-16-04-32bit" class="headerlink" title="PC linux ubuntu serve 16.04 32bit"></a>PC linux ubuntu serve 16.04 32bit</h2><p>ip addr: <code>10.0.0.100</code><br>gateway: <code>10.0.0.138</code></p>
<ol>
<li>配置为静态IP. (弄不好就是无法上外网. 这里折腾半天)</li>
<li>安装NFS客户端. 开机mount NFS文件</li>
<li>安装SSH服务, 以便在windows下使用putty</li>
<li>安装交叉编译工具并测试<br>arm-linux-gcc 3.4.5 (对于2440系列, 别用新版本, 不停的有坑)<br>u-boot-tools<br>mkyaffs2image</li>
<li>PC linux的环境搭建可参考:<ul>
<li>第一次尝试, 失败告终, <del><a href="https://draapho.github.io/2017/02/18/1706-linux-ubuntu14/">嵌入式linux环境搭建1-Ubuntu14</a></del></li>
<li>第二次尝试, 失败告终, <del><a href="https://draapho.github.io/2017/02/19/1706-linux-centos7/">嵌入式linux环境搭建2-CentOS7</a></del></li>
<li>第三次尝试, 成功! <a href="https://draapho.github.io/2017/02/20/1706-linux-ubuntu16/">嵌入式linux环境搭建1-Ubuntu16</a></li>
</ul>
</li>
</ol>
<h2 id="Embedded-Linux-jz2440v3"><a href="#Embedded-Linux-jz2440v3" class="headerlink" title="Embedded Linux jz2440v3"></a>Embedded Linux jz2440v3</h2><p>ip addr: <code>10.0.0.111</code><br>gateway: <code>10.0.0.138</code></p>
<ol>
<li><p>用 jlink 或 openJtag <strong>烧录u-boot</strong></p>
<ul>
<li>u-boot的编译</li>
<li>需要工具jlink或OpenJtag, 一般开发板都会事先烧录好</li>
</ul>
</li>
<li><p>基于u-boot, 用dnw或网络传输 <strong>烧录内核文件</strong></p>
<ul>
<li>最后成功使用nfs, 在u-boot下烧录内核文件. 彻底放弃dnw, 接线也更简洁.</li>
<li>注意hanewin不支持多层文件夹!!!</li>
<li><del>dnw 需要在window下安装驱动, win7/win10下支持不好. win10 有数字签名问题 (重启即失效)</del></li>
<li><del>dnw 在虚拟机下的linux没有尝试成功, 因为我用的hyper-v虚拟机, 要连接到物理usb太麻烦.</del></li>
<li><del>网络传输我这边表现很不稳定, 而且操作上也比dnw繁琐.</del></li>
<li><del>我最终使用的是 windows 下的dnw. 因为只是烧录内核的时候需要使用.</del></li>
</ul>
</li>
<li><p>基于u-boot, 更改 <strong>file system</strong> 的加载方式为nfs系统, 并自动加载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以jz2440的u-boot为例, 进入u-boot命令行模式, 将其设置为nfs加载file system</span></span><br><span class="line"><span class="built_in">set</span> bootargs noinitrd root=/dev/nfs nfsroot=10.0.0.98:/fs ip=10.0.0.111:10.0.0.98:10.0.0.138:255.255.255.0::eth0:off init=/linuxrc console=ttySAC0</span><br><span class="line"><span class="comment"># (简化ip: &#x27;set bootargs noinitrd root=/dev/nfs nfsroot=10.0.0.98:/fs ip=10.0.0.111 init=/linuxrc console=ttySAC0&#x27; 也可以工作)</span></span><br><span class="line"><span class="comment"># (默认值: &#x27;set bootargs noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0&#x27;)</span></span><br><span class="line">save        <span class="comment"># 保存修改</span></span><br><span class="line">reset       <span class="comment"># 重启.</span></span><br></pre></td></tr></table></figure></li>
<li><p>jz2440的环境搭建可参考:</p>
<ul>
<li><a href="https://draapho.github.io/2017/02/21/1707-jz2440-env/">嵌入式linux-jz2440环境搭建</a></li>
</ul>
</li>
</ol>
<h1 id="折腾记"><a href="#折腾记" class="headerlink" title="折腾记"></a>折腾记</h1><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><ol>
<li>之前玩过NAS, 所以有现成的hanewin让windows做NFS服务器.</li>
<li>Ubuntu上安装 nfs-common, 顺利加载NFS文件. 编译了u-boot和kernel, 一切正常</li>
<li>开发板手动挂载nfs, 也成功了</li>
<li>开发板开机通过nfs挂载文件系统时, 各种permssion deny.</li>
<li>明显权限问题, 退回到ubuntu下, 尝试在ubuntu下也做个NFS服务器, 然后windows再倒过来加载.</li>
<li>发现在ubuntu下, 不能把加载过来的NFS文件再次通过NFS分享出去, 应该是出于安全考虑, 没有深入追究.</li>
<li>被第五条思路折腾了挺久, 最后是因为win10专业版下没有找到能做NFS客户端的软件而放弃.</li>
<li>折腾一圈后, 又想到windows共享文件方法, 结果Ubuntu 14.04安装Samba提示依赖错误, 搜索半天网络, 没有解决. 按下不表.</li>
<li>返璞归真, 在ubuntu下老老实实修改权限为777, 编译文件系统, 烧录测试… 结果开发板开机依旧提示错误…</li>
<li>一天后, 理了理思路, 再分析. 应该还是权限问题没跑, 要么chmod, 要么uid, gid问题. 毕竟是windows下NFS传过来的文件.</li>
<li>开始研究hanewin的权限问题, 翻到官网的说明, 确实有几个参数可以设置用户和权限.</li>
<li>一通假设加穷举后, 顺利解决用户和权限问题. 再回到开发板开机通过nfs挂载文件系统, 终于成功了, 而且还是最理想的只需要windows当NFS服务器即可.</li>
<li>期间还因为使用的arm-linux-gcc 4.3.2 版本, 编译成功, 加载部分fs可以运行, 部分fs有问题.一度以为是有些fs源码有问题, 多个问题交织在一起, 所以排错过程就显得异常痛苦迷茫了.</li>
<li>嵌入式开发的起步阶段, 基本就是想打主线游戏, 但不停的有分支任务, 分支任务的分支打断你, 让人直直的想骂这tmd是谁设计的鬼游戏, 还让不让人玩下去…</li>
<li>我想说, 只有保持着对主线好奇, 不忘要打败大boss的初心, 并在分支任务中寻求一点满足感, 才能坚持下去.</li>
</ol>
<h2 id="编译器的巨坑"><a href="#编译器的巨坑" class="headerlink" title="编译器的巨坑"></a><del>编译器的巨坑</del></h2><p>刚开始用了 arm-linux-gcc 4.3.2, 编译u-boot时遇到了第一个坑, 还给解决了.<br>于是”顺利”使用 arm-linux-gcc 4.3.2 编译了u-boot, kernel, led驱动程序.<br>所谓顺利, 是因为没有报错, 生成的文件可以烧录, 启动.<br>加上引号, 是因为最后证明这些生成文件是有问题的, 会导致整个嵌入式系统某些部分无法正常工作.<br>最后在编译测试驱动用的C文件时, 编译出来的可执行文件在开发板上不可执行,<br>才想到可能是编译器问题而尝试着换回到 3.4.5 版本. 并连同内核全部重新编译了.<br>换回去后, 之前一度认为的源码有问题的fs也能成功加载了, 真是个巨坑…</p>
<p>下面列出使用 <code>arm-linux-gcc 4.3.2</code> 编译u-boot遇到问题时的解决方法 (<strong>巨坑的开始</strong>):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果用gcc 4.3.2, 则版本太新, 编译错误. 可以使用自带的arm-none-linux-gnueabi</span></span><br><span class="line"><span class="comment"># 解决方法如下:</span></span><br><span class="line"><span class="comment"># 修改Makefile文件中的PLATFORM_LIBS, 将:</span></span><br><span class="line">PLATFORM_LIBS += -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -lgcc</span><br><span class="line"><span class="comment"># 修改成:</span></span><br><span class="line">PLATFORM_LIBS += -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -lgcc -lc -L /usr/<span class="built_in">local</span>/arm/4.3.2/arm-none-linux-gnueabi/libc/armv4t/usr/lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 cpu /arm920t/config.mk 文件, 将:</span></span><br><span class="line">PLATFORM_CPPFLAGS +=$(call cc-option,-mapcs-32,-mabi=apcs-gnu)</span><br><span class="line">PLATFORM_RELFLAGS +=$(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,))</span><br><span class="line"><span class="comment"># 修改成:</span></span><br><span class="line">PLATFORM_CPPFLAGS +=$(call cc-option,)</span><br><span class="line">PLATFORM_RELFLAGS +=$(call cc-option,$(call cc-option,))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新make, 即可生成 u-boot.bin</span></span><br></pre></td></tr></table></figure>

<p>最后, 对于 arm-linux-gcc 版本问题, 又研究了一下. 应该说不是新版本不能用, 而是需要设置.<br>对应编译原理之类的基本不懂, 暂时也没有时间去验证, 此处写出来提供一个思路, 感觉是可行的.<br>关键点有这么几个.</p>
<ul>
<li>要使用 arm-none-linux-gnueabi</li>
<li>要指定arm架构 -</li>
<li>指定使用的库</li>
</ul>
<p>这个在上面uboot的例子也能看出一二了. 在网上还有人提到:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译 hello.c 时, 需要用如下命令</span></span><br><span class="line">arm-none-linux-gnueabi-gcc -o hello hello.c -static <span class="comment"># 特别指明了 static不能省略!</span></span><br><span class="line"><span class="comment"># 配置Makefile时, 需要指明arm架构</span></span><br><span class="line">CC=<span class="string">&quot;arm-none-linux-gnueabi-gcc -march=armv4t&quot;</span></span><br><span class="line"><span class="comment"># 指定交叉编译工具</span></span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=/usr/<span class="built_in">local</span>/arm-2008q3/bin/arm-none-linux-gnueabi-</span><br><span class="line"><span class="comment"># 最后, 还是没明白 arm-linux-gcc 和 arm-none-linux-gnueabi-gcc的区别.</span></span><br><span class="line"><span class="comment"># 因为打开 arm-linux-gcc 4.3.2 bin下的 arm-linux-gcc 可以看到如下内容:</span></span><br><span class="line"><span class="built_in">exec</span> arm-none-linux-gnueabi-gcc -march=armv4t $*</span><br></pre></td></tr></table></figure>

<p>找到二篇详细说明的, 放上链接<br><a href="http://www.veryarm.com/296.html">arm交叉编译器gnueabi、none-eabi、arm-eabi、gnueabihf、gnueabi区别</a><br><a href="http://blog.csdn.net/u013467442/article/details/44197725">arm-none-linux-gnueabi交叉工具链安装,介绍，区别总结</a></p>
<h1 id="新技术-Docker"><a href="#新技术-Docker" class="headerlink" title="新技术 Docker"></a>新技术 <a href="https://docs.docker.com/">Docker</a></h1><p>Linux下的环境搭建一直让人比较痛苦, 这也直接使得 <code>Docker</code> 优势尽显.<br>简单研究了一下Docker, 这个方案是可行的!<br>可参考 <a href="https://draapho.github.io/2017/02/23/1708-docker/">Docker 初学笔记</a></p>
<p>基于Docker的ARM交叉编译环境, 已经有人在做了.</p>
<ul>
<li><a href="https://github.com/dockcross/dockcross">dockcross/dockcross</a>, 但S3C2440是ARM9, 采用的ARMv4架构</li>
<li><a href="http://hackaday.com/2016/09/01/how-to-use-docker-to-cross-compile-for-raspberry-pi-and-more/">HOW TO USE DOCKER TO CROSS COMPILE FOR RASPBERRY PI</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>environment</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式linux环境搭建2-CentOS7</title>
    <url>/2017/02/19/1706-linux-centos7/</url>
    <content><![CDATA[<h1 id="环境及结论"><a href="#环境及结论" class="headerlink" title="环境及结论"></a>环境及结论</h1><ul>
<li>大环境的搭建思路可参考<a href="https://draapho.github.io/2017/02/16/1705-linux-env/">嵌入式linux环境搭建-主机端</a><ul>
<li>gateway ip <code>10.0.0.138</code></li>
<li>PC windows: win10 64bit, ip <code>10.0.0.98</code></li>
<li>PC linux(最终版本): ubuntu server 16.04 32 bit, ip <code>10.0.0.100</code></li>
<li>Embedded Linux: jz2440v3 ip <code>10.0.0.111</code></li>
</ul>
</li>
<li>目的是尝试不同linux系统下的环境搭建</li>
<li>使用环境: CentOS7 64bit (安装在win10的虚拟机内)</li>
<li>kernel make 失败</li>
<li>彻底死机一次</li>
<li>没法直接安装 u-boot-tools</li>
<li>彻底放弃! 转战Ubuntu</li>
<li>不知是 centos 做 2440 的交叉编译兼容性不好, 还是64bit linux的兼容性不好. 或者两者皆有!</li>
</ul>
<h1 id="安装必要的软件"><a href="#安装必要的软件" class="headerlink" title="安装必要的软件"></a>安装必要的软件</h1><p>静态ip, 安装向导时, 就设置了.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install net-tools   <span class="comment"># to use ifconfig  or use ip addr</span></span><br><span class="line">yum install bzip2       <span class="comment"># bz2压缩格式</span></span><br><span class="line">yum install patch</span><br><span class="line">yum install gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 64位系统要安装了32位程序, 安装如下软件</span></span><br><span class="line">yum install glibc.i686</span><br><span class="line">yum install libstdc++.so.6</span><br></pre></td></tr></table></figure>

<h1 id="安装nfs客户端"><a href="#安装nfs客户端" class="headerlink" title="安装nfs客户端"></a>安装nfs客户端</h1><p>可以参考: <a href="https://www.howtoforge.com/nfs-server-and-client-on-centos-7">NFS server and client installation on CentOS 7</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装nfs工具, 服务器和客户端都装这个</span></span><br><span class="line">yum install nfs-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建用于mount的节点</span></span><br><span class="line">mkdir -p /mnt/nfs/study</span><br><span class="line">mkdir -p /mnt/nfs/work</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> rpcbind</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs-server</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs-lock       <span class="comment"># No such file or directory, 但没影响</span></span><br><span class="line">systemctl <span class="built_in">enable</span> nfs-idmap      <span class="comment"># No such file or directory</span></span><br><span class="line">systemctl start rpcbind</span><br><span class="line">systemctl start nfs-server</span><br><span class="line">systemctl start nfs-lock</span><br><span class="line">systemctl start nfs-idmap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动mount</span></span><br><span class="line">mount -t nfs 10.0.0.98:/study /mnt/nfs/study/</span><br><span class="line">mount -t nfs 10.0.0.98:/work /mnt/nfs/work/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认结果</span></span><br><span class="line">df -kh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置为开机自动加载</span></span><br><span class="line">vi /etc/fstab</span><br><span class="line">    <span class="comment"># ===== 文件内容, 加入如下两句 =====</span></span><br><span class="line">    10.0.0.98:/study   /mnt/nfs/study  nfs defaults 0 0</span><br><span class="line">    10.0.0.98:/work    /mnt/nfs/work   nfs defaults 0 0</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line"></span><br><span class="line">// 建立软连接(快捷方式)</span><br><span class="line"><span class="built_in">cd</span> /home/user/</span><br><span class="line">sudo ln -s /mnt/nfs/study study</span><br><span class="line">sudo ln -s /mnt/nfs/work work</span><br></pre></td></tr></table></figure>


<h1 id="安装-mkyaffs2image"><a href="#安装-mkyaffs2image" class="headerlink" title="安装 mkyaffs2image"></a>安装 mkyaffs2image</h1><p>该工具用于制作文件系统镜像文件<br>文件系统烧录到开发板flash时需要使用镜像文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp mkyaffs2image /bin/                         <span class="comment"># 拷贝到bin</span></span><br><span class="line">chmod +x /bin/mkyaffs2image                    <span class="comment"># 增加可执行权限</span></span><br><span class="line">mkyaffs2image                                       <span class="comment"># 测试是否可用</span></span><br></pre></td></tr></table></figure>


<h1 id="安装及使用交叉编译工具gcc"><a href="#安装及使用交叉编译工具gcc" class="headerlink" title="安装及使用交叉编译工具gcc"></a>安装及使用交叉编译工具gcc</h1><h2 id="安装-arm-linux-gcc-3-4-5"><a href="#安装-arm-linux-gcc-3-4-5" class="headerlink" title="安装 arm-linux-gcc-3.4.5"></a>安装 arm-linux-gcc-3.4.5</h2><p>使用指定的 <code>arm-linux-gcc-3.4.5-glibc-2.3.6</code>. 不要用新版本, 有坑.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 gcc</span></span><br><span class="line">mv arm-linux-gcc-3.4.5-glibc-2.3.6.tar.bz2 /usr/<span class="built_in">local</span>/arm/</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/arm/</span><br><span class="line">tar -xjf arm-linux-gcc-3.4.5-glibc-2.3.6.tar.bz2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加路径到环境变量</span></span><br><span class="line">vi /etc/bashrc</span><br><span class="line">    <span class="comment"># ===== 文件内容, 末尾加入如下语句 =====</span></span><br><span class="line">    <span class="keyword">if</span> [ -d /usr/<span class="built_in">local</span>/arm/gcc-3.4.5-glibc-2.3.6 ] ; <span class="keyword">then</span></span><br><span class="line">        PATH=/usr/<span class="built_in">local</span>/arm/gcc-3.4.5-glibc-2.3.6/bin:<span class="string">&quot;<span class="variable">$&#123;PATH&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试安装结果</span></span><br><span class="line"><span class="built_in">source</span> /etc/bashrc                          <span class="comment"># 不重启更新PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span>                                  <span class="comment"># 查看PATH</span></span><br><span class="line">arm-linux-gcc -v                            <span class="comment"># 测试是否安装成功</span></span><br></pre></td></tr></table></figure>

<h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><p>在centos下, 内核 make clean 会报错: Makefile‘混和的隐含和普通规则’<br>我想还是因为 2440 内核文件使用的makefile太老了. 和centos兼容性不好.<br>按下述方法改了一点后, 最后make还是失败了. 因而放弃 centos 系统.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改根目录下的 Makefile</span></span><br><span class="line">/ %/: prepare scripts FORCE</span><br><span class="line">    $(Q)$(MAKE) KBUILD_MODULES=$(<span class="keyword">if</span> $(CONFIG_MODULES),1) \</span><br><span class="line">    $(build)=$(build-dir)</span><br><span class="line"><span class="comment"># 改成： -----&gt;</span></span><br><span class="line">/: prepare scripts FORCE</span><br><span class="line">    $(Q)$(MAKE) KBUILD_MODULES=$(<span class="keyword">if</span> $(CONFIG_MODULES),1) \</span><br><span class="line">    $(build)=$(build-dir)</span><br><span class="line">%/: prepare scripts FORCE</span><br><span class="line">    $(Q)$(MAKE) KBUILD_MODULES=$(<span class="keyword">if</span> $(CONFIG_MODULES),1) \</span><br><span class="line">    $(build)=$(build-dir)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把：</span></span><br><span class="line">config %config: scripts_basic outputmakefile FORCE</span><br><span class="line">    $(Q)mkdir -p include/linux include/config</span><br><span class="line">    $(Q)$(MAKE) $(build)=scripts/kconfig <span class="variable">$@</span></span><br><span class="line"><span class="comment"># 改成： -----&gt;</span></span><br><span class="line">config: scripts_basic outputmakefile FORCE</span><br><span class="line">    $(Q)mkdir -p include/linux include/config</span><br><span class="line">    $(Q)$(MAKE) $(build)=scripts/kconfig <span class="variable">$@</span></span><br><span class="line">%config: scripts_basic outputmakefile FORCE</span><br><span class="line">    $(Q)mkdir -p include/linux include/config</span><br><span class="line">    $(Q)$(MAKE) $(build)=scripts/kconfig <span class="variable">$@</span></span><br></pre></td></tr></table></figure>





<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>environment</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式linux环境搭建1-Ubuntu14.04</title>
    <url>/2017/02/18/1706-linux-ubuntu14/</url>
    <content><![CDATA[<h1 id="环境及结论"><a href="#环境及结论" class="headerlink" title="环境及结论"></a>环境及结论</h1><ul>
<li>大环境的搭建思路可参考<a href="https://draapho.github.io/2017/02/16/1705-linux-env/">嵌入式linux环境搭建-主机端</a><ul>
<li>gateway ip <code>10.0.0.138</code></li>
<li>PC windows: win10 64bit, ip <code>10.0.0.98</code></li>
<li>PC linux(最终版本): ubuntu server 16.04 32 bit, ip <code>10.0.0.100</code></li>
<li>Embedded Linux: jz2440v3 ip <code>10.0.0.111</code></li>
</ul>
</li>
<li>探索嵌入式linux环境搭建的各方案可行性.</li>
<li>使用环境: Ubuntu 14.04.5 LTS 32bit 桌面版 (安装在win10的虚拟机内)</li>
<li>成功验证了win10作为NFS服务器. 两个linux作为NFS客户端, 三者文件共享的方案</li>
<li>最终遇到了gcc编译器的坑, 就决定换到CentOS系统练练手.</li>
<li>在win 10 下使用虚拟机安装在win10下, 略过不表.</li>
<li>实验结论:<ul>
<li>win10(非企业版)下, 没有找到nfs客户端. 因此没法使用 <strong>ubuntu做NFS服务器</strong> 的方案</li>
<li>ubuntu下安装samba来支持windows文件共享, 失败告终. 因此没法使用 <strong>ubuntu使用samba来支持windows文件共享</strong> 的方案</li>
<li>linux不允许把NFS挂载过来的文件再使用NFS服务共享出去. 因此没法使用 <strong>交叉使用上述方案</strong></li>
<li>还好, 最终 <strong>windows做NFS服务器</strong> 成功了</li>
</ul>
</li>
</ul>
<h1 id="安装必要的软件"><a href="#安装必要的软件" class="headerlink" title="安装必要的软件"></a>安装必要的软件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 make 和 gcc 工具 (非交叉编译用)</span></span><br><span class="line">make -v                     <span class="comment"># GNU Make 3.81</span></span><br><span class="line">gcc -v                      <span class="comment"># gcc version 4.8.4</span></span><br></pre></td></tr></table></figure>


<h1 id="设置静态IP"><a href="#设置静态IP" class="headerlink" title="设置静态IP"></a>设置静态IP</h1><p>个人更喜欢用静态IP, 这样putty的设置更直观方便.<br>如果要使用动态IP, 可以设置 windwos 的 HaneWIN, 用<code>-range</code>来指定nfs客户端的网址段</p>
<p>刚开始怎么样都不能上外网, 突然按照下面的顺序就好了… 原因不明</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/network/interfaces</span><br><span class="line">    <span class="comment"># ===== 文件内容, 大致修改如下: =====</span></span><br><span class="line">    auto lo</span><br><span class="line">    iface lo inet loopback</span><br><span class="line"></span><br><span class="line">    auto eth0</span><br><span class="line"></span><br><span class="line">    iface eth0 inet static</span><br><span class="line">    address  10.0.0.100</span><br><span class="line">    netmask  255.255.255.0</span><br><span class="line">    gateway  10.0.0.138</span><br><span class="line">    dns-nameservers   8.8.8.8  10.0.0.138</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line"></span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>

<h1 id="安装nfs服务-服务器-客户端"><a href="#安装nfs服务-服务器-客户端" class="headerlink" title="安装nfs服务(服务器/客户端)"></a>安装nfs服务(服务器/客户端)</h1><p>最终方案里, windows下用了HaneWIN 做NFS服务器, 虚拟机ubuntu下安装客户端就可以了.<br>这里为了做实验, nfs服务器和客户端都安装了, 可以参考:<br><a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-an-nfs-mount-on-ubuntu-14-04">How To Set Up an NFS Mount on Ubuntu 14.04</a></p>
<h2 id="nfs-客户端的安装"><a href="#nfs-客户端的安装" class="headerlink" title="nfs 客户端的安装"></a>nfs 客户端的安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 nfs 客户端软件</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nfs-common</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立空文件夹用于挂载nfs</span></span><br><span class="line">sudo mkdir -p /mnt/nfs/study</span><br><span class="line">sudo mkdir -p /mnt/nfs/work</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自动挂载(参考文章中的客户端自动挂载方法没有起作用)</span></span><br><span class="line">sudo vim /etc/rc.local</span><br><span class="line">    <span class="comment"># ===== 文件内容, 加入如下两句 =====</span></span><br><span class="line">    sudo mount 10.0.0.98:/study /mnt/nfs/study</span><br><span class="line">    sudo mount 10.0.0.98:/work /mnt/nfs/work</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立软连接(快捷方式), 可忽略此步骤</span></span><br><span class="line">sudo ln -s /mnt/nfs/study /home/user/study</span><br><span class="line">sudo ln -s /mnt/nfs/work /home/user/work</span><br></pre></td></tr></table></figure>

<h2 id="nfs-服务器的安装"><a href="#nfs-服务器的安装" class="headerlink" title="nfs 服务器的安装"></a><del>nfs 服务器的安装</del></h2><p>实际上没有用到linux的nfs服务器功能, 最终用的是windows下的HaneWIN给开发板提供的nfs服务!!!<br>因为最后测试下来, <strong>linux不允许把NFS挂载过来的文件再使用NFS服务共享出去</strong>.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 虚拟机ubuntu 安装服务器, 供开发板端使用nfs.</span></span><br><span class="line">apt-get install nfs-kernel-server</span><br><span class="line">sudo vim /etc/exports</span><br><span class="line">    <span class="comment"># ===== 文件内容, 末尾加入如下语句 =====</span></span><br><span class="line">    <span class="comment"># 加入要共享的文件夹, 一个文件夹一行即可</span></span><br><span class="line">    <span class="comment"># 注意! 由windows 共享过来的目录无法再由ubuntu共享出去</span></span><br><span class="line">    /home/draapho 10.0.0.*(rw,no_root_squash,async,no_subtree_check)</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">sudo exportfs -a</span><br><span class="line">sudo /etc/init.d/nfs-kernel-server restart</span><br></pre></td></tr></table></figure>

<h2 id="其它实验"><a href="#其它实验" class="headerlink" title="其它实验"></a><del>其它实验</del></h2><p>win10(非企业版)下, 没有找到nfs客户端. 因此无法让linux当nfs服务器, win10做nfs客户端.<br>ubuntu下安装samba来支持windows文件共享, 失败告终</p>
<h1 id="安装ssh服务-用putty远程登录"><a href="#安装ssh服务-用putty远程登录" class="headerlink" title="安装ssh服务, 用putty远程登录"></a>安装ssh服务, 用putty远程登录</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装ssh服务</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openssh-server</span><br><span class="line"><span class="comment"># 如果有依赖包冲突, 执行如下指令</span></span><br><span class="line">sudo apt-get install openssh-client=1:6.6p1-2ubuntu1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否已经运行</span></span><br><span class="line">sudo ps -e | grep ssh</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">sudo service ssh start</span><br></pre></td></tr></table></figure>

<h1 id="安装-u-boot-tools-工具"><a href="#安装-u-boot-tools-工具" class="headerlink" title="安装 u-boot-tools 工具"></a>安装 u-boot-tools 工具</h1><p>安装 u-boot-tools, 内核编译后生成uImage使用.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 mkimage</span></span><br><span class="line">sudo apt-get install u-boot-tools</span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">mkimage -V</span><br></pre></td></tr></table></figure>


<h1 id="安装-mkyaffs2image-工具"><a href="#安装-mkyaffs2image-工具" class="headerlink" title="安装 mkyaffs2image 工具"></a>安装 mkyaffs2image 工具</h1><p>该工具用于制作文件系统镜像文件<br>文件系统烧录到开发板flash时需要使用镜像文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp mkyaffs2image /bin/                         <span class="comment"># 拷贝到bin</span></span><br><span class="line">sudo chmod +x /bin/mkyaffs2image                    <span class="comment"># 增加可执行权限</span></span><br><span class="line">mkyaffs2image                                       <span class="comment"># 测试是否可用</span></span><br></pre></td></tr></table></figure>


<h1 id="安装及使用交叉编译工具gcc"><a href="#安装及使用交叉编译工具gcc" class="headerlink" title="安装及使用交叉编译工具gcc"></a>安装及使用交叉编译工具gcc</h1><p>在 arm-linux-gcc 4.3.2 上走的比较远, 结果证明遇到坑了!<br>建议不要尝试最新版本的编译器, 老老实实使用开发板提供的 <code>gcc-3.4.5-glibc-2.3.6</code> 编译器版本.</p>
<h2 id="安装-arm-linux-gcc-4-3-2"><a href="#安装-arm-linux-gcc-4-3-2" class="headerlink" title="安装 arm-linux-gcc 4.3.2"></a><del>安装 arm-linux-gcc 4.3.2</del></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接拷贝解压 arm-linux-gcc-4.3.2.tar.bz2</span></span><br><span class="line"><span class="comment"># 事后证明, gcc-4.3.2 不能正确编译(但能成功编译)2440的linux内核和驱动</span></span><br><span class="line">sudo tar xjvf arm-linux-gcc-4.3.2.tar.bz2 -C /usr/<span class="built_in">local</span>/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加路径到环境变量</span></span><br><span class="line">sudo vim /etc/bash.bashrc</span><br><span class="line">    <span class="comment"># ===== 文件内容, 末尾加入如下语句 =====</span></span><br><span class="line">    <span class="keyword">if</span> [ -d /usr/<span class="built_in">local</span>/arm/4.3.2 ] ; <span class="keyword">then</span></span><br><span class="line">        PATH=/usr/<span class="built_in">local</span>/arm/4.3.2/bin:<span class="string">&quot;<span class="variable">$&#123;PATH&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试安装结果</span></span><br><span class="line"><span class="built_in">source</span> /etc/bash.bashrc                             <span class="comment"># 不重启更新PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span>                                          <span class="comment"># 查看PATH</span></span><br><span class="line">arm-linux-gcc -v                                    <span class="comment"># 测试是否安装成功</span></span><br></pre></td></tr></table></figure>


<p>如果希望sudo超级账户也能用 make 指令 (没有测试过)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -s                                             <span class="comment"># 登录超级账户</span></span><br><span class="line">vi /etc/profile                                     <span class="comment"># 打开profile</span></span><br><span class="line">    <span class="comment"># ===== 文件内容, 末尾加入如下语句 =====</span></span><br><span class="line">    <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/arm/4.3.2/bin</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br></pre></td></tr></table></figure>

<h2 id="遇到问题并解决-结果是坑"><a href="#遇到问题并解决-结果是坑" class="headerlink" title="遇到问题并解决, 结果是坑"></a><del>遇到问题并解决, 结果是坑</del></h2><p>下面列出使用 <code>arm-linux-gcc 4.3.2</code> 编译u-boot遇到问题时的解决方法<br>所谓顺利, 是因为没有报错, 生成的文件可以烧录, 启动.<br>加上引号, 是因为最后证明这些生成文件是有问题的, 会导致整个嵌入式系统某些部分无法正常工作.<br>最后在编译测试驱动用的C文件时, 编译出来的可执行文件在开发板上不可执行,<br>才想到可能是编译器问题而尝试着换回到 3.4.5 版本. 并连同内核全部重新编译了.<br>换回去后, 之前一度认为的源码有问题的fs也能成功加载了, 真是个巨坑…</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果用gcc 4.3.2, 则版本太新, 编译错误. 可以使用自带的arm-none-linux-gnueabi</span></span><br><span class="line"><span class="comment"># 解决方法如下:</span></span><br><span class="line"><span class="comment"># 修改Makefile文件中的PLATFORM_LIBS, 将:</span></span><br><span class="line">PLATFORM_LIBS += -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -lgcc</span><br><span class="line"><span class="comment"># 修改成:</span></span><br><span class="line">PLATFORM_LIBS += -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -lgcc -lc -L /usr/<span class="built_in">local</span>/arm/4.3.2/arm-none-linux-gnueabi/libc/armv4t/usr/lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 cpu /arm920t/config.mk 文件, 将:</span></span><br><span class="line">PLATFORM_CPPFLAGS +=$(call cc-option,-mapcs-32,-mabi=apcs-gnu)</span><br><span class="line">PLATFORM_RELFLAGS +=$(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,))</span><br><span class="line"><span class="comment"># 修改成:</span></span><br><span class="line">PLATFORM_CPPFLAGS +=$(call cc-option,)</span><br><span class="line">PLATFORM_RELFLAGS +=$(call cc-option,$(call cc-option,))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新make, 即可生成 u-boot.bin</span></span><br></pre></td></tr></table></figure>


<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>environment</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式linux环境搭建3-Ubuntu16.04</title>
    <url>/2017/02/20/1706-linux-ubuntu16/</url>
    <content><![CDATA[<h1 id="环境及结论"><a href="#环境及结论" class="headerlink" title="环境及结论"></a>环境及结论</h1><ul>
<li>大环境的搭建思路可参考<a href="https://draapho.github.io/2017/02/16/1705-linux-env/">嵌入式linux环境搭建-主机端</a><ul>
<li>gateway ip <code>10.0.0.138</code></li>
<li>PC windows: win10 64bit, ip <code>10.0.0.98</code></li>
<li>PC linux(最终版本): ubuntu server 16.04 32 bit, ip <code>10.0.0.100</code></li>
<li>Embedded Linux: jz2440v3 ip <code>10.0.0.111</code></li>
</ul>
</li>
<li>使用环境: Ubuntu server 16.04 32bit (安装在win10的虚拟机内)</li>
<li>在经历了两次失败后, 成功搭建了整个环境. 服务器版去掉了UI, 给虚拟机用很好.</li>
<li>补充一点, 刚开始用的是 ubuntu server 16.04 64 bit, 也遇到点问题.<br>由于是要做交叉编译的开发环境, 所以 PC linux 和 embedded linux 用一样的带宽才好.</li>
</ul>
<h1 id="apt-get使用摘要"><a href="#apt-get使用摘要" class="headerlink" title="apt-get使用摘要"></a>apt-get使用摘要</h1><ul>
<li>软件升级: <code>sudo apt-get update</code></li>
<li>普通安装: <code>apt-get install softname1 softname2 ...</code></li>
<li>修复安装： <code>apt-get -f install softname1 softname2...</code>  (-f Atemp to correct broken dependencies)</li>
<li>重新安装： <code>apt-get --reinstall install softname1 softname2...</code></li>
<li>移除式卸载(保留配置)： <code>apt-get remove softname1 softname2 ...</code></li>
<li>清除式卸载(删除配置)： <code>apt-get --purge remove softname1 softname2...</code><br>或 <code>apt-get purge sofname1 softname2...</code></li>
</ul>
<h1 id="安装必要的软件"><a href="#安装必要的软件" class="headerlink" title="安装必要的软件"></a>安装必要的软件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 make</span></span><br><span class="line">sudo apt-get install make</span><br><span class="line">make -v                     <span class="comment"># GNU Make 4.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装gcc, 非交叉编译用</span></span><br><span class="line">sudo apt-get install gcc</span><br><span class="line">gcc -v                      <span class="comment"># gcc version 5.4.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置时区</span></span><br><span class="line">sudo dpkg-reconfigure tzdata</span><br></pre></td></tr></table></figure>


<h1 id="安装32bit兼容库"><a href="#安装32bit兼容库" class="headerlink" title="安装32bit兼容库"></a><del>安装32bit兼容库</del></h1><p>不要安装 64bit 的ubuntu作为交叉编译的linux环境. 我最后换回到了32bit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ia32-libs      <span class="comment"># 提示不可用, 替代方案如下</span></span><br><span class="line">sudo apt-get install lib32ncurses5</span><br></pre></td></tr></table></figure>


<h1 id="设置静态IP"><a href="#设置静态IP" class="headerlink" title="设置静态IP"></a>设置静态IP</h1><p>个人更喜欢用静态IP, 这样putty的设置更直观方便.<br>如果要使用动态IP, 可以设置 windwos 的 HaneWIN, 用<code>-range</code>来指定nfs客户端的网址段</p>
<p>刚开始怎么样都不能上外网, 突然按照下面的顺序就好了… 原因不明</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/network/interfaces</span><br><span class="line">    <span class="comment"># ===== 文件内容, 大致修改如下: =====</span></span><br><span class="line">    auto lo</span><br><span class="line">    iface lo inet loopback</span><br><span class="line"></span><br><span class="line">    auto eth0</span><br><span class="line"></span><br><span class="line">    iface eth0 inet static</span><br><span class="line">    address  10.0.0.100</span><br><span class="line">    netmask  255.255.255.0</span><br><span class="line">    gateway  10.0.0.138</span><br><span class="line">    dns-nameservers   8.8.8.8  10.0.0.138</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可装完ssh服务再重启. 然后验证putty是否可用.</span></span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>


<h1 id="安装ssh服务-用putty远程登录"><a href="#安装ssh服务-用putty远程登录" class="headerlink" title="安装ssh服务, 用putty远程登录"></a>安装ssh服务, 用putty远程登录</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装ssh服务</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openssh-server</span><br><span class="line"><span class="comment"># 如果有依赖包冲突, 执行如下指令</span></span><br><span class="line">sudo apt-get install openssh-client=1:6.6p1-2ubuntu1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否已经运行</span></span><br><span class="line">sudo ps -e | grep ssh</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">sudo service ssh start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启后, 验证是否能用putty功能</span></span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>


<h1 id="nfs-客户端的安装"><a href="#nfs-客户端的安装" class="headerlink" title="nfs 客户端的安装"></a>nfs 客户端的安装</h1><p>参考: <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-an-nfs-mount-on-ubuntu-14-04">How To Set Up an NFS Mount on Ubuntu 14.04</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 nfs 客户端软件</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nfs-common</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立空文件夹用于挂载nfs</span></span><br><span class="line">sudo mkdir -p /mnt/nfs/study</span><br><span class="line">sudo mkdir -p /mnt/nfs/work</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自动挂载(参考文章中的客户端自动挂载方法没有起作用)</span></span><br><span class="line">sudo vim /etc/rc.local</span><br><span class="line">    <span class="comment"># ===== 文件内容, 加入如下两句 =====</span></span><br><span class="line">    sudo mount 10.0.0.98:/study /mnt/nfs/study</span><br><span class="line">    sudo mount 10.0.0.98:/work /mnt/nfs/work</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立软连接(快捷方式), 可忽略此步骤</span></span><br><span class="line"><span class="built_in">cd</span> /home/user/</span><br><span class="line">sudo ln -s /mnt/nfs/study study</span><br><span class="line">sudo ln -s /mnt/nfs/work work</span><br></pre></td></tr></table></figure>


<h1 id="安装交叉编译工具gcc"><a href="#安装交叉编译工具gcc" class="headerlink" title="安装交叉编译工具gcc"></a>安装交叉编译工具gcc</h1><p>老老实实使用开发板提供的 <code>gcc-3.4.5-glibc-2.3.6</code> 编译器版本.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接拷贝解压 gcc-3.4.5-glibc-2.3.6.tar.bz2</span></span><br><span class="line">sudo tar xjf arm-linux-gcc-3.4.5-glibc-2.3.6.tar.bz2 -C /usr/<span class="built_in">local</span>/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加路径到环境变量</span></span><br><span class="line">sudo vim /etc/bash.bashrc</span><br><span class="line">    <span class="comment"># ===== 文件内容, 末尾加入如下语句 =====</span></span><br><span class="line">    <span class="keyword">if</span> [ -d /usr/<span class="built_in">local</span>/gcc-3.4.5-glibc-2.3.6 ] ; <span class="keyword">then</span></span><br><span class="line">        PATH=/usr/<span class="built_in">local</span>/gcc-3.4.5-glibc-2.3.6/bin:<span class="string">&quot;<span class="variable">$&#123;PATH&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试安装结果</span></span><br><span class="line"><span class="built_in">source</span> /etc/bash.bashrc                             <span class="comment"># 不重启更新PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span>                                          <span class="comment"># 查看PATH</span></span><br><span class="line">arm-linux-gcc -v                                    <span class="comment"># 测试是否安装成功</span></span><br></pre></td></tr></table></figure>


<h1 id="安装-u-boot-tools-工具"><a href="#安装-u-boot-tools-工具" class="headerlink" title="安装 u-boot-tools 工具"></a>安装 u-boot-tools 工具</h1><p>安装 u-boot-tools, 内核编译后生成uImage使用.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 mkimage</span></span><br><span class="line">sudo apt-get install u-boot-tools</span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">mkimage -V              <span class="comment"># mkimage version 2016.01+dfsg1-2ubuntu1</span></span><br></pre></td></tr></table></figure>


<h1 id="安装-mkyaffs2image-工具"><a href="#安装-mkyaffs2image-工具" class="headerlink" title="安装 mkyaffs2image 工具"></a>安装 mkyaffs2image 工具</h1><p>该工具用于制作文件系统镜像文件<br>文件系统烧录到开发板flash时需要使用镜像文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp mkyaffs2image /bin/                         <span class="comment"># 拷贝到bin</span></span><br><span class="line">sudo chmod +x /bin/mkyaffs2image                    <span class="comment"># 增加可执行权限</span></span><br><span class="line">mkyaffs2image                                       <span class="comment"># 测试是否可用</span></span><br></pre></td></tr></table></figure>

<h1 id="安装-dnw-工具"><a href="#安装-dnw-工具" class="headerlink" title="安装 dnw 工具"></a>安装 dnw 工具</h1><p>该工具用于配合uboot进行烧录, 无需驱动, 无需额外烧录器, 简单方便</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp dnw /bin/                                   <span class="comment"># 拷贝到bin</span></span><br><span class="line">sudo chmod +x /bin/dnw                              <span class="comment"># 增加可执行权限</span></span><br><span class="line">dnw                                                 <span class="comment"># 测试是否可用</span></span><br></pre></td></tr></table></figure>

<h1 id="安装-ncurses-基本库"><a href="#安装-ncurses-基本库" class="headerlink" title="安装 ncurses 基本库"></a>安装 ncurses 基本库</h1><p>ncurses是字符终端下屏幕控制的基本库, <code>make menuconfig</code> 需要使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装ncurses</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libncurses5-dev libncursesw5-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否成功</span></span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>


<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>environment</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 初学笔记</title>
    <url>/2017/02/23/1708-docker/</url>
    <content><![CDATA[<h1 id="Docker-总览"><a href="#Docker-总览" class="headerlink" title="Docker 总览"></a>Docker 总览</h1><h2 id="几个重要概念"><a href="#几个重要概念" class="headerlink" title="几个重要概念"></a>几个重要概念</h2><ul>
<li>Docker: 是一种容器技术, 可以提供虚拟服务. 物理上共享主机的硬件和网络资源.<br>相比于虚拟机技术, 它轻巧, 快速, 便捷, 跨平台, 易于分配发布. 又同时拥有虚拟机的优点!<br>由于以上特点, 目前docker的容器有蚕食传统软件的趋势: 提供服务时, 给的是docker镜像或容器而非传统的安装软件!<br>譬如, 我学习docker的初衷就是: <strong>一劳永逸的制作一个用于开发2440系列编译环境的pc linux系统</strong><br>可以看出, 我需求就是提供编译服务. 传统的安装软件无法简单的实现, 但docker可以! (目前用的vm, 太重太麻烦)</li>
<li>Union FS (分层存储): 本质是增量管理. 基于原有的运行系统, 执行某些命令后, 把新产生的文件作为增量新建一层文件.<br>直观感受一下, 是这样的:<br><img src="https://draapho.github.io/images/1708/docker-aufs.jpg" alt="docker-aufs"></li>
<li><strong>images (镜像)</strong>: docker 以镜像为基础. 镜像是只读的, 不包含任何动态数据, 内容不可更改!<br>基于基础镜像, 可以在加入自己需要的app和服务后, 打包成自己的具有特殊功能的镜像.</li>
<li><strong>container (容器)</strong>: 容器就是镜像运行时的实体 (类似于类和实例的关系).<br>容器必须基于镜像运行. 可以基于同一个镜像创建多个容器, 来实现不同的功能或服务.<br>容器可以被创建, 启动, 停止, 删除, 暂停等等<br>容器的本质就是进程, 运行时实现某种功能, 只是这个进程的上下文用的是虚拟化的镜像环境.</li>
<li><strong>Docker Registry (仓库)</strong>: 用于存储, 分发镜像的仓库.<br>其中 <a href="https://hub.docker.com/">Docker Hub</a> 就是官方的镜像仓储服务.<br>其运行模式和 <a href="https://github.com/">github</a> 一样, 公开资料免费, 私有资料收费<br>当然, 也可以建立自己的私有 Docker Registry</li>
<li><strong>Docker Volume</strong>, Docker的数据服务.<br>docker 体系要让自己表现更像应用程序, 就离不开对数据的存储和隔离.<br>而docker容器是非持久化的, 可以随时创建和删除, 无法满足数据存储的基本要求.<br>因此提供了Docker Volume. 包括 data volume 和 data volume container</li>
</ul>
<h2 id="docker的技术架构"><a href="#docker的技术架构" class="headerlink" title="docker的技术架构"></a>docker的技术架构</h2><p><img src="https://draapho.github.io/images/1708/docker-structure.jpg" alt="docker-structure"></p>
<ul>
<li>Docker Client / Docker Daemon: 用户和Docker的交互使用的是C/S模式.<br>用户作为客户端使用 http 服务和 Docker Daemon 进行交互</li>
<li>Engine 和 Job: Job本质就是进程. 基于容器, 运行任务.<br>譬如, 对 Docker Registry 的操作就是作为一个job任务实现的.</li>
<li>Docker Registry: 用于存储, 分发镜像的仓库</li>
<li>Graph: Graph对已下载Docker镜像进行保管, 并对已下载容器镜像之间关系进行记录.<br>Graph不但要存储本地具有版本信息的文件系统镜像,<br>而且还要通过GraphDB记录所有文件系统镜像彼此之间的关系</li>
<li>Driver: 驱动模块. Driver驱动主要作用是实现对Docker容器进行环境的定制</li>
<li>Docker container: Docker容器是Docker架构中服务交付的最终体现形式<br>Docker按照业务的需求, 依赖关系和配置文件打包相应的Docker容器</li>
</ul>
<h2 id="初步评估结论"><a href="#初步评估结论" class="headerlink" title="初步评估结论"></a>初步评估结论</h2><ul>
<li>感觉docker 的野心和潜力都很大. 如镜像管理, 跨平台, 容器应用化, 功能化, 服务化.</li>
<li>可以看出主要发展方向是网络和云方面的 (新的项目都是针对网络集群的).</li>
<li>基本已经可以跨平台使用(Docker machine).</li>
<li>我的初衷就是: <strong>一劳永逸的制作一个用于开发2440系列编译环境的pc linux系统</strong><br>就此而言, docker可用, 但初始配置并不轻松.<br>因此暂不急于使用docker来配置这么一个主机编译环境.</li>
</ul>
<h1 id="Docker-的安装"><a href="#Docker-的安装" class="headerlink" title="Docker 的安装"></a>Docker 的安装</h1><p>全程参考官网<br><a href="https://docs.docker.com/engine/getstarted/">Get started with Docker</a></p>
<h2 id="Windows-10-64bit-直接安装"><a href="#Windows-10-64bit-直接安装" class="headerlink" title="Windows 10 64bit 直接安装"></a>Windows 10 64bit 直接安装</h2><p>可直接下载安装 docker, 无需安装在虚拟机下面. 家中的win10是家庭版, 但也能正常安装运行docker.</p>
<p>使用默认设置就能运行, 说一下文件共享. 譬如勾选 <code>E</code> 盘共享后, shell 应该这样用:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker下, 显示E盘全部内容</span></span><br><span class="line">docker run -v e:/:/data alpine ls /data</span><br><span class="line"><span class="comment"># e:/       表示使能的windows e盘.</span></span><br><span class="line"><span class="comment"># :/data    docker容器下, 加载为 /data 目录</span></span><br><span class="line"><span class="comment"># alpine    一个小巧的linux内核, 基于此内核运行指令. 改为ubuntu效果也是一样的</span></span><br><span class="line"><span class="comment"># ls /data  在屏幕上列出 /data (就是e盘) 的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此, 官网范例表示, 显示 c:/Users 下的内容</span></span><br><span class="line">docker run -v c:/Users:/data alpine ls /data</span><br></pre></td></tr></table></figure>

<h2 id="ToolBox-基于虚拟机的安装"><a href="#ToolBox-基于虚拟机的安装" class="headerlink" title="ToolBox 基于虚拟机的安装"></a>ToolBox 基于虚拟机的安装</h2><p>参考<a href="https://docs.docker.com/toolbox/toolbox_install_windows/">Install Docker Toolbox on Windows</a></p>
<ul>
<li>机器要求: 64bit 操作系统, 支持并使能IVT虚拟技术</li>
<li>Windows Vista 及以上版本, 安装默认的 NDIS6 driver 即可.</li>
<li>Windows 7 和 Windows XP, 安装时勾选 <strong>NDIS5 driver</strong></li>
<li>里面也提到了卸载ToolBox时, 如何先删除虚拟机里的 dock-machine</li>
</ul>
<p>使用虚拟机后的文件共享很简单, 在 <code>VirtualBox</code>-&gt;<code>Settings</code>-&gt;<code>Shared Folders</code> 直接修改好就行了.</p>
<p>使用 putty 登录docker虚拟机</p>
<ul>
<li>不太喜欢 Docker Quickstart Terminal 提供的终端, 用起来不顺手(不能用鼠标, 不能复制黏贴)<br>不过只有在这个终端里, 能直接使用 <code>docker-machine</code> 相关的指令</li>
<li>自己使用ConEmu统一了终端, 里面集成好putty. 因此需要使用ssh.</li>
<li>获取 boot2docker 的IP地址.<br>运行 Docker Quickstart Terminal 成功后, 终端上可以找到这样一句话<br><code>docker is configured to use the default machine with IP 10.0.0.100</code><br>或者, 输入 <code>docker-machine ls</code>, 找到其IP地址. 譬如 <code>tcp://10.0.0.100:2376</code><br>或者, 直接登录boot2docker虚拟机, 输入指令 <code>ifconfig</code> 查看IP地址.<code>10.0.0.100</code></li>
<li>boot2docker的登录名默认就是 <code>docker</code>. 如果需要密码的话, 应该是 <code>tcuser</code></li>
<li>运行过 Docker Quickstart Terminal 后, docker自动生成了ssh密钥.<br>一般存储在 <code>C:\Users\my_name\.docker\machine\machines\default\ </code> 或者 <code>%HOMEPATH%\.ssh</code>下面<br><code>id_rsa</code> 是私钥, <code>id_rsa.pub</code> 是公钥</li>
<li>打开 <code>puttygen.exe</code>-&gt;<code>Load an existing private key file</code>-&gt;<code>Load</code>-&gt;选择文件格式为 <code>All Files (*.*)</code>-&gt;选择<code>id_rsa</code>-&gt;弹出框 <code>OK</code><br>接着 <code>puttygen.exe</code> 主界面下-&gt;<code>Save private key</code>-&gt;保存为<code>id_rsa.ppk</code></li>
<li>打开 <code>putty.exe</code>-&gt;左边<code>Connection</code>-&gt;<code>SSH</code>-&gt;<code>Auth</code>-&gt;右边<code>Private key file for authentication</code>-&gt;<code>Browse...</code>-&gt;选择<code>id_rsa.ppk</code><br>接着 <code>putty.exe</code>-&gt;左边<code>Session</code>-&gt;右边<code>Connection type:</code>点选<code>SSH</code>-&gt;<code>Host Name (or IP address)</code>填如<code>docker@10.0.0.100</code>-&gt;<code>Port</code>填入<code>22</code><br>最后 <code>Saved Sessions</code> 填入期望的名称如 <code>boot2docker</code>-&gt;<code>Save</code>-&gt;<code>Open</code>-&gt;连接成功!</li>
</ul>
<h1 id="Docker-常用指令"><a href="#Docker-常用指令" class="headerlink" title="Docker 常用指令"></a>Docker 常用指令</h1><p>可参考:</p>
<ul>
<li><a href="http://www.dockerinfo.net/341.html">Docker命令指令详情-持续更新</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/install/ubuntu.html">Docker — 从入门到实践</a></li>
</ul>
<h2 id="镜像指令"><a href="#镜像指令" class="headerlink" title="镜像指令"></a>镜像指令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从 Docker Hub 获取 ubuntu 16.04 的镜像</span></span><br><span class="line">docker pull ubuntu:16.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有镜像</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 ubuntu</span></span><br><span class="line">docker run -it --rm ubuntu:16.04 bash</span><br><span class="line"><span class="comment"># -it： -i, 交互式操作; -t, 显示终端</span></span><br><span class="line"><span class="comment"># --rm： 容器退出后随之将其删除 (不建议)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器里输入一些指令后, 查看容器的变化</span></span><br><span class="line">docker diff ubuntu:16.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用commit制作的进行成为黑箱镜像, 如果开源发布, 人们会有安全性的担忧(无法知道到底做了什么)</span></span><br><span class="line"><span class="comment"># 将当前容器制作为镜像 (会把容器内的变动新增一层文件)</span></span><br><span class="line">docker commit --message <span class="string">&quot;2440 compiler&quot;</span> container_ID_or_name ubuntu:2440</span><br><span class="line"><span class="comment"># --message: 可省, 记录本次修改的内容</span></span><br><span class="line"><span class="comment"># contain_ID_or_name: 使用 &#x27;docker ps -a&#x27; 可查看所有容器信息</span></span><br><span class="line"><span class="comment"># ubuntu:2440 目标镜像:标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像历史记录</span></span><br><span class="line">docker <span class="built_in">history</span> ubuntu:2440</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存镜像 (本地文件)</span></span><br><span class="line">docker save ubuntu:2440 | gzip &gt; ubuntu-2440.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载镜像 (本地文件)</span></span><br><span class="line">docker load -i ubuntu-2440.tar.gz</span><br><span class="line"><span class="comment"># 相比后面的 &#x27;docker import&#x27;, 镜像存储文件保存完整记录, 体积要大.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker rmi ubuntu:2440</span><br><span class="line"><span class="comment"># ubuntu:2440 目标镜像:标签. 这里也可以用镜像ID代替(短ID也行)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有在 &#x27;mongo:3.2&#x27; 之前的镜像 (windows下不可用)</span></span><br><span class="line">docker rmi $(docker images -q -f before=mongo:3.2)</span><br></pre></td></tr></table></figure>


<h2 id="容器指令"><a href="#容器指令" class="headerlink" title="容器指令"></a>容器指令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出 &quot;hello world&quot;</span></span><br><span class="line">docker run ubuntu <span class="built_in">echo</span> <span class="string">&#x27;Hello world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 ubuntu</span></span><br><span class="line">docker run -it ubuntu:16.04 bash</span><br><span class="line"><span class="comment"># -it： -i, 交互式操作; -t, 显示终端</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line">docker run -d ubuntu sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br><span class="line"><span class="comment"># 会返回container的ID号</span></span><br><span class="line"><span class="comment"># -d: 后台运行, 不输出结果到主机界面上</span></span><br><span class="line"><span class="comment"># sh -c: 作为sh文件执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取容器的输出信息</span></span><br><span class="line">docker logs container_ID_or_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器信息 (print server)</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment"># -a 表示显示所有容器状态(包括终止状态)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器的终止,启动和重启</span></span><br><span class="line">docker stop container_ID_or_name</span><br><span class="line">docker start container_ID_or_name</span><br><span class="line">docker restart container_ID_or_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入指定容器</span></span><br><span class="line">docker attach container_ID_or_name</span><br><span class="line"><span class="comment"># attach 在多窗口时很不方便. 参考资料推荐的是nsenter (windows下不可用)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出容器</span></span><br><span class="line">docker <span class="built_in">export</span> container_ID_or_name &gt; ubuntu.tar</span><br><span class="line"><span class="comment"># 导入容器快照到本地镜像库</span></span><br><span class="line">cat ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1.0</span><br><span class="line"><span class="comment"># 相比前面的 &#x27;docker load&#x27;, 容器快照将丢弃历史记录. 另外, 可以重新指定标签.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker rm container_ID_or_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有容器 (windows下不可用)</span></span><br><span class="line">docker rm $(docker ps -qa)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取某个容器的PID信息 (windows下不可用)</span></span><br><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123; .State.Pid &#125;&#125;&#x27;</span> container_ID_or_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取某个容器的 IP 地址 (windows下不可用)</span></span><br><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27;</span> container_ID_or_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目前 Docker 并没有提供直接的对容器 IP 地址的管理支持</span></span><br></pre></td></tr></table></figure>

<h2 id="其它指令和功能"><a href="#其它指令和功能" class="headerlink" title="其它指令和功能"></a>其它指令和功能</h2><p><a href="https://yeasy.gitbooks.io/docker_practice/content/install/ubuntu.html">Docker — 从入门到实践</a></p>
<ul>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/image/build.html">使用 Dockerfile 定制镜像</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/image/dockerfile/">Dockerfile 指令详解</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/dockerhub.html">Docker Hub 基本操作及自动创建</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/local_repo.html">Docker Registry 构建私有仓库</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/data_management/volume.html">Docker Volumn 数据卷的操作</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/data_management/container.html">Docker Volumn Container 数据卷容器的操作</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/network/port_mapping.html">使用网络-外部访问容器</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/network/linking.html">使用网络-容器互联</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/advanced_network/">高级网络配置</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/advanced_network/quick_guide.html">高级网络配置-网络相关命令列表</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/appendix/faq/">常见问题总结</a></li>
</ul>
<h1 id="资料和参考"><a href="#资料和参考" class="headerlink" title="资料和参考"></a>资料和参考</h1><p><a href="https://yeasy.gitbooks.io/docker_practice/content/install/ubuntu.html">Docker — 从入门到实践</a><br><a href="http://www.dockerinfo.net/2117.html">Docker技术架构详细分析 Docker模块分析</a><br><a href="http://wiki.jikexueyuan.com/project/docker/installation/windows.html">Microsoft Windows 安装docker</a><br><a href="http://www.dockerinfo.net/341.html">Docker命令指令详情-持续更新</a></p>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>快速读懂 makefile</title>
    <url>/2017/04/04/1709-linux-makefile/</url>
    <content><![CDATA[<p><em><strong>转载自 <a href="http://lucky521.github.io/blog/design/2015/10/01/makefile.html">怎么看懂和编写makefile</a></strong></em><br><em><strong>转载自 <a href="http://lucky521.github.io/blog/design/2015/10/01/makefile.html">跟我一起写Makefile</a></strong></em></p>
<hr>
<h1 id="Makefile最基本的组成"><a href="#Makefile最基本的组成" class="headerlink" title="Makefile最基本的组成"></a>Makefile最基本的组成</h1><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">target: dependencies</span></span><br><span class="line">[TAB] command</span><br><span class="line"></span><br><span class="line"><span class="section">目标: 依赖1 依赖2</span></span><br><span class="line">[TAB] 命令</span><br></pre></td></tr></table></figure>
<ul>
<li><code>target</code> 可以是object文件，也可以是可执行文件，也可以是target关键字。<br> 可以一次写多个文件作为同一批次的target。</li>
<li><code>dependencies</code> 有的是源文件，有的是链接文件，如果没有的话可以不写；<br> 想要编target必须先准备好dependencies。</li>
<li><code>clean</code> 是一个特殊的target，一般要做的是rm清理工作；</li>
<li><code>make</code>命令在执行的时候会检查目标文件是否存在, 并比较target文件和dependencies文件的修改日期，<br>如果存在更新的dependencies文件，那么对应的command就会执行，否则的话就不执行，还使用已存在target文件。</li>
<li><code>command</code> 必须要以<code>TAB</code>来对齐， 一般会是gcc/g++的编译命令；</li>
<li>细化到模块一般会有若干个分支target，形成层级的target依赖关系。</li>
</ul>
<p>举个例子:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译和链接一起做了, 看不到中间的.o目标文件</span></span><br><span class="line"><span class="section">hello: hello.c a.c</span></span><br><span class="line">    gcc -o hello hello.c a.c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于大型系统, 更推荐的是编译和链接分开, 如下:</span></span><br><span class="line"><span class="section">hello: hello.o a.o                  # 可执行文件hello 依赖于 hello.o 和 a.o</span></span><br><span class="line">    gcc -o hello hello.o a.o        <span class="comment"># 执行链接</span></span><br><span class="line"></span><br><span class="line"><span class="section">hello.o: hello.c                    # 目标文件依赖于hello.c</span></span><br><span class="line">    gcc -o hello.o -c hello.c       <span class="comment"># 编译出目标文件</span></span><br><span class="line"></span><br><span class="line">a.o : a.c                           <span class="comment"># 另一个目标文件</span></span><br><span class="line">    gcc -o a.o -c a.c               <span class="comment"># -o: object 目标文件, -c: compile 编译</span></span><br></pre></td></tr></table></figure>

<h1 id="隐形规则和变量"><a href="#隐形规则和变量" class="headerlink" title="隐形规则和变量"></a>隐形规则和变量</h1><p>为了使得makefile的内容尽量少一些废话，GNU为makefile加入了一些约定的规则。</p>
<ul>
<li>如果<code>target</code>文件的名称是<code>aa.o</code>，那么make会主动的把同名的源代码文件（如<code>aa.c</code>,<code>aa.cpp</code>）加入到依赖中去。</li>
<li><code>target</code> 和 <code>dependencies</code> 处: 用 <code>%</code> 通配任意的非空字符串</li>
<li><code>command</code> 处: <code>$@</code>目标文件, <code>$&lt;</code>依赖1, <code>$^</code>所有的依赖文件, <code>$?</code>比目标文件新的依赖. 这三个叫自动变量.</li>
<li>变量在定义或被赋值时不加$()，在使用其值时要加 <code>$()</code></li>
<li>常用<code>$(CC)</code>来代替具体的编译器，比如 <code>CC=g++</code></li>
<li>常用<code>$(CFLAGS)</code>来代替C语言编译选项，比如 <code>CFLAGS=-c -Wall</code><br>还会指定头文件include路径，比如 <code>CFLAGS+=-I/usr/include</code></li>
<li>常用<code>$(LDFLAGS)</code>来指定库文件lib路径，比如 <code>LDFLAGS+=-L/usr/lib</code></li>
<li>常用<code>$(LDLIBS)</code>来指定要链接的库名称，比如 <code>LDLIBS+=-llibname</code></li>
</ul>
<p>修改上面的例子:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先使用通配符 % 及自动变量</span></span><br><span class="line"><span class="section">hello: hello.o a.o</span></span><br><span class="line">    gcc -o <span class="variable">$@</span> <span class="variable">$^</span>                    <span class="comment"># $@ 表示hello, $^ 表示两个.o文件</span></span><br><span class="line"></span><br><span class="line">%.o : %.c                           <span class="comment"># 对应了hello.o 和 a.o 两条语句!</span></span><br><span class="line">    gcc -o <span class="variable">$@</span> -c <span class="variable">$&lt;</span>                 <span class="comment"># $@ 表示 .o 文件, $&lt; 表示第一个依赖, 即 .c 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后使用更多的变量 $()</span></span><br><span class="line"><span class="section">hello: hello.o a.o</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span>                  <span class="comment"># CC=gcc, 因此 $(CC)表示gcc</span></span><br><span class="line"></span><br><span class="line">%.o : %.c                           <span class="comment"># 使用更多的编译参数变量</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>

<h1 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h1><p><code>.PHONY</code> 经常被用来作为伪目标。 它的使用目的是这样的：<br>因为当类似clean这样的target关键字作为target并且没有依赖文件时，<br>假如目录下有一个文件也叫clean时，make clean命令则会以为我想编clean这个目标文件，<br>恰好clean文件又不会比依赖文件更旧，所以下面的command就不会被执行。</p>
<p>现在我们用.PHONY作为target，clean作为依赖。<br>这就是告诉make，clean它是一个target，而不是一个普通的文件。</p>
<p>加入 clean 的例子:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">hello: hello.o a.o                          # 执行文件hello, 依赖于.o文件</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span>                          <span class="comment"># 进行链接</span></span><br><span class="line"></span><br><span class="line">%.o : %.c                                   <span class="comment"># 目标文件.o 依赖于同名的.c文件</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> <span class="comment"># 编译出目标文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:                                      # 目标指令, 可调用 make clean 来执行了!</span></span><br><span class="line">    rm -rf *.o                              <span class="comment"># 删除所有的.o文件</span></span><br></pre></td></tr></table></figure>

<h1 id="文件引用和条件判断"><a href="#文件引用和条件判断" class="headerlink" title="文件引用和条件判断"></a>文件引用和条件判断</h1><ul>
<li>如果makefile中引入其他makefile， 使用 <code>include</code> 即可</li>
<li>条件语句的基本结构一般由 <code>ifeq</code> <code>else</code> <code>endif</code> 三个关键字组成</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> another.mk                          <span class="comment"># 调用 another.mk</span></span><br><span class="line"><span class="keyword">include</span> foo *.mk <span class="variable">$(bar)</span>                     <span class="comment"># 更复杂的调用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libs_for_gcc = -lgnu                        <span class="comment"># 变量赋值</span></span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)                            <span class="comment"># 条件判断 $(CC) 是否为gcc</span></span><br><span class="line">    libs=<span class="variable">$(libs_for_gcc)</span>                    <span class="comment"># 变量赋值</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    libs=<span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span>                             # 目标: 依赖</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span> <span class="comment"># 执行的命令</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<h1 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h1><p>函数调用，很像变量的使用，也是以“$”来标识的，有两种语法, 如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">$(&lt;function&gt; &lt;arguments&gt;)</span><br><span class="line">$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>还是来看一个示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">comma := ,</span><br><span class="line">empty :=</span><br><span class="line">space := <span class="variable">$(empty)</span> <span class="variable">$(empty)</span></span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= <span class="variable">$(<span class="built_in">subst</span> <span class="variable">$(space)</span>,<span class="variable">$(comma)</span>,<span class="variable">$(foo)</span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>$(bar)</code>调用了函数一个函数.<ul>
<li>函数    : <code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</code>, 相当于c语言的 <code>subst(from, to, text)</code></li>
<li>参数from: <code>$(comma)</code> 的值是一个逗号</li>
<li>参数to  : <code>$(space)</code> 使用了 <code>$(empty)</code> 定义了一个空格</li>
<li>参数text: <code>$(foo)</code>   的值是 “a b c”</li>
</ul>
</li>
<li>这个函数是把$(foo)中的空格替换成逗号，所以$(bar)的值是“a,b,c”。<ul>
<li>这是一个替换函数</li>
<li>第一个参数是被替换字串</li>
<li>第二个参数是替换字串</li>
<li>第三个参数是替换操作作用的字串</li>
</ul>
</li>
</ul>
<p>Makefile 支持的函数有限, 详情可参考 <a href="http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0">跟我一起写Makefile:使用函数</a></p>
<hr>
<p><em><strong>转载自 <a href="http://lucky521.github.io/blog/design/2015/10/01/makefile.html">怎么看懂和编写makefile</a></strong></em><br><em><strong>转载自 <a href="http://lucky521.github.io/blog/design/2015/10/01/makefile.html">跟我一起写Makefile</a></strong></em></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>embedded</tag>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>jz2440 裸板程序的开发</title>
    <url>/2017/04/05/1710-jz2440-led/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/04/05/1710-jz2440-led/">jz2440裸板程序的开发</a></li>
<li>s3c2440 的裸板开发和单片机无异, 此文主要目的是<strong>熟悉linux下的交叉编译环境和开发方式</strong>.</li>
</ul>
<h1 id="crt0-S-文件"><a href="#crt0-S-文件" class="headerlink" title="crt0.S 文件"></a><code>crt0.S</code> 文件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@******************************************************************************</span><br><span class="line">@ File：crt0.S</span><br><span class="line">@ 功能：通过它转入C程序</span><br><span class="line">@******************************************************************************</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">            ldr     r0, &#x3D;0x53000000     @ WATCHDOG寄存器地址</span><br><span class="line">            mov     r1, #0x0</span><br><span class="line">            str     r1, [r0]            @ 写入0，禁止WATCHDOG，否则CPU会不断重启</span><br><span class="line"></span><br><span class="line">            ldr     sp, &#x3D;1024*4         @ 设置堆栈，注意：不能大于4k, 因为现在可用的内存只有4K</span><br><span class="line">                                        @ nand flash中的代码在复位后会移到内部ram中，此ram只有4K</span><br><span class="line">            bl      main                @ 调用C程序中的main函数</span><br><span class="line">halt_loop:</span><br><span class="line">            b       halt_loop</span><br></pre></td></tr></table></figure>

<h1 id="led-c-文件"><a href="#led-c-文件" class="headerlink" title="led.c 文件"></a><code>led.c</code> 文件</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************************************</span></span><br><span class="line"><span class="comment"> * 按下按钮, 就点亮对应的LED灯.</span></span><br><span class="line"><span class="comment"> * KEY: EINT0, EINT2, EINT11</span></span><br><span class="line"><span class="comment"> * KEY: GPF0,  GPF2,  GPG3</span></span><br><span class="line"><span class="comment"> * LED: D12,   D11,   D10</span></span><br><span class="line"><span class="comment"> * LED: GPF6,  GPF5,  GPF4</span></span><br><span class="line"><span class="comment"> ************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// s3c2440 对应的寄存器地址. 需要看数据手册.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPFCON      (*(volatile unsigned long *)0x56000050)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPFDAT      (*(volatile unsigned long *)0x56000054)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPFUP       (*(volatile unsigned long *)0x56000058)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPGCON      (*(volatile unsigned long *)0x56000060)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPGDAT      (*(volatile unsigned long *)0x56000064)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPGUP       (*(volatile unsigned long *)0x56000068)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIN0        (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIN1        (1&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIN2        (1&lt;&lt;2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIN3        (1&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIN4        (1&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIN5        (1&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIN6        (1&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIN7        (1&lt;&lt;7)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GPFCON = <span class="number">0x1500</span>;        <span class="comment">// set LED pin as output</span></span><br><span class="line">    GPFDAT = <span class="number">0x00</span>;</span><br><span class="line">    GPGCON = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (GPFDAT &amp; PIN0) &#123;</span><br><span class="line">            GPFDAT |= PIN6;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            GPFDAT &amp;= ~PIN6;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GPFDAT &amp; PIN2) &#123;</span><br><span class="line">            GPFDAT |= PIN5;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            GPFDAT &amp;= ~PIN5;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GPGDAT &amp; PIN3) &#123;</span><br><span class="line">            GPFDAT |= PIN4;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            GPFDAT &amp;= ~PIN4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Makefile-文件"><a href="#Makefile-文件" class="headerlink" title="Makefile 文件"></a><code>Makefile</code> 文件</h1><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 目标文件 : 依赖文件1 依赖文件2</span></span><br><span class="line">led.bin : crt0.S led.c</span><br><span class="line">    <span class="comment"># 汇编-&gt;目标文件</span></span><br><span class="line">    arm-linux-gcc -g -c -o crt0.o crt0.S</span><br><span class="line">    <span class="comment"># C-&gt;汇编</span></span><br><span class="line">    arm-linux-gcc -g -c -o led.o led.c</span><br><span class="line">    <span class="comment"># 目标文件链接为 led_elf, 初始地址为0</span></span><br><span class="line">    arm-linux-ld -Ttext 0x0000000 -g  crt0.o led.o -o led_elf</span><br><span class="line">    <span class="comment"># 用 led_elf文件生成 烧录文件 led.bin</span></span><br><span class="line">    arm-linux-objcopy -O binary -S led_elf led.bin</span><br><span class="line">    <span class="comment"># 反汇编</span></span><br><span class="line">    arm-linux-objdump -D -m arm led_elf &gt; led.dis</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f led.dis led.bin led_elf *.o</span><br></pre></td></tr></table></figure>

<h1 id="编译和烧录"><a href="#编译和烧录" class="headerlink" title="编译和烧录"></a>编译和烧录</h1><ul>
<li>将上述三个文件放入同一个目录, 譬如 <code>/led_test</code><ul>
<li><code>crt0.S</code> 可理解为硬件初始化, 使用模板即可</li>
<li><code>led.c</code> 需要自己写, 软件的大部分开发工作用C语言实现</li>
<li><code>Makefile</code> 写的非常直白的makefile, 不适用于复杂的工程.</li>
</ul>
</li>
<li>使用Linux主机进行编译.<ul>
<li>即登录 Ubuntu, 即配置好交叉编译环境的Linux主机</li>
<li>shell 下进入 <code>/led_test</code> 目录</li>
<li>输入指令 <code>make</code> 即可, 就会得到 <code>led.bin</code> 文件</li>
<li>清空编译和链接文件, 输入 <code>make clean</code>, 就相当于执行了 <code>rm -f led.dis led.bin led_elf *.o</code></li>
</ul>
</li>
<li>将 <code>led.bin</code> 烧录到 Flash 中, 最后重启开发板.<ul>
<li>有多种烧录方式, 我这边使用的是 JLINK, 用JFlash烧录即可 (只支持烧录 Nor Flash)</li>
<li>s3c2440 属于 ARM9 系列. 使用Nor Flash启动时, SRAM 起始地址为 0x4000_0000</li>
<li>或者使用uboot+dnw的方式, 烧录到SDRAM中并运行</li>
</ul>
</li>
<li>然后, 如果开发的是嵌入式linux, 基本流程也是这样的 (注意区分两个Linux):<ul>
<li><ol>
<li>在电脑上开发软件 (Windows, Linux, Mac 随便的)</li>
</ol>
</li>
<li><ol start="2">
<li>在<strong>Linux主机</strong>上进行编译(就是交叉编译), 获得一个可执行文件.</li>
</ol>
</li>
<li><ol start="3">
<li>把可执行文件烧录/加载到**嵌入式Linux(开发板)**上, 运行即可.</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>embedded</tag>
        <tag>jz2440</tag>
      </tags>
  </entry>
  <entry>
    <title>使用网络爬虫抓取商品价格并分析</title>
    <url>/2017/04/10/1711-web-spider/</url>
    <content><![CDATA[<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>基于 <a href="http://www.chemistwarehouse.com.au/">Chemist Warehouse</a> 的商品, 抓取其每天的价格变化. 并根据历史信息, 判断其价格变化规律, 以便在打折时购买.</p>
<p>因此, 用户需求有如下几点:</p>
<ul>
<li>抓取网站价格, 需要知道其商品全名, 原价, 打折价, 打折日期, 持续时间</li>
<li>存储这些数据, 供日后分析使用</li>
<li>数据挖掘和分析, 已直观的方式多维度显示出来(譬如单品的打折规律, 打折力度, 打折持续时间. 全年的打折规律)</li>
</ul>
<p>进一步, 技术分析如下:</p>
<ul>
<li>全程使用python即可满足全部需求.</li>
<li>网络爬虫难度不高, 仅需针对特定商品, 每天抓一次, 无需多线程/进程, 无需登录, 无验证码, 无需考虑反爬虫, 无需额外加载JS程序.</li>
<li>数据存储, 使用MySQL, 数据需要去重, 仅记录关键信息. 以便减少数据存储量, 简化数据挖掘和分析的工作</li>
<li>搜索指定产品, 展示历史数据, 使用 pyqt + matplotlib.</li>
</ul>
<h1 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h1><p>花了二天时间, 简单过了一遍网络爬虫的关键技术. 参考资料如下:</p>
<ul>
<li><a href="http://cuiqingcai.com/1052.html">Python爬虫学习系列教程-静觅</a></li>
<li><a href="https://github.com/lining0806/PythonSpiderNotes">Python入门网络爬虫之精华版</a></li>
<li><a href="http://www.w3school.com.cn/xpath/xpath_syntax.asp">XPath 语法</a></li>
</ul>
<p>本着项目导向, 做出结果为先的思路, 没有一步步的实验. 上来先看了几个爬虫框架.</p>
<ul>
<li><code>pyspider</code> 基于web UI, 感觉很直观, 适合于随便玩玩. 个人不喜欢, 二次开发不方便.</li>
<li>python 下另外一个很有名的框架就是 <code>scrapy</code>, 可惜我连配置安装都没有成功的做完. 适合二次开发.<br>应该是公司网络安全机制比较高, 遇到的问题基本都是SSL相关的, 解决了2-3个, 剩下的实在没有思路去解决了…<br>另外scrapy依赖的库也比较多, 因此初装也就比较麻烦. 安装推荐参考<a href="https://docs.scrapy.org/en/latest/intro/install.html#">官网的 Installation guide</a></li>
<li>使用 <code>requests</code> <code>urllib</code> <code>lxml</code> 库. 简单项目直接用这个就够了.</li>
<li>最终抓数据只用了 <code>lxml</code> 一个库就完成了数据抓取, 去重的工作. 关键源码如下:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># pip --trusted-host pypi.python.org install lxml</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取url的原始数据</span></span><br><span class="line">doc = html.parse(<span class="string">&#x27;http://www.chemistwarehouse.com.au/search?searchtext=blackmores%20bone&amp;searchmode=allwords&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取指定的数据值</span></span><br><span class="line">names = doc.xpath(<span class="string">&#x27;//a[@class=&quot;product-container search-result&quot;]/@title&#x27;</span>)</span><br><span class="line"><span class="comment"># 处理数据, 准备存入数据库即可.</span></span><br><span class="line">name = <span class="built_in">map</span>(string.strip, names)</span><br><span class="line"><span class="built_in">print</span> name</span><br></pre></td></tr></table></figure>

<p>另:<br>遇到过了错误 <code>There was a problem confirming the ssl certificate: [SSL: CERTIFICATE_VERIFY_FAILED]</code><br>使用 <code>pip --trusted-host pypi.python.org install lxml</code> 即可避免. 也是安全性问题导致的.</p>
<h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><p>同样地, 该项目对数据存储的要求也很低. 直接选择使用MySQL.</p>
<p>参考资料如下:</p>
<ul>
<li><a href="http://www.runoob.com/python/python-mysql.html">python操作mysql数据库</a></li>
<li><a href="http://www.crazyant.net/686.html">Python操作Mysql实例代码教程（查询手册）</a></li>
<li><a href="http://www.cnblogs.com/mr-wid/archive/2013/05/09/3068229.html">21分钟 MySQL 入门教程</a></li>
<li><a href="http://blog.csdn.net/heizistudio/article/details/8234185">Windows下更改MySQL数据库的存储位置</a></li>
</ul>
<p>Windows 下配置使用MySQL:</p>
<ul>
<li><p>下载运行 <a href="https://dev.mysql.com/downloads/windows/">MySQL Installer</a></p>
</li>
<li><p>必须安装 <code>MySQL Server</code>. 建议安装 <code>MySQL Workbench</code>, 为可视化图像, 便于管理查看.</p>
</li>
<li><p>可视化工具也可以使用别的软件. 如 <a href="https://www.heidisql.com/">heidisql</a></p>
</li>
<li><p>将<code>mysql.exe</code>的路径添加<code>PATH</code>环境变量.</p>
</li>
<li><p>创建新的数据库(Workbecn下, 英文为<code>schema</code>), 命名为 <code>chemistwarehouse</code>. 或者输入指令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p      <span class="comment"># 登录本机的MySQL数据库服务</span></span><br><span class="line"><span class="comment"># mysql&gt;              # 成功后, 提示符变为 mysql&gt;</span></span><br><span class="line">create database chemistwarehouse; <span class="comment"># 创建一个数据库</span></span><br></pre></td></tr></table></figure></li>
<li><p>安装 <a href="https://sourceforge.net/projects/mysql-python/">MySQL for Python</a><br>然后, 在python下面测试一下是否可以成功连接到刚建立的 <code>chemistwarehouse</code> 数据库.<br>成功的话, 会打印版本信息.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initDatabase</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 连接mysql的方法：connect(&#x27;ip&#x27;,&#x27;user&#x27;,&#x27;password&#x27;,&#x27;dbname&#x27;)</span></span><br><span class="line">        connect_db = db.connect(</span><br><span class="line">            <span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;chemistwarehouse&#x27;</span>)</span><br><span class="line">        <span class="comment"># 所有的查询，都在连接con的一个模块cursor上面运行的</span></span><br><span class="line">        cur = connect_db.cursor()</span><br><span class="line">        <span class="comment"># 执行一个查询</span></span><br><span class="line">        cur.execute(<span class="string">&quot;SELECT VERSION()&quot;</span>)</span><br><span class="line">        <span class="comment"># 取得上个查询的结果，是单个结果</span></span><br><span class="line">        data = cur.fetchone()</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Database version : %s &quot;</span> % data</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> connect_db:</span><br><span class="line">            <span class="comment"># 无论如何，连接记得关闭</span></span><br><span class="line">            connect_db.close()</span><br><span class="line"></span><br><span class="line">initDatabase()</span><br></pre></td></tr></table></figure></li>
<li><p>至此, 就可以在python下正常使用MySQL数据库了.<br>将提取出来的数据去重后, 按一定的格式保存进数据库即可.</p>
</li>
<li><p>默认安装在C盘, 而且数据存储也是在C盘. 这个没法接受! 需要把数据存储位置修改到空间更大的E盘.</p>
<ul>
<li>停止MySQL服务, 命令行 <code>net stop MySQL57</code> 或者使用 <code>MySQL Workbench</code> 停止服务</li>
<li>打开 <code>C:\ProgramData\MySQL\MySQL Server 5.7\my.ini</code></li>
<li>修改为 <code>datadir=E:/MySQLdata</code>, 即设置数据库的新目录</li>
<li>复制 <code>C:\ProgramData\MySQL\MySQL Server 5.7\Data</code> 下所有文件到 <code>E:/MySQLdata</code></li>
<li>开启MySQL服务 命令行 <code>net start MySQL57</code> 或者使用 <code>MySQL Workbench</code> 开启服务</li>
<li>检查 MySQL 服务器状态, 确定数据库目录已更新</li>
<li>删除 <code>C:\ProgramData\MySQL\MySQL Server 5.7\Data</code></li>
</ul>
</li>
</ul>
<h1 id="数据显示"><a href="#数据显示" class="headerlink" title="数据显示"></a>数据显示</h1><p>参考资料如下:</p>
<ul>
<li><a href="http://blog.topspeedsnail.com/archives/814">Python 中用 matplotlib 绘制直方图</a> 这个博客有对 matplotlib 制图有一个系列的文章</li>
<li><a href="http://ningning.today/2015/04/17/python/%E7%94%A8matplotlib%E7%BB%98%E5%88%B6%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%92%8C%E9%A5%BC%E5%9B%BE/">用python的matplotlib库绘制柱状图和饼图</a></li>
<li><a href="http://www.jdon.com/idea/matplotlib.html">使用Python matplotlib绘制股票走势图</a></li>
<li><a href="http://blog.rcnelson.com/building-a-matplotlib-gui-with-qt-designer-part-1/">Building a Matplotlib GUI with Qt Designer: Part 1</a>, 由三部分组成, 还有<a href="http://blog.rcnelson.com/building-a-matplotlib-gui-with-qt-designer-part-2/">Part2</a>和<a href="http://blog.rcnelson.com/building-a-matplotlib-gui-with-qt-designer-part-3/">Part3</a></li>
<li><a href="http://eli.thegreenplace.net/2009/01/20/matplotlib-with-pyqt-guis">matplotlib with PyQt GUIs</a>, 有 <a href="https://github.com/eliben/code-for-blog/blob/master/2009/qt_mpl_bars.py">github 范例</a></li>
<li>pyqt的使用可参考我的博客 <a href="https://draapho.github.io/2016/11/16/1617-python-terminal/">python的第一个小程序, 蓝牙及串口终端</a></li>
</ul>
<p>设计思路和注意事项</p>
<ul>
<li>使用pip安装 matplotlib: <code>pip --trusted-host pypi.python.org install matplotlib</code></li>
<li>数据显示和数据抓取是完全独立的, 因此数据抓取单独生成了一个exe文件, 数据显示也单独生成一个文件.</li>
<li>数据显示exe可以打开多个, 以便分析比较. 数据抓取仅可打开一个.</li>
</ul>
<h1 id="源码及性能"><a href="#源码及性能" class="headerlink" title="源码及性能"></a>源码及性能</h1><p>最终源码见 <a href="https://github.com/draapho/chemistwarehouse-spider">github</a></p>
<p>爬虫最终性能:<br>抓取效率一般, 每1000条数据大概要2分钟. 要提高效率可以考虑使用多进程!<br>但一天抓取一次即可, 因此这个速度可以接受. 暂时保持单进程不变.</p>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>embedded</tag>
        <tag>jz2440</tag>
      </tags>
  </entry>
  <entry>
    <title>ezos简要用户手册</title>
    <url>/2017/04/10/1712-ezos/</url>
    <content><![CDATA[<h1 id="ezos开发历史"><a href="#ezos开发历史" class="headerlink" title="ezos开发历史"></a>ezos开发历史</h1><p>ezos最早的思想起源于TCS德国的带有任务性质的超循环方式(前后台方式), 为使用方便, 作者将增减任务的方式直接和函数名相关, 加入延时功能.<br>并写了核心代码 ezos_schedule();  ezos_add(); ezos_delete();  ezos_delay(); 这样一个外表酷似RTOS, 内核为超循环任务的OS就诞生了, 版本V1.0.0.<br>由于使用起来非常方便, 代码为纯C语言, 简单易懂, 因此命名为 ezos, 即easy OS.</p>
<p>后续由 TCS 胡工加入了任务参数, 静态任务, 可实例化任务的概念.<br>整合这些概念后, 重写了部分代码, 将ezos的版本升级至较为实用的V1.3.1.在这个阶段, 使用ezos做了功能较为复杂的项目, 并发现一些任务通讯和同步的问题,<br>在借鉴了抢占式RTOS的一些特性后, 决心重写ezos, 将其变为真正的协作式RTOS. 同时要求代码依旧清晰简洁, 可适用于资源较少的8位单片机应用.</p>
<p>基于以上想法, 将ezos的提升到了V2开始的主版本. 将代码改为linux书写规范, 进化为协作式OS, 支持254级优先级. 使用了链表, 重写所有系统函数.<br>还有, 非常重要的是, 增加了任务间的通讯方式, 支持信号量, 互斥量, 事件, 邮箱, 消息队列.
 </p>
<h1 id="ezos-原理介绍"><a href="#ezos-原理介绍" class="headerlink" title="ezos 原理介绍"></a>ezos 原理介绍</h1><p>ezos是协作式的操作系统, 即支持优先级, 支持任务间通讯. 但任务的轮询调度不是抢占式的, 而必须由任务自己放弃CPU的控制权.<br>即当有一更高优先级的任务需要运行时, ezos并不会马上剥夺现有任务CPU的控制权, 必须等待现有任务自己放弃CPU的控制权, 更高优先级的任务才会被运行.</p>
<p>一个软件系统是否需要使用操作系统, 操作系统的好坏, 个人明确强调, 没有最好只有最合适!<br>这是嵌入式行业的原则之一, 如果有最好最合适的, 那就成了通用的PC行业软件开发, 而非嵌入式软件开发了.</p>
<p>对于软件功能非常简单的嵌入式系统, 前后台/超循环模式可能就是最好的! 资源开销小, 代码直观, 易于调试.<br>对于有一定复杂度的嵌入式系统, 就需要使用操作系统了, 否则软件会变得难以开发, 难以理解和阅读, 难以维护和升级……<br>对于一般复杂度的嵌入式软件, 使用协作式的操作系统是个不错的选择, 相对于抢占式的操作系统, 其缺点为响应时间较慢(但并非不可控制). 优点为系统代码和占用资源很小, 任务流程容易预测, 便于调试和开发.<br>抢占式操作系统的一个最大特点是: 任务随时随地都可能被优先级更高的任务剥夺运行权, 因此也就需要程序员充分考虑任务的原子性要求, 但这是需要培训和经验积累的.<br>问题的严重性更在于, 此类问题很难跟踪调试, 容易让产品是不稳定的. 因此使用协作式的操作系统, 对程序员的要求较低, 也更易于开发出稳定可靠的产品.</p>
<h2 id="ezos的任务数据"><a href="#ezos的任务数据" class="headerlink" title="ezos的任务数据"></a>ezos的任务数据</h2><p>ezos的任务数据存放在 ezos_task_t task_link[__EZOS_TASK_NUM];<br>ezos内置一个idle任务数据, 取名idle, 优先级最低, 为255. 可以简单理解为它是任务数据的表头.<br>当调用ezos_add(), ezos_delete()时, 会自行分配或释放此数据空间.</p>
<h2 id="任务链表和回收链表"><a href="#任务链表和回收链表" class="headerlink" title="任务链表和回收链表"></a>任务链表和回收链表</h2><p>ezos核心思想是两组单向链表: <code>任务链表</code> 和 <code>回收链表</code></p>
<ul>
<li><code>任务链表</code>为单向循环链表, 链表起始节点存放着系统空闲任务.<br>后面的节点按照任务优先级的先后顺序进行排序.<br>对于同优先级的任务, 任务添加或任务改变自身状态时, 会将该任务节点放到同优先级链表节点的末尾.<br>因此, 任务链表从idle往后, 一定是按照优先级顺序排列好的!</li>
</ul>
<p>举例来说, 任务列表如下: 优先级1 -&gt; 优先级3 -&gt; 优先级3 -&gt; 优先级10 -&gt; 优先级11 -&gt; idle(255)<br>则ezos 会按照顺序依次查询任务列表中任务的状态. 更根据状态确定是执行任务还是跳过任务.<br>上表中, 如果新增一个优先级为2的任务, 则此任务会被放在优先级1和优先级3之间.<br>如果新增一个优先级为3的任务, 则此任务会被放在优先级10之前.<br>另外, 如果第一个优先级3的任务运行过后, 也会被放在优先级10之前, 以便让同优先级的其它任务运行.</p>
<ul>
<li><code>回收链表</code>为单向非循环链表, 被删除的任务节点放到到回收链表中.<br>而被添加的任务节点从回收链表取出并分配到任务链表中.</li>
</ul>
<h2 id="ezos的任务状态"><a href="#ezos的任务状态" class="headerlink" title="ezos的任务状态:"></a>ezos的任务状态:</h2><p>源码见 <a href="https://github.com/draapho/ezos">github-ezos</a></p>
<ol>
<li>任务删除状态(EZOS_DELETE), 即终止状态. 任务不在任务链表中, 不会运行.</li>
<li>任务阻塞状态(EZOS_SUSPEND), 任务已在任务链表中, 但被阻塞, 不会被运行. 任务延时也属于阻塞状态.</li>
<li>任务就绪状态(EZOS_READY), 任务已在任务队列中, 可以运行, 但未必正在运行.</li>
<li>任务运行状态(EZOS_RUNNING), 任务已在任务列表中, 并正在运行.</li>
</ol>
<h2 id="ezos任务调度"><a href="#ezos任务调度" class="headerlink" title="ezos任务调度"></a>ezos任务调度</h2><p>借助于ezos任务链表的良好设计, ezos任务调度非常简单, 每次都是从头开始寻找处于就绪态的任务,运行完某个任务后就从头重新开始搜寻.<br>由于任务链表是按照优先级顺序排序的,这样就实现了高优先级任务的快速响应. 而同优先级任务则是轮询处理的.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ezos_schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        task = idle.next;</span><br><span class="line"><span class="comment">// 寻找就绪的任务</span></span><br><span class="line">        <span class="keyword">while</span> (task-&gt;status != EZOS_READY)  task = task-&gt;next;</span><br><span class="line">        run = task;</span><br><span class="line">        run-&gt;status = EZOS_RUNNING;</span><br><span class="line">        ezos_enable_int(mask);</span><br><span class="line"><span class="comment">// 运行任务函数</span></span><br><span class="line">        task-&gt;pfun(&amp;task-&gt;state, &amp;task-&gt;para);</span><br><span class="line">        mask = ezos_disable_int();</span><br><span class="line"><span class="comment">// 自动删除任务</span></span><br><span class="line">        <span class="keyword">if</span> (run-&gt;status == EZOS_RUNNING) ezos_delete_cur();</span><br><span class="line">        run = &amp;idle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="任务的重载"><a href="#任务的重载" class="headerlink" title="任务的重载"></a>任务的重载</h1><p>由于加入了任务的命名体系, 对于可重载的函数就可以添加多个任务了. 而所有的任务操作依据就是任务的名称.<br>任务的名称是不可重复的.对于静态任务函数, 一般将其函数名命名为任务名称即可,<br>方便又好记.对于可重载函数的多个任务, 建议使用 <code>函数名+0</code>, <code>函数名+1</code> 的方式来命名任务名称.</p>
<h1 id="ezos-使用方法"><a href="#ezos-使用方法" class="headerlink" title="ezos 使用方法"></a>ezos 使用方法</h1><h2 id="ezos-基础函数"><a href="#ezos-基础函数" class="headerlink" title="ezos 基础函数"></a>ezos 基础函数</h2><p>为了让ezos工作起来, 相关的基础函数有3个.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ezos_init();        <span class="comment">// ezos初始化函数, main函数尽早调用</span></span><br><span class="line">ezos_scan_1ms();    <span class="comment">// 1ms定时函数, 1ms定时中断调用</span></span><br><span class="line">ezos_schedule();    <span class="comment">// ezos调度函数, 为死循环. main函数最后调用</span></span><br></pre></td></tr></table></figure>


<h2 id="ezos调试函数"><a href="#ezos调试函数" class="headerlink" title="ezos调试函数"></a>ezos调试函数</h2><p>主要有两个调试函数.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ezos_trash_num_min_get();   <span class="comment">// 获取系统最小的剩余任务空间</span></span><br><span class="line">ezos_idle_tick_max_get();   <span class="comment">// 获取idle任务运行间隔最大时间</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>ezos_trash_num_min_get</code> 获取系统最小的剩余任务空间.<br>可用来判断设置的任务数量是否合适, 太小会让任务添加失败, 太大会造成RAM的浪费(但不会造成运算效率的浪费).<br>在稳定运行系统一定的时间后, 根据观察结构, 调整 <code>__EZOS_TASK_NUM</code> 值即可, 建议根据结果, 再预留2-5个任务较为合理</p>
</li>
<li><p><code>ezos_idle_tick_max_get</code> 获取idle任务运行间隔最大时间.<br>可用来判断CPU是否任务过重, 以及任务切换最慢响应时间(最低优先级任务的最差情况).</p>
</li>
<li><p>而最高优先级任务的最差情况. 根据协作式的特点分析可知:<br>最高优先级任务的响应时间 = 某个独占CPU时间最长的ezos任务<br>因此, 在ezos任务中, 不要使用独占CPU的长延时!!! 如果任务过重, 可手动拆分成多个小任务, 完成一次小任务就主动放弃一次CPU的控制权.</p>
</li>
</ul>
<h2 id="常用的任务函数"><a href="#常用的任务函数" class="headerlink" title="常用的任务函数"></a>常用的任务函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ezos_t</span> <span class="title">ezos_add</span><span class="params">(<span class="keyword">void</span> *name,                 <span class="comment">// 任务名称(ID), 该任务的唯一标识</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> (*pfun)(<span class="keyword">ezos_s_t</span>*, <span class="keyword">ezos_p_t</span>*),     <span class="comment">// 任务函数</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">ezos_p_t</span> para,                          <span class="comment">// 任务初始参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int32_t</span> delay_time,                     <span class="comment">// 任务延时时间</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint8_t</span> priority)</span></span>;                      <span class="comment">// 任务优先级</span></span><br><span class="line"></span><br><span class="line">quick_add();                <span class="comment">// 快速添加任务, 用的较多, 输入参数只需pfun和priority.</span></span><br><span class="line">force_add();                <span class="comment">// 强制添加任务, 会先删除该任务, 再重新添加</span></span><br><span class="line"></span><br><span class="line">ezos_delay(<span class="keyword">int32_t</span> time);   <span class="comment">// 任务延时函数</span></span><br></pre></td></tr></table></figure>



<h2 id="ezos编程范例"><a href="#ezos编程范例" class="headerlink" title="ezos编程范例"></a>ezos编程范例</h2><p>源码见 <a href="https://github.com/draapho/ezos">github-ezos</a></p>
<ol>
<li> 单次任务, 见范例 <code>app_lcd</code> 之 <code>task_lcd</code></li>
<li> 循环任务, 见范例 <code>app_rtc</code> 之 <code>task_rtc_1s</code></li>
<li> 状态机任务, 见范例 <code>app_race_led</code> 之 <code>task_race_led</code></li>
<li> 复杂任务, 见范例 <code>app_bell</code> 之 <code>task_bell_1s</code></li>
<li> 可重入任务, 见范例 <code>app_sem</code> 之 <code>task_led</code></li>
<li> 任务的拆分, 见范例 <code>ITT100 dv_pic</code> 之 <code>SavePIPtoSPI</code></li>
</ol>
<p> </p>
<h1 id="ezos之任务通讯"><a href="#ezos之任务通讯" class="headerlink" title="ezos之任务通讯"></a>ezos之任务通讯</h1><p>ezos的任务通讯相关函数统一放在 <code>ezos_ipc.c</code> 文件下.<br>ezos会将所有的添加的ipc串成一个链表. 其数据结构如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">ezos_ipc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *next;         <span class="comment">// 下个IPC指针</span></span><br><span class="line">    <span class="keyword">void</span> *name;         <span class="comment">// 当前IPC指针</span></span><br><span class="line">    <span class="keyword">ezos_t</span> type;        <span class="comment">// IPC类型</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">ezos_ipc</span>   <span class="title">ezos_ipc_t</span>;</span></span><br></pre></td></tr></table></figure>

<p>此数据结构相当于ipc的父类, 基于此父类, 下面会衍生出各个IPC子类,<br>如信号量:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">ezos_ipc_t</span> ipc; <span class="comment">// IPC父类</span></span><br><span class="line">    <span class="keyword">uint8_t</span> value;  <span class="comment">// 信号量值</span></span><br><span class="line">&#125; <span class="keyword">ezos_sem_t</span>;</span><br></pre></td></tr></table></figure>

<p>所有IPC的添加与删除都是对此链表的操作, 使用函数为:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ezos_t</span> <span class="title">ezos_ipc_add</span><span class="params">(<span class="keyword">void</span> *name, <span class="keyword">ezos_t</span> type)</span></span></span><br><span class="line"><span class="function"><span class="keyword">ezos_t</span> <span class="title">ezos_ipc_delete</span><span class="params">(<span class="keyword">void</span> *name)</span></span></span><br></pre></td></tr></table></figure>


<h2 id="IPC的使用"><a href="#IPC的使用" class="headerlink" title="IPC的使用"></a>IPC的使用</h2><p>IPC的释放/发送较简单, IPC的获取/接收使用稍有复杂, 主要是需要判断IPC的返回值, 并进行相关操作.此处已信号量(sem)为例.<br>原函数见:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ezos_t</span> <span class="title">ezos_sem_release</span><span class="params">(<span class="keyword">ezos_sem_t</span> *sem)</span></span></span><br><span class="line"><span class="function"><span class="keyword">ezos_t</span> <span class="title">ezos_sem_take</span><span class="params">(<span class="keyword">ezos_sem_t</span> *sem, <span class="keyword">int32_t</span> timeout)</span></span></span><br></pre></td></tr></table></figure>

<p>对于 ezos_sem_take, 返回值种类有4种! 依次为:</p>
<ol>
<li><code>EZOS_OK</code>,      获取信号量成功</li>
<li><code>EZOS_WAIT</code>,    需要等待信号量, 返回此值后, 原函数需要return</li>
<li><code>EZOS_TIMEOUT</code>, 信号量等待超时</li>
<li><code>EZOS_ERROR</code>,   指定信号量有错误, 说明代码有误</li>
</ol>
<p>使用信号量时, 基本格式为:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EZOS_TASK(task_sem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ezos_t</span> val;</span><br><span class="line">    val = ezos_sem_take(lock, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (val == EZOS_WAIT) <span class="keyword">return</span>;                       <span class="comment">// 直接返回等待</span></span><br><span class="line">    <span class="keyword">if</span> (val == EZOS_OK)           &#123;do_something();&#125;     <span class="comment">// 成功获取信号量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val == EZOS_TIMEOUT) &#123;do_something();&#125;     <span class="comment">// 信号量超时处理</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val == EZOS_ERROR)   &#123;exception();&#125;        <span class="comment">// 异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="IPC编程范例"><a href="#IPC编程范例" class="headerlink" title="IPC编程范例"></a>IPC编程范例</h2><ol>
<li> 信号量(sem), 见范例 <code>app_sem</code></li>
<li> 互斥量(mutex) 及 事件(event) 与 信号量类型, 略</li>
<li> 邮箱(mailbox),  见范例 <code>app_mail</code></li>
<li> 消息队列(message),  见范例 <code>app_message</code></li>
</ol>
<h1 id="ezos-源码"><a href="#ezos-源码" class="headerlink" title="ezos 源码"></a>ezos 源码</h1><p>已将源码放在了 <a href="https://github.com/draapho/ezos">github-ezos</a><br>该源码是一个针对stm32f1xx系列的工程模板文件.<br>分层非常清楚, 整个代码结构框架如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         --------------- 最高层 ----------------</span><br><span class="line">        |                                       |</span><br><span class="line">层一    |        applications (应用层)          |</span><br><span class="line">        |                                       |</span><br><span class="line">         ---------------------------------------</span><br><span class="line">        |                                       |</span><br><span class="line">层二    |          components (组件层)          |</span><br><span class="line">        |                                       |</span><br><span class="line"> --------------------------------------------------------</span><br><span class="line">|                  API (应用程序编程接口)                |</span><br><span class="line"> --------------------------------------------------------</span><br><span class="line">        |                                       |</span><br><span class="line">层三    |             OS (操作系统)             |</span><br><span class="line">        |                                       |</span><br><span class="line">         ---------------------------------------</span><br><span class="line">        |                                       |</span><br><span class="line">层四    |            drivers (驱动层)           |</span><br><span class="line">        |                                       |</span><br><span class="line"> --------------------------------------------------------</span><br><span class="line">|                CMSIS （Cortex软件标准接口）            |</span><br><span class="line"> --------------------------------------------------------</span><br><span class="line">        |                                       |</span><br><span class="line">层五    |           libraries (芯片库)          |</span><br><span class="line">        |                                       |</span><br><span class="line">         --------------- 最低层 ----------------</span><br></pre></td></tr></table></figure>

<ol>
<li><p>applications：应用层</p>
<ul>
<li>包含了main文件, 中断处理文件, 系统配置文件</li>
<li>不建议直接调用最底层 Libraries</li>
<li>放在bsp中, 有利于使用不同的开发板开发应用</li>
</ul>
</li>
<li><p>components：组件层</p>
<ul>
<li>按大功能划分的软件组件。如音频组件、UI组件</li>
<li>不建议直接调用最底层 Libraries</li>
<li>用户可在此处添加特定工程的组件层</li>
<li>用户可在此处添加常用的组件层(完善模板)</li>
</ul>
</li>
<li><p>OS：操作系统</p>
<ul>
<li>有些操作系统需要提供标准接口函数, 比drivers层高.</li>
<li>ezos操作系统与drivers同层，相互不得调用</li>
</ul>
</li>
<li><p>drivers：PCB板级驱动</p>
<ul>
<li>如按键、EEPROM、模拟I2C等等</li>
<li>该层要能对上屏蔽掉最底层 Libraries<br>这样起到承上启下的作用,方便跨平台移植</li>
<li>用户可在此处添加特定的驱动</li>
<li>用户可在此处添加常用的驱动(完善模板)</li>
</ul>
</li>
<li><p>libraries：MCU外设库</p>
<ul>
<li>此部分由芯片厂商提供，是标准库</li>
<li>用户不得修改此层</li>
</ul>
</li>
<li><p>bsp：板级支持包</p>
<ul>
<li>applications应用层放在此包中</li>
<li>components特定工程组件层放在此包中</li>
<li>提供开发板工程模板</li>
</ul>
</li>
<li><p>documents：文档说明</p>
<ul>
<li>提供 doxygen 注释风格的模板，说明，软件</li>
<li>STM32工程模板说明</li>
<li>用户可在此处添加其它说明性文件</li>
</ul>
</li>
<li><p>API：Application Programming Interface，应用程序编程接口</p>
<ul>
<li>API旨在提供软件抽象层，加快项目的开发和移植速度</li>
<li>层一、层二的应用都应该基于API函数来使用</li>
<li>API函数由 Drivers 和 OS 提供, Libraries不得提供函数到应用接口</li>
<li>API函数必须使用标准C书写，与软件平台和硬件完全无关</li>
</ul>
</li>
<li><p>CMSIS：Cortex Microcontroller Software Interface Standard，Cortex软件标准接口</p>
<ul>
<li>CMSIS是ARM公司发布的一个标准接口，旨在提供Cortex-M处理器系列硬件抽象层</li>
<li>仅 Drivers 和 OS 可直接调用 CMSIS 的函数</li>
<li>目前仅提供了芯片核心部分的CMSIS，芯片外设标准库仍是由ST官方书写的</li>
</ul>
</li>
</ol>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded</category>
      </categories>
      <tags>
        <tag>embedded</tag>
        <tag>ezos</tag>
      </tags>
  </entry>
  <entry>
    <title>BLE基础概念</title>
    <url>/2017/04/19/1713-ble/</url>
    <content><![CDATA[<h1 id="ble-架构"><a href="#ble-架构" class="headerlink" title="ble 架构"></a>ble 架构</h1><p><img src="https://draapho.github.io/images/1713/ble-architecture.jpg" alt="ble architecture"></p>
<ul>
<li>PHY, Physical Layer:<br>物理层, 控制无线电信号的收发</li>
<li>LL, Link Layer:<br>链路层, 定义数据包结构, 包括状态信息和收发控制, 以及链路层的加密</li>
<li>HCI, Host-Controller Interface:<br>通过此标准接口, Host层和Controller层进行通讯</li>
<li>L2CAP, Logical Link Control and Adaptation Protocol. 可以理解为一个协议多路复用和分配器(功能上类似于TCPIP的端口).<br><strong>一般而言, BLE应用层开发者无需了解L2CAP层的细节</strong></li>
<li>ATT, Attribute Protocol:<br>该协议将单一的数值(信息)以Attribute(属性)的形式抽象出来，并提供一些方法，供远端设备读取和修改</li>
<li>GATT, Generic Attribute Protocol:<br>基于ATT提供的数值, 将有用的数值组打包好, 已服务(service)的方式开放给上层应用. 它相当于提供一套数据打包框架/规则.</li>
<li>GAP, Generic Access Profile:<br>通用访问服务, 是对LL层的广播,监听,建立连接功能的抽象, 便于开发人员来理解和开发</li>
<li>SM, Security Manager<br>负责BLE通信中有关安全的内容.</li>
</ul>
<h1 id="Physical-Layer"><a href="#Physical-Layer" class="headerlink" title="Physical Layer"></a>Physical Layer</h1><p>物理层, 控制无线电信号的收发</p>
<p><img src="https://draapho.github.io/images/1713/ble-channel.png" alt="ble channel"><br>一图胜千言. 如图所示:</p>
<ul>
<li>BLE占用的频段为 2402Mhz-2480Mhz, 划分为40个Channel(频道), 每个频段2Mhz</li>
<li>3个广播频段被放在了干扰冲突最少的频段, 并被命名为 37,38,39 频道</li>
<li>其余的频段用作数据通讯, 并会采用调频技术来避免干扰和冲突.</li>
<li>BLE和wifi的重合频段还是比较严重的! 和 wifi 的 1,6,11 三个频道完全重合.</li>
</ul>
<h1 id="Link-Layer"><a href="#Link-Layer" class="headerlink" title="Link Layer"></a>Link Layer</h1><p>链路层, 定义数据包结构, 包括状态信息和收发控制, 以及链路层的加密</p>
<p>Link Layer 链路层有5个基本状态:</p>
<ul>
<li>Standby: 睡觉省电.</li>
<li>Advertising: 广播模式, 周期性地发送数据, 使用的是 37-39的广播频道</li>
<li>Scanning: 扫描模式, 扫描/接收广播数据；</li>
<li>Initiating: 连接发起方，扫描带有“可连接”标志的广播数据,一旦发现,则发起连接请求.</li>
<li>Connection: 建立点对点的通讯模式, 此后就开始使用 0-36频道开始通讯了!</li>
</ul>
<p>设备的几种角色</p>
<ul>
<li>Advertiser: 广播者, 处于 Advertising 模式即广播者</li>
<li>Scanner: 扫描者, 处于 Scanning 模式即扫描者</li>
<li>Initiator: 扫描者, 处于 Initiating 模式的扫描, 用于准备建立连接</li>
<li>Slave: 建立通讯后 (Connection 模式), 之前的广播者就变成了Slave从机</li>
<li>Master: 建立通讯后 (Connection 模式), 之前的扫描者/发起者就变成了Master主机</li>
<li>混合模式: 一个设备可以同时是 Advertiser &amp; Scanner 或者 Advertiser &amp; Master 等等. 但需要供应商的软件支持!</li>
</ul>
<p><strong>关于蓝牙设备的角色名称问题, 无力吐槽, 各个分层都有一套自己的术语, 看的时候注意其对应的架构层次再来理解</strong></p>
<h2 id="Advertisement"><a href="#Advertisement" class="headerlink" title="Advertisement"></a>Advertisement</h2><table>
<thead>
<tr>
<th>参数</th>
<th>数值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Advertisement interval</td>
<td>20 ms to 10240 ms</td>
<td>定义广播时间间隔</td>
</tr>
<tr>
<td>Advertisement channels</td>
<td>CH37-CH39</td>
<td>默认值, 不可修改. BLE5新增了第二广播频道</td>
</tr>
<tr>
<td>Discoverability mode</td>
<td>ADV_IND</td>
<td>可被连接的广播</td>
</tr>
</tbody></table>
<pre><code>            | ADV_DIRECT_IND | 可被连接的定向广播
            | ADV_NONCONN_IND | 不可连接的广播
            | ADV_SCAN_IND | 可接受SCAN_REQ请求的广播数据
</code></pre>
<h2 id="Scanning"><a href="#Scanning" class="headerlink" title="Scanning"></a>Scanning</h2><table>
<thead>
<tr>
<th>参数</th>
<th>数值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Scan interval</td>
<td>2.5 ms to 10240 ms</td>
<td>定义扫描时间间隔</td>
</tr>
<tr>
<td>Scan window</td>
<td>2.5 ms to 10240 ms</td>
<td>定义扫描时间窗口</td>
</tr>
<tr>
<td>Scan mode</td>
<td>Active / Passive</td>
<td>主动扫描(会发送Scan Request)</td>
</tr>
</tbody></table>
<p>上图:<br><img src="https://draapho.github.io/images/1713/ble-scan.PNG" alt="ble scan"></p>
<h2 id="Connections"><a href="#Connections" class="headerlink" title="Connections"></a>Connections</h2><ul>
<li>建立通讯后, 设备的角色被分为 Master 和 Slave</li>
<li>发起建立通讯的设备, 即 Initiating 状态的扫描者, 为 Master</li>
<li>之前在广播状态的设备, 即 Advertising 状态的广播者, 为 Slave</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>数值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Minimum Connection Interval</td>
<td>7.5 ms</td>
<td>允许的最小连接间隔</td>
</tr>
<tr>
<td>Maximum Connection Interval</td>
<td>4000 ms</td>
<td>允许的最大连接间隔</td>
</tr>
<tr>
<td>Connection (slave) latency</td>
<td>0 to 500</td>
<td>Slaver允许的延迟次数</td>
</tr>
<tr>
<td>Supervision timeout</td>
<td>100 ms to 32000 ms</td>
<td>设置一个失败超时时间</td>
</tr>
</tbody></table>
<p>对于 <code>Connection latency</code>, 就是Master会持续发送多个数据包来等待Slaver的回应.</p>
<p>BLE点对点连接的数据交换示意图, 也同时说明了频道的变化:<br><img src="https://draapho.github.io/images/1713/ble-connect.png" alt="ble connect.png"></p>
<h1 id="GAP"><a href="#GAP" class="headerlink" title="GAP"></a>GAP</h1><p>通用访问服务, 是对LL层的广播,监听,建立连接功能的抽象, 便于开发人员来理解和开发</p>
<p>GAP的主要作用:</p>
<ul>
<li>Broadcast mode and observation procedure，实现单向的、无连接的通信方式；</li>
<li>Discovery modes and procedures，实现蓝牙设备的发现操作；</li>
<li>Connection modes and procedures，实现蓝牙设备的连接操作；</li>
<li>Bonding modes and procedures，实现蓝牙设备的配对操作.</li>
</ul>
<p>GAP层的蓝牙设备角色:</p>
<ul>
<li>Broadcaster Role，设备正在发送广播；</li>
<li>Observer Role，设备正在扫描广播；</li>
<li>Peripheral Role， 对应Link Layer的slave角色, 可广播和被连接</li>
<li>Central Role，对应Link Layer的master角色, 扫描和发起连接的一方</li>
</ul>
<p><strong>关于蓝牙设备的角色名称问题, 无力吐槽, 各个分层都有一套自己的术语, 看的时候注意其对应的架构层次再来理解</strong></p>
<h1 id="ATT"><a href="#ATT" class="headerlink" title="ATT"></a>ATT</h1><p>该协议将单一的数值(信息)以Attribute(属性)的形式抽象出来，并提供一些方法，供远端设备读取和修改</p>
<p>一个Attribute由Attribute Type、Attribute Handle和Attribute Value组成</p>
<ul>
<li>Attribute Type用于标示Attribute的类型, 譬如温度/湿度等.<br>Attribute Type使用 <code>UUID</code> (Universally Unique IDentifier)区分, 有 16-bit, 32-bit, 128-bit</li>
<li>Attribute Handle是一个16-bit的数值, 简称 <code>Handle</code>. 用作唯一识别Attribute server上的所有Attribute<br>Attribute Handle可理解为Attribute的地址, 有如下意义：<ul>
<li>一个server上可能存在多个相同类型的Attribute, 显然, client有区分这些Attribute的需要</li>
<li>同一类型的多个Attribute, 可以组成一个Group, client可以通过这个Group中的起, 始handle访问所有的Attributes</li>
</ul>
</li>
<li>Attribute Value代表Attribute的值，可以是任何固定长度或者可变长度的octet array （理解为字节类型的数组即可）。</li>
<li>Attribute Permission代表Attribute的权限. 是否可读写, 是否加密等等.</li>
</ul>
<p>ATT设备角色, 采用client-server的形式.</p>
<ul>
<li>Server: 提供信息(即Attribute)的一方为服务方, 一般是传感器节点 (大多数情况是Advertiser / Slaver / Peripheral)</li>
<li>Client: 访问信息(即Attribute)的一方为客户端, 一般是手机等终端 (大多数情况是Scanner / Master / Central)</li>
</ul>
<p><strong>关于蓝牙设备的角色名称问题, 无力吐槽, 各个分层都有一套自己的术语, 看的时候注意其对应的架构层次再来理解</strong></p>
<h1 id="GATT"><a href="#GATT" class="headerlink" title="GATT"></a>GATT</h1><p>基于ATT提供的数值, 将有用的数值组打包好, 已服务(service)的方式开放给上层应用. 它相当于提供一套数据打包框架/规则.</p>
<p>看框架图:<br><img src="https://draapho.github.io/images/1713/ble-gatt1.png" alt="ble gatt.png"><br><img src="https://draapho.github.io/images/1713/ble-gatt.gif" alt="ble gatt.gif"></p>
<p>GATT profile的层次结构依次是： Profile—&gt;Service—&gt;characteristic</p>
<ul>
<li><code>Profile</code> 是基于GATT所派生出的真正的Profile， 由一个或者多个和某一应用场景有关的 <code>Service</code> 组成</li>
<li><code>Service</code> 包含一个或者多个 <code>Characteristic</code>, 也可以通过Include的方式, 包含其它 <code>Service</code></li>
<li><code>Characteristic</code> 则是GATT profile中最基本的数据单位, 由一个 <code>Properties / Declaration</code>, 一个 <code>Value</code>, 一个或者多个<code>Descriptor</code>组成</li>
<li><code>Characteristic Properties / Declaration</code> 定义了characteristic的Value如何被使用，以及characteristic的Descriptor如何被访问。</li>
<li><code>Characteristic Value</code> 是特征的实际值，例如一个温度特征，其Characteristic Value就是温度值就。</li>
<li><code>Characteristic Descriptor</code> 则保存了一些和Characteristic Value相关的信息</li>
</ul>
<p>UUID 的分配</p>
<ul>
<li><a href="https://www.bluetooth.com/specifications/gatt/services">GATT Services 官方标准</a></li>
<li><a href="https://www.bluetooth.com/specifications/gatt/characteristics">GATT Characteristics 官方标准</a></li>
<li><a href="http://www.itu.int/en/ITU-T/asn1/Pages/UUID/uuids.aspx">UUID Generation UUID 生成器</a></li>
</ul>
<h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><p>负责BLE通信中有关安全的内容.</p>
<p>主要技术有:</p>
<ul>
<li>配对, pairing</li>
<li>认证, authentication</li>
<li>加密, encryption</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.silabs.com/documents/login/user-guides/ug103-14-fundamentals-ble.pdf">UG103.14: Application Development Fundamentals: Bluetooth® Smart Technology</a></li>
<li><a href="http://www.wowotech.net/bluetooth/bt_overview.html">蓝牙协议分析(1)_基本概念</a>,<br>简单介绍了标准蓝牙和低功耗蓝牙. 正如作者所说, 蓝牙的架构设计很不”美”, 给人一种拆拆补补, 各自为政的感觉. 但不可否认, 商业上, 蓝牙是成功的!</li>
<li><a href="http://www.wowotech.net/bluetooth/bt_protocol_arch.html">蓝牙协议分析(2)_协议架构</a><br>从全局概念介绍了蓝牙架构的设计, 并对各个分层进行了简单的介绍.</li>
<li><a href="http://www.wowotech.net/bluetooth/ble_stack_overview.html">蓝牙协议分析(3)_蓝牙低功耗(BLE)协议栈介绍</a><br>对快速理解低功耗蓝牙(BLE) 非常有帮助! 也是从架构说起, 逐步深入细节的叙事风格</li>
<li><a href="http://www.wowotech.net/bluetooth/ipv6_over_ble_intro.html">蓝牙协议分析(4)_IPv6 Over BLE介绍</a><br>说明了加入IPv6协议的重大意义. 物联网大势所趋, 而IPv6必将成为数据传输的最终标准! (Zigbee也支持了IPv6, Thread天生就采用6LowPAN协议)</li>
<li><a href="http://www.wowotech.net/bluetooth/ble_broadcast.html">蓝牙协议分析(5)_BLE广播通信相关的技术分析</a></li>
<li><a href="http://www.wowotech.net/bluetooth/ble_address_type.html">蓝牙协议分析(6)_BLE地址类型</a></li>
<li><a href="http://www.wowotech.net/bluetooth/ble_connection.html">蓝牙协议分析(7)_BLE连接有关的技术分析</a></li>
<li><a href="http://www.wowotech.net/bluetooth/ble_white_list.html">蓝牙协议分析(8)_BLE安全机制之白名单</a></li>
<li><a href="http://www.wowotech.net/bluetooth/ble_ll_privacy.html">蓝牙协议分析(9)_BLE安全机制之LL Privacy</a></li>
<li><a href="http://www.wowotech.net/bluetooth/le_encryption.html">蓝牙协议分析(10)_BLE安全机制之LE Encryption</a><br>渐渐就由浅入深, 探讨技术细节了.</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded</category>
      </categories>
      <tags>
        <tag>embedded</tag>
        <tag>ble</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑|这样表达，事半功倍</title>
    <url>/2017/05/04/1714-expression/</url>
    <content><![CDATA[<p><em><strong>转载自 <a href="http://www.jianshu.com/p/a2bcce138f48">逻辑|这样表达，事半功倍（附训练方法）</a></strong></em></p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>﻿表达是生活工作中最重要的沟通方式。<br>正式场合的表达，我们称为“演讲”、“汇报”、“发言”等；<br>休闲场合的表达，我们称为“闲聊”、“侃大山”、“吹牛”等。<br>总而言之，表达是我们传递信息、交流感情的重要技能。<br>那怎样的表达，能事半功倍呢？</p>
<h1 id="一段对话"><a href="#一段对话" class="headerlink" title="一段对话"></a>一段对话</h1><p>我们先来看这样的对话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">老板：“年会准备得怎么样？”</span><br><span class="line">小美：“酒店我们定的XX大酒店，最近搞年会的多，只有那里时间价格都合适。</span><br><span class="line">我们让各个部门都出了节目，彩排了一次，删掉了几个唱歌的节目，剩下都是舞蹈、魔术、小品等。</span><br><span class="line">主持人还在筛选中，主持稿已经编好了。</span><br><span class="line">优秀员工的名单还没定好，有的部门经理还没交名单，不过奖品已经准备好了。</span><br><span class="line">会场的宣传品也买好了，因为是十周年，所以背景墙和装饰品都是十年为主。”</span><br></pre></td></tr></table></figure>

<p>听完小美的回答，你觉得老板的感受是什么？<br>老板清楚年会准备情况了吗？老板又怎么看待小美的能力呢？<br>在现实中，老板听完小美的回答，默默的走开，向另外一个员工询问情况去了。<br>这也就意味着，小美那么长的回答、那么详细的回答，其实都是无效的！</p>
<p>日常生活中，我们经常会有这样类似的表达，所以，我们总是感觉：“我说得这么清楚，对方却还是不明白、不会做、做不好，对方还是不明白我的苦心”。</p>
<p>对方的因素，我们暂不讨论，讨论也无用，我们改变不了别人。<br>我们尝试一下从自己的角度着手，也许，改变一下自己表达的逻辑，就能让对方接收到更多的信息和更正确的感情。</p>
<h1 id="一、神马是逻辑"><a href="#一、神马是逻辑" class="headerlink" title="一、神马是逻辑"></a>一、神马是逻辑</h1><p>如何把200ML的水装进100ML的杯子里呢？（不需要局限目前科学情况能不能做到，展开想象，因为这个例子是为了说明逻辑思考过程，而不是真的让您去装水，嘿嘿）<br>首先我们来分析来题目，正常情况我们都知道，把200ML的水倒入100ML的杯子里，水肯定会流出来，想要装进而不流出来，就要先想想，水会流出来的原因是什么？<br>第一、水太多了<br>第二、杯子容量太小了</p>
<p>还有第三吗？<br>还有一个动词叫“流出来”！所以，第三：地球有引力，多出来的水会流下来。<br>所以，思考这个题目就可以从这三方面着手：水、杯子、客观环境。</p>
<p>水，我们能改变什么呢？<br>形态！把200ML的水成冰柱放进杯子里可以吗？<br>杯子，我们能改变什么呢？<br>数量、材质！两个杯子可以放200ML的水吧！固定材质的杯子确实装不了200ML的水，如果是软性材质的杯子呢？比如类似气球材质的杯子。<br>客观环境，怎样使水不流出来呢？</p>
<p>我把200ML的水倒进一个200ML的量瓶里（或者海绵），把量瓶放进杯子可以吗？﻿我在没有引力的特殊空间里倒水可以吗？</p>
<p><img src="https://draapho.github.io/images/1714/water-analysis.jpg" alt="water-analysis.jpg"></p>
<p>这个案例告诉我们，<strong>任何事物都是分三个关键因素的：主体、客体、外部环境。</strong><br>这个案例的推导过程，便是传说中的“逻辑”：运用概念、判断、推理等思维类型反映事物本质与规律的认识过程。</p>
<p>比如，我走了很远的路，你就能推理出来，我腿软腿酸加口渴。这就是逻辑。<br>所以，我们的<strong>表达需要符合逻辑，才符合人类正常的判断、分析问题的思维过程。</strong></p>
<p>那么什么样的表达才叫“有逻辑”呢？</p>
<p><img src="https://draapho.github.io/images/1714/four-principle.jpg" alt="four-principle.jpg"></p>
<h1 id="二、结论先行"><a href="#二、结论先行" class="headerlink" title="二、结论先行"></a>二、结论先行</h1><p>为什么要结论先行？<br>因为人类的大脑，只能逐句理解我们表达的思想，大脑会默认，我们的前后句表达具有某种逻辑的关系。</p>
<p><strong>如果我们不预先告诉听众这种逻辑关系是什么，听众会非常吃力的去一句一句的去理解、去推导。</strong>在这个过程中，一旦听众的理解与我们的理解不一样，就会造成信息误差，这就是为什么别人做的事总是不符合我们的要求！</p>
<p>而且，如果我们的<strong>表达句式很长，或信息量很大，对方会由于逐句理解而产生疲劳</strong>，那我们表达的后半段，对听众而言，都是无效的。</p>
<p><img src="https://draapho.github.io/images/1714/pyramid-people.jpg" alt="pyramid-people.jpg"></p>
<p><strong>解决办法只有一个：结论先行！</strong></p>
<h2 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上个星期，我去了我舅舅家。</span><br><span class="line">你知道吗，我舅舅家在很偏远的乡下。</span><br><span class="line">就是路边还有很老的电线杆，晚上开灯，灯还会忽亮忽暗的乡下。</span><br><span class="line">他们主要是种田为生，要么就出门打工，当然打工的人也就过年才回老家咯。</span><br><span class="line">我到他家里的时候，正好他们忙完农活，我想着他们忙完了应该回家休息或者做晚饭对吧，</span><br><span class="line">没想到啊，他们竟然聚集在一个修了洋房的村民家买彩票，</span><br><span class="line">没想到啊，乡下比城里更加盛行彩票...</span><br></pre></td></tr></table></figure>

<p>请问以上表达，中心思想是什么？你看完后，心累吗？<br>不好意思，主人，为了案情需要，编了这么长一段废话，为了让您感受到结论先行的突出优势，哈哈哈，不要打我~</p>
<p>怎样把上面的话，变成结论先行的表达呢？ 修改如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原来乡下比城里更加盛行彩票！</span><br><span class="line">上个星期，我去了我舅舅家，他家在很偏远的乡下。</span><br><span class="line">我到他家里的时候，正好他们忙完农活，我想着他们忙完了应该回家休息或做晚饭对吧，</span><br><span class="line">没想到啊，他们竟然聚集在一个修了洋房的村民家买彩票...</span><br></pre></td></tr></table></figure>

<p>结论先行还有个好处就是督促自己少说废话。因为话是我们自己说出来的，我们都急于维护自己的观点，所以后面的解释，一般都是为了维护…</p>
<h2 id="否定的结论，记得先赞美对方！"><a href="#否定的结论，记得先赞美对方！" class="headerlink" title="否定的结论，记得先赞美对方！"></a><strong>否定的结论，记得先赞美对方！</strong></h2><h2 id="训练方法："><a href="#训练方法：" class="headerlink" title="训练方法："></a>训练方法：</h2><p>方法一、表达从这句开始：我想表达一个观点…（强迫自己从结论说起）<br>方法二、<br>    1. 自己围绕一个主题说一段话并且录音<br>    2. 重听录音，找到结论<br>    3. 从结论开始再说一次，并录音<br>    4. 对比两段录音的效果，找到成就感。</p>
<h1 id="三、以上统下"><a href="#三、以上统下" class="headerlink" title="三、以上统下"></a>三、以上统下</h1><p>以上统下的意思是：所有的论据都要支撑论点，所有的原因都要支持结论。<br>翻译为人话就是：荤类下面没有南瓜，也不能把鸡腿放到素菜下面。<br>当我们做到了结论先行，后面的表达都要能支持这个结论。像上面的案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">他们主要是种田为生，要么就出门打工，当然打工的人也就过年才回老家咯。</span><br></pre></td></tr></table></figure>

<p>这句话不能支持“乡下比城里更加盛行彩票”的结论，就应该删掉！<br>想要做到以上统下，可以向自己提问，“论据支持论点吗？”</p>
<h2 id="举个栗子：-1"><a href="#举个栗子：-1" class="headerlink" title="举个栗子："></a>举个栗子：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我喜欢男神宋仲基，因为他帅，他眼神温柔，他脱衣有肉、穿衣显瘦（咽口水），</span><br><span class="line">都敏俊也很帅～</span><br></pre></td></tr></table></figure>
<p>那句话不能支持“我喜欢宋仲基”？<br>对，就是最后一句，都敏俊！</p>
<h2 id="训练方法：-1"><a href="#训练方法：-1" class="headerlink" title="训练方法："></a>训练方法：</h2><ol>
<li>自己围绕一个主题说一段话并且录音</li>
<li>重听录音，找到结论和论点、论据，并画成如上图一样的结构图</li>
<li>问自己“论据支持论点吗”</li>
<li>修改论点或者论据</li>
<li>按照修改后的结构图，再说一次并录音</li>
<li>对比两段录音的效果，找到成就感。</li>
</ol>
<h2 id="四、归类分组"><a href="#四、归类分组" class="headerlink" title="四、归类分组"></a>四、归类分组</h2><p>你现在正准备出去散步，你爱人说“顺便买点东西回来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">葡萄、牛奶、土豆、胡萝卜、鸡蛋、橘子、咸鸭蛋、苹果、酸奶</span><br></pre></td></tr></table></figure>

<p>你买回来什么？<br>如果换成这样呢？</p>
<p><img src="https://draapho.github.io/images/1714/buy-stuff.jpg" alt="buy-stuff.jpg"></p>
<p>有没有好记一些？<br><strong>人的大脑天生就会把相似的东西串在一起记忆、理解</strong>，这就是为什么英语背单词有词根记忆这码事。<br>我们不能违背人的天性，所以，在表达中，我们要把相似的论据放在一起，不同的论据进行分组呈现。<br>归类分组要注意<strong>不要重复！</strong></p>
<p>我经常会在工作总结中看到别人的总结如下：<br>成绩：业绩达成80%<br>不足：业绩只达成80%<br>这就是典型的分组有问题，80%的业绩到底是成绩还是不足？<br>一个论据只能在一个论点里！</p>
<h2 id="训练方法：-2"><a href="#训练方法：-2" class="headerlink" title="训练方法："></a>训练方法：</h2><ol>
<li>围绕主题罗列所以的论据</li>
<li>将论据分组</li>
<li>给每组找到一个中心思想，这个中心思想是该组每个论据的共同特质</li>
<li>检查结果“有没有遗漏”、“有没有重复”</li>
</ol>
<h1 id="五、逻辑递进"><a href="#五、逻辑递进" class="headerlink" title="五、逻辑递进"></a>五、逻辑递进</h1><p>逻辑递进就是按照某种推导方向，来全面的认知事物，翻译为人话叫：顺序！<br>常用的逻辑递进方式有：<br>时间（步骤）顺序：第一、第二、第三；<br>结构（空间）顺序：东南西北中，动作表情语言；<br>程度（重要性）顺序：最重要（核心）、次重要、第三重要……<br>演绎顺序：大前提、小前提、结论；</p>
<p>而我想着重强调的是，表达中最有效的顺序，应该是： <strong>以听众的利益/需求程度来排序</strong></p>
<h2 id="举个栗子：-2"><a href="#举个栗子：-2" class="headerlink" title="举个栗子："></a>举个栗子：</h2><p>我们银行需要跟餐饮商家合作，我们的工作人员交出以下合作方案：</p>
<ol>
<li>客户持卡消费享受88折</li>
<li>客户通过我们银行的APP购买商家优惠券80抵100元（类似团购APP消费模式）</li>
<li>客户到店消费满200元送乐扣水杯（水杯归我们银行出钱购买）</li>
</ol>
<p>这样的排序方式能打动商家吗？<br>商家需要什么？商家想要打折、想少收钱吗？<br>商家想要的是，你能帮我提高客单价，让我赚实实在在的钱！你能帮我吸引很多的客户入店，让我赚实实在在的钱！</p>
<p>所以，最好的排序方式应该是：</p>
<ol>
<li>客户到店消费满200元送乐扣水杯（提高了客单价，还不用商家出钱）</li>
<li>APP购买优惠券80抵100（虽然少赚点钱，但是能吸引客户从店外入店消费）</li>
<li>客户持卡消费88折（已经到店吃完了的客户，多么不想打折）</li>
</ol>
<h2 id="训练方法：-3"><a href="#训练方法：-3" class="headerlink" title="训练方法："></a>训练方法：</h2><ol>
<li>自己围绕一个主题说一段话并且录音</li>
<li>重听录音，找到结论和论点、论据，并画成结构图</li>
<li>写下听众的需求和利益点</li>
<li>按照需求程度将论据重新排序</li>
<li>按照修改后的结构图，再说一次并录音</li>
<li>对比两段录音的效果，找到成就感。</li>
</ol>
<h1 id="六、终极栗子"><a href="#六、终极栗子" class="headerlink" title="六、终极栗子"></a>六、终极栗子</h1><p>你马上要参加技术总监岗位的竞聘，以下是你多年来的工作业绩，请问你怎么表达？<br>工作业绩总结：2010年至2016年，参与了10个项目</p>
<ul>
<li>项目1： 担任技术负责人，保证多个项目如期完成</li>
<li>项目2： 克服人员经验不足的困难，开展岗位培训</li>
<li>项目3： 辅助技术攻关，解决重大难点</li>
<li>项目4： 在公司流程基础上，制定新的公司管理流程和规范</li>
<li>项目5： 为方便员工学习及知识传承，建立领域知识库</li>
<li>项目6： 主持项目实施研讨，制定项目实施规范</li>
<li>项目7： 作为导师，带教3位新员工</li>
<li>项目8： 制作全套岗位课件（10个PPT），并授课</li>
<li>项目9： 负责梦里花大型项目技术担当，并作出突出贡献</li>
<li>项目10： 组织技术部人员与华为技术部人员学习沟通，提供人员综合能力</li>
</ul>
<p>试着自己画结构图，表达一下，再看答案欧～<br><img src="https://draapho.github.io/images/1714/work-performance.jpg" alt="work-performance.jpg"></p>
<h1 id="彩蛋：表达生动三大宝"><a href="#彩蛋：表达生动三大宝" class="headerlink" title="彩蛋：表达生动三大宝"></a>彩蛋：表达生动三大宝</h1><p>这部分属于彩蛋，跟逻辑没关系，跟表达有关系。<br>很多人的表达干巴巴的，没有说服力，怎么办呢？<br><strong>表达生动三大宝：数据、案例、对比</strong></p>
<h2 id="举个栗子：-3"><a href="#举个栗子：-3" class="headerlink" title="举个栗子："></a>举个栗子：</h2><p>“这块我很熟练”<br>这句话听上去是不是很没有说服力？<br>加个数据：“我有三年的工作经验”、“我处理过上百起这类业务”<br>加个案例“之前XX公司他们的那个XX项目，听说过吗，就是我做的”<br>加个对比“之前我们领导对这块很不满意，我接手一年以后，这块业务直接成了公司的重点发展项目！”<br>怎么样，是不是听上去更值得相信？</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>还记得文章开头的案例吗？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">老板：年会准备得怎么样？</span><br><span class="line">小美的同事，我，这样回答：</span><br><span class="line">    其他准备工作都已经完成，只差敲定主持人跟优秀员工名单了（结论先行）。</span><br><span class="line">    会场（论点A）定的XX大酒店，</span><br><span class="line">    XX大酒店时间与价格都合适（论据A1），</span><br><span class="line">    会场装饰道具都已经采购好，全是以十周年为主题（论据A2），</span><br><span class="line">    节目这块（论点B）已经彩排了一次，</span><br><span class="line">    择优录取了十个节目，都是舞蹈、魔术、小品等（论据B1），</span><br><span class="line">    主持人还在筛选中，主持稿已经编好了（论据B2），</span><br><span class="line">    颁奖的优秀员工的名单还没定好，因为有的部门经理还没交名单，不过奖品已经准备好了（论据B3）。</span><br><span class="line">    您放心，肯定能按时完成准备工作，您要是能帮忙催下部门经理就好了，我们催得他们都烦了。</span><br><span class="line">老板：行，优秀员工的事我去催一下！</span><br></pre></td></tr></table></figure>

<p><img src="https://draapho.github.io/images/1714/annual-meeting.jpg" alt="annual-meeting.jpg"></p>
<p><strong>表达：一定要让对方好理解、好接受为原则，一定要以对方的利益为出发点！</strong><br>注：本文逻辑结构来源于《金字塔原理》书中金字塔结构～</p>
<hr>
<p><em><strong>转载自 <a href="http://www.jianshu.com/p/a2bcce138f48">逻辑|这样表达，事半功倍（附训练方法）</a></strong></em></p>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>self-expression</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言知识巩固</title>
    <url>/2017/05/17/1715-c/</url>
    <content><![CDATA[<h1 id="常数的数据类型"><a href="#常数的数据类型" class="headerlink" title="常数的数据类型"></a>常数的数据类型</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 1234            <span class="comment">// default type, int</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 123456l         <span class="comment">// long</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 1234u           <span class="comment">// unsigned int</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 123456ul        <span class="comment">// unsigned long</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 123.4f          <span class="comment">// float</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 1e-2f           <span class="comment">// float</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 123.4           <span class="comment">// default type, double</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 1e-2            <span class="comment">// default type, double</span></span></span><br></pre></td></tr></table></figure>


<h1 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X    <span class="meta-string">&#x27;x&#x27;</span>        <span class="comment">// 直接使用字母, 会自动转换为ASCII编码</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR   <span class="meta-string">&#x27;\015&#x27;</span>     <span class="comment">// 八进制表示CR, 以\0开头</span></span></span><br><span class="line">#define CR   &#x27;\13&#x27;      // 十进制表示CR, 以\开头</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR   <span class="meta-string">&#x27;\x0D&#x27;</span>     <span class="comment">// 十六进制表示CR, 以\x开头</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR   <span class="meta-string">&#x27;\r&#x27;</span>       <span class="comment">// 特殊表示法</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串, 独立使用多个双引号, 也表示一串字符串</span></span><br><span class="line"><span class="keyword">char</span> short_str[] = <span class="string">&quot;hello,&quot;</span> <span class="string">&quot; world&quot;</span> <span class="string">&quot;!&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> long_str[] = <span class="string">&quot;this is a very very long string,&quot;</span></span><br><span class="line">                  <span class="string">&quot;so you can set it in multi lines &quot;</span></span><br><span class="line">                  <span class="string">&quot;by this way&quot;</span></span><br></pre></td></tr></table></figure>



<h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># <span class="number">1.</span> == 和 != 优先级高于位操作符 &amp; | ^</span><br><span class="line"><span class="keyword">if</span> ((x &amp; MASK) == <span class="number">0</span>)        <span class="comment">// (x &amp; MASK) 括号不能省!</span></span><br><span class="line"><span class="keyword">if</span> ( x &amp; y == <span class="number">0</span>)            <span class="comment">// 含义为 x &amp; (y==0)</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span> 赋值运算符优先级最低 (只比逗号高一级别)</span><br><span class="line"><span class="keyword">if</span> ((c = getchar()) != EOF) <span class="comment">// c获得输入值, 然后判断是否是结束符</span></span><br><span class="line"><span class="keyword">if</span> (c = getchar() != EOF)   <span class="comment">// 含义为 c = (getchar() != EOF), 所以c的赋值为 TRUE 或者 FALSE</span></span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span> &amp;&amp; 的优先级 高于 ||</span><br><span class="line"><span class="keyword">if</span> ((cond1 || cond2) &amp;&amp; cond3)  <span class="comment">// 先或再与</span></span><br><span class="line"><span class="keyword">if</span> (cond1 || cond2 &amp;&amp; cond3)    <span class="comment">// 含义为 cond1 || (cond2 &amp;&amp; cond3)</span></span><br><span class="line"></span><br><span class="line"># <span class="number">4.</span> 算数运算优先级高于位移运算</span><br><span class="line">(msb &lt;&lt; <span class="number">4</span>) + lsb            <span class="comment">// 先位移, 再做加法</span></span><br><span class="line">msb &lt;&lt; <span class="number">4</span> + lsb              <span class="comment">// 含义为 msb &lt;&lt; (4 + lsb)</span></span><br><span class="line"></span><br><span class="line"># <span class="number">5.</span> 先-&gt;/./&amp;, 然后++/--, 最后 *,</span><br><span class="line">++p-&gt;len                    <span class="comment">// ++(p-&gt;len), len值++</span></span><br><span class="line">p-&gt;len++                    <span class="comment">// (p-&gt;len)++, len值++</span></span><br><span class="line">(++p)-&gt;len                  <span class="comment">// 先加p的值, 然后取len值</span></span><br><span class="line">p++-&gt;len                    <span class="comment">// (p++)-&gt;len 先加p的值, 然后取len值</span></span><br><span class="line">p-&gt;++len                    <span class="comment">// p-&gt;(++len) 语法错误, 不知道len是什么!</span></span><br><span class="line"></span><br><span class="line">++*p                        <span class="comment">// ++(*p), 内容++</span></span><br><span class="line">(*p)++                      <span class="comment">// 内容++</span></span><br><span class="line">*p++                        <span class="comment">// *(p++), 地址++, 然后取内容</span></span><br><span class="line"></span><br><span class="line">++*p-&gt;str                   <span class="comment">// ++(*p-&gt;str). str指向的内容++</span></span><br><span class="line">(*p-&gt;str)++                 <span class="comment">// str指向的内容++</span></span><br><span class="line">*p-&gt;str++                   <span class="comment">// *(p-&gt;str), (p-&gt;str)++. 取出str的内容, 然后str地址++</span></span><br><span class="line">*p++-&gt;str                   <span class="comment">// *p-&gt;str, p++. 取出str的内容, 然后p++</span></span><br><span class="line">*++p-&gt;str                   <span class="comment">// *(++p-&gt;str). str地址++, 然后取str的内容</span></span><br><span class="line">*p-&gt;++str                   <span class="comment">// *p-&gt;(++str) 语法错误, 不知道str是什么!</span></span><br><span class="line"></span><br><span class="line">++*p.len                    <span class="comment">// ++*(p.len), 多数情况下p是指针, 因此语法错误</span></span><br><span class="line">++(*p).len                  <span class="comment">// ++(p-&gt;len), str值++</span></span><br><span class="line">(*p++).len                  <span class="comment">// p++-&gt;len, p地址++, 然后取str值</span></span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>说明</th>
<th>结合方向</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>后置 <code>++</code> <code>--</code></td>
<td>自增++ 自减–</td>
<td>左到右</td>
</tr>
<tr>
<td></td>
<td><code>[]</code></td>
<td>数组下标</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>()</code></td>
<td>（表达式）/函数名(形参表)</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>.</code></td>
<td>对象.成员名</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>-&gt;</code></td>
<td>对象指针-&gt;成员名</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td><code>-</code></td>
<td>负号</td>
<td>右到左</td>
</tr>
<tr>
<td></td>
<td><code>(类型)</code></td>
<td>强制类型转换</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>++</code> <code>--</code> 前置</td>
<td>++自增 –自减</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>*</code></td>
<td>*指针表达式</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>&amp;</code></td>
<td>&amp;左值表达式</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>!</code></td>
<td>!表达式</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>~</code></td>
<td>~表达式</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>sizeof</code></td>
<td>sizeof 表达式/sizeof(类型)</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td><code>*</code> <code>/</code> <code>%</code></td>
<td>乘 除 取余</td>
<td>左到右</td>
</tr>
<tr>
<td>4</td>
<td><code>+</code> <code>-</code></td>
<td>加 减</td>
<td>左到右</td>
</tr>
<tr>
<td>5</td>
<td><code>&lt;&lt;</code> <code>&gt;&gt;</code></td>
<td>左移 右移</td>
<td>左到右</td>
</tr>
<tr>
<td>6</td>
<td><code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code></td>
<td>大于(等于) 小于(等于)</td>
<td>左到右</td>
</tr>
<tr>
<td>7</td>
<td><code>==</code> <code>!=</code></td>
<td>等于 不等于</td>
<td>左到右</td>
</tr>
<tr>
<td>8</td>
<td><code>&amp;</code></td>
<td>按位与</td>
<td>左到右</td>
</tr>
<tr>
<td>9</td>
<td><code>^</code></td>
<td>按位异或</td>
<td>左到右</td>
</tr>
<tr>
<td>10</td>
<td><code>l</code> (竖杠)</td>
<td>按位或</td>
<td>左到右</td>
</tr>
<tr>
<td>11</td>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
<td>左到右</td>
</tr>
<tr>
<td>12</td>
<td><code>ll</code> (竖杠)</td>
<td>逻辑或</td>
<td>左到右</td>
</tr>
<tr>
<td>13</td>
<td><code>?:</code></td>
<td>表达式1? 表达式2: 表达式3</td>
<td>右到左</td>
</tr>
<tr>
<td>14</td>
<td><code>=</code> <code>/=</code> <code>*=</code> <code>%=</code> <code>+=</code> <code>-=</code></td>
<td>赋值运算符</td>
<td>右到左</td>
</tr>
<tr>
<td></td>
<td><code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>&amp;=</code> <code>^=</code> <code>l=</code> (竖杠)</td>
<td>位赋值运算符</td>
<td></td>
</tr>
<tr>
<td>15</td>
<td><code>,</code></td>
<td>表达式,表达式,…</td>
<td>左到右</td>
</tr>
</tbody></table>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以 const 为例, volitale是一样的.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>;          <span class="comment">// int是const</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>;          <span class="comment">// int是const</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*;        <span class="comment">// char是const</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>*;        <span class="comment">// char是const</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span>;        <span class="comment">// *(指针)是const</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>;  <span class="comment">// char和*都是const</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>* <span class="keyword">const</span>;  <span class="comment">//char和*都是const</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>register</code>, 建议编译器把该变量直接放到寄存器中, 而不是内存中. 以提高运算速度!<ul>
<li>注意, 只是<strong>建议</strong>, 因此编译器可以忽略这个关键字</li>
<li>变量必须是能被CPU寄存器接收的数据类型, 如 <code>int</code></li>
<li>现代编译器的优化效率很高, 因此 <code>register</code> 很少使用.</li>
<li><strong>还有一点</strong>. 譬如 <code>register int val;</code> 这时 <code>&amp;val</code> 会报错! 因为取的是内存地址, 而val是在寄存器内, 所以不存在内存地址!</li>
</ul>
</li>
<li><code>auto</code>, 老版本C用于声明这是一个局部变量(与<code>static</code>相反). 新版本用于声明一个自动类型的变量.<ul>
<li>这个关键字是真没人去用. 因为函数内默认就是局部变量.</li>
<li>习惯写C的人, 基本习惯了先选好一个数据类型.</li>
</ul>
</li>
</ul>
<h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #, Stringfication! 将宏变量直接转变为字符串(加上双引号)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(v)        printf(#v <span class="meta-string">&quot;=%x\n&quot;</span>, v)</span></span><br><span class="line"></span><br><span class="line">debug(value);           <span class="comment">// 宏展开为 printf(&quot;value&quot; &quot;=%x\n&quot;, value)</span></span><br><span class="line">                        <span class="comment">// 若value值为0xFF, 执行结果就是打印出: value=0xFF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ##, Concatenator! 宏变量连接符, 多用于自动生成变量名</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAT(x,y)        x##y</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINK(a,b,c)     a##_##b##_##c</span></span><br><span class="line"></span><br><span class="line">CAT(var, <span class="number">12</span>);           <span class="comment">// 宏展开为 var12</span></span><br><span class="line">LINK(name,age,sex);     <span class="comment">// 宏展开为 name_age_sex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __VA_ARGS__, 宏定义可变参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_DEBUG 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DRV_DEBUG</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> DRV_PRINT(fmt, ...) printf(fmt, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> DRV_PRINT(fmt, ...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器内置的宏定义:</span></span><br><span class="line">__LINE__                <span class="comment">// 在源代码中插入当前源代码行号；</span></span><br><span class="line">__FILE__                <span class="comment">// 在源文件中插入当前源文件名；</span></span><br><span class="line">__DATE__                <span class="comment">// 在源文件中插入当前的编译日期</span></span><br><span class="line">__TIME__                <span class="comment">// 在源文件中插入当前编译时间；</span></span><br><span class="line">__STDC__                <span class="comment">// 当要求程序严格遵循ANSI C标准时该标识被赋值为1；</span></span><br><span class="line">__cplusplus             <span class="comment">// 当编写C++程序时该标识符被定义。</span></span><br></pre></td></tr></table></figure>


<h1 id="typedef-的用法"><a href="#typedef-的用法" class="headerlink" title="typedef 的用法"></a>typedef 的用法</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我习惯将所有typedef定义为形如 uint8_t, 即已 &quot;_t&quot; 结尾</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; <span class="keyword">point_t</span>;                          <span class="comment">// 数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">pfun_t</span>)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;    <span class="comment">// 函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> <span class="keyword">array80_t</span>[<span class="number">80</span>];         <span class="comment">// 数组</span></span><br></pre></td></tr></table></figure>

<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *name[] = &#123; <span class="string">&quot;None&quot;</span>, <span class="string">&quot;Jan&quot;</span>, <span class="string">&quot;Feb&quot;</span>, <span class="string">&quot;Mar&quot;</span> &#125;;     <span class="comment">// 指针数组 name</span></span><br><span class="line"><span class="keyword">int</span> *daytab[<span class="number">13</span>];    <span class="comment">// 指针数组 daytab</span></span><br><span class="line"><span class="keyword">int</span> (*daytab)[<span class="number">13</span>];  <span class="comment">// 数组指针 daytab, 譬如 int a[3][13], 则可以 p=a; p++后就指向了 &amp;a[1][0]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">f</span><span class="params">()</span></span>;           <span class="comment">// f 函数的返回值为指针类型</span></span><br><span class="line"><span class="keyword">int</span> (*pf)();        <span class="comment">// 函数指针 pf</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这两个是极端复杂的例子, 实际代码建议先用 typedef 定义好一层, 然后再嵌套使用, 会容易理解的多!</span></span><br><span class="line"><span class="keyword">char</span> (*(*x[<span class="number">3</span>])())[<span class="number">5</span>];   <span class="comment">// x: array[3] of pointer to function returning pointer to array[5] of char</span></span><br><span class="line">                        <span class="comment">// x,一个指针数组, 这些指针指向函数, 函数的返回值是数组指针...</span></span><br><span class="line"><span class="keyword">char</span> (*(*x())[])();     <span class="comment">// x: function returning pointer to array[] of pointer to function returning char</span></span><br><span class="line">                        <span class="comment">// x,一个函数, 返回值为一个指针. 这个指针指向一个函数指针列表. 函数指针列表指向的函数是返回 char 类型的.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 举个例子 -----&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">foo</span><span class="params">()</span>    </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">bar</span><span class="params">()</span>    </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;b&#x27;</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">blurga</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;c&#x27;</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">bletch</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;d&#x27;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> (*gfunclist[])() = &#123;foo, bar, blurga, bletch&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> (*(*x())[])()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">char</span> <span class="params">(*funclist[<span class="number">4</span>])</span><span class="params">()</span> </span>= &#123;foo, bar, blurga, bletch&#125;;</span><br><span class="line">    <span class="keyword">return</span> &amp;funclist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,gfunclist[<span class="number">0</span>]());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> (*(*fs)[<span class="number">4</span>])();</span><br><span class="line">    fs = x();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,(*fs)[<span class="number">1</span>]());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更容易读懂的版本 -----&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">char</span> <span class="params">(*<span class="keyword">pfun_t</span>)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">foo</span><span class="params">()</span>    </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">bar</span><span class="params">()</span>    </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;b&#x27;</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">blurga</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;c&#x27;</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">bletch</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;d&#x27;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pfun_t</span> gfunclist[] = &#123;foo, bar, blurga, bletch&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pfun_t</span>* <span class="title">x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pfun_t</span> funclist[<span class="number">4</span>] = &#123;foo, bar, blurga, bletch&#125;;</span><br><span class="line">    <span class="keyword">return</span> funclist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,gfunclist[<span class="number">0</span>]());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pfun_t</span> *fs;</span><br><span class="line">    fs = x();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,fs[<span class="number">1</span>]());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="结构体和位域"><a href="#结构体和位域" class="headerlink" title="结构体和位域"></a>结构体和位域</h1><ul>
<li><code>Bit-fields</code> 位域, 一般不建议使用. 编译器相关且机器相关, 因此可移植性很差.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> is;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> keyword : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">extern</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">static</span> : <span class="number">1</span>;</span><br><span class="line">    &#125; flags;</span><br><span class="line">&#125; bit_union;</span><br></pre></td></tr></table></figure>


<h1 id="printf-及-scanf"><a href="#printf-及-scanf" class="headerlink" title="printf 及 scanf"></a>printf 及 scanf</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印任意字符串的安全方法</span></span><br><span class="line"><span class="built_in">printf</span>(s);                      <span class="comment">// FAILS if s contains %</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);                <span class="comment">// SAFE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用可变参数的方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minprintf</span><span class="params">(<span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap; <span class="comment">/* points to each unnamed arg in turn */</span></span><br><span class="line">    va_start(ap, fmt); <span class="comment">/* make ap point to 1st unnamed arg */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something ...</span></span><br><span class="line">    ival = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">// do something ...</span></span><br><span class="line"></span><br><span class="line">    va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义 printf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_PRINT(fmt, ...) printf(fmt, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// scanf 避免溢出的方法</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf);               <span class="comment">// 可能溢出!</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%20s&quot;</span>, buf);             <span class="comment">// 最多读取20个字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己写个scanner.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanner</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> buflen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> format[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">if</span> (buflen == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">snprintf</span>(format, <span class="keyword">sizeof</span>(format), <span class="string">&quot;%%%ds&quot;</span>, (<span class="keyword">int</span>)(buflen<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">scanf</span>(format, buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://net.pku.edu.cn/~course/cs101/2008/resource/The_C_Programming_Language.pdf">The C programming Language</a></li>
<li>[Cheat Sheets of the C standard library][<a href="http://ws3.ntcu.edu.tw/ACS099133/cheatsheet/c-libraries-cheatsheet.pdf]">http://ws3.ntcu.edu.tw/ACS099133/cheatsheet/c-libraries-cheatsheet.pdf]</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>AI和物联网的潜在应用</title>
    <url>/2017/05/29/1716-AI-IoT/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基于目前AI和物联网的发展, 在可见的未来必然有无数的领域受到严重影响.<br>就我思考的范围而言, 此文列举出技术上基本可行的几种应用, 只是需要在商业模式, 技术细节上需要进一步考虑.</p>
<h1 id="AI的发展模式"><a href="#AI的发展模式" class="headerlink" title="AI的发展模式"></a>AI的发展模式</h1><p>AlphoGo 在围棋上的完胜绝对是意义非凡. AlphoGo是真AI, 而不单单是一堆0,1+逻辑运算的机器.</p>
<p>数学上有个概念叫建模, 本质上就是一种抽象. 只是这种抽象需要用数学表达出来, 便于他人理解和使用.<br>有了这么一个模型后, 就能描述系统的因果关系和相互关系.</p>
<p>大家都知道数学建模很难, 但实际上, 不严格的建模无处不在, 人类的经验就是对某个事物/系统/过程的一种建模结果,<br>依靠这种经验, 人去判断事物/系统/过程的因果关系和相互关系. 但经验很难学习和表达!</p>
<p>AlphoGo 就是基于人类的过往经验和自我训练, 形成了自己的对围棋的一套认知, 一组经验.<br>这种经验的形成设计者可以去查看前因后果, 但恐怕很难去描述和理解.</p>
<p>关键点就是:</p>
<ul>
<li><strong>AlphoGo 对围棋进行了抽象, 有自己对围棋的经验, 或者说”理解”.</strong>, 其抽象能力高于所有的人类棋手!</li>
<li>围棋有规则, 有边界, 但无法穷举运算. 也就是需要一定程度的抽象来解决问题.</li>
<li>智力至少是和抽象能力正相关的. 智商高的一般抽象能力更强, “理解”的更快更深更透.</li>
</ul>
<h2 id="现阶段的AI"><a href="#现阶段的AI" class="headerlink" title="现阶段的AI"></a>现阶段的AI</h2><p>目前阶段的AI需要人类设定目标和范围, 需要大量的数据进行前期训练已获得对抽象能力, 或曰”经验”.<br>通过良好的训练, 这种”经验”可以远胜于人类! 而且人类很难去理解.</p>
<p>这一阶段的AI必然被广泛应用于特定目标, 譬如股市, 人像识别, 军事领域.<br>人们对这一阶段的AI也会觉得比较放心, 因为目标是人给的, 训练数据也是人给的.<br>至少这台机器只有智力, 没有创造力! 但毫无疑问, 即使在这一阶段, 也会造成大量人员的事业, 金融业已经发生了!</p>
<p>训练好的机器可以单机运行, 因此AI机器人从技术上讲, 已经可行了. 譬如蔬果采集机器人.</p>
<h2 id="第二阶段的AI"><a href="#第二阶段的AI" class="headerlink" title="第二阶段的AI"></a>第二阶段的AI</h2><p>第一阶段的AI, 最繁琐的部分就是前期训练, 让AI获取数据, 用以获取”经验”<br>自然而然, 人们会想着办法偷懒, 让机器自己去获取数据, 自我训练. 这不就是”自我学习”么.<br>这阶段依然是安全的, AI有如一个听话懂事又聪明的小孩, 给定目标, 拼命学习, 执行任务.<br>但是, 其实人们已经渐渐失去了对AI的控制, AI能自学后, 人们越来越难理解AI的”思考”方式, 追踪整个过程变得复杂而不现实.</p>
<p>这一阶段, AI飞速发展, 在各个特定领域展露手脚… (人们或许可以自娱自乐获取财富? 或是踩脚踏车?)</p>
<h2 id="第三阶段的AI"><a href="#第三阶段的AI" class="headerlink" title="第三阶段的AI"></a>第三阶段的AI</h2><p>量变是会造成质变的. 当人们越来越依赖于AI的时候, 或许不仅会让AI自学, 还会为了解决更复杂的问题, 让不同的AI相互交流和学习.<br>譬如做城市规划的AI, 必然可以读取人口预测AI, 建筑规划AI, 地质天气信息预测AI,<br>说不定为了达到目标, 这个大AI还会自动分配一个小任务: 城市人口迁徙预测AI (分配目标, 自学去)<br>这个时候, 人们已经完全无法了解城市规划AI所做决定的前因后果了… 这个AI的目的可能是明确的, 但其边界已经不由人类控制.</p>
<p>如果此时给AI若干终极问题 (目标明确, 边界由AI自行决定):</p>
<ul>
<li>帮助人类永生 (即人类一直繁衍生存下去) …</li>
<li>让所有人幸福 …</li>
<li>探索宇宙 …</li>
</ul>
<p>希望到这时候, AI还没有学会用欺骗来达到目的, 这样人们可能还有机会提前知道AI给出的解决方案, 来决定是不是要拔电源…</p>
<h1 id="物联网的基础模式"><a href="#物联网的基础模式" class="headerlink" title="物联网的基础模式"></a>物联网的基础模式</h1><p>目前物联网发展日趋成熟, 共享单车的技术方案充分展示了这种技术上的成熟度!</p>
<p><img src="https://draapho.github.io/images/1716/IoT_structure.png" alt="IoT_structure"></p>
<h2 id="节点端"><a href="#节点端" class="headerlink" title="节点端"></a>节点端</h2><p>主要功能就是信息的采集和发送.<br>主要技术难点是供电持久性, 便携性, 稳定可靠性.<br>部分涉及音视频传输的节点, 技术上就更复杂.<br>不同的应用领域有不同的需求, 是一个需要定制的设备.</p>
<h2 id="云端"><a href="#云端" class="headerlink" title="云端"></a>云端</h2><p>云端即数据库, 进行数据的收集, 存储和再分析. 需要注意安全性, 吞吐量.<br>未来, 数据即价值所在. 因为目前的AI需要前期大量的数据来训练, 训练成功后有无穷的潜力.</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>没啥好说的, 目前高度集中于两种展示平台:</p>
<ul>
<li>浏览器</li>
<li>苹果手机APP</li>
<li>android手机APP</li>
</ul>
<h1 id="潜在的商业应用"><a href="#潜在的商业应用" class="headerlink" title="潜在的商业应用"></a>潜在的商业应用</h1><p>天马行空, 随便聊聊. 作为一个技术人员, 可以肯定技术上已经可行或即将可行.</p>
<h2 id="一般的物联网应用"><a href="#一般的物联网应用" class="headerlink" title="一般的物联网应用"></a>一般的物联网应用</h2><p>更多在于发现潜在的商业机会, 挖掘特定行业的物联需求.<br>技术实现有一定复杂度(跨度太大, 从硬件到云端, 完全自行开发不现实).</p>
<h2 id="物联网方案公司"><a href="#物联网方案公司" class="headerlink" title="物联网方案公司"></a>物联网方案公司</h2><p>考虑到大多数初创公司没有能力进行全程研发, 建立物联网方案公司, 帮助其解决技术难题.<br>自我定位要准确: 帮助别的公司完成研发, 要考虑别的公司的核心利益.<br>因此, 采集的核心数据要开放出来, 不能私有.<br>对没有研发能力的公司可以收取服务费维持系统运行,<br>对于发展到一定程度, 希望全部自己控制的公司可以进行技术买断.</p>
<p>收费模式为: 低进入费, 稳定的服务费, 高买断费.</p>
<h2 id="共享汽车"><a href="#共享汽车" class="headerlink" title="共享汽车"></a>共享汽车</h2><p>灵感来源于共享单车和无人驾驶车.<br>若无人驾驶车量产后, 政府允许真的无人汽车自主运行. 那汽车租赁有机会在城市里蚕食掉大部分私车市场.<br>因为呼之即来, 挥之即去(就近自动找停车位). 不用担心停车, 维护问题. 每辆车的高频率使用也意味着单次出行的低成本.</p>
<h2 id="农业收割"><a href="#农业收割" class="headerlink" title="农业收割"></a>农业收割</h2><p>单机版AI+机器人, 可以完成非标准化的蔬果采摘工作.<br>提前训练好AI, 用来识别特定的水果, 以及采摘方式.<br>将此AI植入合适的机器人, 即可实现高效的自动农业收割.</p>
<p>当然, 都AI机器人了, 自然也是结合物联网上传采摘了多少果子之类的简单功能了.</p>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>AI IoT thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>敏捷开发 Scrum 学习</title>
    <url>/2017/05/31/1717-scrum/</url>
    <content><![CDATA[<h1 id="学习资源推荐"><a href="#学习资源推荐" class="headerlink" title="学习资源推荐"></a>学习资源推荐</h1><ul>
<li><a href="http://scrumtrainingseries.com/">Scrum Training Series</a>, 通俗易懂的视频教程</li>
<li><a href="http://www.scrumreferencecard.com/">Scrum Reference Card</a>, Scrum 参考卡</li>
<li><a href="http://scrummasterchecklist.org/">The Scrum Master Checklist</a>, Scrum Master 职能清单</li>
<li><a href="http://www.scrumguides.org/download.html">The Scrum Guide™</a>, Scrum 指导手册下载 (多国语言)</li>
<li>测试. 建议测试完后, 再看一下 <a href="http://scrumtrainingseries.com/">Scrum Training Series</a> 视频<ul>
<li><a href="https://www.proprofs.com/quiz-school/story.php?title=mte3mjcynamkcf">Scrum Assessment</a></li>
<li><a href="https://www.proprofs.com/quiz-school/story.php?title=quizscrum">Scrum (Programming) Quiz</a></li>
<li><a href="https://www.proprofs.com/quiz-school/story.php?title=certified-scrum-master-test">Certified Scrum Master Test</a></li>
<li><a href="https://www.proprofs.com/quiz-school/story.php?title=NjAyMjg5#">Scrum Training Series, Part 1: Introduction To Scrum</a></li>
<li><a href="https://www.proprofs.com/quiz-school/story.php?title=NzA4NjI0OO75">Scrum 30题</a></li>
</ul>
</li>
</ul>
<h1 id="Scrum-核心点概要"><a href="#Scrum-核心点概要" class="headerlink" title="Scrum 核心点概要"></a>Scrum 核心点概要</h1><p><img src="https://draapho.github.io/images/1717/Sprint.JPG" alt="Sprint"></p>
<h2 id="敏捷开发宣言"><a href="#敏捷开发宣言" class="headerlink" title="敏捷开发宣言"></a>敏捷开发宣言</h2><ul>
<li><strong>Individuals and interactions</strong> over processes and tools</li>
<li><strong>Working software</strong> over comprehensive documentation</li>
<li><strong>Customer collaboration</strong> over contract negotiation</li>
<li><strong>Responding to change</strong> over following a plan</li>
</ul>
<h2 id="Scrum-Team-Roles"><a href="#Scrum-Team-Roles" class="headerlink" title="Scrum Team Roles"></a>Scrum Team Roles</h2><ul>
<li><strong>Product Owner</strong>, 产品负责人<ol>
<li>核心工作是确定产品需求, 确定产品是否可接受/可发布. 并确保研发团队专注于该产品的开发(挡住干系人对研发团队可能的干扰)</li>
<li>管理和维护 <code>PBI</code>, 并设定优先级.</li>
<li>确保 <code>PBI</code> 对整个团队清晰可见, 高度透明, 并清楚的知道最高优先项.</li>
<li>需要与第三方(利益相关者/老板/客户)确定需求, 接纳或拒绝新需求.</li>
<li>第三方只能和产品负责人讨论产品进度/好坏之类的问题, 甚至发牢骚. 不得直接干预研发团队!</li>
<li>一般地, 此职位可由项目经理担任. 需要特别注意公司老板不得越过项目经理去分配任务!</li>
<li>产品负责人只需要粗颗粒的拆分一下需求, 更细粒度的拆分由研发团队一起完成.</li>
<li><strong>Focused more on the what than on how</strong>. 侧重于要产品实现什么, 而不是怎么实现的问题.</li>
<li>仅对产品负责, 并不是研发团队的管理人员! Scrum 要求研发团队自我管理.</li>
</ol>
</li>
<li><strong>Development Team</strong>, 研发团队<ol>
<li>产品的技术实现团队, 由4-9人组成较为合适. 譬如 UI设计师x1, 行业专家x1, 软件开发x2, 测试x1.</li>
<li>跨职能, 职责包括需求分析和拆解, 设计, 编码, 测试以及部署.</li>
<li>团队成员自我组织和管理, 高度协作. 相互平等, 没有领导者!</li>
<li>整个团队最好在一起工作, 可以大大提高效率.</li>
<li>在 <code>Sprint Planning Meeting</code> 上, 把 <code>PBI</code> 拆解为 <code>Sprint Tasks</code> 放在 <code>Sprint Backlog</code> 一栏.</li>
<li>以 <code>Sprint</code> 为周期, 都要尽可能的完成一个可演示/可发布的产品版本.</li>
</ol>
</li>
<li><strong>Scrum Master</strong>, Scrum大师 (被误解最多的一个职位)<ol>
<li>Scrum的起步很困难, 因此有了Scrum大师来帮助整个团队理解Scrum的理论, 实践方式, 以及内在精神. 排除实践过程中可能走得弯路.</li>
<li>Scrum大师没有任何决策权, 也不是一个管理岗位. 主要作用就是帮助团队学习使用Scrum框架, 消除误解, 排除干扰和障碍.</li>
<li>这个角色的初衷, 类似于婴儿学步阶段需要有个引导者, 这样可以学的快, 少摔跤. 但没有这个角色, 并不是说就学不会走路了.</li>
<li>实际项目中, 很少有团队会去请一个Scrum大师… 因此这个职位可以被分解为两部分: 理解Scrum, 严格执行Scrum的实践要求.</li>
<li>Scrum的理论和精神已经摆在那里, 因此可以团队成员一起学习讨论, 在实践中进行案例分析, 自学之.</li>
<li>严格执行Scrum的实践, 主要包括: 建立一个舒适的会议环境, 安排和控制会议时间, 确保会议内容仅与项目相关. 建议找一个项目之外的人来做.</li>
</ol>
</li>
</ul>
<h2 id="The-Sprint"><a href="#The-Sprint" class="headerlink" title="The Sprint"></a>The Sprint</h2><ul>
<li><code>Sprint</code> 是Scrum的核心, 时间跨度为2周到一个月.</li>
<li><code>Sprint</code> 由 <code>Sprint Planning</code>, <code>Daily Scrums</code>, 开发工作, <code>Sprint Review</code>, <code>Sprint Retrospective</code> 组成</li>
<li>一个 Sprint 周期内, 可以看成是一个完整的瀑布模式:<ul>
<li>不能改变设定的目标</li>
<li>必须有测试, 不能降低检测标准</li>
<li>目标实现的范围可以和 <code>Product Owner</code> 重新讨论和确定</li>
<li>最终实现一个可用的, 完全测试过的, 可潜在发布的软件版本.</li>
</ul>
</li>
<li>仅<code>Product Owner</code> 有权取消一个 <code>Sprint</code>. 很少出现这种情况, 写在这里只是为了明确职责.</li>
<li><code>Done</code>的定义<ul>
<li>Scrum团队的每个人都清除的知道 <code>Done</code> 意味着什么.</li>
<li><code>Done</code> 可以是大家共同理解的惯例, 标准或指南</li>
<li><code>Done</code> 也可以由 <code>Development Team</code> 在 <code>Sprint Planning Meeting</code> 上确定.</li>
</ul>
</li>
</ul>
<h2 id="Scrum-Meetings"><a href="#Scrum-Meetings" class="headerlink" title="Scrum Meetings"></a>Scrum Meetings</h2><p><img src="https://draapho.github.io/images/1717/meeting_flow.JPG" alt="meeting_flow"></p>
<p><img src="https://draapho.github.io/images/1717/meeting_schedule.JPG" alt="meeting_schedule"></p>
<ul>
<li><strong>Backlog Refinement Meeting</strong> PBI修整会议<ol>
<li>所有Scrum人员参与, 可以在每个Sprint执行过程中拿出点时间(如2小时)进行一次, 为下一次的 <code>Sprint Planning</code> 做准备</li>
<li>主要任务是将部分高优先级的粗颗粒<code>PBI</code>分解为细颗粒 <code>PBI</code>, 并确定对<code>Product Owner</code>而言何为 <code>Done</code></li>
<li>细化程度为 <a href="http://xp123.com/articles/invest-in-good-stories-and-smart-tasks/"><strong>INVEST</strong>: Independent, Negotiable, Valuable, Estimable, Small, Testable 或 <strong>SMART</strong>: Specific, Measurable, Achievable, Relevant, Time-boxed</a>, 以及 <strong>3W</strong>: Who, What, Why</li>
</ol>
</li>
<li><strong>Sprint Planning Meeting</strong> 计划会议<ol>
<li>所有Scrum人员参与. 时间控制在4-8小时左右.</li>
<li><code>Sprint Planning</code> 需要确定在一个<code>Sprint</code>周期内, 做什么以及怎么做.</li>
<li><code>Product Owner</code> 维护 <code>PBI</code> 的优先级. 每次总是讨论最高优先级的 <code>PBI</code></li>
<li><code>Product Owner</code> 不应对 <code>Development Team</code> 施加进度压力. 产品开发复杂度远大于外行的想象, 直接干预容易在后期造成技术负债.</li>
<li><code>Development Team</code> 确定何为 <code>Done</code>. 需要特别注意还要考虑代码的向后兼容性, 必要时甚至重构.</li>
<li><code>Development Team</code> 进一步拆分 <code>PBI</code> 为 <code>Sprint Task</code>, 并认领这些任务.</li>
<li><code>Development Team</code> 需要相互协作和评估, 设定在一个 <code>Sprint</code> 周期内可完成的目标.<br>初期, 开发人员容易接受过多的任务, 而不是过少的任务. 这会导致一个 <code>Sprint</code> 内无法完成承诺的任务!<br>注意, 这里不单是指编码工作, 还包含了设计, 代码重构, 完整的测试, 以及潜在的发布, 是一整个瀑布开发的模式.</li>
</ol>
</li>
<li><strong>Daily Scrum Meeting</strong> 日会<ol>
<li>每天同一时间, 同一地点, <code>Development Team</code> 花费15分钟相互报告情况.</li>
<li>内容为: 昨天做了什么, 今天要做什么, 是否遇到障碍. 这样可确保任务透明, 成员自律而高效.</li>
<li>站着开会, 以保持会议简短. 如果有额外需要关注的话题, 在该会议结束后, 相关人员参与即可.</li>
<li><code>Product Owner</code> 可以选择参与. 但团队的领导或主管不要参与!</li>
<li>日会讨论时, 可能会讨论出其他不相干的话题(sidebar), 则可以日会后仅相关人员参与. 不要占用日会时间.</li>
</ol>
</li>
<li><strong>Sprint Review Meeting</strong> 评审会议<ol>
<li>一个<code>Sprint</code>周期到达后, 就需要开评审会议, 以确定成果. <code>Development Team</code> 展示一个可潜在交付的软件版本.</li>
<li>所有Scrum人员, 以及干系人都可以参加, <code>Development Team</code> 进行现场演示以获得干系人的反馈 (不是写文案做报告).</li>
<li><code>Product Owner</code> 逐条检查在 <code>Sprint Backlog</code> 里的 <code>PBI</code>, 宣布哪些<code>Done</code>, 哪些没有完成(即将完成也是没完成!).</li>
<li><code>Product Owner</code> 将没完成的 <code>PBI</code> 放回 <code>Product Backlog</code>, 重新设定优先级</li>
<li><code>Product Owner</code> 配合干系人, 将他们新的意见转换为需求, 放入 <code>Product Backlog</code>, 设定优先级</li>
</ol>
</li>
<li><strong>Sprint Retrospective Meeting</strong> 回顾会议<ol>
<li>所有Scrum人员参与, 可以放在<code>Sprint Review Meeting</code> 之后, 花费1-3小时.</li>
<li>回顾上一个 Sprint 执行过程中的经验得失 (譬如交流是否顺畅, 开发工具的使用, 学习心得) . 是否有改进余地.</li>
<li><code>Scrum Master</code> 需要引导与会人真实的表达了自己的想法, 达到解决障碍和问题, 改进流程的目的.</li>
<li>回顾会议不是为了评估谁好谁坏, 决定日后如何分配奖金. 追求的是共同进步, 一起完成项目, 追求团队的成功.</li>
<li>这一部分, 我理解的不是很好.</li>
</ol>
</li>
</ul>
<h2 id="Scrum-Artifacts"><a href="#Scrum-Artifacts" class="headerlink" title="Scrum Artifacts"></a>Scrum Artifacts</h2><ul>
<li><strong>Product Backlog</strong><ol>
<li>一个展示区, 用于展示项目所期望的功能, 可以随时增减. 说明要做什么(开发目标)</li>
<li>所有干系人可见, 所有干系人(包括团队)均可添加条目</li>
<li><code>Product Owner</code> 持续地按优先级在 <code>Product Backlog</code> 区域排列 <code>PBI</code></li>
<li>顶部为细颗粒<code>PBI</code>, 底部为粗颗粒<code>PBI</code>.</li>
</ol>
</li>
<li><strong>Product Backlog Item</strong>, 简称<code>PBI</code><ol>
<li>由 <code>Backlog Refinement Meeting</code> 分解条目, 安排优先级.</li>
<li><code>PBI</code> 通常写成 <code>User Story</code>, 工作规模控制在 2-3个人工作2-3天可完成.</li>
</ol>
</li>
<li><strong>Sprint Backlog</strong><ol>
<li>在 <code>Sprint Planning Meeting</code> 上, <code>Development Team</code> 和 <code>Product Owner</code> 协商承诺的<code>PBI</code>组成</li>
<li>整个Scrum人员可见. 在Sprint执行期间, 承诺范围和任务目标不可改变.</li>
<li>在Sprint执⾏行期间, 团队将发现兑现既定范围承诺还需要的附加任务, 则放到 <code>Sprint Backlog</code> 中.</li>
<li>放在这里的 <code>PBI</code> 需要定义好 <code>Done</code>. 注意考虑复用性和向后兼容性, 以防止潜在的技术债务.</li>
</ol>
</li>
<li><strong>Sprint Task</strong> (optional)<ol>
<li>对如何完成一条PBI的若干简单描述. 该任务必须细化到一天以内即可完成</li>
<li>在Sprint执行期间, 每个人都可主动认领任务</li>
<li>由整个团队拥有, 需要协作.</li>
<li>这是一个可选项, 而非必须项. 过度使用并不利于提高效率.</li>
</ol>
</li>
<li><strong>Increment</strong><ol>
<li><code>Increment</code> 是一个 Sprint 完成的所有产品待办列表项的总和</li>
<li>完成一个 Sprint 时, 新的 <code>Increment</code> 必须是 <code>Done</code> 的, 并可用和潜在可发布.</li>
</ol>
</li>
</ul>
<h2 id="若干种Sprint的展示板"><a href="#若干种Sprint的展示板" class="headerlink" title="若干种Sprint的展示板"></a>若干种Sprint的展示板</h2><p><img src="https://draapho.github.io/images/1717/Sprint_backlog_1.JPG" alt="Sprint_backlog_1"></p>
<p><img src="https://draapho.github.io/images/1717/Sprint_backlog_2.JPG" alt="Sprint_backlog_2"></p>
<p><img src="https://draapho.github.io/images/1717/Sprint_backlog_3.JPG" alt="Sprint_backlog_3"></p>
<p><img src="https://draapho.github.io/images/1717/Sprint_backlog_4.JPG" alt="Sprint_backlog_4"></p>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>scrum</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下配置支持Windows访问的samba共享</title>
    <url>/2017/07/06/1718-linux-samba/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>家用电脑, 环境的搭建思路可参考<a href="https://draapho.github.io/2017/02/16/1705-linux-env/">嵌入式linux环境搭建-主机端</a></p>
<p>单位电脑, 没有使用nfs共享文件.<br>用的环境是: VMware Ubuntu 16.04 + Windows 7 + VMware 文件共享<br>尝试编译uboot时, 弹出一个错误提示</p>
<blockquote>
<p>ln: creating symbolic link XXXXXX : Operation not supported</p>
</blockquote>
<p>问题根源和解决方法:<br>出现这类问题，主要是由于在编译的时候，要用ln去建立一些软链接，而这些文件是从Windows中，通过VMWare虚拟机共享进Linux的，Windows不支持软链接，所以，编译会报错。<br>解决办法就是，在VMWare下的Linux中，建立Samba服务， 然后新创建新samba用户和文件夹，然后在windows中就可以访问到该文件夹了。</p>
<p>相比于nfs共享文件, 唯一的缺点是: 文件存放在虚拟机中, 需要始终打开虚拟机才能在windows下访问文件. 因此文件的备份和修复也稍微麻烦一点. 优点是, 不需要付费软件.</p>
<hr>
<p>下文转载自 <a href="http://blog.csdn.net/i_chips/article/details/19191957">Ubuntu下配置支持Windows访问的samba共享</a></p>
<hr>
<h1 id="一、安装Ubuntu-samba服务器"><a href="#一、安装Ubuntu-samba服务器" class="headerlink" title="一、安装Ubuntu samba服务器"></a>一、安装Ubuntu samba服务器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install samba</span><br><span class="line">$ sudo apt-get install smbclient <span class="comment"># Linux客户端测试用</span></span><br></pre></td></tr></table></figure>

<h1 id="二、创建samba配置文件"><a href="#二、创建samba配置文件" class="headerlink" title="二、创建samba配置文件"></a>二、创建samba配置文件</h1><ol>
<li><p>备份原配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.bak</span><br></pre></td></tr></table></figure></li>
<li><p>创建共享目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo mkdir -p /home/share</span><br><span class="line"><span class="comment"># 一般来说，该目录的权限为755，将其改为777之后，Owner之外的其他用户才有权限写入。</span></span><br><span class="line">$ sudo chmod 777 /home/share</span><br></pre></td></tr></table></figure></li>
<li><p>修改配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/samba/smb.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># ===== 文件内容, 在smb.conf最后添加： =====</span></span><br><span class="line">[share]</span><br><span class="line">    path = /home/share</span><br><span class="line">    browseable = yes</span><br><span class="line">    writable = yes</span><br><span class="line">    comment = smb share <span class="built_in">test</span></span><br><span class="line"><span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>另外，总结一下常见的samba配置及说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[share]                           # 该共享的共享名</span><br><span class="line">    comment &#x3D; smb share test  # 该共享的备注</span><br><span class="line">    path &#x3D; &#x2F;home&#x2F;share        # 共享路径</span><br><span class="line">    allow hosts &#x3D; host(subnet) # 设置该Samba服务器允许的工作组或者域</span><br><span class="line">    deny hosts &#x3D; host(subnet) # 设置该Samba服务器拒绝的工作组或者域</span><br><span class="line">    available &#x3D; yes|no        # 设置该共享目录是否可用</span><br><span class="line">    browseable &#x3D; yes|no       # 设置该共享目录是否可显示</span><br><span class="line">    writable &#x3D; yes|no         # 指定了这个目录缺省是否可写，也可以用readonly &#x3D; no来设置可写</span><br><span class="line">    public &#x3D; yes|no           # 指明该共享资源是否能给游客帐号访问，guest ok &#x3D; yes其实和public &#x3D; yes是一样的</span><br><span class="line">    user &#x3D; user, @group       # user设置所有可能使用该共享资源的用户，也可以用@group代表group这个组的所有成员，不同的项目之间用空格或者逗号隔开</span><br><span class="line">    valid users &#x3D; user, @group # 指定能够使用该共享资源的用户和组</span><br><span class="line">    invalid users &#x3D; user, @group # 指定不能够使用该共享资源的用户和组</span><br><span class="line">    read list &#x3D; user, @group  # 指定只能读取该共享资源的用户和组</span><br><span class="line">    write list &#x3D; user, @group # 指定能读取和写该共享资源的用户和组</span><br><span class="line">    admin list &#x3D; user, @group # 指定能管理该共享资源（包括读写和权限赋予等）的用户和组</span><br><span class="line">    hide dot files &#x3D; yes|no   # 指明是否像UNIX那样隐藏以“.”号开头的文件</span><br><span class="line">    create mode &#x3D; 0755        # 指明新建立的文件的属性，一般是0755</span><br><span class="line">    directory mode &#x3D; 0755     # 指明新建立的目录的属性，一般是0755</span><br><span class="line">    sync always &#x3D; yes|no      # 指明对该共享资源进行写操作后是否进行同步操作</span><br><span class="line">    short preserve case &#x3D; yes|no # 指明是否区分文件名大小写</span><br><span class="line">    preserve case &#x3D; yes|no    # 指明是否保持大小写</span><br><span class="line">    case sensitive &#x3D; yes|no   # 指明是否对大小写敏感，一般选no，不然可能引起错误</span><br><span class="line">    mangle case &#x3D; yes|no      # 指明混合大小写</span><br><span class="line">    default case &#x3D; upper|lower # 指明缺省的文件名是全部大写还是小写</span><br><span class="line">    force user &#x3D; testuser     # 强制把建立文件的属主是谁。如果我有一个目录，让guest可以写，那么guest就可以删除，如果我用force user&#x3D; testuser强制建立文件的属主是testuser，同时限制create mask &#x3D; 0755，这样guest就不能删除了</span><br><span class="line">    wide links &#x3D; yes|no       # 指明是否允许共享外符号连接，比如共享资源里面有个连接指向非共享资源里面的文件或者目录，如果设置wide links &#x3D; no将使该连接不可用</span><br><span class="line">    max connections &#x3D; 100     # 设定最大同时连接数</span><br><span class="line">    delete readonly &#x3D; yes|no  # 指明能否删除共享资源里面已经被定义为只读的文件</span><br></pre></td></tr></table></figure>

<h1 id="三、创建samba用户"><a href="#三、创建samba用户" class="headerlink" title="三、创建samba用户"></a>三、创建samba用户</h1><p>注意，创建samba用户之前，必须先确保有一个同名的linux用户，否则samba用户会创建失败。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo smbpasswd -a <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>

<h1 id="四、重启samba服务"><a href="#四、重启samba服务" class="headerlink" title="四、重启samba服务"></a>四、重启samba服务</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service smbd restart</span><br></pre></td></tr></table></figure>

<h1 id="五-客户端访问测试"><a href="#五-客户端访问测试" class="headerlink" title="五. 客户端访问测试"></a>五. 客户端访问测试</h1><ol>
<li><p>Linux客户端访问测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ smbclient -L //localhost/share</span><br></pre></td></tr></table></figure></li>
<li><p>Windows客户端访问测试<br> 可以访问如下地址 <code>\\Linux的IP或者主机名\share</code></p>
</li>
<li><p>我一般会把虚拟机端Linux的IP搞成静态地址, 这样远程登录也更方便</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ifconfig                          <span class="comment"># 查看IP信息</span></span><br><span class="line">$ sudo vim /etc/network/interfaces</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ===== 文件内容, 大致修改如下: =====</span></span><br><span class="line">    auto lo</span><br><span class="line">    iface lo inet loopback</span><br><span class="line">    auto eth0</span><br><span class="line"></span><br><span class="line">    iface eth0 inet static          <span class="comment"># 使用静态地址</span></span><br><span class="line">    address  192.168.0.100          <span class="comment"># 设置静态地址</span></span><br><span class="line">    netmask  255.255.255.0</span><br><span class="line">    gateway  192.168.0.1            <span class="comment"># 网关</span></span><br><span class="line">    dns-nameservers   8.8.8.8  192.168.0.1</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果public = no，此时需要输入samba用户密码；<br>如果public = yes，则作为nobody用户直接访问。<br>另外，在Windows客户端使用 <code>net use * /del /y</code> 这条命令可以清理访问缓存。</p>
<hr>
<p>转载自 <a href="http://blog.csdn.net/i_chips/article/details/19191957">Ubuntu下配置支持Windows访问的samba共享</a></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>uboot</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot之makefile分析</title>
    <url>/2017/07/07/1719-uboot-makefile/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/11/24/1735-jz2440-basic/">jz2440分区及启动的基础概念</a></li>
<li><a href="https://draapho.github.io/2017/07/07/1719-uboot-makefile/">uboot之makefile分析</a></li>
<li><a href="https://draapho.github.io/2017/08/25/1720-uboot-source/">uboot之源码分析</a></li>
<li><a href="https://draapho.github.io/2017/08/30/1721-uboot-modify/">uboot之定制指令</a></li>
</ul>
<p>本文基于 u-boot-1.1.6, 使用jz2440开发板. 若要使用最新的u-boot版本见: <a href="http://www.denx.de/wiki/U-Boot/WebHome">u-boot官网</a>  <a href="ftp://ftp.denx.de/pub/u-boot/">u-boot下载</a></p>
<h1 id="u-boot-编译过程"><a href="#u-boot-编译过程" class="headerlink" title="u-boot 编译过程"></a>u-boot 编译过程</h1><ol>
<li>解压缩 u-boot-1.1.6</li>
<li>打补丁 针对特定开发板发布的补丁. 打补丁方法<br><code>uboot目录下$ patch -p1 &lt; ../补丁文件</code>  p1表示忽略补丁目标目录的第一层</li>
<li>配置 <code>make 100ask24x0_config</code></li>
<li>编译: <code>make</code>, 获取 <code>u-boot.bin</code> 文件</li>
<li>烧录, 多种方式, 可以用jlink烧录到 NOR Flash 中</li>
</ol>
<h1 id="u-boot功能"><a href="#u-boot功能" class="headerlink" title="u-boot功能:"></a>u-boot功能:</h1><ul>
<li>本质是单片机程序</li>
<li>硬件相关初始化<ul>
<li>关看门狗</li>
<li>初始化时钟</li>
<li>初始化SDRAM</li>
<li>从Flash读取内核</li>
</ul>
</li>
<li>最终目的: 启动内核</li>
<li>为开发方便, 还支持:<ul>
<li>烧写flash</li>
<li>网卡</li>
<li>USB</li>
<li>串口</li>
</ul>
</li>
</ul>
<h1 id="u-boot的README"><a href="#u-boot的README" class="headerlink" title="u-boot的README"></a>u-boot的README</h1><p>要了解 u-boot 的架构和设计思路, 建议先看自带的 <code>README</code> 文件. 重要信息如下:</p>
<ul>
<li><code>include/configs/&lt;board_name&gt;.h</code>  板级配置头文件</li>
<li><code>make NAME_config</code>                加载配置, 准备编译</li>
<li><code>make</code> or <code>make all</code>              编译生成bin文件</li>
<li><code>Monitor Commands - Overview:</code>    u-boot 指令概览</li>
<li><code>Environment Variables:</code>          u-boot 环境变量</li>
<li><code>Linux HOWTO:</code>                    编译linux uImage</li>
<li><code>Boot Linux:</code>                     u-boot 启动Linux相关设置</li>
</ul>
<p>自己设置板级配置的步骤: (位于 README line 2375)</p>
<ol>
<li>Add a new configuration option for your board to the toplevel<br> “Makefile” and to the “MAKEALL” script, using the existing<br> entries as examples. Note that here and at many other places<br> boards and other names are listed in alphabetical sort order. Please<br> keep this order.</li>
<li>Create a new directory to hold your board specific code. Add any<br> files you need. In your board directory, you will need at least<br> the “Makefile”, a “<board>.c”, “flash.c” and “u-boot.lds”.</li>
<li>Create a new configuration file “include/configs/<board>.h” for<br> your board</li>
<li>If you’re porting U-Boot to a new CPU, then also create a new<br> directory to hold your CPU specific code. Add any files you need.</li>
<li> Run “make <board>_config” with your new name.</li>
<li>Type “make”, and you should get a working “u-boot.srec” file<br> to be installed on your target system.</li>
<li> Debug and solve any problems that might arise.</li>
</ol>
<h1 id="u-boot的Makefile"><a href="#u-boot的Makefile" class="headerlink" title="u-boot的Makefile"></a>u-boot的Makefile</h1><p>分析 <code>100ask24x0</code> 即jz2440板子的Makefile实现. Linux下可以使用grep搜索.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pwd = u-boot-1.1.6 文件夹下</span></span><br><span class="line">grep -n 100ask24x0 ./Makefile       <span class="comment"># 在Makefile文件下查找 100ask24x0, 并显示行号</span></span><br><span class="line">grep -nr 100ask24x0 *               <span class="comment"># 当前目录递归查找 100ask24x0</span></span><br><span class="line">grep -nwr 100ask24x0 *              <span class="comment"># w=word, 100ask24x0 作为一个单词查找</span></span><br><span class="line">grep -nd skip 100ask24x0 *          <span class="comment"># 仅在当前目录查找, 不显示子目录信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 特别强大的一条指令, 可针对指定文件搜索指定关键字!</span></span><br><span class="line"><span class="comment"># 先用find找出所有的Makefile文件, 然后在Makefile文件内查找 uImage 关键字.</span></span><br><span class="line">find ./ -name <span class="string">&quot;Makefile&quot;</span> | xargs grep -nw --color <span class="string">&quot;uboot&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="‘make-100ask24x0-config’-指令分析"><a href="#‘make-100ask24x0-config’-指令分析" class="headerlink" title="‘make 100ask24x0_config’ 指令分析"></a>‘make 100ask24x0_config’ 指令分析</h2><p><code>make 100ask24x0_config</code> 其指令结构和 <code>make clean</code> 是一样的.<br>因此在 Makefile 里找到 <code>100ask24x0_config</code> 为目标的行即可:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1886    100ask24x0_config   :   unconfig</span><br><span class="line">1887        @$(MKCONFIG) $(@:_config=) arm arm920t 100ask24x0 NULL s3c24x0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标为 100ask24x0_config, 没有依赖</span></span><br><span class="line"><span class="comment"># 执行 make 100ask24x0_config 后, 实际运行的就是第二行的指令</span></span><br><span class="line"><span class="comment"># 找到并替换里面的变量:</span></span><br><span class="line"><span class="comment">#   MKCONFIG    := $(SRCTREE)/mkconfig</span></span><br><span class="line"><span class="comment">#   SRCTREE     := $(CURDIR)</span></span><br><span class="line"><span class="comment">#   $(@:_config=) 其中 $(@) 表示目标, 即 `100ask24x0_config:_config=空`, 最终得到 `100ask24x0`</span></span><br><span class="line"><span class="comment"># 整句替换下来的指令就变成了:</span></span><br><span class="line">    ./mkconfig 100ask24x0 arm arm920t 100ask24x0 NULL s3c24x0</span><br></pre></td></tr></table></figure>

<p>因此, 我们需要去当前文件夹下查找 <code>mkconfig</code> 这个脚本文件.<br>下面直接删减成最终执行的样子, 前面加上原来的行号便于学习比较</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入为: ./mkconfig 100ask24x0 arm arm920t 100ask24x0 NULL s3c24x0</span></span><br><span class="line"><span class="comment"># 对应的变量:  $0        $1      $2   $3       $4        $5    $6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印信息</span></span><br><span class="line">23  BOARD_NAME=<span class="string">&quot;<span class="variable">$1</span>&quot;</span>                             <span class="comment"># BOARD_NAME=100ask24x0</span></span><br><span class="line">28  <span class="string">&quot;Configuring for <span class="variable">$&#123;BOARD_NAME&#125;</span> board...&quot;</span>    <span class="comment"># Configuring for 100ask24x0 board...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新创建一系列的软链接:</span></span><br><span class="line">46  <span class="built_in">cd</span> ./include</span><br><span class="line">47  rm -f asm</span><br><span class="line">48  ln -s asm-<span class="variable">$2</span> asm                            <span class="comment"># asm-&gt;asm-arm, 建立一个软连接, 使用asm-arm</span></span><br><span class="line">51  rm -f asm-<span class="variable">$2</span>/arch                           <span class="comment"># asm-arm/arch</span></span><br><span class="line">56  ln -s <span class="variable">$&#123;LNPREFIX&#125;</span>arch-<span class="variable">$6</span> asm-<span class="variable">$2</span>/arch        <span class="comment"># LNPREFIX. 因此 asm-arm/arch-&gt;arch-s3c24x0</span></span><br><span class="line">60  rm -f asm-<span class="variable">$2</span>/proc</span><br><span class="line">61  ln -s <span class="variable">$&#123;LNPREFIX&#125;</span>proc-armv asm-<span class="variable">$2</span>/proc      <span class="comment"># asm-arm/proc-&gt;proc-armv,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 config.mk 文件</span></span><br><span class="line">67  <span class="built_in">echo</span> <span class="string">&quot;ARCH   = <span class="variable">$2</span>&quot;</span> &gt;  config.mk             <span class="comment"># &gt;  新建, &quot;ARCH   = arm&quot;</span></span><br><span class="line">68  <span class="built_in">echo</span> <span class="string">&quot;CPU    = <span class="variable">$3</span>&quot;</span> &gt;&gt; config.mk             <span class="comment"># &gt;&gt; 追加, &quot;CPU    = arm920t&quot;</span></span><br><span class="line">69  <span class="built_in">echo</span> <span class="string">&quot;BOARD  = <span class="variable">$4</span>&quot;</span> &gt;&gt; config.mk             <span class="comment"># &gt;&gt; 追加, &quot;BOARD  = 100ask24x0&quot;</span></span><br><span class="line">71  [ <span class="string">&quot;<span class="variable">$5</span>&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$5</span>&quot;</span> != <span class="string">&quot;NULL&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;VENDOR = <span class="variable">$5</span>&quot;</span> &gt;&gt; config.mk   <span class="comment"># $5 = NULL, 不写VENDOR字段</span></span><br><span class="line">73  [ <span class="string">&quot;<span class="variable">$6</span>&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$6</span>&quot;</span> != <span class="string">&quot;NULL&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;SOC    = <span class="variable">$6</span>&quot;</span> &gt;&gt; config.mk   <span class="comment"># &quot;SOC = s3c24x0&quot;</span></span><br><span class="line"><span class="comment"># 可以使用 `cat ./include/config.mk` 查看该文件的内容.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 config.h 文件. 为了 `#include &lt;configs/100ask24x0.h&gt;`</span></span><br><span class="line">82  &gt; config.h                                                      <span class="comment"># &gt;  新建 config.h</span></span><br><span class="line">84  <span class="built_in">echo</span> <span class="string">&quot;/* Automatically generated - do not edit */&quot;</span> &gt;&gt;config.h   <span class="comment"># &gt;&gt; 追加写入</span></span><br><span class="line">85  <span class="built_in">echo</span> <span class="string">&quot;#include &lt;configs/<span class="variable">$1</span>.h&gt;&quot;</span> &gt;&gt;config.h                       <span class="comment"># &gt;&gt; 追加写入, $1=100ask24x0</span></span><br><span class="line"><span class="comment"># 可以使用 `cat ./include/config.h` 查看该文件的内容.</span></span><br></pre></td></tr></table></figure>

<h2 id="‘make’-指令分析"><a href="#‘make’-指令分析" class="headerlink" title="‘make’ 指令分析"></a>‘make’ 指令分析</h2><p><code>make</code> 实际上执行的是 <code>make all</code>, Makefile 中比较重要的几行为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">116 # load ARCH, BOARD, and CPU configuration</span><br><span class="line">117 include $(OBJTREE)&#x2F;include&#x2F;config.mk</span><br><span class="line">118 export  ARCH CPU BOARD VENDOR SOC</span><br><span class="line"># .&#x2F;include&#x2F;config.mk 这个文件由 &#96;make 100ask24x0_config&#96; 指令生成, 可获得如下变量</span><br><span class="line"># ARCH   &#x3D; arm</span><br><span class="line"># CPU    &#x3D; arm920t</span><br><span class="line"># BOARD  &#x3D; 100ask24x0</span><br><span class="line"># SOC    &#x3D; s3c24x0</span><br><span class="line"></span><br><span class="line">164 include $(TOPDIR)&#x2F;config.mk</span><br><span class="line"># u-boot-1.1.6 根目录下的配置文件, 里面有一些变量的定义</span><br><span class="line"></span><br><span class="line">169 OBJS  &#x3D; cpu&#x2F;$(CPU)&#x2F;start.o</span><br><span class="line">193 LIBS  &#x3D; lib_generic&#x2F;libgeneric.a</span><br><span class="line">194 LIBS +&#x3D; board&#x2F;$(BOARDDIR)&#x2F;lib$(BOARD).a</span><br><span class="line">195 LIBS +&#x3D; cpu&#x2F;$(CPU)&#x2F;lib$(CPU).a</span><br><span class="line">197 LIBS +&#x3D; cpu&#x2F;$(CPU)&#x2F;$(SOC)&#x2F;lib$(SOC).a</span><br><span class="line">199 LIBS +&#x3D; lib_$(ARCH)&#x2F;lib$(ARCH).a</span><br><span class="line"># 加载几个板级参数相关的变量值. 特别注意 start.o 这个文件, 是整个u-boot最先运行的文件</span><br><span class="line"></span><br><span class="line">239 ALL &#x3D; $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map $(U_BOOT_NAND)</span><br><span class="line">241 all:        $(ALL)</span><br><span class="line"># &#96;make&#96; 指令的入口就在这里. 可以根据 ALL 目标后面的依赖开始看这个 make 的过程</span><br><span class="line"></span><br><span class="line">262 $(obj)u-boot:       depend version $(SUBDIRS) $(OBJS) $(LIBS) $(LDSCRIPT)</span><br><span class="line">263         UNDEF_SYM&#x3D;&#96;$(OBJDUMP) -x $(LIBS) |sed  -n -e &#39;s&#x2F;.*\(__u_boot_cmd_.*\)&#x2F;-u\1&#x2F;p&#39;|sort|uniq&#96;;\</span><br><span class="line">264         cd $(LNDIR) &amp;&amp; $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \</span><br><span class="line">265             --start-group $(__LIBS) --end-group $(PLATFORM_LIBS) \</span><br><span class="line">266             -Map u-boot.map -o u-boot</span><br><span class="line"># 比较重要的一个指令. 可以运行 &#96;make&#96;, 在最后会看到这条指令的展开式, 用这种倒推的方式比较方便. 其展开如下:</span><br><span class="line"></span><br><span class="line">make[1]: Leaving directory &#39;&#x2F;home&#x2F;draapho&#x2F;jz2440&#x2F;uboot&#x2F;u-boot-1.1.6&#x2F;common&#39;</span><br><span class="line"># 这句不重要, 但这句的位置很明显, 所以写在这里了.</span><br><span class="line"></span><br><span class="line">UNDEF_SYM&#x3D;&#96;arm-linux-objdump -x lib_generic&#x2F;libgeneric.a board&#x2F;100ask24x0&#x2F;lib100ask24x0.a cpu&#x2F;arm920t&#x2F;libarm920t.a cpu&#x2F;arm920t&#x2F;s3c24x0&#x2F;libs3c24x0.a lib_arm&#x2F;libarm.a fs&#x2F;cramfs&#x2F;libcramfs.a fs&#x2F;fat&#x2F;libfat.a fs&#x2F;fdos&#x2F;libfdos.a fs&#x2F;jffs2&#x2F;libjffs2.a fs&#x2F;reiserfs&#x2F;libreiserfs.a fs&#x2F;ext2&#x2F;libext2fs.a net&#x2F;libnet.a disk&#x2F;libdisk.a rtc&#x2F;librtc.a dtt&#x2F;libdtt.a drivers&#x2F;libdrivers.a drivers&#x2F;nand&#x2F;libnand.a drivers&#x2F;nand_legacy&#x2F;libnand_legacy.a drivers&#x2F;usb&#x2F;libusb.a drivers&#x2F;sk98lin&#x2F;libsk98lin.a common&#x2F;libcommon.a |sed  -n -e &#39;s&#x2F;.*\(__u_boot_cmd_.*\)&#x2F;-u\1&#x2F;p&#39;|sort|uniq&#96;;\</span><br><span class="line"># 整个语句有点复杂, 用了一系列管道指令, 将最终结果赋值给 UNDEF_SYM 这么一个变量</span><br><span class="line"># 对 &quot;UNDEF_SYM&#x3D;&#96;$(OBJDUMP) -x $(LIBS) |sed  -n -e &#39;s&#x2F;.*\(__u_boot_cmd_.*\)&#x2F;-u\1&#x2F;p&#39;|sort|uniq&#96;;\&quot; 的展开</span><br><span class="line"># 其中 &quot;board&#x2F;100ask24x0&#x2F;lib100ask24x0.a cpu&#x2F;arm920t&#x2F;libarm920t.a cpu&#x2F;arm920t&#x2F;s3c24x0&#x2F;libs3c24x0.a lib_arm&#x2F;libarm.a&quot; 就是对 $(LIBS) 的展开</span><br><span class="line"></span><br><span class="line">cd &#x2F;home&#x2F;draapho&#x2F;jz2440&#x2F;uboot&#x2F;u-boot-1.1.6 &amp;&amp;</span><br><span class="line"># &quot;cd $(LNDIR) &amp;&amp;&quot; 的展开, 进入 u-boot-1.1.6 目录.</span><br><span class="line"></span><br><span class="line">arm-linux-ld -Bstatic -T &#x2F;home&#x2F;draapho&#x2F;jz2440&#x2F;uboot&#x2F;u-boot-1.1.6&#x2F;board&#x2F;100ask24x0&#x2F;u-boot.lds -Ttext 0x33F80000  $UNDEF_SYM cpu&#x2F;arm920t&#x2F;start.o \</span><br><span class="line"># &quot;$(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \&quot; 的展开</span><br><span class="line"># $(LD) 就是 arm-linux-ld 链接指令. 其中 &quot;LD    &#x3D; $(CROSS_COMPILE)ld&quot;, 定义在 &quot;.&#x2F;config.mk&quot;, $(CROSS_COMPILE) 在 Makefile 下面.</span><br><span class="line"># $(LDFLAGS) 给出了链接指令的参数, 定义在 &quot;.&#x2F;config.mk&quot;, 形式为 &quot;LDFLAGS +&#x3D; -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE) $(PLATFORM_LDFLAGS)&quot;</span><br><span class="line"># 根据 &quot;cpu&#x2F;arm920t&#x2F;start.o&quot;, 可以知道 start.s 的文件位置, 便于以后查看. (由u-boot.lds可知, 这是u-boot第一个运行的代码段)</span><br><span class="line"># !!! 其中 $(LDSCRIPT) 和 $(TEXT_BASE) 很重要 !!!</span><br><span class="line">    # &quot;LDSCRIPT :&#x3D; $(TOPDIR)&#x2F;board&#x2F;$(BOARDDIR)&#x2F;u-boot.lds&quot;, 定义在 &quot;.&#x2F;config.mk&quot;. 可以查看链接脚本</span><br><span class="line">    # &quot;TEXT_BASE &#x3D; 0x33F80000&quot;, 定义在 &quot;.&#x2F;board&#x2F;100ask24x0&#x2F;config.mk&quot;. 这个参数明显是板级相关的. 也可以使用 0x33F80000 来搜索.</span><br><span class="line"></span><br><span class="line">                --start-group lib_generic&#x2F;libgeneric.a board&#x2F;100ask24x0&#x2F;lib100ask24x0.a cpu&#x2F;arm920t&#x2F;libarm920t.a cpu&#x2F;arm920t&#x2F;s3c24x0&#x2F;libs3c24x0.a lib_arm&#x2F;libarm.a fs&#x2F;cramfs&#x2F;libcramfs.a fs&#x2F;fat&#x2F;libfat.a fs&#x2F;fdos&#x2F;libfdos.a fs&#x2F;jffs2&#x2F;libjffs2.a fs&#x2F;reiserfs&#x2F;libreiserfs.a fs&#x2F;ext2&#x2F;libext2fs.a net&#x2F;libnet.a disk&#x2F;libdisk.a rtc&#x2F;librtc.a dtt&#x2F;libdtt.a drivers&#x2F;libdrivers.a drivers&#x2F;nand&#x2F;libnand.a drivers&#x2F;nand_legacy&#x2F;libnand_legacy.a drivers&#x2F;usb&#x2F;libusb.a drivers&#x2F;sk98lin&#x2F;libsk98lin.a common&#x2F;libcommon.a --end-group -L &#x2F;usr&#x2F;local&#x2F;gcc-3.4.5-glibc-2.3.6&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;arm-linux&#x2F;3.4.5 -lgcc \</span><br><span class="line">                -Map u-boot.map -o u-boot</span><br><span class="line"># 依旧属于 arm-linux-ld 的指令, 这里就是对 &quot;$(__LIBS)&quot; 和 &quot;$(PLATFORM_LIBS)&quot; 的展开, 忽略这一段, 对理解没有影响.</span><br></pre></td></tr></table></figure>

<h2 id="‘u-boot-lds’-链接脚本分析"><a href="#‘u-boot-lds’-链接脚本分析" class="headerlink" title="‘u-boot.lds’ 链接脚本分析"></a>‘u-boot.lds’ 链接脚本分析</h2><p>根据对 Makefile 的分析, 可以知道uboot代码的偏移地址被设置成了 <code>-Ttext 0x33F80000</code> 这么一个值.<br>其含义就是, <strong>给u-boot的代码段分配的空间位于SDRAM最顶部的512K.</strong><br>jz2440使用的SDRAM大小为 64M, 即 0x400_0000, 预留512K (0x8_0000)给u-boot代码, 得到地址 0x3F8_0000.<br>因为 s3c24x0 给SDRAM分配的地址是从 0x3000_0000 开始的, 所以有了 0x33F8_0000 这么一个值.</p>
<p>链接脚本 <code>./board/100ask24x0/u-boot.lds</code> 也很重要. 从中可以知道u-boot整个代码段的分配情况. 下面来分析一下:<br>链接脚本的作用就是安排目标文件在可执行文件中的顺序, 便于链接器生成最终的可执行文件.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OUTPUT_FORMAT(&quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;)</span><br><span class="line">&#x2F;*OUTPUT_FORMAT(&quot;elf32-arm&quot;, &quot;elf32-arm&quot;, &quot;elf32-arm&quot;)*&#x2F;</span><br><span class="line">OUTPUT_ARCH(arm)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; . 表示当前位置, 设置当前位置为 0. 实际物理地址需要加上偏移量 0x33F80000</span><br><span class="line">    . &#x3D; 0x00000000;</span><br><span class="line"></span><br><span class="line">    . &#x3D; ALIGN(4);                   &#x2F;&#x2F; 4字节对齐</span><br><span class="line">    .text      :                    &#x2F;&#x2F; 代码段</span><br><span class="line">    &#123;</span><br><span class="line">      cpu&#x2F;arm920t&#x2F;start.o   (.text) &#x2F;&#x2F; 第一段代码放 start.s</span><br><span class="line">      board&#x2F;100ask24x0&#x2F;boot_init.o (.text)  &#x2F;&#x2F; 第二段代码放 boot_init.c (非必须)</span><br><span class="line">      *(.text)                      &#x2F;&#x2F; 其它的代码段</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . &#x3D; ALIGN(4);</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;        &#x2F;&#x2F; 只读数据段, RO段</span><br><span class="line"></span><br><span class="line">    . &#x3D; ALIGN(4);</span><br><span class="line">    .data : &#123; *(.data) &#125;            &#x2F;&#x2F; 数据段, RW段</span><br><span class="line"></span><br><span class="line">    . &#x3D; ALIGN(4);</span><br><span class="line">    .got : &#123; *(.got) &#125;              &#x2F;&#x2F; uboot自定义, 非标准段</span><br><span class="line"></span><br><span class="line">    . &#x3D; .;</span><br><span class="line">    __u_boot_cmd_start &#x3D; .;         &#x2F;&#x2F; 赋值 __u_boot_cmd_start, 命令段起始位置</span><br><span class="line">    .u_boot_cmd : &#123; *(.u_boot_cmd) &#125;&#x2F;&#x2F; uboot 命令段, uboot通过宏定义, 将命令放在该段</span><br><span class="line">    __u_boot_cmd_end &#x3D; .;           &#x2F;&#x2F; 赋值 __u_boot_cmd_end, 命令段结束位置</span><br><span class="line"></span><br><span class="line">    . &#x3D; ALIGN(4);</span><br><span class="line">    __bss_start &#x3D; .;                &#x2F;&#x2F; 赋值 __bss_start</span><br><span class="line">    .bss : &#123; *(.bss) &#125;              &#x2F;&#x2F; bss 段</span><br><span class="line">    _end &#x3D; .;                       &#x2F;&#x2F; 赋值 _end</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>jz2440</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot之源码分析</title>
    <url>/2017/08/25/1720-uboot-source/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/11/24/1735-jz2440-basic/">jz2440分区及启动的基础概念</a></li>
<li><a href="https://draapho.github.io/2017/07/07/1719-uboot-makefile/">uboot之makefile分析</a></li>
<li><a href="https://draapho.github.io/2017/08/25/1720-uboot-source/">uboot之源码分析</a></li>
<li><a href="https://draapho.github.io/2017/08/30/1721-uboot-modify/">uboot之定制指令</a></li>
</ul>
<p>本文基于 u-boot-1.1.6, 使用jz2440开发板. 若要使用最新的u-boot版本见: <a href="http://www.denx.de/wiki/U-Boot/WebHome">u-boot官网</a>  <a href="ftp://ftp.denx.de/pub/u-boot/">u-boot下载</a></p>
<h1 id="u-boot功能"><a href="#u-boot功能" class="headerlink" title="u-boot功能:"></a>u-boot功能:</h1><ul>
<li>本质是单片机程序</li>
<li>硬件相关初始化<ul>
<li>关看门狗</li>
<li>初始化时钟</li>
<li>初始化SDRAM</li>
<li>从Flash读取内核</li>
</ul>
</li>
<li>最终目的: 启动内核</li>
<li>为开发方便, 还支持:<ul>
<li>烧写flash</li>
<li>网卡</li>
<li>USB</li>
<li>串口</li>
</ul>
</li>
</ul>
<p><img src="https://draapho.github.io/images/1720/uboot-start.png" alt="uboot-start"></p>
<h1 id="查看内存地址分配"><a href="#查看内存地址分配" class="headerlink" title="查看内存地址分配"></a>查看内存地址分配</h1><p>可以使用指令 <code>readelf -s u-boot | grep _start</code> 查看uboot的内存地址分配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ readelf -s u-boot|grep _start</span><br><span class="line">    63: 33f80118     0 NOTYPE  LOCAL  DEFAULT    1 _start_armboot</span><br><span class="line">   218: 33fb0798     4 OBJECT  LOCAL  DEFAULT   10 mem_malloc_start</span><br><span class="line">   906: 33fb5a0c     4 OBJECT  LOCAL  DEFAULT   10 bin_start_address</span><br><span class="line">  1303: 33f9f274    88 FUNC    LOCAL  DEFAULT    1 setup_start_tag</span><br><span class="line">  1507: 33f80000     0 NOTYPE  GLOBAL DEFAULT    1 _start   &#x2F;&#x2F; 等同于 config.mk 中的 TEXT_BASE值</span><br><span class="line">  1657: 33f80044     0 NOTYPE  GLOBAL DEFAULT    1 _armboot_start</span><br><span class="line">  1776: 33f80048     0 NOTYPE  GLOBAL DEFAULT    1 _bss_start</span><br><span class="line">  1869: 33fb06ac     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start</span><br><span class="line">  2038: 33fb016c     0 NOTYPE  GLOBAL DEFAULT  ABS __u_boot_cmd_start</span><br></pre></td></tr></table></figure>

<p><img src="https://draapho.github.io/images/1720/uboot-ram.gif" alt="uboot-ram"></p>
<h1 id="一-汇编初始化-start-s"><a href="#一-汇编初始化-start-s" class="headerlink" title="一 汇编初始化, start.s"></a>一 汇编初始化, start.s</h1><p>由链接脚本 <code>./board/100ask24x0/u-boot.lds</code> 可知,<br>uboot启动后, 首先执行的就是 <code>cpu/arm920t/start.s</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">41 .globl _start                        &#x2F;&#x2F; 程序入口</span><br><span class="line">42 _start:  b       reset               &#x2F;&#x2F; 跳转到reset执行</span><br><span class="line"></span><br><span class="line">75 _TEXT_BASE:                          &#x2F;&#x2F; _TEXT_BASE值, 可知等同于 _start</span><br><span class="line">76      .word   TEXT_BASE               &#x2F;&#x2F; 赋值</span><br><span class="line">79 _armboot_start:                      &#x2F;&#x2F; _armboot_start 值等同于 TEXT_BASE</span><br><span class="line">80      .word _start                    &#x2F;&#x2F; 赋值 _start 给 _armboot_start</span><br><span class="line"></span><br><span class="line">122 reset:</span><br><span class="line">124 &#x2F;* set the cpu to SVC32 mode *&#x2F;     &#x2F;&#x2F; 1. 将CPU设置为SVC32管理模式</span><br><span class="line">131 &#x2F;* turn off the watchdog *&#x2F;         &#x2F;&#x2F; 2. 关闭看门狗</span><br><span class="line">150 &#x2F;* mask all IRQs ... - default *&#x2F;   &#x2F;&#x2F; 3. 关中断</span><br><span class="line"></span><br><span class="line">                                        &#x2F;&#x2F; 4. 初始化SDRAM</span><br><span class="line">174 #ifndef CONFIG_SKIP_LOWLEVEL_INIT     &#x2F;&#x2F; 一个宏定义开关</span><br><span class="line">175     adr r0, _start                    &#x2F;&#x2F; 读取当前地址, 如果是从nand flash启动, 这段代码被自动拷贝到片内4K RAM, 初始地址为0</span><br><span class="line">                                          &#x2F;&#x2F; 反之, 如果代码是直接复制到SDRAM中并运行(如调试器), 则_start和_TEXT_BASE值相等</span><br><span class="line">176     ldr r1, _TEXT_BASE                &#x2F;&#x2F; TEXT_BASE 由 &quot;.&#x2F;board&#x2F;100ask24x0&#x2F;config.mk&quot; 赋值为 0x33F80000</span><br><span class="line">                                          &#x2F;&#x2F; 可在linux用指令 &quot;grep -nr TEXT_BASE *&quot; 搜索</span><br><span class="line">177     cmp     r0, r1                    &#x2F;&#x2F; 比较两个值. 不等的话, 说明片外SDRAM还没有被初始化过</span><br><span class="line">178     blne    cpu_init_crit             &#x2F;&#x2F; 初始化片外SDRAM的控制 (关MMU, 初始化存储控制器)</span><br><span class="line">179 #endif</span><br><span class="line"></span><br><span class="line">182 stack_setup:                        &#x2F;&#x2F; 5. 设置栈指针, 栈指针向下递减, 推指针向上递增.</span><br><span class="line">183     ldr r0, _TEXT_BASE                &#x2F;&#x2F; 从 _TEXT_BASE 开始分配空间. _TEXT_BASE    上面是uboot代码段</span><br><span class="line">184     sub r0, r0, #CFG_MALLOC_LEN       &#x2F;&#x2F; uboot 自己用的 malloc 堆空间</span><br><span class="line">185     sub r0, r0, #CFG_GBL_DATA_SIZE    &#x2F;&#x2F; 全局变量, 保存uboot系统参数的预留空间</span><br><span class="line">187 #ifdef CONFIG_USE_IRQ</span><br><span class="line">188     sub r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)    &#x2F;&#x2F; IRQ 以及 FIQ, 中断模式的栈</span><br><span class="line">189 #endif</span><br><span class="line">190     sub sp, r0, #12                 &#x2F;&#x2F; 再减去12字节后, 就是sp栈指针的起始位置</span><br><span class="line"></span><br><span class="line">193 bl clock_init                       &#x2F;&#x2F; 6. 初始化系统时钟, 设置为400MHz</span><br><span class="line"></span><br><span class="line">197 relocate:                           &#x2F;&#x2F; 7. 拷贝代码. 把uboot代码从nand&#x2F;nor flash拷贝到片外 SDRAM 中</span><br><span class="line"></span><br><span class="line">219 clear_bss:                          &#x2F;&#x2F; 8. 清bss. 将未初始化过的全局变量设为0. Block Started by Symbol</span><br><span class="line"></span><br><span class="line">261 _start_armboot: .word start_armboot &#x2F;&#x2F; 9. 调用 start_armboot, c语言函数.</span><br></pre></td></tr></table></figure>

<h1 id="二-板级初始化-board-c"><a href="#二-板级初始化-board-c" class="headerlink" title="二 板级初始化, board.c"></a>二 板级初始化, board.c</h1><p><code>grep -nwr start_armboot *</code>, 找出 <code>start_armboot</code> 源码文件和行号.<br>可知, 其位于 <code>./lib_arm/board.c</code> 的236行.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">216</span> <span class="keyword">init_fnc_t</span> *init_sequence[] = &#123;...&#125;;    <span class="comment">// 初始化函数组</span></span><br><span class="line"></span><br><span class="line"><span class="number">236</span> <span class="function"><span class="keyword">void</span> <span class="title">start_armboot</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="number">248</span>     gd = (<span class="keyword">gd_t</span>*)(_armboot_start - CFG_MALLOC_LEN - <span class="keyword">sizeof</span>(<span class="keyword">gd_t</span>));</span><br><span class="line">        <span class="comment">// 实际指向的就是 CFG_GBL_DATA_SIZE 段, 下面是清零, 对应的结构体是 gd_t</span></span><br><span class="line"></span><br><span class="line"><span class="number">258</span>     <span class="keyword">for</span> (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) &#123;&#125;</span><br><span class="line">        <span class="comment">// 依次调用初始化函数, 如果返回值为0, 则初始化失败, 系统出错!</span></span><br><span class="line">        <span class="comment">// 在init的过程中, 相关的函数对 gd_t 内容赋值.</span></span><br><span class="line"></span><br><span class="line"><span class="number">266</span>     size = flash_init ();               <span class="comment">// 初始化nor flash</span></span><br><span class="line"><span class="number">267</span>     display_flash_config (size);</span><br><span class="line"></span><br><span class="line"><span class="number">297</span>     mem_malloc_init (_armboot_start - CFG_MALLOC_LEN);  <span class="comment">// 堆地址的初始化</span></span><br><span class="line"></span><br><span class="line"><span class="number">301</span>     nand_init();                        <span class="comment">// 初始化 nand flash</span></span><br><span class="line"></span><br><span class="line"><span class="number">310</span>     env_relocate ();                    <span class="comment">// 加载uboot的环境变量</span></span><br><span class="line"></span><br><span class="line">...     <span class="comment">// 网卡, devices_init, 显示终端, 控制台, 其它驱动等等 初始化, 略过不表</span></span><br><span class="line"></span><br><span class="line"><span class="number">403</span>     main_loop ();                       <span class="comment">// 初始化结束, 跳转到 main.c 文件的 void main_loop(void)</span></span><br><span class="line"><span class="number">407</span> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="三-识别终端指令-main-c"><a href="#三-识别终端指令-main-c" class="headerlink" title="三 识别终端指令, main.c"></a>三 识别终端指令, main.c</h1><p><code>grep -nr &quot;main_loop (void)&quot; *</code>, 可找到 <code>./common/main.c</code> 的301行 main_loop<br>整个文件的最核心指令就是 run_command(), 即识别和运行指令函数.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">301</span> <span class="function"><span class="keyword">void</span> <span class="title">main_loop</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="number">404</span>     s = getenv (<span class="string">&quot;bootdelay&quot;</span>);           <span class="comment">// 获取 bootdelay 环境变量</span></span><br><span class="line"><span class="number">405</span>     bootdelay = s ? (<span class="keyword">int</span>)simple_strtol(s, <span class="literal">NULL</span>, <span class="number">10</span>) : CONFIG_BOOTDELAY;</span><br><span class="line"></span><br><span class="line"><span class="number">432</span>     s = getenv (<span class="string">&quot;bootcmd&quot;</span>);             <span class="comment">// 加载 bootcmd 环境变量, 此变量为linux加载和启动指令</span></span><br><span class="line"><span class="number">436</span>     <span class="keyword">if</span> (bootdelay &gt;= <span class="number">0</span> &amp;&amp; s &amp;&amp; !abortboot (bootdelay)) &#123;    <span class="comment">// 倒计时结束, 自动加载linux</span></span><br><span class="line"><span class="number">443</span>         <span class="built_in">printf</span>(<span class="string">&quot;Booting Linux ...\n&quot;</span>);  <span class="comment">// 终端打印信息</span></span><br><span class="line"><span class="number">444</span>         run_command (s, <span class="number">0</span>);             <span class="comment">// 运行 bootcmd 的指令.</span></span><br><span class="line"><span class="number">454</span>     &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// abortboot 函数内会判断倒计时, 并获取按键操作, 只有 &#x27; &#x27; 空格才能跳出启动</span></span><br><span class="line">        <span class="comment">// 457-467行不会运行, 因为没有宏定义 CONFIG_MENUKEY</span></span><br><span class="line"><span class="number">478</span>     run_command(<span class="string">&quot;menu&quot;</span>, <span class="number">0</span>);             <span class="comment">// 执行 &quot;menu&quot; 指令, 打印jz2440定制的菜单信息</span></span><br><span class="line"></span><br><span class="line"><span class="number">488</span>     <span class="keyword">for</span> (;;) &#123;                          <span class="comment">// 死循环, 等待终端输入指令</span></span><br><span class="line"><span class="number">497</span>         len = readline (CFG_PROMPT);    <span class="comment">// 读取终端输入, 提示符为 &quot;OpenJTAG&gt; &quot;</span></span><br><span class="line"><span class="number">521</span>         rc = run_command (lastcommand, flag);   <span class="comment">// 执行输入的指令</span></span><br><span class="line"><span class="number">527</span>     &#125;</span><br><span class="line"><span class="number">529</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指令数据结构被放在 __u_boot_cmd 段内, 对应的指令函数可以在 ./common/cmd_***.c 内找到</span></span><br><span class="line"><span class="number">1280</span>    <span class="function"><span class="keyword">int</span> <span class="title">run_command</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line"><span class="number">1361</span>        <span class="keyword">if</span> ((cmdtp = find_cmd(argv[<span class="number">0</span>])) == <span class="literal">NULL</span>) &#123;...&#125;      <span class="comment">// 查找指令是否存在</span></span><br><span class="line"><span class="number">1391</span>        <span class="keyword">if</span> ((cmdtp-&gt;cmd) (cmdtp, flag, argc, argv) != <span class="number">0</span>) &#123;&#125; <span class="comment">// 调用指令函数</span></span><br><span class="line"><span class="number">1403</span>    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="四-加载和启动linux"><a href="#四-加载和启动linux" class="headerlink" title="四 加载和启动linux"></a>四 加载和启动linux</h1><h2 id="bootcmd-指令分析"><a href="#bootcmd-指令分析" class="headerlink" title="bootcmd 指令分析"></a>bootcmd 指令分析</h2><p>在uboot命令行下, 输入 <code>printenv</code> 可以查看uboot的环境变量<br>可以找到如下信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bootcmd&#x3D;nand read.jffs2 0x30007FC0 kernel; bootm 0x30007FC0</span><br><span class="line">    &#x2F;&#x2F; 启动指令分为了两条:</span><br><span class="line">    &#x2F;&#x2F; 1. nand read.jffs2 0x30007FC0 kernel</span><br><span class="line">        &#x2F;&#x2F; 从 nand flash 的 kernel 分区读取数据, 放到地址 0x30007FC0 处(SDRAM)</span><br><span class="line">    &#x2F;&#x2F; 2. bootm 0x30007FC0</span><br><span class="line">        &#x2F;&#x2F; 从 0x30007FC0 启动linux</span><br><span class="line"></span><br><span class="line">bootdelay&#x3D;2</span><br><span class="line">    &#x2F;&#x2F; 启动延时参数为2S</span><br><span class="line">    &#x2F;&#x2F; 因此uboot的环境变量可以是参数设置, 也可以是命令行, 命令行的本质是字符串</span><br></pre></td></tr></table></figure>

<h2 id="flash-分区信息"><a href="#flash-分区信息" class="headerlink" title="flash 分区信息"></a>flash 分区信息</h2><p>可以通过 “./include/configs/100ask24x0.h” 中的 MTDPARTS_DEFAULT 来分析获得flash分区情况</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTDPARTS_DEFAULT <span class="meta-string">&quot;mtdparts=nandflash0:256k@0(bootloader),&quot;</span> \</span></span><br><span class="line">                            <span class="string">&quot;128k(params),&quot;</span> \</span><br><span class="line">                            <span class="string">&quot;2m(kernel),&quot;</span> \</span><br><span class="line">                            <span class="string">&quot;-(root)&quot;</span></span><br><span class="line"><span class="comment">// nandflash0: 分区位于 nandflash 上</span></span><br><span class="line"><span class="comment">// 256k@0(bootloader), 第一个分区从0地址开始, 占用256k, 分区名称 bootloader</span></span><br><span class="line"><span class="comment">// 128k(params), 第二个分区紧邻第一个分区, 占用128K, 分区名称 params</span></span><br><span class="line"><span class="comment">// 2m(kernel), 第三个分区紧邻第二个分区, 占用2m字节, 分区名称 kernel</span></span><br><span class="line"><span class="comment">// -(root), 剩余的空间全部分配给第四个分区, 名称为 root</span></span><br></pre></td></tr></table></figure>

<p>也可以在uboot下, 使用 “mtdparts” 可以查看 flash 的分区情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OpenJTAG&gt; mtdparts</span><br><span class="line"> <span class="comment">#: name                size            offset          mask_flags</span></span><br><span class="line"> 0: bootloader          0x00040000      0x00000000      0</span><br><span class="line"> 1: params              0x00020000      0x00040000      0</span><br><span class="line"> 2: kernel              0x00200000      0x00060000      0</span><br><span class="line"> 3: root                0x0fda0000      0x00260000      0</span><br></pre></td></tr></table></figure>

<h2 id="加载linux内核"><a href="#加载linux内核" class="headerlink" title="加载linux内核"></a>加载linux内核</h2><p>执行 <code>nand read.jffs2 0x30007FC0 kernel</code> 指令, 源码在 <code>./common/cmd_nand.c</code> 的 do_nand 函数</p>
<ul>
<li>jffs2 是读取的格式, 但此处并非是指 kernel 是jffs2格式. jffs2方式无需块对齐和页对齐, 提高通用性.</li>
<li>可知 kernel 分区大小为 0x200000 (2M), 起始地址为 0x60000</li>
<li>所以整条指令等价于: nand read.jffs2 0x30007FC0(目标地址) 0x60000(源地址) 0x200000(字节大小)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// nand     read.jffs2  0x30007FC0  kernel</span></span><br><span class="line">    <span class="comment">// argv[0]  argv[1]     argv[2]     argv[3]</span></span><br><span class="line"></span><br><span class="line"><span class="number">166</span> <span class="function"><span class="keyword">int</span> <span class="title">do_nand</span><span class="params">(<span class="keyword">cmd_tbl_t</span> * cmdtp, <span class="keyword">int</span> flag, <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="number">316</span>     <span class="keyword">if</span> (<span class="built_in">strncmp</span>(cmd, <span class="string">&quot;read&quot;</span>, <span class="number">4</span>) == <span class="number">0</span> || <span class="built_in">strncmp</span>(cmd, <span class="string">&quot;write&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">322</span>         addr = (ulong)simple_strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">16</span>);                    <span class="comment">// 目标地址 addr = 0x30007FC0</span></span><br><span class="line"><span class="number">326</span>         <span class="keyword">if</span> (arg_off_size(argc - <span class="number">3</span>, argv + <span class="number">3</span>, nand, &amp;off, &amp;size) != <span class="number">0</span>) &#123;...&#125; <span class="comment">// 获取源地址以及长度</span></span><br><span class="line">            <span class="comment">// arg_off_size 中, 如果发现导入的参数是分区名字, 就会调用 find_dev_and_part() 来获取改分区的地址和长度</span></span><br><span class="line">            <span class="comment">// 最终会将源地址以及长度放入 &amp;off, &amp;size 中</span></span><br><span class="line"><span class="number">336</span>         opts.buffer = (u_char*) addr;                                       <span class="comment">// sdram, 直接就是一片buffer</span></span><br><span class="line"><span class="number">337</span>         opts.length = size;</span><br><span class="line"><span class="number">338</span>         opts.offset = off;</span><br><span class="line"><span class="number">340</span>         ret = nand_read_opts(nand, &amp;opts);                                  <span class="comment">// 读取nand到buffer中</span></span><br><span class="line"><span class="number">416</span>     <span class="built_in">printf</span>(<span class="string">&quot; %d bytes %s: %s\n&quot;</span>, size, read ? <span class="string">&quot;read&quot;</span> : <span class="string">&quot;written&quot;</span>, ret ? <span class="string">&quot;ERROR&quot;</span> : <span class="string">&quot;OK&quot;</span>); <span class="comment">// 打印进度</span></span><br><span class="line"><span class="number">419</span>     <span class="keyword">return</span> ret == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;                        返回读取结果</span><br><span class="line"><span class="number">511</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="启动linux内核"><a href="#启动linux内核" class="headerlink" title="启动linux内核"></a>启动linux内核</h2><p>执行 <code>bootm 0x30007FC0</code> 指令, 源码在 <code>./common/cmd_bootm.c</code> 的 do_bootm 函数</p>
<ul>
<li>设置 0x30007FC0 这个奇怪的值, 是有原因的. 简而言之, 是为了避免拷贝内核两次, 加快启动速度</li>
<li>kernel 最后编译时的指令是 <code>make uImage</code>, 因此其格式是 uImage</li>
<li>相比于纯压缩文件 zImage 的内核文件, uImage 在 zImage之前加上了长度为 0x40 的头部信息 (image_header_t)</li>
<li>0x30007FC0 + 0x40 = 0x30008000, 正好就是 uImage 头部信息要求的加载地址.</li>
<li>而 0x30008000 这个地址, 是有linux源码在 <code>Makefile</code> 里写死的. 可搜索关键字 <code>zreladdr-y</code> 和 <code>ZRELADDR</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">149</span> <span class="keyword">image_header_t</span> header;              <span class="comment">// uImage的头部信息, 占用0x40字节</span></span><br><span class="line">        <span class="comment">// ih_load, Data Load Address,   加载地址, 如果发现加载地址不对, do_bootm会重新移动内核文件到此地址</span></span><br><span class="line">        <span class="comment">// ih_ep,   Entry Point Address, 入口地址, 跳转到此地址开始执行linux内核</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// bootm    0x30007FC0</span></span><br><span class="line">    <span class="comment">// argv[0]  argv[1]</span></span><br><span class="line"><span class="number">153</span> <span class="function"><span class="keyword">int</span> <span class="title">do_bootm</span> <span class="params">(<span class="keyword">cmd_tbl_t</span> *cmdtp, <span class="keyword">int</span> flag, <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="number">163</span>     <span class="keyword">image_header_t</span> *hdr = &amp;header;                              <span class="comment">// 指针 hdr 指向头部信息</span></span><br><span class="line"><span class="number">171</span>     addr = simple_strtoul(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">16</span>);                   <span class="comment">// 获取地址, 0x30007FC0</span></span><br><span class="line"><span class="number">183</span>     memmove (&amp;header, (<span class="keyword">char</span> *)addr, <span class="keyword">sizeof</span>(<span class="keyword">image_header_t</span>));    <span class="comment">// 读取头部信息</span></span><br><span class="line"><span class="number">229</span>     data = addr + <span class="keyword">sizeof</span>(<span class="keyword">image_header_t</span>);                       <span class="comment">// data为linux内核起始地址</span></span><br><span class="line"><span class="number">321</span>     <span class="keyword">if</span>(ntohl(hdr-&gt;ih_load) == data) &#123;</span><br><span class="line"><span class="number">322</span>         <span class="built_in">printf</span> (<span class="string">&quot;   XIP %s ... &quot;</span>, name);                        <span class="comment">// 一致, 不用移动了</span></span><br><span class="line"><span class="number">323</span>     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">340</span>         memmove ((<span class="keyword">void</span> *) ntohl(hdr-&gt;ih_load), (uchar *)data, len);     <span class="comment">// 否则, 把内核移动到加载地址</span></span><br><span class="line"><span class="number">342</span>     &#125;</span><br><span class="line"><span class="number">418</span>     do_bootm_linux  (cmdtp, flag, argc, argv, addr, len_ptr, verify);   <span class="comment">// 启动linux</span></span><br><span class="line"><span class="number">477</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>do_bootm_linux</code> 函数位于 <code>./lib_arm/armlinux.c</code>,<br><strong>注意</strong>, cmd_bootm.c文件内的那个do_bootm_linux不会被调用, 因为没有宏定义 CONFIG_PPC</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">79</span>  <span class="function"><span class="keyword">void</span> <span class="title">do_bootm_linux</span> <span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此函数主要做两件事情:</span></span><br><span class="line">    <span class="comment">// 1. uboot 需要告诉内核一些系统参数 (内存大小, 终端波特率等等)</span></span><br><span class="line">    <span class="comment">// 2. 跳转到入口地址, 启动内核</span></span><br><span class="line"><span class="number">85</span>      <span class="keyword">void</span> (*theKernel)(<span class="keyword">int</span> zero, <span class="keyword">int</span> arch, uint params);         <span class="comment">// linux启动函数</span></span><br><span class="line"><span class="number">86</span>      <span class="keyword">image_header_t</span> *hdr = &amp;header;                              <span class="comment">// uImage 头部信息</span></span><br><span class="line"><span class="number">87</span>      <span class="keyword">bd_t</span> *bd = gd-&gt;bd;                                          <span class="comment">// 处于 CFG_GBL_DATA_SIZE 段内</span></span><br><span class="line"><span class="number">90</span>      <span class="keyword">char</span> *commandline = getenv (<span class="string">&quot;bootargs&quot;</span>);                    <span class="comment">// 获取 bootargs 参数</span></span><br><span class="line"></span><br><span class="line"><span class="number">93</span>      theKernel = (<span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>, uint))ntohl(hdr-&gt;ih_ep);    <span class="comment">// ih_ep, 即linux入口地址</span></span><br><span class="line"></span><br><span class="line"><span class="number">235</span>     setup_start_tag (bd);                                       <span class="comment">// 一系列的TAG参数设置, 准备传递给linux</span></span><br><span class="line">        <span class="comment">// 对jz2440, TAG地址是 0x30000100.</span></span><br><span class="line">        <span class="comment">// 在 &quot;./board/100ask24x0/100ask24x0.c&quot; 中, gd-&gt;bd-&gt;bi_boot_params = 0x30000100;</span></span><br><span class="line"><span class="number">237</span>     setup_serial_tag (&amp;params);</span><br><span class="line"><span class="number">240</span>     setup_revision_tag (&amp;params);</span><br><span class="line"><span class="number">243</span>     setup_memory_tags (bd);</span><br><span class="line"><span class="number">246</span>     setup_commandline_tag (bd, commandline);                    <span class="comment">// 告知linux文件系统的位置</span></span><br><span class="line"><span class="number">250</span>     setup_initrd_tag (bd, initrd_start, initrd_end);</span><br><span class="line"><span class="number">253</span>     setup_videolfb_tag ((<span class="keyword">gd_t</span> *) gd);</span><br><span class="line"><span class="number">255</span>     setup_end_tag (bd);                                         <span class="comment">// 参数设置结束</span></span><br><span class="line"></span><br><span class="line"><span class="number">259</span>     <span class="built_in">printf</span> (<span class="string">&quot;\nStarting kernel ...\n\n&quot;</span>);</span><br><span class="line"><span class="number">270</span>     theKernel (<span class="number">0</span>, bd-&gt;bi_arch_number, bd-&gt;bi_boot_params);      <span class="comment">// 调用入口地址, 传入参数, 启动linux</span></span><br><span class="line"><span class="number">271</span> &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel之编译体验</title>
    <url>/2017/09/01/1722-kernel-compile/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/09/01/1722-kernel-compile/">kernel之编译体验</a></li>
<li><a href="https://draapho.github.io/2017/09/14/1724-kernel-makefile/">kernel之Makefile分析</a></li>
<li><a href="https://draapho.github.io/2017/09/15/1725-kernel-launch/">kernel之内核启动分析</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="解压缩和打补丁"><a href="#解压缩和打补丁" class="headerlink" title="解压缩和打补丁"></a>解压缩和打补丁</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu shell</span></span><br><span class="line"></span><br><span class="line">tar xjvf linux-2.6.22.6.tar.bz2             <span class="comment"># 解压kernel源码</span></span><br><span class="line"><span class="built_in">cd</span> linux-2.6.22.6                           <span class="comment"># 进入kernel源码目录</span></span><br><span class="line">patch -p1 &lt; ../linux-2.6.22.6_jz2440.patch  <span class="comment"># 打补丁文件, p1表忽略patch文件内的1层目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd = linux-2.6.22.6</span></span><br><span class="line">cp ../4.3寸LCD_mach-smdk2440.c arch/arm/mach-s3c2440/mach-smdk2440.c    <span class="comment"># 替换为4.3寸屏源码</span></span><br></pre></td></tr></table></figure>

<h1 id="生成配置文件-“-config”"><a href="#生成配置文件-“-config”" class="headerlink" title="生成配置文件 “.config”"></a>生成配置文件 “.config”</h1><p>整个嵌入式linux系统的配置, 其根源就是这么一个 “.config” 文件.<br>然后编译时, 会通过makefile变量和C语言的宏定义来实现模块的使能, 禁止或生成为<code>.ko</code>模块.</p>
<h2 id="生成”-config”"><a href="#生成”-config”" class="headerlink" title="生成”.config”"></a>生成”.config”</h2><p>生成<code>.config</code>配置文件有三种方法:</p>
<ul>
<li>直接使用 <code>make menuconfig</code> 进行配置<ul>
<li>配置项太多了, 基本不会直接用这种方式</li>
</ul>
</li>
<li>基于默认配置自行修改<ul>
<li>确保 <code>pwd</code> 路径在kernel源码路径下: <code>./linux-2.6.22.6/</code></li>
<li><code>find -name &quot;*defconfig&quot;</code>, 查找默认配置文件</li>
<li>可以找到, 最相关的配置文件为 <code>./arch/arm/configs/s3c2410_defconfig</code></li>
<li><code>make s3c2410_defconfig</code>, 加载这个默认配置.</li>
<li>注意最后一句 “configuration written to .config”, 因此最终生成的就是一个 <code>.config</code> 文件</li>
<li><code>make menuconfig</code> 根据需求, 部分修改配置 <code>.config</code> 文件.</li>
<li>如果遇到错误提示 <code>fatal error: curses.h:</code>. 安装 <code>sudo apt-get install libncurses5-dev libncursesw5-dev</code></li>
</ul>
</li>
<li>使用厂家提供的配置文件<ul>
<li>jz2440 提供的配置文件名为 <code>config_ok</code></li>
<li><code>cp config_ok .config</code> 直接改名为 <code>.config</code> 文件即可.</li>
<li><code>make menuconfig</code>, 一样可以再自己定制配置.</li>
</ul>
</li>
</ul>
<h2 id="修改”-config”"><a href="#修改”-config”" class="headerlink" title="修改”.config”"></a>修改”.config”</h2><p>执行 <code>make menuconfig</code> 后, 有个简单的用户界面. 关键操作如下:</p>
<ul>
<li><code>上下左右</code>键进行移动, <code>Enter</code>键进入子菜单.</li>
<li>按两边 <code>ESC</code> 返回上一级, 或退出界面.</li>
<li><code>蓝色高亮字母</code> 为快捷键, 按了直接跳到那一行</li>
<li><code>Y</code> 表示需要加载这个模块</li>
<li><code>N</code> 表示不要加载这个模块</li>
<li><code>M</code> 表示将此模块生成 <code>.ko</code> 文件, 可动态加载.</li>
<li><code>?</code> 显示当前行的帮助信息, 帮助页按 <code>上下</code> 或 <code>jk</code> 进行翻页</li>
<li><code>/</code> 搜索关键字</li>
</ul>
<h1 id="分析配置过程"><a href="#分析配置过程" class="headerlink" title="分析配置过程"></a>分析配置过程</h1><p>从 “.config” 文件出发, 分析查看该文件如何影响 Makefile 文件以及C语言的宏定义.</p>
<h2 id="“-config”-文件"><a href="#“-config”-文件" class="headerlink" title="“.config” 文件"></a>“.config” 文件</h2><p>使用 <code>vim .config</code> 查看该文件, 可知其基本格式为 <code>CONFIG_XXX=</code></p>
<ul>
<li><code># CONFIG_XXX is not set</code> 此项被配置为 <code>N</code>, 不编译</li>
<li><code>CONFIG_XXX=y</code> 此项被配置为 <code>Y</code>, 直接编译进内核</li>
<li><code>CONFIG_XXX=m</code> 此项被配置为 <code>M</code>, 编译为<code>.ko</code>文件, 供动态加载</li>
<li><code>CONFIG_LOCALVERSION=&quot;&quot;</code> 此项为字符串, 也可能是数值</li>
</ul>
<p>我们以 <code>CONFIG_DM9000</code> 为例, 进行搜索. 忽略一些其他的配置文件, 关键的文件有如下几个:</p>
<ul>
<li><code>include/linux/autoconf.h:129:   #define CONFIG_DM9000 1</code><ul>
<li>这是个C语言的头文件, 很明显是给C语言代码调用的.</li>
<li>该文件由Makefile调用 <code>./scripts/kconfig/</code> 内的脚本自动生成.</li>
<li>对于 <code>y</code> <code>m</code> 的配置项, 宏定义为 <code>1</code></li>
<li>对于 <code>n</code> 的配置项, 不进行宏定义</li>
</ul>
</li>
<li><code>include/config/auto.conf:128:   CONFIG_DM9000=y</code><ul>
<li>这个文件是给 Makefile 调用的, 里面的值全部被认为是Makefile变量.</li>
<li>该文件由Makefile调用 <code>./scripts/kconfig/</code> 内的脚本自动生成.</li>
<li>对于 <code>y</code> <code>m</code> 以及其它值的配置项, 照抄一遍 <code>.config</code> 里的内容</li>
<li>对于 <code>n</code> 的配置项, 无定义!</li>
</ul>
</li>
<li><code>drivers/net/Makefile:197:   obj-$(CONFIG_DM9000) += dm9dev9000c.o</code><ul>
<li>子目录下的 Makefile 会被顶层的 Makefile 包含</li>
<li>由<code>auto.conf</code>文件可知<code>$(CONFIG_DM9000)=y</code></li>
<li>所以此句等同于 <code>obj-y += dm9dev9000c.o</code></li>
<li>同理, 被设置成 <code>m</code> 的变量就会有 <code>obj-m += xxx.o</code></li>
<li>如果配置项被设为 <code>n</code>, 则变量为空, 替换后为 <code>obj- += xxx.o</code>, 会被直接忽略</li>
<li>Makefile 最后就通过 <code>obj-y</code> 或 <code>obj-m</code> 来识别配置, 编译模块.</li>
</ul>
</li>
<li><code>.config:588:   CONFIG_DM9000=y</code><ul>
<li><code>./.config</code> 配置文件. 一切配置的源头文件.</li>
</ul>
</li>
</ul>
<h1 id="编译和烧录内核"><a href="#编译和烧录内核" class="headerlink" title="编译和烧录内核"></a>编译和烧录内核</h1><h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp config_ok .config                        <span class="comment"># 加载厂家默认配置</span></span><br><span class="line">make clean                                  <span class="comment"># 清空</span></span><br><span class="line">make uImage                                 <span class="comment"># 编译获得内核image</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可能在make时, 提示如下错误信息. 原因是新版的make对老的Makefile规则不兼容</span></span><br><span class="line">Makefile:1449: *** mixed implicit and normal rules.  Stop.</span><br><span class="line"></span><br><span class="line">vim Makefile</span><br><span class="line">    <span class="comment"># 416行      config %config: scripts_basic outputmakefile FORCE</span></span><br><span class="line">    <span class="comment">#   改为 -&gt;  %config: scripts_basic outputmakefile FORCE</span></span><br><span class="line">    <span class="comment"># 1449行     / %/: prepare scripts FORCE</span></span><br><span class="line">    <span class="comment">#   改为 -&gt;  %/: prepare scripts FORCE</span></span><br><span class="line">    <span class="comment"># 保存后重新编译即可.</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-nfs-烧录"><a href="#使用-nfs-烧录" class="headerlink" title="使用 nfs 烧录"></a>使用 nfs 烧录</h2><p>如果配置好网路, 建议使用 nfs 进行烧录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"><span class="comment"># 要使用nfs功能, 必须正确设置uboot的ip地址</span></span><br><span class="line"><span class="comment"># 将 .../linux-2.6.22.6/arch/arm/boot/uImage 拷贝到 /jz2440/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kernel: 在OpenJTAG&gt; 提示符下</span></span><br><span class="line">nfs 30000000 10.0.0.98:/jz2440/uImage       <span class="comment"># nfs 加载 kernel 固件到ram中 (0x30000000是sdram的地址)</span></span><br><span class="line">nand erase kernel                           <span class="comment"># 擦除 falsh 的 kernel 区</span></span><br><span class="line">nand write.jffs2 30000000 kernel            <span class="comment"># 烧录 kernel (ram-&gt;flash)</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-dnw-烧录"><a href="#使用-dnw-烧录" class="headerlink" title="使用 dnw 烧录"></a>使用 dnw 烧录</h2><p><strong>确保链接了开发板的串口和usb口, 并把usb口关联到Ubuntu上.</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开 jz2440 开发板串口终端, 启动时输入空格键, 进入如下菜单</span></span><br><span class="line"><span class="comment">##### 100ask Bootloader for OpenJTAG #####</span></span><br><span class="line">[n] Download u-boot to Nand Flash</span><br><span class="line">[o] Download u-boot to Nor Flash            <span class="comment"># 如果是Nand Flash启动的话，这个菜单项没有</span></span><br><span class="line">[k] Download Linux kernel uImage</span><br><span class="line">[j] Download root_jffs2 image</span><br><span class="line">[y] Download root_yaffs image</span><br><span class="line">[d] Download to SDRAM &amp; Run</span><br><span class="line">[z] Download zImage into RAM</span><br><span class="line">[g] Boot linux from RAM</span><br><span class="line">[f] Format the Nand Flash</span><br><span class="line">[s] Set the boot parameters</span><br><span class="line">[b] Boot the system</span><br><span class="line">[r] Reboot u-boot</span><br><span class="line">[q] Quit from menu</span><br><span class="line"></span><br><span class="line">Enter your selection: k                     <span class="comment"># 输入k, 烧录 kernel</span></span><br><span class="line">USB host is connected. Waiting a download.  <span class="comment"># 提示连接成功</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 Ubuntu 终端, 输入</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6                    # 确保在 kernel 源码路径下</span></span><br><span class="line">sudo dnw ./arch/arm/boot/uImage             <span class="comment"># 输入dnw指令, 指明烧录文件</span></span><br><span class="line"><span class="comment"># DNW usb device found!                     # 开始烧录</span></span><br></pre></td></tr></table></figure>




<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot之定制指令</title>
    <url>/2017/08/30/1721-uboot-modify/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/11/24/1735-jz2440-basic/">jz2440分区及启动的基础概念</a></li>
<li><a href="https://draapho.github.io/2017/07/07/1719-uboot-makefile/">uboot之makefile分析</a></li>
<li><a href="https://draapho.github.io/2017/08/25/1720-uboot-source/">uboot之源码分析</a></li>
<li><a href="https://draapho.github.io/2017/08/30/1721-uboot-modify/">uboot之定制指令</a></li>
</ul>
<p>本文基于 u-boot-1.1.6, 使用jz2440开发板. 若要使用最新的u-boot版本见: <a href="http://www.denx.de/wiki/U-Boot/WebHome">u-boot官网</a>  <a href="ftp://ftp.denx.de/pub/u-boot/">u-boot下载</a></p>
<h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h1><ol>
<li>新建文件 <code>./common/cmd_hello.c</code>, 按照其他 cmd_XXX 文件内容, 依样画葫芦即可.</li>
<li>打开文件 <code>./common/Makefile</code>, 在 <code>COBJS = ...</code> 一行, 加入 <code>cmd_hello.o</code> 即可.</li>
<li>Linux主机下, <code>make</code> 指令重新编译 u-boot, 并生成 <code>u-boot.bin</code> 文件</li>
<li>烧录并执行, 测试新指令即可, 譬如在uboot命令行下, 输入 <code>hello DRA&amp;PHO</code>.</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;command.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_hello</span> <span class="params">(<span class="keyword">cmd_tbl_t</span> *cmdtp, <span class="keyword">int</span> flag, <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;hello world!, %d\n&quot;</span>, argc);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">U_BOOT_CMD(</span><br><span class="line">    hello,  CFG_MAXARGS,    <span class="number">1</span>,  do_hello,</span><br><span class="line">    <span class="string">&quot;hello   - print hello world and arguments\n&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[arg [arg ...]]\n    - print hello and arguments\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\ttest purpose, learn to write uboot command\n&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>我们用倒推法, 从关键的 <code>U_BOOT_CMD</code> 宏定义开始分析.<br>找到其宏定义所在的文件 <code>./include/command.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">39</span>  <span class="class"><span class="keyword">struct</span> <span class="title">cmd_tbl_s</span> &#123;</span></span><br><span class="line"><span class="number">40</span>      <span class="keyword">char</span>        *name;      <span class="comment">/* Command Name         */</span>          <span class="comment">// 指令名称</span></span><br><span class="line"><span class="number">41</span>      <span class="keyword">int</span>     maxargs;    <span class="comment">/* maximum number of arguments  */</span>      <span class="comment">// 参数最大数量</span></span><br><span class="line"><span class="number">42</span>      <span class="keyword">int</span>     repeatable; <span class="comment">/* autorepeat allowed?      */</span>          <span class="comment">// 空格键是否可自动重复指令</span></span><br><span class="line"><span class="number">44</span>      <span class="keyword">int</span>     (*cmd)(struct cmd_tbl_s *, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">char</span> *[]);     <span class="comment">// 指令函数</span></span><br><span class="line"><span class="number">45</span>      <span class="keyword">char</span>        *usage;     <span class="comment">/* Usage message    (short) */</span>      <span class="comment">// 短帮助说明</span></span><br><span class="line"><span class="number">47</span>      <span class="keyword">char</span>        *help;      <span class="comment">/* Help  message    (long)  */</span>      <span class="comment">// 长帮助说明</span></span><br><span class="line"><span class="number">53</span>  &#125;;</span><br><span class="line"><span class="number">55</span>  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cmd_tbl_s</span>    <span class="title">cmd_tbl_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="number">57</span>  <span class="keyword">extern</span> <span class="keyword">cmd_tbl_t</span>  __u_boot_cmd_start;</span><br><span class="line"><span class="number">58</span>  <span class="keyword">extern</span> <span class="keyword">cmd_tbl_t</span>  __u_boot_cmd_end;</span><br><span class="line">    <span class="comment">// 这两个变量不存在与任何的C或者汇编文件中, 其来源于 &quot;./board/100ask24x0/u-boot.lds&quot; 链接脚本里面</span></span><br><span class="line"></span><br><span class="line"><span class="number">93</span>  <span class="meta">#<span class="meta-keyword">define</span> Struct_Section  __attribute__ ((unused,section (<span class="meta-string">&quot;.u_boot_cmd&quot;</span>)))</span></span><br><span class="line">    <span class="comment">// 指定变量存放的段位置, 由链接脚本决定.</span></span><br><span class="line"></span><br><span class="line"><span class="number">97</span>  <span class="meta">#<span class="meta-keyword">define</span> U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \</span></span><br><span class="line"><span class="number">98</span>  <span class="keyword">cmd_tbl_t</span> __u_boot_cmd_#<span class="meta">#name Struct_Section = &#123;#name, maxargs, rep, cmd, usage, help&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已 U_BOOT_CMD(hello,  CFG_MAXARGS, 1, do_hello, ...); 为例, 展开后为</span></span><br><span class="line">    <span class="keyword">cmd_tbl_t</span> __u_boot_cmd_hello __attribute__ ((unused,section (<span class="string">&quot;.u_boot_cmd&quot;</span>))) = &#123;</span><br><span class="line">    <span class="comment">// 这个变量结构被指定存放在 &quot;.u_boot_cmd&quot; 段内</span></span><br><span class="line">        hello,                                                      <span class="comment">// 指令名称 hello</span></span><br><span class="line">        CFG_MAXARGS,                                                <span class="comment">// 参数最大数量</span></span><br><span class="line">        <span class="number">1</span>,                                                          <span class="comment">// 可重复指令</span></span><br><span class="line">        do_hello,                                                   <span class="comment">// 指令函数</span></span><br><span class="line">        <span class="string">&quot;hello   - print hello world and arguments\n&quot;</span>,              <span class="comment">// 短帮助说明</span></span><br><span class="line">        <span class="string">&quot;...&quot;</span>                                                       <span class="comment">// 长帮助说明</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>清楚了指令的结构体存放方式后, 需要考虑uboot是如何识别输入的指令, 并执行其指定的函数 <code>do_XXX</code><br>这个文件位于 <code>./common/command.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">346</span> <span class="function"><span class="keyword">cmd_tbl_t</span> *<span class="title">find_cmd</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd)</span> </span>&#123;</span><br><span class="line"><span class="number">360</span>     <span class="keyword">for</span> (cmdtp = &amp;__u_boot_cmd_start;                           <span class="comment">// 在&quot;.u_boot_cmd&quot;段内查找指令</span></span><br><span class="line"><span class="number">361</span>          cmdtp != &amp;__u_boot_cmd_end;</span><br><span class="line"><span class="number">362</span>          cmdtp++) &#123;</span><br><span class="line"><span class="number">363</span>          <span class="keyword">if</span> (<span class="built_in">strncmp</span> (cmd, cmdtp-&gt;name, len) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">364</span>             <span class="keyword">if</span> (len == <span class="built_in">strlen</span> (cmdtp-&gt;name))</span><br><span class="line"><span class="number">365</span>                 <span class="keyword">return</span> cmdtp;   <span class="comment">/* full match */</span></span><br><span class="line"><span class="number">367</span>             cmdtp_temp = cmdtp; <span class="comment">/* abbreviated command ? */</span></span><br><span class="line"><span class="number">368</span>             n_found++;</span><br><span class="line"><span class="number">369</span>         &#125;</span><br><span class="line"><span class="number">370</span>     &#125;</span><br><span class="line"><span class="number">371</span>     <span class="keyword">if</span> (n_found == <span class="number">1</span>) &#123;         <span class="comment">/* exactly one match */</span></span><br><span class="line"><span class="number">372</span>         <span class="keyword">return</span> cmdtp_temp;</span><br><span class="line"><span class="number">373</span>     &#125;</span><br><span class="line"><span class="number">376</span> &#125;</span><br></pre></td></tr></table></figure>

<p>此时, 通过查找 find_cmd 函数, 发现被多次调用, 其中一条路径是指令自动完成, 此处忽略.<br>可以发现它也被 <code>./common/main.c</code> 的 <code>run_command</code> 调用了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">301</span>  <span class="function"><span class="keyword">void</span> <span class="title">main_loop</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 源码分析中, 已经分析到此函数. 用于自动启动kernel, 或者等待终端输入指令并执行</span></span><br><span class="line"><span class="number">488</span>     <span class="keyword">for</span> (;;) &#123;                                  <span class="comment">// 死循环, 等待终端输入</span></span><br><span class="line"><span class="number">497</span>         len = readline (CFG_PROMPT);            <span class="comment">// 读取整行, 会存放到 console_buffer 中</span></span><br><span class="line"><span class="number">501</span>         <span class="built_in">strcpy</span> (lastcommand, console_buffer);   <span class="comment">// 赋值给 lastcommand, 譬如 hello 指令</span></span><br><span class="line"><span class="number">521</span>         rc = run_command (lastcommand, flag);   <span class="comment">// 执行 lastcommand</span></span><br><span class="line"><span class="number">527</span>     &#125;</span><br><span class="line"><span class="number">529</span>  &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1280</span> <span class="function"><span class="keyword">int</span> <span class="title">run_command</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line"><span class="number">1361</span>    <span class="keyword">if</span> ((cmdtp = find_cmd(argv[<span class="number">0</span>])) == <span class="literal">NULL</span>) &#123;...&#125;          <span class="comment">// 查找指令</span></span><br><span class="line"><span class="number">1391</span>    <span class="keyword">if</span> ((cmdtp-&gt;cmd) (cmdtp, flag, argc, argv) != <span class="number">0</span>) &#123;...&#125;  <span class="comment">// 执行指令函数, 譬如调用 do_hello</span></span><br><span class="line"><span class="number">1403</span> &#125;</span><br></pre></td></tr></table></figure>

<p>至此, 指令部分的实现分析完成. 再倒过来总结一下:</p>
<ul>
<li>main_loop 中, 终端等待用户输入指令, 譬如 “hello”</li>
<li>run_command 先查找指令是否存在, 调用find_cmd</li>
<li>find_cmd 会在 “.u_boot_cmd” 段内查找指令是否存在</li>
<li>因此, 增减指令很简单, 只有两个关键点:<ul>
<li>使用 <code>U_BOOT_CMD</code> 宏定义, 定义好指令结构, 编译器会自动存放进”.u_boot_cmd” 段</li>
<li>实现指令函数. 习惯上将其命名为 “do_XXX”, 如 “do_hello”.</li>
</ul>
</li>
<li>指令存在的话, 执行指令函数, 即通过 (cmdtp-&gt;cmd) (cmdtp, flag, argc, argv) 的形式调用 do_hello</li>
<li>执行完成后, 继续死循环等待下一条输入</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>最实用的 Linux 命令行使用技巧</title>
    <url>/2017/09/07/1723-linux-cmd-useful/</url>
    <content><![CDATA[<p><em><strong>转载自 <a href="https://www.oschina.net/translate/most-useful-linux-command-line-tricks#comments">最实用的 Linux 命令行使用技巧</a></strong></em><br><em><strong>英文原文 <a href="https://dzone.com/articles/most-useful-linux-command-line-tricks">Most Useful Linux Command Line Tricks</a></strong></em></p>
<hr>
<h1 id="将输出内容以表格的形式显示出来"><a href="#将输出内容以表格的形式显示出来" class="headerlink" title="将输出内容以表格的形式显示出来"></a>将输出内容以表格的形式显示出来</h1><p>可以使用 <code>cmd | column -t</code> 指令, 譬如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount | column –t                   <span class="comment"># 默认空格进行制表</span></span><br><span class="line">cat /etc/passwd | column -t -s:     <span class="comment"># 指定冒号进行制表</span></span><br></pre></td></tr></table></figure>


<h1 id="重复执行一个命令，直到它运行成功"><a href="#重复执行一个命令，直到它运行成功" class="headerlink" title="重复执行一个命令，直到它运行成功"></a>重复执行一个命令，直到它运行成功</h1><p>如果在 Google 上搜索这个功能，你会发现很多人都问到了如何重复执行命令，直到这个命令成功返回并且运行正常。 Google上的建议里就包括 ping 服务器，直到它变得空闲为止，还有就是检查是否有向特定的目录上传了具有特定扩展名的文件，还有就是检查特定的URL是否已经存在，诸如此类的办法。</p>
<p>其实你还可以使用 while true 的循环来实现来实现这个功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">while</span> <span class="literal">true</span>    <span class="comment"># 检测文件是否存在, 直到创建成功</span></span><br><span class="line">&gt; <span class="keyword">do</span></span><br><span class="line">&gt; cat <span class="built_in">test</span> &gt; /dev/null 2&gt;&amp;1 &amp;&amp; <span class="built_in">break</span></span><br><span class="line">&gt; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">$ <span class="keyword">while</span> <span class="literal">true</span>    <span class="comment"># ping google, 直到成功</span></span><br><span class="line">&gt; <span class="keyword">do</span></span><br><span class="line">&gt; ping -c 1 google.com &gt; /dev/null 2&gt;&amp;1 &amp;&amp; <span class="built_in">break</span></span><br><span class="line">&gt; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>在上面这个示例中，<code>&gt;/dev/null 2&gt;＆1</code> 会让程序的输出重定向到 <code>/dev/ null</code>。 标准错误和标准输出都会被包含进去。<br>这是我认为最酷的Linux命令行技巧之一。</p>
<h1 id="对进程进行排序"><a href="#对进程进行排序" class="headerlink" title="对进程进行排序"></a>对进程进行排序</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux | sort -rnk 4        <span class="comment"># 内存资源的使用量排序</span></span><br><span class="line">ps aux | sort -nk 3         <span class="comment"># 按CPU资源的使用量排序</span></span><br></pre></td></tr></table></figure>


<h1 id="定时的监视性命令输出"><a href="#定时的监视性命令输出" class="headerlink" title="定时的监视性命令输出"></a>定时的监视性命令输出</h1><p>使用 watch 命令，你就可以查看到任何命令的任何输出。例如，你可以查看可用空间以及它的使用量增长情况。<br>通过利用 watch 命令来操作会变化的数据，你可以尽情想象自己能拿这个来做些什么哦。 譬如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">watch df -h                 <span class="comment"># 实时查看磁盘空间情况</span></span><br></pre></td></tr></table></figure>


<h1 id="在会话关掉以后继续运行程序"><a href="#在会话关掉以后继续运行程序" class="headerlink" title="在会话关掉以后继续运行程序"></a>在会话关掉以后继续运行程序</h1><p>可以用 nohup 命令做到 - 该指令表示不做挂断操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup wget site.com/file.zip</span><br><span class="line">nohup ping -c 10 google.com</span><br><span class="line"><span class="comment"># 会在同一个目录下生成一个名称为 nohup.out 的文件，其中包含了正在运行的程序的输出内容</span></span><br></pre></td></tr></table></figure>


<h1 id="自动对任何命令回答-Yes-或者-No"><a href="#自动对任何命令回答-Yes-或者-No" class="headerlink" title="自动对任何命令回答 Yes 或者 No"></a>自动对任何命令回答 Yes 或者 No</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yes | apt-get update</span><br><span class="line">no | apt-get update</span><br></pre></td></tr></table></figure>


<h1 id="创建具有指定大小的文件"><a href="#创建具有指定大小的文件" class="headerlink" title="创建具有指定大小的文件"></a>创建具有指定大小的文件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=out.txt bs=1M count=10</span><br><span class="line"><span class="comment"># 创建出一个 10 MB 的文件，填充零作为内容</span></span><br></pre></td></tr></table></figure>


<h1 id="以根目录用户来运行最后一个命令"><a href="#以根目录用户来运行最后一个命令" class="headerlink" title="以根目录用户来运行最后一个命令"></a>以根目录用户来运行最后一个命令</h1><p>有时，你会忘记在需要 root 权限的命令之前敲入 sudo。 这时候你没必要去重写命令;<br>只要输入 <code>sudo !!</code> 就行了！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/shadow</span><br><span class="line">!!                  <span class="comment"># 重复执行最后一条指令 cat /etc/shadow</span></span><br><span class="line">sudo !!             <span class="comment"># 等同于最后一条指令前面加上sudo</span></span><br></pre></td></tr></table></figure>


<h1 id="对命令行会话进行记录"><a href="#对命令行会话进行记录" class="headerlink" title="对命令行会话进行记录"></a>对命令行会话进行记录</h1><p>如果想要把自己在 shell 屏幕上敲的内容记录下来，可以使用 <code>script</code> 命令<br>将所有敲写的内容保存到一个名为 <code>typescript</code> 的文件中去。<br>等你敲入 <code>exit</code> 命令以后，所有命令就都会被写入该文件，以便你事后再回过头去查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">script</span><br><span class="line"><span class="comment"># Script started, file is typescript</span></span><br><span class="line">ll                  <span class="comment"># normal cmd, will be　saved to typescript</span></span><br><span class="line"><span class="built_in">exit</span>                <span class="comment"># exit script</span></span><br><span class="line"><span class="comment"># Script done, file is typescript</span></span><br><span class="line"></span><br><span class="line">cat typescript      <span class="comment"># show what you do</span></span><br></pre></td></tr></table></figure>


<h1 id="用标签符号替换空格符"><a href="#用标签符号替换空格符" class="headerlink" title="用标签符号替换空格符"></a>用标签符号替换空格符</h1><p>可以使用 tr 命令替换任何字符，这个用起来非常方便：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat typescript | tr <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;\t&#x27;</span> &gt; out      <span class="comment"># 空格替换为制表符, 保存为out文件</span></span><br><span class="line">cat myfile | tr a-z A-Z&gt; output         <span class="comment"># 大小写转换</span></span><br></pre></td></tr></table></figure>


<h1 id="强大的-Xargs-命令"><a href="#强大的-Xargs-命令" class="headerlink" title="强大的 Xargs 命令"></a>强大的 Xargs 命令</h1><p>xargs 命令是最重要的 Linux 命令行技巧之一。你可以使用这个命令将命令的输出作为参数传递给另一个命令。例如，搜索 png 文件然后对其进行压缩或者其它操作：<br><code>find. -name *.png -type f -print | xargs tar -cvzf images.tar.gz</code></p>
<p>又或者你的文件中有一个 URL 的列表，而你想要做的是以不同的方式下载或者处理这些 URL，可以这样做：<br><code>cat urls.txt | xargs wget</code></p>
<p>请你要记得，<strong>第一个命令的输出会在 xargs 命令结尾处传递</strong>。<br>那如果命令需要中间过程的输出，该怎么办呢？这个简单！<br>只需要使用 <code>xargs -i</code> 并结合 <code>&#123;&#125;</code> 就行了。如下所示，替换在第一个命令的输出应该去的地方的参数：<br><code>ls /etc/*.conf | xargs -i cp &#123;&#125; /home/out</code></p>
<h1 id="其它指令"><a href="#其它指令" class="headerlink" title="其它指令"></a>其它指令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> -                        <span class="comment"># 回到你操作过的上一个目录去</span></span><br><span class="line">getconf LONG_BIT            <span class="comment"># 检查机器架构的位数 32/64</span></span><br></pre></td></tr></table></figure>


<hr>
<p><em><strong>转载自 <a href="https://www.oschina.net/translate/most-useful-linux-command-line-tricks#comments">最实用的 Linux 命令行使用技巧</a></strong></em><br><em><strong>英文原文 <a href="https://dzone.com/articles/most-useful-linux-command-line-tricks">Most Useful Linux Command Line Tricks</a></strong></em></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel之Makefile分析</title>
    <url>/2017/09/14/1724-kernel-makefile/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/09/01/1722-kernel-compile/">kernel之编译体验</a></li>
<li><a href="https://draapho.github.io/2017/09/14/1724-kernel-makefile/">kernel之Makefile分析</a></li>
<li><a href="https://draapho.github.io/2017/09/15/1725-kernel-launch/">kernel之内核启动分析</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="Makefile-概览"><a href="#Makefile-概览" class="headerlink" title="Makefile 概览"></a>Makefile 概览</h1><p><code>.\linux-2.6.22.6\Documentation\kbuild\makefiles.txt</code> 详细介绍了 kernel 的 makefile用法.<br>建议完整过一遍, 它对如何配置, 生成配置, 编译过程有完整的阐述.</p>
<p>Makefile分为5个部分:</p>
<ul>
<li><code>Makefile</code>, 位于kernel根目录, 顶层Makefile. 最终目的是编译内核, 生成 <code>vmlinux</code> 和 <code>modules</code>.</li>
<li><code>.config</code>, kernel配置文件, 已在 <a href="https://draapho.github.io/2017/09/01/1722-kernel-compile/">kernel之编译体验</a>分析过生成方式和过程</li>
<li><code>arch/$(ARCH)/Makefile</code>, 芯片架构相关的Makefile</li>
<li><code>scripts/Makefile.*</code>, Makefile的规则和脚本</li>
<li><code>kbuild Makefiles</code>, 即各子目录下的<code>Makefile</code>, 最终都会被顶层Makefile调用的.</li>
</ul>
<p><code>obj-y</code>, 表示需要编译进内核, 其形式很简单</p>
<ul>
<li><code>obj-$(CONFIG_DM9000) += dm9dev9000c.o</code>, 含变量的形式.</li>
<li><code>obj-y += dm9dev9000c.o</code>, 替换变量后的直观形式.</li>
</ul>
<p><code>obj-m</code>, 表示需要编译为<code>.ko</code>模块. 有三种形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 单文件编译为模块, 变量$(CONFIG_ISDN_PPP_BSDCOMP)为m</span><br><span class="line">obj-$(CONFIG_ISDN_PPP_BSDCOMP) +&#x3D; isdn_bsdcomp.o</span><br><span class="line"></span><br><span class="line"># 多文件编译为模块, 变量$(CONFIG_ISDN)为m</span><br><span class="line"># 目标模块名称 isdn.ko</span><br><span class="line">obj-$(CONFIG_ISDN) +&#x3D; isdn.o</span><br><span class="line"># 关联相关源文件, 使用 xxx-objs. $(LD) 链接命令会链接如下文件.</span><br><span class="line">isdn-objs :&#x3D; isdn_net_lib.o isdn_v110.o isdn_common.o</span><br><span class="line"></span><br><span class="line"># 多文件可配置, 编译为模块. 可使用 xxx-$(CONFIG_) 来配置</span><br><span class="line"># $(CONFIG_EXT2_FS) 为m, 即需要生成 ext2.ko 模块文件</span><br><span class="line">obj-$(CONFIG_EXT2_FS)        +&#x3D; ext2.o</span><br><span class="line"># 必须的关联文件有如下两个, 此处效果等同于 ext2-objs :&#x3D; balloc.o bitmap.o</span><br><span class="line">ext2-y                       :&#x3D; balloc.o bitmap.o</span><br><span class="line"># 另外一个文件则根据配置决定是否编译进模块. 其值为 y 或者空.</span><br><span class="line">ext2-$(CONFIG_EXT2_FS_XATTR) +&#x3D; xattr.o</span><br></pre></td></tr></table></figure>

<p><code>lib-y</code> 编译为库文件. 形如 <code>lib-y := checksum.o delay.o</code><br>一般仅用于 <code>lib/</code> 以及 <code>arch/*/lib-y</code> 目录下面</p>
<p>另外还有一些 <code>EXTRA_CFLAGS</code>, <code>EXTRA_AFLAGS</code>, <code>EXTRA_LDFLAGS</code>, <code>EXTRA_ARFLAGS</code> 的 flag配置<br>此处略过不表.</p>
<h1 id="linux下关键字搜索技巧"><a href="#linux下关键字搜索技巧" class="headerlink" title="linux下关键字搜索技巧"></a>linux下关键字搜索技巧</h1><p>由于有多个Makefile, 变量也分布在不同的文件中, 所以阅读起来比较麻烦.<br>此处再重复列举一下linux下的搜索技巧</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -n 100ask24x0 ./Makefile       <span class="comment"># 在Makefile文件下查找 100ask24x0, 并显示行号</span></span><br><span class="line">grep -nr 100ask24x0 *               <span class="comment"># 当前目录递归查找 100ask24x0</span></span><br><span class="line">grep -nwr 100ask24x0 *              <span class="comment"># w=word, 100ask24x0 作为一个单词查找</span></span><br><span class="line">grep -nd skip 100ask24x0 *          <span class="comment"># 仅在当前目录查找, 不显示子目录信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 特别强大的一条指令, 可针对指定文件搜索指定关键字!</span></span><br><span class="line"><span class="comment"># 先用find找出所有的Makefile文件, 然后在Makefile文件内查找 uImage 关键字.</span></span><br><span class="line">find ./ -name <span class="string">&quot;Makefile&quot;</span> | xargs grep -nw --color <span class="string">&quot;uImage&quot;</span></span><br></pre></td></tr></table></figure>


<h1 id="Makefile整体分析"><a href="#Makefile整体分析" class="headerlink" title="Makefile整体分析"></a>Makefile整体分析</h1><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">    <span class="comment"># 顶层Makefile, 位于 &quot;./linux-2.6.22.6/Makefile&quot;</span></span><br><span class="line">    <span class="comment"># 这里就不按文件顺序排列, 而按照分析Makefile的逻辑顺序排列了.</span></span><br><span class="line"></span><br><span class="line">186 ARCH        ?= arm                  <span class="comment"># arm 架构</span></span><br><span class="line">187 CROSS_COMPILE   ?= arm-linux-       <span class="comment"># 指定编译器</span></span><br><span class="line"></span><br><span class="line">192 KCONFIG_CONFIG  ?= .config          <span class="comment"># 指定配置文件</span></span><br><span class="line"></span><br><span class="line">284 LD      = <span class="variable">$(CROSS_COMPILE)</span>ld        <span class="comment"># 指定一些列指令</span></span><br><span class="line">285 CC      = <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 编译时, 我们使用 make uImage, 因为需要uImage格式.</span></span><br><span class="line">    <span class="comment"># 但过程和 make all 是一样的, 都需要生成 vmlinux</span></span><br><span class="line">484 all: vmlinux                       <span class="comment"># 直接make, 就是生成vmlinux</span></span><br><span class="line"></span><br><span class="line">581 <span class="comment"># Build vmlinux. 可以看一行开始的注释, 说明了vmlinux的依赖结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找到了 vmlinux 这个目标有关的依赖文件, 逐一扩展来看</span></span><br><span class="line">745 vmlinux: $(vmlinux-lds) $(vmlinux-init) $(vmlinux-main) $(kallsyms.o) FORCE</span><br><span class="line">    <span class="comment"># kernel/kallsyms.c</span></span><br><span class="line"></span><br><span class="line">608 vmlinux-init := $(head-y) $(init-y)</span><br><span class="line">609 vmlinux-main := $(core-y) $(libs-y) $(drivers-y) $(net-y)</span><br><span class="line">611 vmlinux-lds  := arch/<span class="variable">$(ARCH)</span>/kernel/vmlinux.lds</span><br><span class="line">    <span class="comment"># vmlinux-lds:= arch/arm/kernel/vmlinux.lds</span></span><br><span class="line">    <span class="comment"># 此文件由 vmlinux.lds.S 在make时自动生成!</span></span><br><span class="line"></span><br><span class="line">434 init-y      := init/</span><br><span class="line">435 drivers-y   := drivers/ sound/</span><br><span class="line">436 net-y       := net/</span><br><span class="line">437 libs-y      := lib/</span><br><span class="line">438 core-y      := usr/</span><br><span class="line">562 core-y      += kernel/ mm/ fs/ ipc/ security/ crypto/ block/</span><br><span class="line"></span><br><span class="line">573 init-y      := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/built-in.o, $(init-y)</span>)</span><br><span class="line">574 core-y      := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/built-in.o, $(core-y)</span>)</span><br><span class="line">575 drivers-y   := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/built-in.o, $(drivers-y)</span>)</span><br><span class="line">576 net-y       := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/built-in.o, $(net-y)</span>)</span><br><span class="line">577 libs-y1     := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/lib.a, $(libs-y)</span>)</span><br><span class="line">578 libs-y2     := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/built-in.o, $(libs-y)</span>)</span><br><span class="line">579 libs-y      := $(libs-y1) $(libs-y2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># patsubst 是makefile内的字符串替换函数, 替换结果为:</span></span><br><span class="line">    <span class="comment"># init-y    := init/built-in.o</span></span><br><span class="line">    <span class="comment"># core-y    := usr/built-in.o kernel/built-in.o mm/built-in.o fs/built-in.o ... (略)</span></span><br><span class="line">    <span class="comment"># drivers-y := drivers/built-in.o sound/built-in.o</span></span><br><span class="line">    <span class="comment"># net-y     := net/built-in.o</span></span><br><span class="line">    <span class="comment"># libs-y    := lib/lib.a lib/built-in.o</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># find ./ -name &quot;Makefile&quot; | xargs grep -nw --color &quot;head-y&quot;</span></span><br><span class="line">    <span class="comment"># 查出 head-y 位于 &quot;./arch/arm/Makefile&quot; 以及 &quot;./arch/arm/kernel/Makefile&quot; 内</span></span><br><span class="line">    <span class="comment"># head-y    := arch/arm/kernel/head.S arch/arm/kernel/init_task.c, 分析见 架构文件内的Makefile.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 此句就是执行指令, 将上述相关文件打包生成vmlinux二进制内核文件. 太难懂, 先略过.</span></span><br><span class="line">745 vmlinux: $(vmlinux-lds) $(vmlinux-init) $(vmlinux-main) $(kallsyms.o) FORCE</span><br><span class="line">749 <span class="variable">$(<span class="built_in">call</span> if_changed_rule,vmlinux__)</span></span><br><span class="line">750 <span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> -f <span class="variable">$(srctree)</span>/scripts/Makefile.modpost <span class="variable">$@</span></span><br><span class="line">751 <span class="variable">$(Q)</span>rm -f .old_version</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">    <span class="comment"># 架构文件内的 Makefile, 位于 &quot;./arch/arm/Makefile&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查找 .config 文件可知, CONFIG_MMU=y</span></span><br><span class="line">26  <span class="keyword">ifeq</span> (<span class="variable">$(CONFIG_MMU)</span>,)       <span class="comment"># CONFIG_MMU不为空, 条件不成立</span></span><br><span class="line">27  MMUEXT      := -nommu</span><br><span class="line">28  <span class="keyword">endif</span>                       <span class="comment"># 因此 $(MMUEXT) 为空</span></span><br><span class="line"></span><br><span class="line">94  head-y      := arch/arm/kernel/head<span class="variable">$(MMUEXT)</span>.o arch/arm/kernel/init_task.o</span><br><span class="line">    <span class="comment"># head-y    := arch/arm/kernel/head.S arch/arm/kernel/init_task.c</span></span><br><span class="line">    <span class="comment"># 至于 &quot;./arch/arm/kernel/Makefile&quot; 内的head-y, 猜测是为 extra-y 服务的, 不去追究.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># make uImage时, 也需要先生成 vmlinux. 事实上, uImage格式只是比vmlinux多64字节的头.</span></span><br><span class="line">227 zImage Image xipImage bootpImage uImage: vmlinux</span><br></pre></td></tr></table></figure>


<p>至此, 为生成vmlinux的原材料都已经分析完成, 就看如何执行指令了.<br>但是, 由Makefile进行分析的话, 需要去看一系列的脚本文件, 工作量太大, 也难以理解.<br>我们倒过来分析, 直接执行 <code>make uImage V=1</code>, 查看编译指令是否和分析的一致.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6</span></span><br><span class="line">make uImage             <span class="comment"># 生成 uImage, 如有必要, 先 make clean</span></span><br><span class="line">rm vmlinux              <span class="comment"># 删除目标文件vmlinux</span></span><br><span class="line">make uImage V=1         <span class="comment"># 查看生成vmlinux时, 详细的编译指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以在执行结果中, 找到这么一行:</span></span><br><span class="line"><span class="comment"># arm-linux-ld -EL  -p --no-undefined -X -o vmlinux -T arch/arm/kernel/vmlinux.lds</span></span><br><span class="line"><span class="comment"># arch/arm/kernel/head.o arch/arm/kernel/init_task.o  init/built-in.o</span></span><br><span class="line"><span class="comment"># --start-group  usr/built-in.o  arch/arm/kernel/built-in.o  arch/arm/mm/built-in.o  arch/arm/common/built-in.o  arch/arm/mach-s3c2410/built-in.o  arch/arm/mach-s3c2400/built-in.o  arch/arm/mach-s3c2412/built-in.o  arch/arm/mach-s3c2440/built-in.o  arch/arm/mach-s3c2442/built-in.o  arch/arm/mach-s3c2443/built-in.o  arch/arm/nwfpe/built-in.o  arch/arm/plat-s3c24xx/built-in.o  kernel/built-in.o  mm/built-in.o  fs/built-in.o  ipc/built-in.o  security/built-in.o  crypto/built-in.o  block/built-in.o  arch/arm/lib/lib.a  lib/lib.a  arch/arm/lib/built-in.o  lib/built-in.o  drivers/built-in.o  sound/built-in.o  net/built-in.o</span></span><br><span class="line"><span class="comment"># --end-group .tmp_kallsyms2.o</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析如下:</span></span><br><span class="line">    <span class="comment"># &quot;arm-linux-ld&quot;                    链接命令</span></span><br><span class="line">    <span class="comment"># &quot;-o vmlinux&quot;                      目标文件</span></span><br><span class="line">    <span class="comment"># &quot;-T arch/arm/kernel/vmlinux.lds&quot;  指定链接脚本</span></span><br><span class="line">    <span class="comment"># 一系列的 &quot;.o&quot; 文件, 就是前文分析出的相关文件, 能一一对应的.</span></span><br></pre></td></tr></table></figure>

<h1 id="链接指令的工作方式"><a href="#链接指令的工作方式" class="headerlink" title="链接指令的工作方式"></a>链接指令的工作方式</h1><p>链接指令的工作方式为, 根据链接脚本的要求对每个文件内的段按顺序排放. 相同的段, 则按照指令的文件顺序排放.<br>譬如: lds 一开始的段位 <code>.text.head</code> 和 <code>.init</code>. 那么以 head.o 和 init_task.o 为例, 其排放顺序为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># .text.head 段开始</span><br><span class="line">head.text.head          # 第一个文件的 .text.head 段</span><br><span class="line">init_task.text.head     # 第二个文件的 .text.head 段</span><br><span class="line"># .text.head 段结束</span><br><span class="line"></span><br><span class="line"># .init 段开始</span><br><span class="line">head.init               # 第一个文件的 .init 段</span><br><span class="line">init_task.init          # 第二个文件的 .init 段</span><br><span class="line"># .init 段结束</span><br><span class="line"></span><br><span class="line"># 这样, 链接指令就会把各文件打包生成一个最终的二进制文件, 名称为 vmlinux</span><br></pre></td></tr></table></figure>

<p>为分析内核启动过程, 重要的信息如下:</p>
<ul>
<li>第1个文件: <code>arch/arm/kernel/head.S</code></li>
<li>链接脚本:  <code>arch/arm/kernel/vmlinux.lds</code></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel之内核启动分析</title>
    <url>/2017/09/15/1725-kernel-launch/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/09/01/1722-kernel-compile/">kernel之编译体验</a></li>
<li><a href="https://draapho.github.io/2017/09/14/1724-kernel-makefile/">kernel之Makefile分析</a></li>
<li><a href="https://draapho.github.io/2017/09/15/1725-kernel-launch/">kernel之内核启动分析</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="内核引导阶段-head-S"><a href="#内核引导阶段-head-S" class="headerlink" title="内核引导阶段 head.S"></a>内核引导阶段 <code>head.S</code></h1><p>由 <a href="https://draapho.github.io/2017/08/25/1720-uboot-source/">uboot之源码分析</a> 可知, uboot最后调用的函数是</p>
<ul>
<li><code>theKernel (0, bd-&gt;bi_arch_number, bd-&gt;bi_boot_params)</code>, 会把一些板级参数传递给linux内核使用.</li>
</ul>
<p>由 <a href="https://draapho.github.io/2017/09/14/1724-kernel-makefile/">kernel之Makefile分析</a> 可知, 两个重要的文件如下:</p>
<ul>
<li>第1个文件: <code>arch/arm/kernel/head.S</code></li>
<li>链接脚本: <code>arch/arm/kernel/vmlinux.lds</code></li>
</ul>
<p><code>head.S</code> 主要完成了如下工作.</p>
<p><img src="https://draapho.github.io/images/1725/stage1.JPG" alt="内核引导阶段"></p>
<ul>
<li><code>__lookup_machine_type</code> 会将 theKernel 传入的单板类型与内核支持的单板类型逐一比较.</li>
<li><code>.arch.info.init</code> 这一个段存放的就是内核支持的单板类型.<ul>
<li>定义在 <code>./arch/arm/kernel/vmlinux.lds</code></li>
<li><code>__lookup_machine_type</code> 会对该段进行轮询</li>
<li>该段的数据结构为 <code>machine_desc</code>, 定义在 <code>./include/asm-arm/mach/arch.h</code></li>
<li><code>arch.h</code> 文件还宏定义了 <code>MACHINE_START</code> <code>MACHINE_END</code>,<br>  调用该宏定义, 就会将相关数据放在 <code>.arch.info.init</code> 段内</li>
</ul>
</li>
<li><code>./arch/arm/mach-s3c2440/mach-smdk2440.c:</code> 内调用了 <code>MACHINE_START(S3C2440, &quot;SMDK2440&quot;)</code><ul>
<li>kernel下 <code>grep -nr MACH_TYPE_S3C2440</code> 可知 MACH_TYPE_S3C2440 的值为 362</li>
<li>uboot下 <code>grep -nr bi_arch_number</code> 可知其值为 MACH_TYPE_S3C2440, 即 362</li>
<li>这样, kernel就能确定是支持当前的开发板的. (当前的开发板信息由uboot提供给kernel)</li>
</ul>
</li>
</ul>
<h1 id="内核启动第二阶段-init-main-c"><a href="#内核启动第二阶段-init-main-c" class="headerlink" title="内核启动第二阶段 init/main.c"></a>内核启动第二阶段 <code>init/main.c</code></h1><p><code>head-common.S</code> 调用 <code>start_kernel</code> 后, 代码会转到 <code>init/main.c</code>, 使用的是C语言.</p>
<p><img src="https://draapho.github.io/images/1725/stage2.JPG" alt="内核启动第二阶段"></p>
<p>从 <code>start_kernel</code> 开始, 函数的基本调用关系如下:</p>
<ul>
<li><code>setup_arch(&amp;command_line);</code> 读取uboot传过来的TAG参数<ul>
<li>位于 <code>./arch/arm/kernel/setup.c</code> 770 行</li>
<li>uboot 的 <code>setup_memory_tags</code> 存放内存大小</li>
<li>uboot 的 <code>setup_commandline_tag</code> 告知linux挂载文件系统的命令行</li>
<li>uboot 的 <code>/board/100ask24x0/100ask24x0.c</code> 中, <code>gd-&gt;bd-&gt;bi_boot_params = 0x30000100</code></li>
<li>使用了 <code>machine_desc</code> 结构体, <code>.boot_params = S3C2410_SDRAM_PA + 0x100</code>, 其值就是 <code>0x30000100</code></li>
<li>至此, uboot存放在内存中的TAG参数, 就能被内核读取出来了.</li>
<li>此函数还会把挂载文件系统的命令赋值给 <code>boot_command_line</code>, 后续会去处理.</li>
<li><code>parse_cmdline</code> 会去处理放在 <code>early_param.init</code> 段的指令.</li>
</ul>
</li>
<li><code>parse_early_param</code>, 此函数会把 <code>boot_command_line</code>传递给<code>do_early_param</code>让其执行挂载文件系统的指令.<ul>
<li><code>do_early_param</code><ul>
<li>搜索 <code>.init.setup</code> 段, 调用有early标记的函数 (大多只是设置一下参数)</li>
</ul>
</li>
</ul>
</li>
<li><code>unknown_bootoption</code> (使用 parse_args 先检查参数后再执行该函数)<ul>
<li><code>obsolete_checksetup</code><ul>
<li>搜索 <code>.init.setup</code> 段, 调用非early标记的函数 (大多只是设置一下参数)</li>
</ul>
</li>
</ul>
</li>
<li><code>rest_init</code>, 去做剩余的初始化工作<ul>
<li><code>kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);</code> 首先就是创建一个线程来做初始化工作<ul>
<li><code>kernel_init</code> 会调用 <code>prepare_namespace</code><ul>
<li>在 <code>do_mounts.c</code> 文件下 <code>prepare_namespace</code> 调用 <code>mount_root</code></li>
<li>目的就是挂载文件系统.</li>
</ul>
</li>
<li>挂载完文件系统后, 调用 <code>init_post</code>, 尝试执行第一个应用程序(下述应用程序不会再返回)<ul>
<li><code>run_init_process(execute_command);</code></li>
<li><code>run_init_process(&quot;/sbin/init&quot;);</code></li>
<li><code>run_init_process(&quot;/etc/init&quot;);</code></li>
<li><code>run_init_process(&quot;/bin/init&quot;);</code></li>
<li><code>run_init_process(&quot;/bin/sh&quot;);</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>以默认的启动指令为例 <code>&quot;root=/dev/hda1 ro init=/bin/bash console=ttySAC0&quot;</code><pre><code>      - `__setup(&quot;root=&quot;, root_dev_setup);` 位于 `./init/do_mounts.c`
      - `__setup(&quot;init=&quot;, init_setup);` 位于 `./init/main.c`
      - `__setup(&quot;console=&quot;, console_setup);` 位于 `./kernel/printk.c`
      - 以上命令对应的函数都会由 `obsolete_checksetup` 函数来调用. 主要是设置好相关参数.
</code></pre>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./init/main.c</span></span><br><span class="line"></span><br><span class="line"><span class="number">497</span> <span class="function">asmlinkage <span class="keyword">void</span> __init <span class="title">start_kernel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="number">520</span>     tick_init();</span><br><span class="line"><span class="number">521</span>     boot_cpu_init();</span><br><span class="line"><span class="number">522</span>     page_address_init();</span><br><span class="line"><span class="number">524</span>     printk(linux_banner);                           <span class="comment">// 打印linux版本信息</span></span><br><span class="line"><span class="number">525</span>     setup_arch(&amp;command_line);                      <span class="comment">// 读取uboot传过来的TAG参数</span></span><br><span class="line">                                                        <span class="comment">// 搜索 &quot;early_param.init&quot; 段, 并调用相关函数</span></span><br><span class="line"><span class="number">526</span>     setup_command_line(command_line);               <span class="comment">// 复制一下 command_line.</span></span><br><span class="line"></span><br><span class="line"><span class="number">544</span>     printk(KERN_NOTICE <span class="string">&quot;Kernel command line: %s\n&quot;</span>, boot_command_line); <span class="comment">// 打印文件系统挂载命令</span></span><br><span class="line"><span class="number">545</span>     parse_early_param();                            <span class="comment">// 最终会搜索 &quot;.init.setup&quot; 段, 调用有early标记的函数</span></span><br><span class="line"><span class="number">546</span>     parse_args(<span class="string">&quot;Booting kernel&quot;</span>, static_command_line, __start___param,</span><br><span class="line"><span class="number">547</span>        __stop___param - __start___param,            <span class="comment">// 搜索 &quot;__param&quot; 段</span></span><br><span class="line"><span class="number">548</span>        &amp;unknown_bootoption);                        <span class="comment">// 最终会搜索 &quot;.init.setup&quot; 段, 调用非early标记的函数</span></span><br><span class="line"></span><br><span class="line"><span class="number">575</span>     console_init();                                 <span class="comment">// 控制终端初始化</span></span><br><span class="line"></span><br><span class="line"><span class="number">636</span>     rest_init();                                    <span class="comment">// 剩余部分的初始化</span></span><br><span class="line"><span class="number">637</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">466</span> <span class="function"><span class="keyword">void</span> __init <span class="title">parse_early_param</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="number">475</span>     strlcpy(tmp_cmdline, boot_command_line, COMMAND_LINE_SIZE);</span><br><span class="line">        <span class="comment">// parse_args 会先检查参数, 最后调用函数, 此处是do_early_param,</span></span><br><span class="line">        <span class="comment">// 参数为 boot_command_line 启动命令, 由uboot传递进来. 实际不会在此处执行.</span></span><br><span class="line"><span class="number">476</span>     parse_args(<span class="string">&quot;early options&quot;</span>, tmp_cmdline, <span class="literal">NULL</span>, <span class="number">0</span>, do_early_param);</span><br><span class="line"><span class="number">478</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">450</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">do_early_param</span><span class="params">(<span class="keyword">char</span> *param, <span class="keyword">char</span> *val)</span> </span>&#123;</span><br><span class="line"><span class="number">454</span>     <span class="keyword">for</span> (p = __setup_start; p &lt; __setup_end; p++)   <span class="comment">// 遍历 &quot;.init.setup&quot; 段</span></span><br><span class="line"><span class="number">455</span>         <span class="keyword">if</span> (p-&gt;early &amp;&amp; <span class="built_in">strcmp</span>(param, p-&gt;str) == <span class="number">0</span>) <span class="comment">// 在段内找了匹配boot_command_line的命令, 则执行</span></span><br><span class="line"><span class="number">456</span>             <span class="keyword">if</span> (p-&gt;setup_func(val) != <span class="number">0</span>)</span><br><span class="line"><span class="number">463</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">258</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">unknown_bootoption</span><span class="params">(<span class="keyword">char</span> *param, <span class="keyword">char</span> *val)</span> </span>&#123;</span><br><span class="line"><span class="number">274</span>     <span class="keyword">if</span> (obsolete_checksetup(param))                 <span class="comment">// 调用 obsolete_checksetup</span></span><br><span class="line"><span class="number">313</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">190</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">obsolete_checksetup</span><span class="params">(<span class="keyword">char</span> *line)</span> </span>&#123;</span><br><span class="line"><span class="number">195</span>     p = __setup_start;                              <span class="comment">// 遍历 &quot;.init.setup&quot; 段</span></span><br><span class="line"><span class="number">196</span>     <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="number">199</span>         <span class="keyword">if</span> (p-&gt;early) &#123;                             <span class="comment">// 有early标记, 跳过.</span></span><br><span class="line"><span class="number">210</span>         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;setup_func(line + n))         <span class="comment">// 执行指令对应的函数</span></span><br><span class="line"><span class="number">214</span>     &#125; <span class="keyword">while</span> (p &lt; __setup_end);<span class="number">24</span></span><br><span class="line"><span class="number">217</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">426</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> noinline __init_refok <span class="title">rest_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS | CLONE_SIGHAND); <span class="comment">// 创建一个初始化用的线程</span></span><br><span class="line">        schedule();                                     <span class="comment">// 调度</span></span><br><span class="line"><span class="number">447</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">787</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">kernel_init</span><span class="params">(<span class="keyword">void</span> * unused)</span> </span>&#123;</span><br><span class="line"><span class="number">828</span>         prepare_namespace();                        <span class="comment">// 调用 mount_root, 加载文件系统</span></span><br><span class="line"><span class="number">836</span>     init_post();                                    <span class="comment">// 执行应用程序</span></span><br><span class="line"><span class="number">838</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">748</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> noinline <span class="title">init_post</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;               <span class="comment">// 执行应用程序</span></span><br><span class="line"><span class="number">756</span>     <span class="keyword">if</span> (sys_open((<span class="keyword">const</span> <span class="keyword">char</span> __user *) <span class="string">&quot;/dev/console&quot;</span>, O_RDWR, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                                                        <span class="comment">// 尝试打开终端设备, 文件0-&gt;printf</span></span><br><span class="line"><span class="number">757</span>         printk(KERN_WARNING <span class="string">&quot;Warning: unable to open an initial console.\n&quot;</span>);</span><br><span class="line"><span class="number">759</span>     (<span class="keyword">void</span>) sys_dup(<span class="number">0</span>);                              <span class="comment">// 赋值文件0, 生成文件1-&gt;scanf</span></span><br><span class="line"><span class="number">760</span>     (<span class="keyword">void</span>) sys_dup(<span class="number">0</span>);                              <span class="comment">// 赋值文件0, 生成文件2-&gt;err</span></span><br><span class="line">        <span class="comment">// 以上四句作用为设置标准输入输出流, (printf, scanf, err)</span></span><br><span class="line"></span><br><span class="line"><span class="number">744</span>     <span class="keyword">if</span> (execute_command) &#123;</span><br><span class="line"><span class="number">745</span>         run_init_process(execute_command);</span><br><span class="line"><span class="number">746</span>         printk(KERN_WARNING <span class="string">&quot;Failed to execute %s.  Attempting &quot;</span></span><br><span class="line"><span class="number">747</span>                 <span class="string">&quot;defaults...\n&quot;</span>, execute_command);</span><br><span class="line"><span class="number">748</span>     &#125;</span><br><span class="line">        <span class="comment">// 传入的启动参数内有 &quot;init=&quot; 启动程序, 则执行! 执行成功的话不会再返回这里!</span></span><br><span class="line"></span><br><span class="line"><span class="number">779</span>     run_init_process(<span class="string">&quot;/sbin/init&quot;</span>);</span><br><span class="line"><span class="number">780</span>     run_init_process(<span class="string">&quot;/etc/init&quot;</span>);</span><br><span class="line"><span class="number">781</span>     run_init_process(<span class="string">&quot;/bin/init&quot;</span>);</span><br><span class="line"><span class="number">782</span>     run_init_process(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">        <span class="comment">// 没有配置过启动指令, 依次尝试上述四个默认程序. 某一个执行成功后就不会再返回!</span></span><br><span class="line"></span><br><span class="line"><span class="number">784</span>     panic(<span class="string">&quot;No init found.  Try passing init= option to kernel.&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行首个应用程序失败, 打印内核错误信息!</span></span><br><span class="line"><span class="number">785</span> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们擦除开发板文件系统后, 来看一下打印出来的启动信息</span></span><br><span class="line"></span><br><span class="line">OpenJTAG&gt; nand erase root           <span class="comment"># uboot 下, 擦除root块</span></span><br><span class="line">OpenJTAG&gt; reset                     <span class="comment"># uboot 下, 重启系统</span></span><br><span class="line"></span><br><span class="line">Booting Linux ...</span><br><span class="line">NAND <span class="built_in">read</span>: device 0 offset 0x60000, size 0x200000</span><br><span class="line"><span class="comment">## Booting image at 30007fc0 ...</span></span><br><span class="line">...</span><br><span class="line">Starting kernel ...</span><br><span class="line">...</span><br><span class="line">Kernel <span class="built_in">command</span> line: noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0</span><br><span class="line">loop: module loaded</span><br><span class="line">...</span><br><span class="line">Creating 4 MTD partitions on <span class="string">&quot;NAND 256MiB 3,3V 8-bit&quot;</span>:</span><br><span class="line">0x00000000-0x00040000 : <span class="string">&quot;bootloader&quot;</span></span><br><span class="line">0x00040000-0x00060000 : <span class="string">&quot;params&quot;</span></span><br><span class="line">0x00060000-0x00260000 : <span class="string">&quot;kernel&quot;</span></span><br><span class="line">0x00260000-0x10000000 : <span class="string">&quot;root&quot;</span></span><br><span class="line">...</span><br><span class="line">VFS: Mounted root (yaffs filesystem).</span><br><span class="line">...</span><br><span class="line">Kernel panic - not syncing: No init found.  Try passing init= option to kernel.</span><br><span class="line"><span class="comment"># 此句就是由./init/main.c文件784行打印出来的. 因为没有文件系统, 第一个应用程序执行失败!</span></span><br></pre></td></tr></table></figure>

<p>如果正常启动, 会打印如下信息, 可知第一个应用程序名字是 <code>BusyBox</code>, 然后启动了 <code>/bin/sh</code>!!!<br><code>init started: BusyBox v1.7.0 (2008-01-22 10:04:09 EST)</code><br><code>starting pid 764, tty &#39;&#39;: &#39;/etc/init.d/rcS&#39;</code><br><code>Please press Enter to activate this console.</code><br><code>starting pid 770, tty &#39;/dev/s3c2410_serial0&#39;: &#39;/bin/sh&#39;</code></p>
<h1 id="初始化中用到的段-vmlinux-lds"><a href="#初始化中用到的段-vmlinux-lds" class="headerlink" title="初始化中用到的段 vmlinux.lds"></a>初始化中用到的段 <code>vmlinux.lds</code></h1><h2 id="init-setup-段分析"><a href="#init-setup-段分析" class="headerlink" title=".init.setup 段分析"></a><code>.init.setup</code> 段分析</h2><p>在 <code>./arch/arm/kernel/vmlinux.lds</code> 中有这么一个段<br><code>*(.init.setup)</code>, 其头尾为 <code>__setup_start</code> <code>__setup_end</code></p>
<p>这一个段存放着需要通过读取命令行来执行的初始化工作, 内核称之为 <code>unknow_xxx</code><br>定义在此段的变量通过两个宏定义实现 <code>__setup</code> 以及 <code>early_param</code><br>简单理解的话, <code>early_param</code> 是需要先执行的命令行, <code>__setup</code> 则稍后执行.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># ./include/linux/init.h</span><br><span class="line"></span><br><span class="line"><span class="number">148</span> <span class="class"><span class="keyword">struct</span> <span class="title">obs_kernel_param</span> &#123;</span></span><br><span class="line"><span class="number">149</span>     <span class="keyword">const</span> <span class="keyword">char</span> *str;</span><br><span class="line"><span class="number">150</span>     <span class="keyword">int</span> (*setup_func)(<span class="keyword">char</span> *);</span><br><span class="line"><span class="number">151</span>     <span class="keyword">int</span> early;</span><br><span class="line"><span class="number">152</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">160</span> <span class="meta">#<span class="meta-keyword">define</span> __setup_param(str, unique_id, fn, early)            \</span></span><br><span class="line"><span class="number">161</span>     <span class="keyword">static</span> <span class="keyword">char</span> __setup_str_##unique_id[] __initdata = str; \</span><br><span class="line"><span class="number">162</span>     <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">obs_kernel_param</span> __<span class="title">setup_</span>##<span class="title">unique_id</span>  \</span></span><br><span class="line"><span class="class">163         __<span class="title">attribute_used__</span>              \</span></span><br><span class="line"><span class="class">164         __<span class="title">attribute__</span>((__<span class="title">section__</span>(&quot;.<span class="title">init</span>.<span class="title">setup</span>&quot;))) \</span></span><br><span class="line"><span class="class">165         __<span class="title">attribute__</span>((<span class="title">aligned</span>((<span class="title">sizeof</span>(<span class="title">long</span>)))))    \</span></span><br><span class="line"><span class="class">166         =</span> &#123; __setup_str_##unique_id, fn, early &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">171</span> <span class="meta">#<span class="meta-keyword">define</span> __setup(str, fn)                    \</span></span><br><span class="line"><span class="number">172</span>     __setup_param(str, fn, fn, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">179</span> <span class="meta">#<span class="meta-keyword">define</span> early_param(str, fn)                    \</span></span><br><span class="line"><span class="number">180</span>     __setup_param(str, fn, fn, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>先来分析 <code>__setup(str, fn)</code> 这么一个宏定义, 它设置的就是命令行队列, 将字符串关联到函数.</p>
<ul>
<li><code>unique_id</code> 就是fn的函数地址</li>
<li>存放在 <code>.init.setup</code> 段内.</li>
<li>与数据结构 <code>obs_kernel_param</code> 相关. 保存的就是 str, fn, 以及early三个变量.</li>
<li>通过这样一种结构, 可以很方便的使用字符串来调用指定的函数.</li>
<li><code>grep -nwr __setup ./arch/arm</code> 可找到 <code>__setup(&quot;tft=&quot;, qt2410_tft_setup);</code>, 很明显就是用来初始化屏幕的.</li>
<li>在 <code>./init/do_mounts.c</code>里, 还能找到 <code>__setup(&quot;root=&quot;, root_dev_setup)</code>, 是用来挂载文件系统的.</li>
</ul>
<p>然后看 <code>early_param(str, fn)</code> 宏定义.</p>
<ul>
<li><code>__setup</code> 是一样的.</li>
<li>只是将标记 <code>early</code> 赋值为1. 表示需要较早执行的初始化工作, 一般为更底层的驱动</li>
<li>arm 架构几乎没有用到 <code>early_param</code> 的地方, 搜索的话, 可以看到 pci 的初始化就用到了 <code>early_param</code></li>
</ul>
<h2 id="early-param-init-段"><a href="#early-param-init-段" class="headerlink" title="early_param.init 段"></a><code>early_param.init</code> 段</h2><p>和 <code>.init.setup</code> 段类似, 其定义在<br><code>./include/asm-arm/setup.h</code>, 220行.<br>关联的宏定义为 <code>__early_param</code>, 初始化如 <code>initrd=</code> <code>mem=</code> 之类的命令<br><code>grep -nwr __early_param</code> 进行查询, 结果不多的.<br>搜索 <code>grep -nwr __early_begin</code>, 可知, 其处理函数为 <code>parse_cmdline</code></p>
<h2 id="param-段"><a href="#param-段" class="headerlink" title="__param 段"></a><code>__param</code> 段</h2><p>该段主要用于给驱动模块的初始化. 设置参数使用.<br>定义在 <code>./include/linux/moduleparam.h</code>, 72 行<br>其调用位于 <code>./init/main.c</code> 的 <code>parse_args</code> (<code>grep -nwr __start___param</code>)<br>关联的宏定义为 <code>module_param_call</code> <code>module_param_named</code> <code>module_param</code> 以及 <code>module_param_string</code><br>查阅后, 可以发现全部是和驱动模块有关的.</p>
<h1 id="linux下的分区"><a href="#linux下的分区" class="headerlink" title="linux下的分区"></a>linux下的分区</h1><p>jz2440的启动参数为 <code>root= /dev/mtdblock3</code>,<br>linux下没有分区表的概念, 这里分区是在内核源码里写死的.<br>可见 <code>./arch/arm/plat-s3c24xx/common-smdk.c</code> 的118行, <code>smdk_default_nand_part</code><br>它分配了4个的分区:</p>
<table>
<thead>
<tr>
<th>分区</th>
<th>对应mtdblock</th>
<th>size</th>
</tr>
</thead>
<tbody><tr>
<td><code>bootloader</code></td>
<td>mtdblock0</td>
<td>0x00040000</td>
</tr>
<tr>
<td><code>params</code></td>
<td>mtdblock1</td>
<td>0x00020000</td>
</tr>
<tr>
<td><code>kernel</code></td>
<td>mtdblock2</td>
<td>0x00200000</td>
</tr>
<tr>
<td><code>root</code></td>
<td>mtdblock3</td>
<td>MTDPART_SIZ_FULL</td>
</tr>
</tbody></table>
<h1 id="更多参考"><a href="#更多参考" class="headerlink" title="更多参考"></a>更多参考</h1><ul>
<li><a href="http://blog.csdn.net/skyflying2012/article/details/41142801"> linux kernel的cmdline参数解析原理分析</a></li>
<li><a href="https://danielmaker.github.io/blog/linux/inside_start_kernel.html">深入淺出 start_kernel</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_5d9051c00100ij93.html">嵌入式Linux中基于MTD的文件系统的结构框架图</a></li>
<li><a href="http://blog.csdn.net/yusiguyuan/article/details/9471577">u-boot中分区和内核MTD分区关系</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>最全的常用正则表达式大全</title>
    <url>/2017/10/07/1727-soft-reexample/</url>
    <content><![CDATA[<p><em><strong>转载自 <a href="http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html">最全的常用正则表达式大全——包括校验数字、字符、一些特殊的需求等等</a></strong></em></p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li><a href="https://draapho.github.io/2016/12/18/1628-soft-regular/">正则表达式</a></li>
<li><a href="https://draapho.github.io/2017/09/19/1726-soft-easyre/">人人都看得懂的正则表达式教程</a></li>
<li><a href="https://draapho.github.io/2017/10/07/1727-soft-reexample/">最全的常用正则表达式大全</a></li>
</ul>
<p>本文收纳了很丰富的正则表达式的实用例子</p>
<p>很多不太懂正则的朋友，在遇到需要用正则校验数据时，往往是在网上去找很久，结果找来的还是不很符合要求。所以我最近把开发中常用的一些正则表达式整理了一下，在这里分享一下。给自己留个底，也给朋友们做个参考。</p>
<h1 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h1><ul>
<li>数字: <code>^[0-9]*$</code></li>
<li>n位的数字: <code>^\d&#123;n&#125;$</code></li>
<li>至少n位的数字: <code>^\d&#123;n,&#125;$</code></li>
<li>m-n位的数字: <code>^\d&#123;m,n&#125;$</code></li>
<li>零和非零开头的数字: <code>^(0|[1-9][0-9]*)$</code></li>
<li>非零开头的最多带两位小数的数字: <code>^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$</code></li>
<li>带1-2位小数的正数或负数: <code>^(\-)?\d+(\.\d&#123;1,2&#125;)?$</code></li>
<li>正数、负数、和小数: <code>^(\-|\+)?\d+(\.\d+)?$</code></li>
<li>有两位小数的正实数: <code>^[0-9]+(.[0-9]&#123;2&#125;)?$</code></li>
<li>有1~3位小数的正实数: <code>^[0-9]+(.[0-9]&#123;1,3&#125;)?$</code></li>
<li>非零的正整数: <code>^[1-9]\d*$</code><br>  或 <code>^([1-9][0-9]*)&#123;1,3&#125;$</code><br>  或 <code>^\+?[1-9][0-9]*$</code></li>
<li>非零的负整数: <code>^\-[1-9][]0-9&quot;*$</code><br>  或 <code>^-[1-9]\d*$</code></li>
<li>非负整数: <code>^\d+$</code><br>  或 <code>^[1-9]\d*|0$</code></li>
<li>非正整数: <code>^-[1-9]\d*|0$</code><br>  或 <code>^((-\d+)|(0+))$</code></li>
<li>非负浮点数: <code>^\d+(\.\d+)?$</code><br>  或 <code>^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</code></li>
<li>非正浮点数: <code>^((-\d+(\.\d+)?)|(0+(\.0+)?))$</code><br>  或 <code>^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</code></li>
<li>正浮点数: <code>^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$</code><br>  或 <code>^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</code></li>
<li>负浮点数: <code>^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$</code><br>  或 <code>^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</code></li>
<li>浮点数: <code>^(-?\d+)(\.\d+)?$</code><br>  或 <code>^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</code></li>
</ul>
<h1 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h1><ul>
<li>汉字: <code>^[\u4e00-\u9fa5]&#123;0,&#125;$</code></li>
<li>英文和数字: <code>^[A-Za-z0-9]+$</code><br>  或 <code>^[A-Za-z0-9]&#123;4,40&#125;$</code></li>
<li>长度为3-20的所有字符: <code>^.&#123;3,20&#125;$</code></li>
<li>由26个英文字母组成的字符串: <code>^[A-Za-z]+$</code></li>
<li>由26个大写英文字母组成的字符串: <code>^[A-Z]+$</code></li>
<li>由26个小写英文字母组成的字符串: <code>^[a-z]+$</code></li>
<li>由数字和26个英文字母组成的字符串: <code>^[A-Za-z0-9]+$</code></li>
<li>由数字、26个英文字母或者下划线组成的字符串: <code>^\w+$</code><br>  或 <code>^\w&#123;3,20&#125;$</code></li>
<li>中文、英文、数字包括下划线: <code>^[\u4E00-\u9FA5A-Za-z0-9_]+$</code></li>
<li>中文、英文、数字但不包括下划线等符号: <code>^[\u4E00-\u9FA5A-Za-z0-9]+$</code><br>  或 <code>^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$</code></li>
<li>可以输入含有 <code>^%&amp;&#39;,;=?$\&quot;</code> 等字符: <code>[^%&amp;&#39;,;=?$\x22]+</code></li>
<li>禁止输入含有 <code>^~&quot;</code> 的字符: <code>[^~\x22]+</code></li>
</ul>
<h1 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h1><ul>
<li>Email地址: <code>^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</code></li>
<li>域名: <code>[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?</code></li>
<li>InternetURL: <code>[a-zA-z]+://[^\s]*</code> 或 <code>^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</code></li>
<li>手机号码: <code>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$</code></li>
<li>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX):<br>  <code>^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$</code></li>
<li>国内电话号码(0511-4405222、021-87888822):<br>  <code>\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</code></li>
<li>身份证号(15位、18位数字): <code>^\d&#123;15&#125;|\d&#123;18&#125;$</code></li>
<li>短身份证号码(数字、字母x结尾): <code>^([0-9])&#123;7,18&#125;(x|X)?$</code><br>  或 <code>^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$</code></li>
<li>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线):<br>  <code>^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</code></li>
<li>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线):<br>  <code>^[a-zA-Z]\w&#123;5,17&#125;$</code></li>
<li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间):<br>  <code>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$</code></li>
<li>日期格式: <code>^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</code></li>
<li>一年的12个月(01～09和1～12): <code>^(0?[1-9]|1[0-2])$</code></li>
<li>一个月的31天(01～09和1～31): <code>^((0?[1-9])|((1|2)[0-9])|30|31)$</code></li>
<li>钱的输入格式:<ul>
<li>有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”:<br>  <code>^[1-9][0-9]*$</code></li>
<li>这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式:<br>  <code>^(0|[1-9][0-9]*)$</code></li>
<li>一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号:<br>  <code>^(0|-?[1-9][0-9]*)$</code></li>
<li>这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分:<br>  <code>^[0-9]+(.[0-9]+)?$</code></li>
<li>必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的:<br>  <code>^[0-9]+(.[0-9]&#123;2&#125;)?$</code></li>
<li>这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样:<br>  <code>^[0-9]+(.[0-9]&#123;1,2&#125;)?$</code></li>
<li>这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样:<br>  <code>^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$</code></li>
<li>1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须:<br>  <code>^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$</code></li>
<li>备注: 这就是最终结果了,别忘了<code>+</code>可以用<code>*</code>替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</li>
</ul>
</li>
<li>xml文件: <code>^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</code></li>
<li>中文字符的正则表达式: <code>[\u4e00-\u9fa5]</code></li>
<li>双字节字符: <code>[^\x00-\xff]</code><br>  (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</li>
<li>空白行的正则表达式: <code>\n\s*\r</code> (可以用来删除空白行)</li>
<li>HTML标记的正则表达式: <code>&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt;</code><br>  (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</li>
<li>首尾空白字符的正则表达式: <code>^\s*|\s*$或(^\s*)|(\s*$)</code><br>  (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</li>
<li>腾讯QQ号: <code>[1-9][0-9]&#123;4,&#125;</code> (腾讯QQ号从10000开始)</li>
<li>中国邮政编码: <code>[1-9]\d&#123;5&#125;(?!\d)</code> (中国邮政编码为6位数字)</li>
<li>IP地址: <code>\d+\.\d+\.\d+\.\d+</code> (提取IP地址时有用)</li>
<li>IP地址: <code>((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</code></li>
</ul>
<hr>
<p><em><strong>转载自 <a href="http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html">最全的常用正则表达式大全——包括校验数字、字符、一些特殊的需求等等</a></strong></em></p>
]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>regular</tag>
      </tags>
  </entry>
  <entry>
    <title>人人都看得懂的正则表达式教程</title>
    <url>/2017/09/19/1726-soft-easyre/</url>
    <content><![CDATA[<p><em><strong>转载自 <a href="https://mp.weixin.qq.com/s?__biz=MzI4MDEwNzAzNg==&mid=2649444384&idx=1&sn=b1650af947842bbafb229eaabef4447e&key=93e82051231712653225010bec76aa3cdd1bb9dfb4cb4676f695a6cba336d79a73a39a9ae825aae8c16f26c0d1e0c67f7d96c8e03161da2c68ed58cc68e7c5818fdc72647bae92df46a1b85a43e276cd&ascene=1&uin=MTUzODYxOTg2MQ==&devicetype=Windows-QQBrowser&version=61030006&pass_ticket=X0yVRsvNQron8bDKwr7uv0tD/afEwhP8NalG1zmH0siQV8OIDKoyAcobBC8fze13">人人都看得懂的正则表达式教程</a></strong></em></p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li><a href="https://draapho.github.io/2016/12/18/1628-soft-regular/">正则表达式</a></li>
<li><a href="https://draapho.github.io/2017/09/19/1726-soft-easyre/">人人都看得懂的正则表达式教程</a></li>
<li><a href="https://draapho.github.io/2017/10/07/1727-soft-reexample/">最全的常用正则表达式大全</a></li>
</ul>
<p>本文有助于快速上手正则表达式, 但语法非常不全, 因此写出的表达式不够简练.</p>
<p>编写验证规则最流行和最简单的方法就是正则表达式了，但唯一的一个问题是正则表达式的语法太隐晦了，让人蛋疼无比。<br>很多开发者为了在项目中应用复杂的验证，经常要使用一些小抄来记住正则式的复杂语法和各种常用命令。<br>在这篇文章中，我将试图让大家明白什么是正则表达式，以及如何更轻松地学习正则表达式。</p>
<h1 id="3个重要的正则式命令"><a href="#3个重要的正则式命令" class="headerlink" title="3个重要的正则式命令"></a>3个重要的正则式命令</h1><p>记住正则语法最好的办法就是记住这三样东西：BCD</p>
<ul>
<li><strong>B</strong>racket, 括号<ul>
<li>方括号 <code>[需要匹配的字符]</code></li>
<li>花括号 <code>&#123;指定匹配字符的数量&#125;</code></li>
<li>圆括号 <code>(字符分组)</code></li>
</ul>
</li>
<li><strong>C</strong>aret, 插入符号<ul>
<li><code>^</code> 表示字符串开始</li>
</ul>
</li>
<li><strong>D</strong>ollars, 美元符号<ul>
<li><code>$</code> 表示字符串结束</li>
</ul>
</li>
</ul>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><ul>
<li><code>[a-g]&#123;3&#125;</code><br>  输入的字符在a-g之间并且长度为3</li>
<li><code>[a-g]&#123;1,3&#125;</code><br>  输入的字符在a-g之间并且最大长度为3最小长度为1</li>
<li><code>^[0-9]&#123;8&#125;$</code><br>  匹配像91230456, 01237648那样的固定8位数</li>
<li><code>^[0-9]&#123;3,7&#125;$</code><br>  验证最小长度为3最大长度为7的数字，如：123, 1274667, 87654</li>
<li><code>^[a-z]&#123;3&#125;[0-9]&#123;7&#125;$</code><br>  验证像LJI1020那样的发票编号，前3个是字母剩余为8位长度的数字</li>
<li><code>^www[.][a-z]&#123;1,15&#125;[.](com|org)$</code><br>  验证简单的网址URL格式, 域名是长度在1-15的英文字母</li>
<li><code>^[a-zA-Z0-9]&#123;1,10&#125;@[a-zA-Z]&#123;1,10&#125;.(com|org)$</code><br>  验证email格式</li>
<li><code>^(([0-9])|([0-1][0-9])|([0-2][0-5]))$</code><br>  验证值在0-25的数字</li>
<li><code>^([1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])[- / .]([1-9]|0[1-9]|1[0-2])[- / .](1[9][0-9][0-9]|2[0][0-9][0-9])$</code><br>  验证DD/MM/YYYY格式的日期<pre><code>  - `([1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])` DD允许数值为`1-9,01-09,10-19,20-29,30-31`
  - `[- / .]` 允许的日期分隔符
  - `([1-9]|0[1-9]|1[0-2])` MM月份的数值 `1-9,01-09,10-12`
  - `(1[9][0-9][0-9]|2[0][0-9][0-9])` YY年份的数值 `1900-2099`
</code></pre>
</li>
</ul>
<h1 id="快捷命令"><a href="#快捷命令" class="headerlink" title="快捷命令"></a>快捷命令</h1><table>
<thead>
<tr>
<th>实际命令</th>
<th>快捷命令</th>
</tr>
</thead>
<tbody><tr>
<td><code>[0-9]</code></td>
<td><code>d</code></td>
</tr>
<tr>
<td><code>[a-z][0-9][_]</code></td>
<td><code>w</code></td>
</tr>
<tr>
<td>0次或多次发生</td>
<td><code>*</code></td>
</tr>
<tr>
<td>1次或多次发生</td>
<td><code>+</code></td>
</tr>
<tr>
<td>0次或1次发生</td>
<td><code>?</code></td>
</tr>
</tbody></table>
<hr>
<p><em><strong>转载自 <a href="https://mp.weixin.qq.com/s?__biz=MzI4MDEwNzAzNg==&mid=2649444384&idx=1&sn=b1650af947842bbafb229eaabef4447e&key=93e82051231712653225010bec76aa3cdd1bb9dfb4cb4676f695a6cba336d79a73a39a9ae825aae8c16f26c0d1e0c67f7d96c8e03161da2c68ed58cc68e7c5818fdc72647bae92df46a1b85a43e276cd&ascene=1&uin=MTUzODYxOTg2MQ==&devicetype=Windows-QQBrowser&version=61030006&pass_ticket=X0yVRsvNQron8bDKwr7uv0tD/afEwhP8NalG1zmH0siQV8OIDKoyAcobBC8fze13">人人都看得懂的正则表达式教程</a></strong></em></p>
]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>regular</tag>
      </tags>
  </entry>
  <entry>
    <title>人类简史简图</title>
    <url>/2017/10/16/1729-history-of-humankind/</url>
    <content><![CDATA[<p><em><strong>转载自 <a href="https://www.zhihu.com/question/27767448">怎样评价尤瓦尔·赫拉力的《人类简史》? 的部分回答</a></strong></em></p>
<hr>
<p><img src="https://draapho.github.io/images/1729/Humankind1.png" alt="人类简史简图"></p>
<p><img src="https://draapho.github.io/images/1729/Humankind2.jpg" alt="人类简史简图"></p>
<hr>
<p><em><strong>转载自 <a href="https://www.zhihu.com/question/27767448">怎样评价尤瓦尔·赫拉力的《人类简史》? 的部分回答</a></strong></em></p>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>fs之BusyBox的使用与编译</title>
    <url>/2017/11/02/1730-fs-busybox/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/11/02/1730-fs-busybox/">fs之Busybox的编译与使用</a></li>
<li><a href="https://draapho.github.io/2017/11/03/1731-fs-build/">fs之创建文件系统</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="什么是BusyBox"><a href="#什么是BusyBox" class="headerlink" title="什么是BusyBox"></a>什么是BusyBox</h1><p>BusyBox 是linux下的一个应用程序, 集成了最常用的Linux命令和工具.<br>在jz2440开发板里, <strong>BusyBox是内核成功启动后, 调用的第一个应用程序.</strong><br>启动jz2440开发板, 在终端内输入如下指令, 可以发现系统指令都是BusyBox的软链接.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板终端</span></span><br><span class="line">$ ls -l /bin/ls</span><br><span class="line">lrwxrwxrwx    1 1000     1000            7 Jan 22  2008 /bin/ls -&gt; busybox</span><br><span class="line">$ ls -l /bin/cp</span><br><span class="line">lrwxrwxrwx    1 1000     1000            7 Jan 22  2008 /bin/cp -&gt; busybox</span><br><span class="line"></span><br><span class="line">$ ls -l /linuxrc</span><br><span class="line">lrwxrwxrwx    1 1000     1000           11 Jan 22  2008 /linuxrc -&gt; bin/busybox</span><br><span class="line">$ ls -l /sbin/init</span><br><span class="line">lrwxrwxrwx    1 1000     1000            7 Jan 22  2008 /sbin/init -&gt; ../bin/busybox</span><br><span class="line">$ ls -l /bin/sh</span><br><span class="line">lrwxrwxrwx    1 1000     1000            7 Jan 22  2008 /bin/sh -&gt; busybox</span><br></pre></td></tr></table></figure>

<h1 id="BusyBox的使用"><a href="#BusyBox的使用" class="headerlink" title="BusyBox的使用"></a>BusyBox的使用</h1><p>内核启动后, 调用的第一个应用程序就是BusyBox. 而BusyBox的职责如下:</p>
<ul>
<li>读取配置文件, <code>/etc/inittab</code></li>
<li>解析配置文件, <code>&lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</code><ul>
<li>指定程序, <code>&lt;process&gt;</code></li>
<li>何时执行, <code>&lt;action&gt;</code></li>
</ul>
</li>
<li>执行程序</li>
</ul>
<h2 id="启动BusyBox"><a href="#启动BusyBox" class="headerlink" title="启动BusyBox"></a>启动BusyBox</h2><p>由 <a href="https://draapho.github.io/2017/09/15/1725-kernel-launch/">kernel之内核启动分析</a> 可知,<br><code>start_kernel</code> 函数最后会尝试调用: <code>run_init_process(execute_command);</code>, 由uboot的传入execute_command.<br>查看uboot的bootargs环境变量, <code>init=/linuxrc</code>, 所以会执行 <code>run_init_process(&quot;/linuxrc&quot;)</code><br>由于 <code>/linuxrc</code> 是 <code>/bin/busybox</code> 的软连接, 所以最终调用了busybox.</p>
<p>如果调用失败, 会依次尝试如下指令, 但这些指令都是busybox的软连接, 等同于调用了busybox指令</p>
<ul>
<li><code>run_init_process(&quot;/sbin/init&quot;);</code>, busybox的软连接</li>
<li><code>run_init_process(&quot;/etc/init&quot;);</code>, 指令不存在</li>
<li><code>run_init_process(&quot;/bin/init&quot;);</code>, 指令不存在</li>
<li><code>run_init_process(&quot;/bin/sh&quot;);</code>, busybox的软连接</li>
</ul>
<p>BusyBox 源码大致的函数调用关系:</p>
<ul>
<li><code>init_main</code>, busybox的入口<ul>
<li><code>parse_inittab</code>, 准备分析配置文件<ul>
<li><code>file=fopen(INITTAB, &quot;r&quot;)</code>, 打开配置文件 <code>/etc/inittab</code></li>
<li><code>new_init_action</code>, 创建并链表化 init_action 结构.</li>
</ul>
</li>
<li><code>run_actions(SYSINIT)</code>, 初始化工作, 最早被执行<ul>
<li><code>waitfor(a,0)</code>, 等待执行完成</li>
<li><code>delete_init_action(a)</code>, 从 init_action_list 链表中删除, 不会再被执行了</li>
</ul>
</li>
<li><code>run_actions(WAIT)</code>, 等待执行完成<ul>
<li>同 <code>run_actions(SYSINIT)</code></li>
</ul>
</li>
<li><code>run_actions(ONCE)</code>, 执行一次且不会等待执行完成.<ul>
<li><code>run(a)</code>, 执行指令, 不会等待执行完成</li>
<li><code>delete_init_action(a)</code>, 从链表中删除</li>
</ul>
</li>
<li><code>run_actions(RESPAWN)</code>, 如果子进程终止, 那么会重新孵化(调用执行).</li>
<li><code>run_actions(ASKFIRST)</code>, 相比于RESPAWN, 要求用户按键确认.</li>
</ul>
</li>
</ul>
<h2 id="BusyBox使用说明"><a href="#BusyBox使用说明" class="headerlink" title="BusyBox使用说明"></a>BusyBox使用说明</h2><p>查看busybox源码, <code>busybox-1.7.0/examples/inittab</code> 文件内有较为详细的说明.<br>关键内容如下:</p>
<ul>
<li>配置文件格式: <code>&lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</code></li>
<li><code>&lt;id&gt;</code>, 指定tty终端. 非强制, 会在前面加上 <code>/dev/</code> 变成 <code>/dev/&lt;id&gt;</code><ul>
<li>譬如 <code>tty2</code>, 实际运行的终端是 <code>/dev/tty2</code></li>
<li>如果没有值的话, 对应的文件会是 <code>/dev/null</code></li>
</ul>
</li>
<li><code>&lt;runlevels&gt;</code>, 忽略</li>
<li><code>&lt;action&gt;</code>, 包括:<ul>
<li><code>sysinit</code>, 用作系统初始化, 执行指令并等待完成</li>
<li><code>respawn</code>, 执行指令, 如果子线程终止, 会被重新孵化/执行</li>
<li><code>askfirst</code>, 功能同 <code>respawn</code>, 只是需要用户按键确认</li>
<li><code>wait</code>, 执行指令并等待完成</li>
<li><code>once</code>, 执行指令不等待.</li>
<li><code>restart</code>, <code>ctrlaltdel</code>, <code>shutdown</code>, 由linux内核信号量传递而来. 执行指令并等待.</li>
</ul>
</li>
<li><code>&lt;process&gt;</code>, 要执行的应用程序或者脚本</li>
<li>如果BusyBox没有找到 <code>/etc/inittab</code> 文件, 则会自动加载如下应用程序:<ul>
<li><code>::sysinit:/etc/init.d/rcS</code>, 系统初始化时, 调用rcS脚本</li>
<li><code>::askfirst:/bin/sh</code>, 询问后, 运行终端</li>
<li><code>::ctrlaltdel:/sbin/reboot</code>, 按键重启</li>
<li><code>::shutdown:/sbin/swapoff -a</code>, 关机时要做的事</li>
<li><code>::shutdown:/bin/umount -a -r</code>, 关机时要做的事</li>
<li><code>::restart:/sbin/init</code>, 重启后要做的事</li>
</ul>
</li>
<li>jz2440的 <code>/etc/inittab</code> 内容如下<ul>
<li><code>::sysinit:/etc/init.d/rcS</code>, 初始化配置</li>
<li><code>s3c2410_serial0::askfirst:-/bin/sh</code>, 指定串口运行终端</li>
<li><code>::ctrlaltdel:/sbin/reboot</code>, 特定按键重启</li>
<li><code>::shutdown:/bin/umount -a -r</code>, 关机时要做的事</li>
</ul>
</li>
</ul>
<h1 id="BusyBox的编译"><a href="#BusyBox的编译" class="headerlink" title="BusyBox的编译"></a>BusyBox的编译</h1><p>BusyBox的编译和安装可以查看源码内提供的 <code>INSRALL</code> 文件. 编译方法和过程和内核是类似的.<br>在linux主机ubuntu下进行交叉编译:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xjf busybox-1.7.0.tar.bz2      <span class="comment"># 解压</span></span><br><span class="line"><span class="built_in">cd</span> busybox-1.7.0/                   <span class="comment"># 进入目录, pwd=./busybox-1.7.0</span></span><br><span class="line">make menuconfig                     <span class="comment"># 会弹出UI配置界面</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果报错: *** mixed implicit and normal rules: deprecated syntax</span></span><br><span class="line"><span class="comment"># 修改makefile相关的行:</span></span><br><span class="line"><span class="comment"># config %config: 修改为 %config:</span></span><br><span class="line"><span class="comment"># / %/: 修改为 %/</span></span><br></pre></td></tr></table></figure>

<p>BusyBox的配置项也非常多, 在此就不深入研究了.<br>需要注意的是, 因为这里是交叉编译. 所以编译前, 需要修改BusyBox的编译工具链.<br>因为没有在Menuconfig界面里找到, 所以通过Makefile文件直接修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pwd=./busybox-1.7.0</span></span><br><span class="line">vim Makefile</span><br><span class="line"></span><br><span class="line"><span class="comment"># vim 界面</span></span><br><span class="line"><span class="comment"># 使用 :/COMPILE 找到 CROSS_COMPILE 配置项, 修改为</span></span><br><span class="line">CROSS_COMPILE   ?= arm-linux-</span><br><span class="line"><span class="comment"># 使用 :wq 保存退出</span></span><br><span class="line"></span><br><span class="line">make                <span class="comment"># 编译</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装, 不能使用 make install, 否则Linux主机Ubuntu的命令就会被破坏掉!</span></span><br><span class="line">mkdir ~/jz2440/fs_first                         <span class="comment"># 创建一个filesystem, 实验用</span></span><br><span class="line">make CONFIG_PREFIX=~/jz2440/fs_first install    <span class="comment"># 安装到指定目录</span></span><br><span class="line"><span class="comment"># 再次强调, 这里是交叉编译, 不能直接用 make install. 否则linux主机的系统就被破坏了.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 fs_first 目录</span></span><br><span class="line"><span class="comment"># 可以看到全部都是常用的linux指令, 存放在 /bin /sbin /usr/bin /usr/sbin 目录下面.</span></span><br><span class="line"><span class="built_in">cd</span> ~/jz2440/fs_first/</span><br><span class="line">total 20</span><br><span class="line">drwxrwxr-x 5 name group 4096 Nov  2 15:46 ./</span><br><span class="line">drwxrwxrwx 7 name group 4096 Nov  2 15:44 ../</span><br><span class="line">drwxrwxr-x 2 name group 4096 Nov  2 15:46 bin/</span><br><span class="line">lrwxrwxrwx 1 name group   11 Nov  2 15:46 linuxrc -&gt; bin/busybox*</span><br><span class="line">drwxrwxr-x 2 name group 4096 Nov  2 15:46 sbin/</span><br><span class="line">drwxrwxr-x 4 name group 4096 Nov  2 15:46 usr/</span><br></pre></td></tr></table></figure>

<p>这样, BusyBox编译就完成了.<br>然后, 就可以考虑构建linux的文件系统了</p>
<p>要构建一个最小的linux根文件系统, 至少需要如下文件:</p>
<ul>
<li><code>dev/console</code>, linux内核的标准IO接口</li>
<li><code>dev/null</code>, 相当于一个NULL文件</li>
<li>init进程, 即 <code>bin/busybox</code></li>
<li><code>etc/inittab</code> 配置文件, (可以省略, busybox会调用其默认值)</li>
<li>配置文件里指定的应用程序或脚本, 如 <code>/etc/init.d/rcS</code> <code>bin/sh</code></li>
<li>C语言库 <code>lib/</code></li>
</ul>
<h1 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h1><ul>
<li><a href="http://blog.csdn.net/kyokowl/article/details/6921640">busybox 详解</a></li>
<li>嵌入式Linux应用开发完全手册, 第17章BusyBox相关部分</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>fs</tag>
      </tags>
  </entry>
  <entry>
    <title>fs之创建文件系统</title>
    <url>/2017/11/03/1731-fs-build/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/11/02/1730-fs-busybox/">fs之Busybox的编译与使用</a></li>
<li><a href="https://draapho.github.io/2017/11/03/1731-fs-build/">fs之创建文件系统</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="要构建一个最小的linux根文件系统"><a href="#要构建一个最小的linux根文件系统" class="headerlink" title="要构建一个最小的linux根文件系统"></a>要构建一个最小的linux根文件系统</h1><ul>
<li><code>dev/console</code>, linux内核的标准IO接口</li>
<li><code>dev/null</code>, 相当于一个NULL文件</li>
<li>init进程, 即 <code>bin/busybox</code></li>
<li><code>etc/inittab</code> 配置文件, (可以省略, busybox会调用其默认值)</li>
<li>配置文件里指定的应用程序或脚本, 如 <code>/etc/init.d/rcS</code> <code>bin/sh</code></li>
<li>C语言库 <code>lib/</code></li>
</ul>
<p>在 <a href="https://draapho.github.io/2017/11/02/1730-fs-busybox/">fs之Busybox的编译与使用</a> 一文中,<br>已经将busybox安装到指定目录 <code>~/jz2440/fs_first/</code>,<br>接下来, 基于此目录, 继续完善嵌入式linux的最小文件系统</p>
<h2 id="创建-dev-console-dev-null-文件"><a href="#创建-dev-console-dev-null-文件" class="headerlink" title="创建 dev/console dev/null 文件"></a>创建 <code>dev/console</code> <code>dev/null</code> 文件</h2><p><code>dev/console</code> 用于标准输入输出<br><code>dev/null</code> 空设备, 用于丢弃不需要的输出流, 或提供空输入.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pwd = ~/jz2440/fs_first/</span></span><br><span class="line"></span><br><span class="line">$ ll /dev/console /dev/null</span><br><span class="line"><span class="comment"># 查看现有系统的这两个文件的详情</span></span><br><span class="line">crw------- 1 root root 5, 1 Sep  5 00:01 /dev/console</span><br><span class="line"><span class="comment"># c表示字符设备, 5为主设备号, 1为次设备号</span></span><br><span class="line">crw-rw-rw- 1 root root 1, 3 Sep  5 00:01 /dev/null</span><br><span class="line"><span class="comment"># c表示字符设备, 1为主设备号, 3为次设备号</span></span><br><span class="line"></span><br><span class="line">$ mkdir dev</span><br><span class="line">$ <span class="built_in">cd</span> dev        <span class="comment"># 进入 ~/jz2440/fs_first/dev/ 目录</span></span><br><span class="line"></span><br><span class="line">$ sudo mknod console c 5 1</span><br><span class="line">$ sudo mknod null c 1 3</span><br><span class="line"><span class="comment"># 仿照现有的文件系统内容, 创建 console 和 null 两个节点文件</span></span><br><span class="line"></span><br><span class="line">$ ll            <span class="comment"># pwd=~/jz2440/fs_first/dev/</span></span><br><span class="line">drwxrwxr-x 2 draapho draapho 4096 Nov  3 11:01 ./</span><br><span class="line">drwxrwxr-x 6 draapho draapho 4096 Nov  3 11:00 ../</span><br><span class="line">crw-r--r-- 1 root    root    5, 1 Nov  3 11:00 console</span><br><span class="line">crw-r--r-- 1 root    root    1, 3 Nov  3 11:01 null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 至此, 创建 /dev/console 以及 /dev/null 完成.</span></span><br></pre></td></tr></table></figure>

<h2 id="创建-etc-inittab-文件"><a href="#创建-etc-inittab-文件" class="headerlink" title="创建 etc/inittab 文件"></a>创建 <code>etc/inittab</code> 文件</h2><p><code>etc/inittab</code> 供busybox初始化时调用的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pwd = ~/jz2440/fs_first/</span></span><br><span class="line"></span><br><span class="line">$ mkdir etc</span><br><span class="line">$ vim etc/inittab</span><br><span class="line"><span class="comment"># 输入 &quot;console::askfirst:-/bin/sh&quot;, 保存退出</span></span><br><span class="line">$ cat etc/inittab</span><br><span class="line">console::askfirst:-/bin/sh</span><br><span class="line"><span class="comment"># &quot;-/bin/sh&quot; 前面的-, 提示让busybox开启一个账户登陆终端.</span></span><br><span class="line"><span class="comment"># 由源码函数 ash_main() 代码可知当检测到 - 时, 赋值isloginsh = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 至此, 创建 etc/inittab 完成.</span></span><br></pre></td></tr></table></figure>

<h2 id="安装C库"><a href="#安装C库" class="headerlink" title="安装C库"></a>安装C库</h2><p>务必使用 <code>gcc-3.4.5-glibc-2.3.6</code> 这个版本的C库<br>在 <a href="https://draapho.github.io/2017/02/20/1706-linux-ubuntu16/">嵌入式linux环境搭建3-Ubuntu16.04</a> 中,<br>已经将这个库安装到了 <code>/usr/local/</code> 目录下.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/gcc-3.4.5-glibc-2.3.6/arm-linux/lib</span><br><span class="line">$ ll</span><br><span class="line"><span class="comment"># 查看解压后的库文件, 针对 arm-linux的库</span></span><br><span class="line">...</span><br><span class="line">-rwxr-xr-x  1 draapho draapho  112886 Jan 22  2008 ld-2.3.6.so*</span><br><span class="line">lrwxrwxrwx  1 draapho draapho      11 Jan 22  2008 ld-linux.so.2 -&gt; ld-2.3.6.so*</span><br><span class="line">drwxr-xr-x  2 draapho draapho    4096 Jan 22  2008 ldscripts/</span><br><span class="line">-rwxr-xr-x  1 draapho draapho   17586 Jan 22  2008 libanl-2.3.6.so*</span><br><span class="line">-rw-r--r--  1 draapho draapho   13094 Jan 22  2008 libanl.a</span><br><span class="line">lrwxrwxrwx  1 draapho draapho      11 Jan 22  2008 libanl.so -&gt; libanl.so.1*</span><br><span class="line">lrwxrwxrwx  1 draapho draapho      15 Jan 22  2008 libanl.so.1 -&gt; libanl-2.3.6.so*</span><br><span class="line">...</span><br><span class="line"><span class="comment"># &quot;.a&quot; 表示静态库, &quot;.so&quot;表示动态库, 还有很多动态库的软连接.</span></span><br><span class="line"><span class="comment"># 我们只需要拷贝动态库和动态库的软连接即可.</span></span><br><span class="line"></span><br><span class="line">$ mkdir ~/jz2440/fs_first/lib</span><br><span class="line">$ cp *.so* ~/jz2440/fs_first/lib/ -d</span><br><span class="line"><span class="comment"># 拷贝动态库到最小文件系统下面. &quot;-d&quot; 表示只需要拷贝连接. cp指令默认会拷贝连接到的内容.</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> ~/jz2440/fs_first/</span><br><span class="line">$ ll lib</span><br><span class="line"><span class="comment"># 查看一下拷贝结果.</span></span><br><span class="line"><span class="comment"># 至此, 创建 lib/ C库完成.</span></span><br></pre></td></tr></table></figure>

<h1 id="制作并烧录yaffs2映像文件"><a href="#制作并烧录yaffs2映像文件" class="headerlink" title="制作并烧录yaffs2映像文件"></a>制作并烧录yaffs2映像文件</h1><p>直接说结论, 一般文件系统都会放到 nand flash 里,<br>所以会使用 mkyaffs2image 工具将目录文件生成为 yaffs2 格式文件系统,<br>最后烧录进 nand flash 的 root 分区即可.</p>
<p>linux下的大多数工具都需要下载源码再自己编译, 譬如这里的 mkyaffs2image.<br>对于这类软件的安装, 我一般归到环境搭建里面去.<br>可以参考 <a href="https://draapho.github.io/2017/02/20/1706-linux-ubuntu16/">嵌嵌入式linux环境搭建3-Ubuntu16.04</a></p>
<h2 id="flash和文件系统比较"><a href="#flash和文件系统比较" class="headerlink" title="flash和文件系统比较"></a>flash和文件系统比较</h2><ul>
<li>jffs2: Journalling Flash FileSystem V2<ul>
<li>主要用于<strong>NOR FLASH</strong>, 基于MTD驱动层.</li>
<li>缺点是当文件系统已满或接近满时，因为垃圾收集的关系而使jffs2的运行速度大大放慢</li>
<li>jffs不适合用于NAND闪存</li>
</ul>
</li>
<li>yaffs： Yet Another Flash File System<ul>
<li>针对<strong>NAND FLASH</strong>而设计的一种日志型文件系统. 直接提供了API对FLASH进行操作.</li>
<li>与jffs2相比, 减少了数据压缩等功能, 所以速度更快, 挂载时间更短, 内存占用较小.</li>
<li>yaffs 仅支持小页(512 Bytes), yaffs2 可支持大页(2KB)的NAND闪存. yaffs2也优化了性能.</li>
<li>大多数情况, 嵌入式系统推荐使用 yaffs2</li>
</ul>
</li>
<li>Cramfs: Compressed ROM File System<ul>
<li>一种<strong>只读</strong>的压缩文件系统。它也基于MTD驱动程序.</li>
<li>按页单独压缩, 可以随机页访问. 高压缩比, 可节省Flash空间.</li>
<li>速度快，效率高，其只读的特点有利于保护文件系统免受破坏，提高了系统的可靠性.</li>
</ul>
</li>
<li>NOR FLASH vs NAND FLASH</li>
</ul>
<table>
<thead>
<tr>
<th>NOR FLASH</th>
<th>NAND FLASH</th>
</tr>
</thead>
<tbody><tr>
<td>接口时序同SRAM,易使用</td>
<td>地址/数据线复用，数据位较窄</td>
</tr>
<tr>
<td>读取速度较快</td>
<td>读取速度较慢</td>
</tr>
<tr>
<td>擦除速度慢，以64-128KB的块为单位</td>
<td>擦除速度快，以8－32KB的块为单位</td>
</tr>
<tr>
<td>写入速度慢</td>
<td>写入速度快</td>
</tr>
<tr>
<td>随机存取速度较快，支持XIP(eXecute In Place，芯片内执行)，适用于代码存储。在嵌入式系统中，常用于存放引导程序、根文件系统等。</td>
<td>顺序读取速度较快，随机存取速度慢，适用于数据存储(如大容量的多媒体应用)。在嵌入式系统中，常用于存放用户文件系统等。</td>
</tr>
<tr>
<td>单片容量较小，1-32MB</td>
<td>单片容量较大，8-128MB，提高了单元密度</td>
</tr>
<tr>
<td>最大擦写次数10万次</td>
<td>最大擦写次数100万次</td>
</tr>
</tbody></table>
<h2 id="制作yaffs2映像文件"><a href="#制作yaffs2映像文件" class="headerlink" title="制作yaffs2映像文件"></a>制作yaffs2映像文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/jz2440/</span><br><span class="line">$ mkyaffs2image fs_first fs_first.yaffs2</span><br><span class="line"><span class="comment"># 进入文件系统所在的上级目录, 然后制作镜像</span></span><br><span class="line"></span><br><span class="line">$ ll</span><br><span class="line">-rw------- 1 draapho draapho 8750016 Nov  3 12:23 fs_first.yaffs2</span><br><span class="line"><span class="comment"># 查看制作结果</span></span><br></pre></td></tr></table></figure>

<h2 id="烧录yaffs2映像文件"><a href="#烧录yaffs2映像文件" class="headerlink" title="烧录yaffs2映像文件"></a>烧录yaffs2映像文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"><span class="comment"># 打开 jz2440 开发板串口终端, 启动时输入空格键, 进入如下菜单</span></span><br><span class="line"><span class="comment">##### 100ask Bootloader for OpenJTAG #####</span></span><br><span class="line">...</span><br><span class="line">[y] Download root_yaffs image</span><br><span class="line">...</span><br><span class="line">Enter your selection: y                     <span class="comment"># 输入k, 烧录 root_yaffs</span></span><br><span class="line">USB host is connected. Waiting a download.  <span class="comment"># 提示连接成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 Ubuntu 终端, 输入</span></span><br><span class="line"><span class="built_in">cd</span> ~/jz2440/</span><br><span class="line">sudo dnw fs_first.yaffs2                    <span class="comment"># 输入dnw指令, 指明烧录文件</span></span><br><span class="line"><span class="comment"># DNW usb device found!                     # 开始烧录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板重启后, 就能启动终端输入指令操作了.</span></span><br></pre></td></tr></table></figure>

<h1 id="进一步完善linux根文件系统"><a href="#进一步完善linux根文件系统" class="headerlink" title="进一步完善linux根文件系统"></a>进一步完善linux根文件系统</h1><p>上面只是完成了linux文件系统的基础功能.<br>要实现更高级的功能, 我们需要更为复杂全面的文件系统.</p>
<h2 id="创建-proc-文件"><a href="#创建-proc-文件" class="headerlink" title="创建 proc 文件"></a>创建 <code>proc</code> 文件</h2><p>proc目录即process的简写, 可以让ps指令查看linux的进程.<br>知道 <code>/proc</code> 的基本作用和使用方法以后, 我们需要把这些功能整合到文件系统里面.<br>为了循序渐进的说明, 下面展示了三种方法, 常用的就是第三种.</p>
<h3 id="开发板人工实现"><a href="#开发板人工实现" class="headerlink" title="开发板人工实现"></a><del>开发板人工实现</del></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板终端</span></span><br><span class="line"></span><br><span class="line">$ ps</span><br><span class="line">PID  Uid        VSZ Stat Command</span><br><span class="line">ps: can<span class="string">&#x27;t open &#x27;</span>/proc<span class="string">&#x27;: No such file or directory</span></span><br><span class="line"><span class="string"># 譬如执行ps指令, 就会提示没有找到 /proc 目录</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 我们先手工实现一下</span></span><br><span class="line"><span class="string"># pwd=/</span></span><br><span class="line"><span class="string">$ mkdir proc</span></span><br><span class="line"><span class="string">$ mount -t proc none /proc</span></span><br><span class="line"><span class="string"># 创建 proc 目录, 并挂载到此目录. -t 为指定挂载类型为 proc.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ ps</span></span><br><span class="line"><span class="string">  PID  Uid        VSZ Stat Command</span></span><br><span class="line"><span class="string">    1 0          3088 S   init</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string"># 这样, ps指令就能看到进程了.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ cd /proc</span></span><br><span class="line"><span class="string">$ ls</span></span><br><span class="line"><span class="string">1              745            diskstats      locks          sys</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">$ cd 1          # 进入目录1</span></span><br><span class="line"><span class="string">$ ls -l fd      # 查看目录fd (file descriptor)</span></span><br><span class="line"><span class="string">lrwx------    1 0        0              64 Jan  1 00:10 0 -&gt; /dev/console</span></span><br><span class="line"><span class="string">lrwx------    1 0        0              64 Jan  1 00:10 1 -&gt; /dev/console</span></span><br><span class="line"><span class="string">lrwx------    1 0        0              64 Jan  1 00:10 2 -&gt; /dev/console</span></span><br><span class="line"><span class="string"># 可以看到init进程的三个文件描述符, 分别对应了 标准输入, 标准输出, 标准错误.</span></span><br></pre></td></tr></table></figure>


<h3 id="集成到文件系统-直接-mount"><a href="#集成到文件系统-直接-mount" class="headerlink" title="~~集成到文件系统, 直接 mount ~~"></a>~~集成到文件系统, 直接 mount ~~</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Linux主机, Ubuntu终端</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 proc 文件</span></span><br><span class="line">$ <span class="built_in">cd</span> ~/jz2440/fs_first/</span><br><span class="line">$ mkdir proc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加初始化脚本</span></span><br><span class="line">$ vim etc/inittab</span><br><span class="line"><span class="comment"># 新增一行 &quot;::sysinit:/etc/init.d/rcS&quot; 用作运行脚本</span></span><br><span class="line">$ cat etc/inittab</span><br><span class="line">console::askfirst:-/bin/sh</span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建脚本, 执行挂载指令</span></span><br><span class="line">$ mkdir etc/init.d</span><br><span class="line">$ vim etc/init.d/rcS</span><br><span class="line"><span class="comment"># 加入脚本语句 &quot;mount -t proc none /proc&quot; 挂载proc目录</span></span><br><span class="line">$ cat etc/init.d/rcS</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">$ chmod +x etc/init.d/rcS</span><br><span class="line"><span class="comment"># 加上可执行的权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样, 嵌入式linux完成启动后, 会运行init进程.</span></span><br><span class="line"><span class="comment"># - init进程运行 /etc/inittab 内的指令</span></span><br><span class="line"><span class="comment"># - 就会运行 /etc/init.d/rcS 脚本</span></span><br><span class="line"><span class="comment"># - 最终运行 mount -t proc none /proc 指令</span></span><br></pre></td></tr></table></figure>

<h3 id="集成到文件系统-使用-mount-a"><a href="#集成到文件系统-使用-mount-a" class="headerlink" title="集成到文件系统, 使用 mount -a"></a>集成到文件系统, 使用 <code>mount -a</code></h3><p>一般的, linux需要mount多个文件, 因此使用更为通用的 <code>mount -a</code> 指令,<br>然后去读取 <code>/etc/fstab</code> 文件内的配置项.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Linux主机, Ubuntu终端</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 proc 文件, tmp 文件</span></span><br><span class="line">$ <span class="built_in">cd</span> ~/jz2440/fs_first/</span><br><span class="line">$ mkdir proc</span><br><span class="line">$ mkdir tmp         <span class="comment"># 临时文件目录, 顺便一起做掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加初始化脚本</span></span><br><span class="line">$ vim etc/inittab</span><br><span class="line"><span class="comment"># 新增一行 &quot;::sysinit:/etc/init.d/rcS&quot; 用作运行脚本</span></span><br><span class="line">$ cat etc/inittab</span><br><span class="line">console::askfirst:-/bin/sh</span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建脚本, 执行挂载指令</span></span><br><span class="line">$ mkdir etc/init.d</span><br><span class="line">$ vim etc/init.d/rcS</span><br><span class="line"><span class="comment"># 加入脚本语句 &quot;mount -a&quot; 挂载proc目录</span></span><br><span class="line">$ cat etc/init.d/rcS</span><br><span class="line">mount -a</span><br><span class="line">$ chmod +x etc/init.d/rcS</span><br><span class="line"><span class="comment"># 加上可执行的权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建挂载指令的配置文件</span></span><br><span class="line">$ vim etc/fstab</span><br><span class="line"><span class="comment"># 创建 fstab 配置文件, 输入必要的内容, 见cat的结果</span></span><br><span class="line">$ cat etc/fstab</span><br><span class="line"><span class="comment">#dev    dir     type    options         dump    fsck</span></span><br><span class="line">proc    /proc   proc    defaults        0       0</span><br><span class="line">tmpfs   /tmp    tmpfs   defaults        0       0</span><br><span class="line"><span class="comment"># 这里加载proc, 顺便把临时文件的加载也做了</span></span><br></pre></td></tr></table></figure>

<p>此时. 可以使用 mkyaffs2image 生成镜像文件并烧录, 测试一下.</p>
<h3 id="fstab文件的简单说明"><a href="#fstab文件的简单说明" class="headerlink" title="fstab文件的简单说明"></a>fstab文件的简单说明</h3><ul>
<li>dev, 要挂接的设备<ul>
<li>譬如: <code>/dev/hd2</code> <code>/dev/mtdblock1</code></li>
<li>对于 proc, 直接忽略此字段. 可以是任意值</li>
<li>对于NFS文件系统, 此字段为 <code>&lt;host&gt;:&lt;dir&gt;</code></li>
</ul>
</li>
<li>mount-point, 挂载点, 即一个目录文件</li>
<li>type, 文件系统类型<ul>
<li>如 jffs, yaffs, ext2, nfs</li>
<li>也可以是auto, 对DVD, usb等设备会非常有用</li>
<li>proc, tmpfs 等是特殊的文件类型, 都有特定功能.</li>
</ul>
</li>
<li>options, 挂接参数.<ul>
<li>一般用 defaults 就行</li>
<li>参考<a href="https://wiki.archlinux.org/index.php/Fstab_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">fstab (简体中文)</a></li>
</ul>
</li>
<li>dump和fsck, 文件系统的备份和检查<ul>
<li>嵌入式系统一般都禁用, 设置为0</li>
</ul>
</li>
</ul>
<h2 id="使用-mdev-自动生成文件"><a href="#使用-mdev-自动生成文件" class="headerlink" title="使用 mdev 自动生成文件"></a>使用 mdev 自动生成文件</h2><p>udev是Linux的设备管理器。它主要的功能是管理/dev目录底下的设备节点<br>busybox提供了udev的简化版本mdev, 其作用是在系统启动或动态加载驱动时, 自动生成节点文件.</p>
<p>在busybox源码里, 可以找到 <code>busybox-1.7.0\docs\mdev.txt</code>. 关键步骤如下:</p>
<ul>
<li><code>mount -t sysfs sysfs /sys</code></li>
<li><code>echo /bin/mdev &gt; /proc/sys/kernel/hotplug</code></li>
<li><code>mdev -s</code></li>
<li><code>mount -t tmpfs mdev /dev</code></li>
<li><code>mkdir /dev/pts</code></li>
<li><code>mount -t devpts devpts /dev/pts</code></li>
</ul>
<p>由于我们使用的是 <code>mount -a</code>, 因此具体步骤稍有修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Linux主机, Ubuntu终端</span></span><br><span class="line"><span class="comment"># pwd = ~/jz2440/fs_first/</span></span><br><span class="line"></span><br><span class="line">$ mkdir sys</span><br><span class="line">$ vim etc/fstab</span><br><span class="line"><span class="comment"># 修改fstab, 按要求增加 /sys /dev.</span></span><br><span class="line">$ cat etc/fstab</span><br><span class="line"><span class="comment">#dev    dir     type    options         dump    fsck</span></span><br><span class="line">proc    /proc   proc    defaults        0       0</span><br><span class="line">tmpfs   /tmp    tmpfs   defaults        0       0</span><br><span class="line">sysfs   /sys    sysfs   defaults        0       0</span><br><span class="line">tmpfs   /dev    tmpfs   defaults        0       0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加初始化指令到 etc/init.d/rcS</span></span><br><span class="line">$ vim etc/init.d/rcS</span><br><span class="line"><span class="comment"># 修改rcS, mdev的要求增加指令</span></span><br><span class="line">$ cat etc/init.d/rcS</span><br><span class="line">mount -a</span><br><span class="line">mkdir /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"><span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev -s</span><br><span class="line"><span class="comment"># 不存在 /bin/mdev, busybox实际把它放在了 /sbin/mdev 下面.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样, 嵌入式linux完成启动后, 会运行init进程.</span></span><br><span class="line"><span class="comment"># - init进程运行 /etc/inittab 内的指令</span></span><br><span class="line"><span class="comment"># - 然后调用 /etc/init.d/rcS 脚本</span></span><br><span class="line"><span class="comment"># - 依次执行rcS脚本内的指令,</span></span><br><span class="line"><span class="comment"># - 执行&quot;mount -a&quot;时, 会根据 /etc/fstab 的配置挂载文件系统.</span></span><br></pre></td></tr></table></figure>

<p>完成烧录后, 使用 <code>ls /dev</code>, 就会看到自动生成了非常多的设备文件.<br>至此, 一个最小linux文件系统制作完成了.</p>
<h1 id="制作-jffs2-映像文件"><a href="#制作-jffs2-映像文件" class="headerlink" title="制作 jffs2 映像文件"></a>制作 jffs2 映像文件</h1><p>jffs2 是一个压缩的文件系统, 所以体积几乎比yaffs2小一半.<br>多用于 NOR FLASH</p>
<h2 id="生成-jffs2-工具"><a href="#生成-jffs2-工具" class="headerlink" title="生成 jffs2 工具"></a>生成 jffs2 工具</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mtd-utils-05.07.23.tar.bz2 可生成jffs2工具</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先需要压缩库zlib-1.2.3的支持</span></span><br><span class="line">$ tar xzf zlib-1.2.3.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> zlib-1.2.3</span><br><span class="line">$ ./configure --shared --prefix=/usr</span><br><span class="line"><span class="comment"># 配置为动态库, 放入/usr目录下</span></span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后编译 mkfs.jffs2</span></span><br><span class="line">$ tar xjf mtd-utils-05.07.23.tar.bz2</span><br><span class="line">$ <span class="built_in">cd</span> mtd-utils-05.07.23/util</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试一下是否装好了</span></span><br><span class="line">$ mkfs.jffs</span><br></pre></td></tr></table></figure>

<h2 id="制作-jffs2-映像文件-1"><a href="#制作-jffs2-映像文件-1" class="headerlink" title="制作 jffs2 映像文件"></a>制作 jffs2 映像文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/jz2440/</span><br><span class="line">$ mkfs.jffs -n -s 2048 -e 128KiB -d fs_first -o fs_first.jffs2</span><br><span class="line"><span class="comment"># -n            不要再每个擦除块上都加上清除标记</span></span><br><span class="line"><span class="comment"># -s 2048       指定Flash页大小</span></span><br><span class="line"><span class="comment"># -e 128KiB     指定Flash块大小(最小擦除单位)</span></span><br><span class="line"><span class="comment"># -d fs_first   文件系统目录</span></span><br><span class="line"><span class="comment"># -0 fs_first.jffs2 目标文件</span></span><br></pre></td></tr></table></figure>

<p>至此, jffs2 格式的映像文件制作完成.</p>
<h2 id="烧录-jffs2-映像文件"><a href="#烧录-jffs2-映像文件" class="headerlink" title="烧录 jffs2 映像文件"></a>烧录 jffs2 映像文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"><span class="comment"># 打开 jz2440 开发板串口终端, 启动时输入空格键, 进入如下菜单</span></span><br><span class="line"><span class="comment">##### 100ask Bootloader for OpenJTAG #####</span></span><br><span class="line">...</span><br><span class="line">[j] Download root_jffs2 image</span><br><span class="line">...</span><br><span class="line">Enter your selection: j                     <span class="comment"># 输入k, 烧录 root_jffs2</span></span><br><span class="line">USB host is connected. Waiting a download.  <span class="comment"># 提示连接成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 Ubuntu 终端, 输入</span></span><br><span class="line"><span class="built_in">cd</span> ~/jz2440/</span><br><span class="line">sudo dnw fs_first.yaffs2                    <span class="comment"># 输入dnw指令, 指明烧录文件</span></span><br><span class="line"><span class="comment"># DNW usb device found!                     # 开始烧录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到, 开发板 uboot, q退出菜单进入命令行模式</span></span><br><span class="line"><span class="comment"># 由于linux会自动识别为yaffs2格式, 因此还需要设置一下uboot环境变量, 指定文件系统的类型.</span></span><br><span class="line">$ <span class="built_in">set</span> bootargs noinitrd console=ttySAC0 root=/dev/mtdblock3 rootfstype=jffs2 init=/linuxrc</span><br><span class="line">$ saveenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板重启后, 就能启动终端输入指令操作了.</span></span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://www.cnblogs.com/zelos/archive/2011/03/27/1996766.html">嵌入式系统文件系统比较 jffs2, yaffs, cramfs, romfs, ramdisk, ramfs/tmpfs （转）</a></li>
<li><a href="http://blog.csdn.net/daofengdeba/article/details/7721340">Cramfs、JFFS2、YAFFS2的全面对比</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Fstab_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">fstab (简体中文)</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>fs</tag>
      </tags>
  </entry>
  <entry>
    <title>Python2和Python3共存时, pip的使用</title>
    <url>/2017/11/13/1732-python-pip/</url>
    <content><![CDATA[<h1 id="pip的使用"><a href="#pip的使用" class="headerlink" title="pip的使用"></a>pip的使用</h1><p>pip 为python的包管理器. 最新的python2和python3都已经自带pip.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示帮助</span></span><br><span class="line">pip</span><br><span class="line">pip --<span class="built_in">help</span></span><br><span class="line">pip install -h                      <span class="comment"># 显示安装的帮助</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装包</span></span><br><span class="line">pip install PackageName             <span class="comment"># latest version</span></span><br><span class="line">pip install PackageName==1.0.4      <span class="comment"># specific version</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 包列表</span></span><br><span class="line">pip list                            <span class="comment"># 显示已安装的包</span></span><br><span class="line">pip list --outdated                 <span class="comment"># 显示有更新的包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示包的简介, 以及包的源码文件</span></span><br><span class="line">pip show --files PackageName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新包</span></span><br><span class="line">pip install --U PackageName</span><br><span class="line">pip install --upgrade PackageName</span><br><span class="line">pip install --upgrade pip           <span class="comment"># pip更新自己</span></span><br><span class="line">python -m pip install --U pip       <span class="comment"># -m 表示调用python模块, 这里就是要调用pip</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载包</span></span><br><span class="line">pip uninstall PackageName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遇到SSL问题, 下载失败时, 信任下载源即可</span></span><br><span class="line"><span class="comment"># [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:XXX)</span></span><br><span class="line">pip list --outdated --trusted-host pypi.python.org</span><br><span class="line">pip install --trusted-host pypi.python.org PackageName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果还是不行, 再试试下面这句. index-url 将源指定为http格式, 不用https了, 然后设置为信任.</span></span><br><span class="line">pip install --index-url=http://pypi.python.org/simple/ --trusted-host pypi.python.org PackageName</span><br></pre></td></tr></table></figure>

<h1 id="linux下的双版本"><a href="#linux下的双版本" class="headerlink" title="linux下的双版本"></a>linux下的双版本</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo python2 hello.py</span><br><span class="line">sudo python3 hello.py</span><br><span class="line"><span class="comment"># 指定版本运行源码</span></span><br><span class="line"></span><br><span class="line">sudo pip2 install PackageName</span><br><span class="line">sudo pip3 install PackageName</span><br><span class="line"><span class="comment"># 直接使用pip+版本</span></span><br><span class="line"></span><br><span class="line">sudo python2 -m pip install PackageName</span><br><span class="line">sudo python3 -m pip install PackageName</span><br><span class="line"><span class="comment"># -m 表示调用python模块, 这里就是要调用pip</span></span><br></pre></td></tr></table></figure>

<h2 id="源码内指定版本"><a href="#源码内指定版本" class="headerlink" title="源码内指定版本"></a>源码内指定版本</h2><p>将需要指定的python版本放在源码的第一行.<br>支持如下方式:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env</span></span><br><span class="line"><span class="comment"># 使用默认的系统环境</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!python2</span></span><br><span class="line"><span class="comment">#!python3</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># 指定python版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment">#!/usr/local/bin/python2.7</span></span><br><span class="line"><span class="comment">#!/usr/local/bin/python3.5</span></span><br><span class="line"><span class="comment"># 通过路径指定版本</span></span><br></pre></td></tr></table></figure>

<p>举个python3的例子, 格式如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="comment"># ... 源码</span></span><br></pre></td></tr></table></figure>

<h1 id="windows下的双版本"><a href="#windows下的双版本" class="headerlink" title="windows下的双版本"></a>windows下的双版本</h1><h2 id="windows官解"><a href="#windows官解" class="headerlink" title="windows官解"></a>windows官解</h2><p>Windows下, 官方提供了 <a href="https://www.python.org/dev/peps/pep-0397/">Python launcher for Windows</a> 的方法.<br>在安装 python3 的时候 (版本&gt;=3.3), 记得勾选 <code>py launcher</code> 选项.<br>这样, 就会python3就会生成一个py.exe命令. 可以指定调用python2或者python3.<br>安装了 <code>py laucher</code> 后, 也支持源码第一行指定版本</p>
<ul>
<li><code>#! python2</code></li>
<li><code>#! python3</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">py -2 hello.py</span><br><span class="line">py -3 hello.py</span><br><span class="line"><span class="comment"># 指定版本运行源码</span></span><br><span class="line"></span><br><span class="line">py -2 -m pip install PackageName</span><br><span class="line">py -3 -m pip install PackageName</span><br><span class="line"><span class="comment"># -m 表示调用python模块, 这里就是要调用pip</span></span><br></pre></td></tr></table></figure>

<h2 id="windows土法"><a href="#windows土法" class="headerlink" title="windows土法"></a>windows土法</h2><p>但是, 官解真的没有土方法方便. 但不知道是否有潜在风险题<br>土法就是改名, 让windows下的用法和linux一样.</p>
<ul>
<li>在python2的根目录, <strong>复制</strong>一份<code>python.exe</code>, 然后改名为 <code>python2.exe</code>.</li>
<li>进入<code>Scripts</code>目录, <strong>复制</strong>一份<code>pip.exe</code>, 然后改名为 <code>pip2.exe</code>.</li>
<li>同样python3根目录, <strong>复制</strong>一份<code>python.exe</code>, 然后改名为 <code>python3.exe</code>.</li>
<li>进入<code>Scripts</code>目录, <strong>复制</strong>一份<code>pip.exe</code>, 然后改名为 <code>pip3.exe</code>.</li>
<li>注意不是直接改名. 要保留原来的 <code>python.exe</code> 和 <code>pip.exe</code></li>
<li>可以和linux下一样, 愉快的玩耍了. 如下:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python2 hello.py</span><br><span class="line">python3 hello.py</span><br><span class="line"><span class="comment"># 指定版本运行源码</span></span><br><span class="line"></span><br><span class="line">pip2 install PackageName</span><br><span class="line">pip3 install PackageName</span><br><span class="line"><span class="comment"># 直接使用pip+版本</span></span><br><span class="line"></span><br><span class="line">sudo python2 -m pip install PackageName</span><br><span class="line">sudo python3 -m pip install PackageName</span><br><span class="line"><span class="comment"># -m 表示调用python模块, 这里就是要调用pip</span></span><br></pre></td></tr></table></figure>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://python.freelycode.com/contribution/detail/139">Windows上Python2和3如何兼容？</a></li>
<li><a href="http://www.cnblogs.com/an9wer/p/5564284.html">python2.X和python3.X在同一平台下的切换技巧</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式Linux学习目录</title>
    <url>/2017/11/23/1734-linux-content/</url>
    <content><![CDATA[<h1 id="嵌入式开发环境搭建"><a href="#嵌入式开发环境搭建" class="headerlink" title="嵌入式开发环境搭建"></a>嵌入式开发环境搭建</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/02/16/1705-linux-env/">嵌入式linux环境搭建-主机端</a><ul>
<li><a href="https://draapho.github.io/2017/07/06/1718-linux-samba/">Ubuntu下配置支持Windows访问的samba共享</a></li>
<li><a href="https://draapho.github.io/2017/11/29/1739-ubuntu-nfs/">Ubuntu 16.04安装配置NFS</a></li>
<li><a href="https://draapho.github.io/2017/11/27/1737-linux-ide/">LinK+, 一款Linux内核开发IDE</a></li>
<li><a href="https://draapho.github.io/2017/02/20/1706-linux-ubuntu16/">嵌入式linux环境搭建3-Ubuntu16</a></li>
</ul>
</li>
<li><a href="https://draapho.github.io/2017/02/21/1707-jz2440-env/">嵌入式linux环境搭建-jz2440开发板</a></li>
<li><a href="https://draapho.github.io/2017/11/28/1738-dhcp-env/">基于DHCP建立嵌入式Linux开发环境</a></li>
</ul>
<h1 id="jz2440学习"><a href="#jz2440学习" class="headerlink" title="jz2440学习"></a>jz2440学习</h1><ul>
<li><a href="https://draapho.github.io/2017/04/05/1710-jz2440-led/">jz2440裸板程序的开发</a></li>
<li><a href="https://draapho.github.io/2017/11/24/1735-jz2440-basic/">jz2440分区及启动的基础概念</a></li>
<li><a href="https://draapho.github.io/2017/07/07/1719-uboot-makefile/">uboot之makefile分析</a></li>
<li><a href="https://draapho.github.io/2017/08/25/1720-uboot-source/">uboot之源码分析</a></li>
<li><a href="https://draapho.github.io/2017/08/30/1721-uboot-modify/">uboot之定制指令</a></li>
<li><a href="https://draapho.github.io/2017/09/01/1722-kernel-compile/">kernel之编译体验</a></li>
<li><a href="https://draapho.github.io/2017/09/14/1724-kernel-makefile/">kernel之Makefile分析</a></li>
<li><a href="https://draapho.github.io/2017/09/15/1725-kernel-launch/">kernel之内核启动分析</a></li>
<li><a href="https://draapho.github.io/2017/11/02/1730-fs-busybox/">fs之Busybox的编译与使用</a></li>
<li><a href="https://draapho.github.io/2017/11/03/1731-fs-build/">fs之创建文件系统</a></li>
</ul>
<ul>
<li><a href="https://draapho.github.io/2017/11/22/1733-drv-chr1/">驱动之字符设备-框架</a></li>
<li><a href="https://draapho.github.io/2017/11/30/1740-drv-chr2/">驱动之基于LinK+设计按键驱动</a></li>
<li><a href="https://draapho.github.io/2017/12/07/1741-drv-chr3/">驱动之基于中断设计按键驱动</a></li>
<li><a href="https://draapho.github.io/2017/12/11/1742-drv-chr4/">驱动之poll机制</a></li>
<li><a href="https://draapho.github.io/2017/12/12/1743-drv-chr5/">驱动之异步通知</a></li>
<li><a href="https://draapho.github.io/2017/12/13/1744-drv-chr6/">驱动之同步互斥阻塞</a></li>
<li><a href="https://draapho.github.io/2018/01/04/1801-drv-chr7/">驱动之定时器按键防抖</a></li>
</ul>
<ul>
<li><a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a></li>
<li><a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a></li>
<li><a href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">驱动之RTC分析</a></li>
<li><a href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">驱动之LCD驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/11/1806-drv-ts/">驱动之触摸屏驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">驱动之USB基础概念和框架</a></li>
<li><a href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">驱动之USB设备驱动程序</a></li>
</ul>
<ul>
<li><a href="https://draapho.github.io/2018/01/22/1809-drv-blk/">驱动之块设备-框架</a></li>
<li><a href="https://draapho.github.io/2018/01/24/1810-drv-nand1/">驱动之NAND Flash框架</a></li>
<li><a href="https://draapho.github.io/2018/01/25/1811-drv-nand2/">驱动之NAND Flash源码</a></li>
<li><a href="https://draapho.github.io/2018/01/26/1812-drv-nor/">驱动之NOR Flash</a></li>
<li><a href="https://draapho.github.io/2018/02/06/1813-drv-net/">驱动之网卡驱动</a></li>
</ul>
<h1 id="QQ物联学习"><a href="#QQ物联学习" class="headerlink" title="QQ物联学习"></a>QQ物联学习</h1><ul>
<li><a href="https://draapho.github.io/2017/12/18/1746-qqiot-env/">嵌入式linux环境搭建-QQ物联</a></li>
<li><a href="https://draapho.github.io/2017/12/22/1748-qqiot-procedure/">QQ物联开发步骤简介</a></li>
<li><a href="https://draapho.github.io/2017/12/20/1747-qqiot-bind/">QQ物联绑定分析</a></li>
<li><a href="https://draapho.github.io/2017/12/23/1749-qqiot-demo/">QQ物联演示项目</a></li>
</ul>
<h1 id="Yocto学习"><a href="#Yocto学习" class="headerlink" title="Yocto学习"></a>Yocto学习</h1><ul>
<li><a href="https://draapho.github.io/2017/12/15/1745-yocto-install/">Yocto 的安装与体验</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
      </tags>
  </entry>
  <entry>
    <title>jz2440分区及启动的基础概念</title>
    <url>/2017/11/24/1735-jz2440-basic/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/11/24/1735-jz2440-basic/">jz2440分区及启动的基础概念</a></li>
<li><a href="https://draapho.github.io/2017/07/07/1719-uboot-makefile/">uboot之makefile分析</a></li>
<li><a href="https://draapho.github.io/2017/08/25/1720-uboot-source/">uboot之源码分析</a></li>
<li><a href="https://draapho.github.io/2017/08/30/1721-uboot-modify/">uboot之定制指令</a></li>
<li>大致了解一下linux软件层次, 以及jz2440的分区情况, 启动流程.</li>
</ul>
<h1 id="linux软件层次"><a href="#linux软件层次" class="headerlink" title="linux软件层次"></a>linux软件层次</h1><ul>
<li>引导程序: 分为两部分 硬件中的固化boot代码 和 BootLoader代码, 其中固化的boot代码可有可无, BootLoader是烧写上去的<ul>
<li>PC linux: 分为 BIOS (固件程序) 和 BootLoader(GRUB等程序)</li>
<li>执行过程: BIOS执行硬件检测 和 资源分配, 之后将BootLoader读取到内存中, 开始执行BootLoader内容</li>
<li>执行作用: 将内核读取到内存中, 跳转到内核的入口运行, 正式执行操作系统程序</li>
<li>嵌入式 linux: BootLoader与硬件的依赖性很强, S3C2440 使用的是u-boot</li>
<li>执行过程: 初始化基本硬件, 加载BootLoader, 读取uboot环境变量, 启动uboot.</li>
<li>执行作用: 和 pc linux 是一样的. 读取内核并执行.</li>
</ul>
</li>
<li>Linux内核 (kernel): 嵌入式开发板定制的内核 和 其启动参数</li>
<li>文件系统 (file system): 即Linux中的文件系统</li>
<li>应用程序: 即用户执行的应用程序</li>
</ul>
<h2 id="jz2440的分区和启动"><a href="#jz2440的分区和启动" class="headerlink" title="jz2440的分区和启动"></a>jz2440的分区和启动</h2><p>s3c2440 的线性地址分配:<br><img src="https://draapho.github.io/images/1707/address-mapping.jpg" alt="address mapping"></p>
<p>jz2440 的分区: (在uboot下, 用 <code>mtdparts</code> 查看分区情况)</p>
<table>
<thead>
<tr>
<th>jz2440 物理设备</th>
<th>大小(byte)</th>
<th>线性地址</th>
</tr>
</thead>
<tbody><tr>
<td>SFR Area</td>
<td>寄存器</td>
<td>0x4800_0000 - 0x5B00_0020</td>
</tr>
<tr>
<td>SDRAM</td>
<td>64M</td>
<td>0x3000_0000 - 0x3400_0000</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Nor Flash</td>
<td>2M</td>
<td>0x0000_0000 - 0x0020_0000</td>
</tr>
<tr>
<td>- u-boot</td>
<td>-</td>
<td>0x0000_0000 开始</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Nand Flash</td>
<td>256M</td>
<td>非总线设备, 无法映射地址</td>
</tr>
<tr>
<td>- bootloader</td>
<td>256K</td>
<td>0x0000_0000 - 0x0004_0000</td>
</tr>
<tr>
<td>- params</td>
<td>128K</td>
<td>0x0004_0000 - 0x0006_0000</td>
</tr>
<tr>
<td>- kernel</td>
<td>2M</td>
<td>0x0006_0000 - 0x0026_0000</td>
</tr>
<tr>
<td>- root</td>
<td>253.6M</td>
<td>0x0026_0000 - 0x1000_0000</td>
</tr>
</tbody></table>
<p>jz2440开发板启动方式:</p>
<ul>
<li>Nor flash: JLink 只能烧录 Nor flash. 默认使用这种方式! 使用nfs文件系统<br><img src="https://draapho.github.io/images/1707/nor-flash-boot.png" alt="Nor flash boot"></li>
<li>Nand flash: 使用本地文件系统启动. 也可用于裸跑测试. (Steppingstone 就是 BootSRAM)<br><img src="https://draapho.github.io/images/1707/nand-flash-boot.png" alt="Nand flash boot"></li>
<li>**以下部分初学先忽略! **</li>
<li>如果是通过uboot的内核命令行给MTD层传递MTD分区信息, 内核读取到的分区信息始终和u-boot中的保持一致(推荐的做法)<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line">setenv bootargs noinitrd console=ttySAC0 root=/dev/mtdblock3 rootfstype=jffs2 mtdparts=nand_flash:128k(u-boot)ro,64k(u-boot envs),3m(kernel),30m(root.jffs2),30m(root.yaffs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ubuntu shell, 内核配置时使能</span></span><br><span class="line">Device Drivers -&gt; Memory Technology Device (MTD) support -&gt; Command line partition table parsing</span><br></pre></td></tr></table></figure></li>
<li>如果是把分区信息写在内核源代码MTD里定义好的方法, 要保证它和u-boot中的保持一致,即同步修改uboot及内核的相关部分</li>
<li><strong>参考</strong>: <a href="http://laokongzhuang.blog.51cto.com/2404494/858788">嵌入式linux flash分区配置</a></li>
<li>**以上部分初学先忽略! **</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>environment</tag>
        <tag>jz2440</tag>
      </tags>
  </entry>
  <entry>
    <title>linux软件的安装和管理</title>
    <url>/2017/11/26/1736-linux-apt/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>接触linux至今, 遇到的最大的坑就是软件的安装!<br>找不到包, 找不到指定版本的包, 包依赖关系出问题, 软件源要更新…<br>因此, 在这里集中整理一下上述问题的解决方式.</p>
<h1 id="apt-命令"><a href="#apt-命令" class="headerlink" title="apt 命令"></a>apt 命令</h1><p>最新 Ubuntu推荐使用 <code>apt</code> 指令. 其常用功能如下</p>
<table>
<thead>
<tr>
<th>apt 命令</th>
<th>功能说明</th>
<th>对应的旧命令</th>
</tr>
</thead>
<tbody><tr>
<td><code>apt list</code></td>
<td>根据名称列出软件包</td>
<td><code>dpkg list</code></td>
</tr>
<tr>
<td><code>apt search</code></td>
<td>搜索软件包描述</td>
<td><code>apt-cache search</code></td>
</tr>
<tr>
<td><code>apt show</code></td>
<td>显示软件包细节</td>
<td><code>apt-cache show</code></td>
</tr>
<tr>
<td><code>apt install</code></td>
<td>安装软件包</td>
<td><code>apt-get install</code></td>
</tr>
<tr>
<td><code>apt remove</code></td>
<td>移除软件包</td>
<td><code>apt-get remove</code></td>
</tr>
<tr>
<td><code>apt update</code></td>
<td>更新可用软件包列表</td>
<td><code>apt-get update</code></td>
</tr>
<tr>
<td><code>apt upgrade</code></td>
<td>升级指定的软件</td>
<td><code>apt-get upgrade</code></td>
</tr>
<tr>
<td><code>apt full-upgrade</code></td>
<td>升级指定的软件并安装或删除其依赖的软件</td>
<td><code>apt-get dist-upgrade</code></td>
</tr>
<tr>
<td><code>apt edit-sources</code></td>
<td>编辑软件源信息文件</td>
<td><code>vim /etc/apt/sources.list</code></td>
</tr>
</tbody></table>
<h1 id="软件源"><a href="#软件源" class="headerlink" title="软件源"></a>软件源</h1><p>就是存放Ubuntu可执行软件的网址. 分为官方软件源和PPA软件源<br>Ubuntu的软件源都记录在了 <code>/etc/apt/sources.list</code> 文件下面.</p>
<h2 id="Ubuntu-官方软件源"><a href="#Ubuntu-官方软件源" class="headerlink" title="Ubuntu 官方软件源"></a>Ubuntu 官方软件源</h2><p>顾名思义, 就是官方提供的软件下载地址. 格式如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;us.archive.ubuntu.com&#x2F;ubuntu&#x2F; xenial main restricted</span><br><span class="line"># deb-src http:&#x2F;&#x2F;us.archive.ubuntu.com&#x2F;ubuntu&#x2F; xenial main restricted</span><br></pre></td></tr></table></figure>

<p>由于众所周知的原因, 在国内经常是不能用的. 那么可以替换为如下网址, 是官方软件源的镜像.<br>更多可见 <a href="https://segmentfault.com/a/1190000000375848">国内开源镜像站点汇总</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;ubuntu&#x2F; xenial main restricted</span><br><span class="line"># deb-src http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;ubuntu&#x2F; xenial main restricted</span><br></pre></td></tr></table></figure>

<h2 id="PPA软件源"><a href="#PPA软件源" class="headerlink" title="PPA软件源"></a>PPA软件源</h2><p>PPA软件源, 即”Personal Package Archives”, 个人软件包集.<br>Ubuntu开设了一个开发者平台, 允许开发者建立自己的软件仓库并上传.<br>因此, 用PPA不能保证安全性.</p>
<p>PPA的格式如下, 网址都是 <code>ppa.launchpad.net</code> 开头的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb http://ppa.launchpad.net/wireshark-dev/stable/ubuntu trusty main</span><br><span class="line"><span class="comment"># deb-src http://ppa.launchpad.net/wireshark-dev/stable/ubuntu trusty main</span></span><br></pre></td></tr></table></figure>

<h1 id="update-upgrade-dist-upgrade-的区别"><a href="#update-upgrade-dist-upgrade-的区别" class="headerlink" title="update upgrade dist-upgrade 的区别"></a><code>update</code> <code>upgrade</code> <code>dist-upgrade</code> 的区别</h1><p>update 更新的是软件源信息. 因此一般习惯在install之前, 使用update更新一下.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt edit-sources       <span class="comment"># 更改软件源列表</span></span><br><span class="line">sudo apt update             <span class="comment"># 根据软件源列表下载新的版本信息和包信息</span></span><br><span class="line">sudo apt install XXX        <span class="comment"># 可以下载了. 如果还是有问题, 说明这个软件在源列表中不存在或者是网络问题.</span></span><br></pre></td></tr></table></figure>

<p>upgrade 更新的是指定的软件到最新版本. 但不去考虑依赖关系.<br>dist-upgrade 会判断软件新版本的依赖关系, 如果依赖关系变了, 它能自动升级依赖的软件.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt upgrade XXX        <span class="comment"># 只升级指定的软件, 不考虑其依赖关系</span></span><br><span class="line">sudo apt full-upgrade XXX   <span class="comment"># 字面意思: 全面升级! 就是会去自动安装/删除依赖的软件.</span></span><br></pre></td></tr></table></figure>

<h1 id="build-dep-自动建立编译环境"><a href="#build-dep-自动建立编译环境" class="headerlink" title="build-dep 自动建立编译环境"></a>build-dep 自动建立编译环境</h1><p>譬如要手工编译 apache2, 那么可以用 <code>apt-get build-dep</code> 来快速建立编译环境.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get build-dep apache2</span><br><span class="line"><span class="comment"># 会列出一系列会被安装的软件, 并询问是否要安装.</span></span><br><span class="line"><span class="comment"># 先回答NO.</span></span><br><span class="line"></span><br><span class="line">sudo apt-get build-dep apache2 | tee apache2.log</span><br><span class="line"><span class="comment"># 为了便于日后查看关系包, 建议先做个记录:</span></span><br></pre></td></tr></table></figure>

<h1 id="查看依赖关系"><a href="#查看依赖关系" class="headerlink" title="查看依赖关系"></a>查看依赖关系</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-cache depends XXX</span><br><span class="line"><span class="comment"># 查看正向依赖, XXX依赖的软件</span></span><br><span class="line"></span><br><span class="line">apt-cache rdepends XXX</span><br><span class="line"><span class="comment"># 查看反向依赖, 依赖XXX的软件</span></span><br></pre></td></tr></table></figure>


<h1 id="遇到错误"><a href="#遇到错误" class="headerlink" title="遇到错误"></a>遇到错误</h1><h2 id="找不到资源"><a href="#找不到资源" class="headerlink" title="找不到资源"></a>找不到资源</h2><ul>
<li>检查网络, 是否需要翻墙. 必要的话, 更改软件源列表.</li>
<li>检查网络, 是否安全性太高了. 有些公司网络容易产生这样的情况.</li>
<li><code>sudo apt update</code>, 更新软件源在试试.</li>
</ul>
<h2 id="Java-安装失败"><a href="#Java-安装失败" class="headerlink" title="Java 安装失败"></a>Java 安装失败</h2><p>Java向下兼容, 建议直接安装java最新版<br><code>sudo apt-get install openjdk-8-jdk</code></p>
<p>更复杂的情况, 参考这篇stackoverflow吧</p>
<ul>
<li><a href="https://stackoverflow.com/questions/32942023/ubuntu-openjdk-8-unable-to-locate-package">Ubuntu: OpenJDK 8 - Unable to locate package</a></li>
</ul>
<h2 id="Could-not-get-lock"><a href="#Could-not-get-lock" class="headerlink" title="Could not get lock"></a>Could not get lock</h2><p><code>E:Could not get lock /var/lib/apt/lists/lock - open (11: Resource temporarily unavailable)</code><br>获取资源锁失败, 说明有另外一个apt-get在运行. 这种情况多发生在新装的Ubuntu中, 他会自动运行apt-get<br>解决方法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 或者去查看进程</span></span><br><span class="line">ps -e | grep apt</span><br><span class="line"><span class="comment"># 看是否有进程在执行</span></span><br><span class="line"><span class="comment"># 6362 ? 00:00:00 apt</span></span><br><span class="line"><span class="comment"># 6934 ? 00:00:00 apt-get</span></span><br><span class="line"><span class="comment"># 7368 ? 00:00:00 synaptic</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有的话, 直接杀掉</span></span><br><span class="line">sudo killall apt</span><br><span class="line">sudo killall apt-get</span><br><span class="line">sudo killall synaptic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还是不行的话, 直接移除锁</span></span><br><span class="line">sudo rm /var/cache/apt/archives/lock</span><br><span class="line">sudo rm /var/lib/dpkg/lock</span><br></pre></td></tr></table></figure>

<h2 id="X-not-fully-installed-or-removed"><a href="#X-not-fully-installed-or-removed" class="headerlink" title="X not fully installed or removed"></a>X not fully installed or removed</h2><p>多发生在安装过程中, 发生意外错误, 导致部分软件没有安装好.<br>如果在Ubuntu下面修改过<code>/usr/bin/python</code>软链接, 改2.7版本到3.5的话,<br>安装某些依赖python软件也会发生这个问题!</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此错误发生在安装 libsdl1.2-dev 过程中. libsdl1.2-dev 依赖另外两个软件</span></span><br><span class="line"><span class="comment"># 原因是, 我修改了  /usr/bin/python -&gt; python3.5*</span></span><br><span class="line"><span class="comment"># 解决方法就是改回来 /usr/bin/python -&gt; python2.7*</span></span><br><span class="line"></span><br><span class="line">$ sudo apt install libsdl1.2-dev</span><br><span class="line">......</span><br><span class="line">3 not fully installed or removed</span><br><span class="line">Do you want to <span class="built_in">continue</span>? [Y/n]</span><br><span class="line">......</span><br><span class="line">Errors were encountered <span class="keyword">while</span> processing:</span><br><span class="line">libglib2.0-dev</span><br><span class="line">libpulse-dev:i386</span><br><span class="line">libsdl1.2-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先解决没有完全安装或者删除的问题, 方法如下, 按照依赖关系, 倒过来逐一删除:</span></span><br><span class="line">$ sudo dpkg -r libsdl1.2-dev</span><br><span class="line">$ sudo dpkg -r libpulse-dev:i386</span><br><span class="line">$ sudo dpkg -r libglib2.0-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后尝试重新安装. 我这里的问题是python语法错误</span></span><br><span class="line"><span class="comment"># 只能改回来 /usr/bin/python -&gt; python2.7*</span></span><br><span class="line">sudo apt-get -f autoremove</span><br><span class="line">sudo apt-get -f install</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libglib2.0-dev</span><br></pre></td></tr></table></figure>


<h2 id="软件版本问题"><a href="#软件版本问题" class="headerlink" title="软件版本问题"></a>软件版本问题</h2><p>先试试指定版本号安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install package=version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 譬如</span></span><br><span class="line">apt-get install nautilus=2.2.4-1</span><br></pre></td></tr></table></figure>

<p>如果更复杂的, 譬如依赖的软件需要指定版本, 直接参考stackoverflow吧<br><a href="https://askubuntu.com/questions/140246/how-do-i-resolve-unmet-dependencies-after-adding-a-ppa">How do I resolve unmet dependencies after adding a PPA?</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.jianshu.com/p/3dad50f452b6">apt与apt-get的区别</a></li>
<li><a href="http://www.jianshu.com/p/57a91bc0c594">详解Ubuntu软件源</a></li>
<li><a href="http://blog.csdn.net/wangyezi19930928/article/details/54928201">apt-get update ，upgarde 和dist-upgrade 的区别</a></li>
<li><a href="http://blog.csdn.net/mifangdebaise/article/details/50553596">记一条好用的ubuntu命令: apt-get build-dep</a></li>
<li><a href="http://blog.csdn.net/zwjsatan/article/details/8101712">sudo apt-get update更新源失败</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>apt</tag>
      </tags>
  </entry>
  <entry>
    <title>LinK+, 一款Linux内核开发IDE</title>
    <url>/2017/11/27/1737-linux-ide/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>LinK+ 是一款在linux下基于eclipse开发的免费的Linux内核以及驱动开发软件.<br>这个软件在国外知名度也不高. 国内更是没人介绍过这一款软件.<br>软件的现状是: 开发者似乎已经停止更新, 设想中支持的ARM架构也没有下文. 因此不支持嵌入式的仿真.<br><strong>我主要用它来查看内核源码, 开发驱动, 能快速的搭建好驱动架构, 支持内核函数跳转查看! 自动生成Makefile.</strong></p>
<p>网址如下: <a href="https://sourceforge.net/projects/linkplustest/">Linux Kernel Programming IDE (LinK+)</a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>根据用户手册, 有多种安装方法. 使用最简单的 LinK+IDE方式.<br>下载 32bit, 因为我用的是32位的Ubuntu.</p>
<ul>
<li><a href="https://sourceforge.net/projects/linkplustest/files/installers/">点这里, 下载页面</a></li>
<li><a href="http://sourceforge.net/projects/linkplustest/files/documentation/LinK%2B_UserManual_Rev4.pdf">安装和使用手册</a></li>
</ul>
<p><strong>说明一下 LinK+ UserManual 里面的 <code>-</code>横杠都是错误的, 终端无法识别!</strong><br>然后按照说明安装如下依赖的软件.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装最新版 openjdk, 向下兼容jdk6即可.</span></span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装open ssh</span></span><br><span class="line">sudo apt-get install openssh-client openssh-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其它依赖的软件</span></span><br><span class="line">sudo apt-get install libqt4-dev</span><br><span class="line">sudo apt-get install libncurses5</span><br><span class="line">sudo apt-get install qemu</span><br><span class="line">sudo apt-get install bridge-utils iptables dnsmasq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 LinK+IDE</span></span><br><span class="line"><span class="comment"># 下载好LinK+IDE的文件, LinK+ IDE-linux.gtk.x86.tar.gz.tar.gz</span></span><br><span class="line">tar -xzvf LinK+\ IDE-linux.gtk.x86.tar.gz.tar.gz</span><br><span class="line">./linkplus</span><br><span class="line"><span class="comment"># 安装成功的话, 就能运行了.</span></span><br></pre></td></tr></table></figure>

<p>然后, LinK+IDE 的升级和插件不用看了. 很久没更新过了.</p>
<h1 id="Kernel源码的编译和阅读"><a href="#Kernel源码的编译和阅读" class="headerlink" title="Kernel源码的编译和阅读"></a>Kernel源码的编译和阅读</h1><p>先确定linux内核源码可以在终端下成功编译.<br>新建Makefile工程<br><img src="https://draapho.github.io/images/1737/link1.JPG" alt="link.JPG"></p>
<p>选择源码路径, 工具链使用Makefile自己的, 所以选<code>&lt;none&gt;</code><br><img src="https://draapho.github.io/images/1737/link2.JPG" alt="link.JPG"></p>
<p>选中项目, 然后在菜单里取消自动编译, 最后选择项目属性<br><img src="https://draapho.github.io/images/1737/link3.JPG" alt="link.JPG"></p>
<p>设定编译指令, <code>make</code> 即可<br><img src="https://draapho.github.io/images/1737/link5.JPG" alt="link.JPG"></p>
<p>设定指令目标. 内核使用 <code>uImage</code>, 驱动使用 <code>make modules</code><br><img src="https://draapho.github.io/images/1737/link6.JPG" alt="link.JPG"></p>
<p>如果需要设置更多的指令目标, 用如下方式. Create是设置, Build是执行<br><img src="https://draapho.github.io/images/1737/link7.JPG" alt="link.JPG"></p>
<p>设置自定义目标<br><img src="https://draapho.github.io/images/1737/link8.JPG" alt="link.JPG"></p>
<p>好了, 如果这样直接 <code>Make Targets</code>-&gt;<code>Build...</code>-&gt;<code>uImage</code>, 会编译失败.<br>原因是Eclipse下面无法正确识别Makefile下面的CROSS_COMPILE路径.<br>见 <a href="https://www.crifan.com/ubuntu_eclipse_cross_compile_uboot_based_on_makefile/">Ubuntu下基于Eclipse去调用Makefile交叉编译Uboot</a><br>需要将其改为绝对路径. 打开内核源码根目录下的 <code>Makefile</code>, 187行, 修改如下:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CROSS_COMPILE ?= arm-linux-</span></span><br><span class="line">CROSS_COMPILE   ?= /usr/local/gcc-3.4.5-glibc-2.3.6/bin/arm-linux-</span><br></pre></td></tr></table></figure>


<p>再次在eclipse下尝试编译, 就成功了. 看Console的输出, 获得uImage文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Kernel: arch&#x2F;arm&#x2F;boot&#x2F;Image is ready</span><br><span class="line">Kernel: arch&#x2F;arm&#x2F;boot&#x2F;zImage is ready</span><br><span class="line">Image arch&#x2F;arm&#x2F;boot&#x2F;uImage is ready</span><br></pre></td></tr></table></figure>

<p>但Ecilpse依旧会显示很多警告和错误. 原因不明, 查的如下资料:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/8563978/what-is-kernel-section-mismatch">What is kernel section mismatch?</a></li>
<li><a href="http://www.linuxdiyf.com/linux/24369.html">解决编译kernel出现WARNING:Section mismatch(es)</a></li>
</ul>
<p>先忽略这些错误警告, 但此时, 有些函数依旧不能正常跳转. 原因是 <code>.\include\linux\autoconf.h</code> 没有被其它头文件包含, 里面的宏定义linux源码无法识别. 解决办法是我们自己把这些宏定义加入eclipse的SYMBOLS. 手工一个个加入不现实, 我写了一个python代码, 把linux下的config自动转为eclipse可识别的XML格式:<br><strong><a href="https://github.com/draapho/Blog/tree/master/_blog_stuff/linux/config2xml.py">下载config2xml</a></strong></p>
<p>将这个文件放在linux源码根目录下, 配置好<code>.config</code> 文件. 然后在终端运行它</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pwd = linux内核源码根目录</span></span><br><span class="line">$ python config2xml.py</span><br><span class="line">Generate ../eclipse_SYMBOLS.xml successfully...</span><br></pre></td></tr></table></figure>

<p>成功后, 会在上层目录生成 <code>eclipse_SYMBOLS.xml</code> 这么一个文件.<br>然后回到eclipse里面, 将其导入. 如图:<br><img src="https://draapho.github.io/images/1737/link9.JPG" alt="link.JPG"></p>
<p>另外, 为方便跳转, 可以在eclipse下面把linux源码下不相关的平台代码排除掉.<br><img src="https://draapho.github.io/images/1737/link4.JPG" alt="link.JPG"></p>
<p>最后, 需要把项目的index索引重建一下才能正确跳转. 重建耗时较长.<br><img src="https://draapho.github.io/images/1737/link10.JPG" alt="link.JPG"></p>
<p><strong>至此内核源码的C语言部分已经能成功的跳转查看了.汇编部分可以用eclipse的搜索功能.</strong></p>
<h1 id="写驱动"><a href="#写驱动" class="headerlink" title="写驱动"></a>写驱动</h1><p>需要先在工程里加载好Kernel源码!<br>然后参考 <strong><a href="https://draapho.github.io/2017/11/30/1740-drv-chr2/">驱动之基于LinK+设计按键驱动</a></strong></p>
<p>大致步骤如下:</p>
<ul>
<li>LinK+IDE里, 新建工程-&gt;Linux Kernel Development(LinK+)</li>
<li>选择 Device Driver Project</li>
<li>写好驱动名称, 驱动路径, 作者, 开源证书类型</li>
<li>Kernel Version 要去掉 <code>Use Host Machine Kernel</code>, 选择我们已经编译好的嵌入式内核源码路径</li>
<li>X86架构 (ARM不支持),</li>
<li>下面两步可以根据需求自己选择驱动框架, LinK+会自动生成有框架的.c和.h以及Makefile文件.</li>
<li>驱动下面, 所有的跳转都可用, 可以非常方便的查看函数和宏定义.</li>
<li>可以使用eclipse去编译, 设置一个 <code>modules</code> 目标就可以了.</li>
</ul>
<h1 id="Eclipse交叉编译说明"><a href="#Eclipse交叉编译说明" class="headerlink" title="Eclipse交叉编译说明"></a>Eclipse交叉编译说明</h1><p>这个方法的核心是不用Eclipse自己的编译工具链. 所有的编译工具都由Makefile内指定了.<br>所以, 这个也适用于编译查看u-boot源码.<br>如果是应用层代码, 那么就需要自己写Makefile指定编译工具了.<br>另外一个方法是, 另外下载一个 <code>Eclipse IDE for C/C++</code>, 单独为应用层代码配置一个环境.</p>
<p>可参考:</p>
<ul>
<li><a href="http://www.linuxidc.com/Linux/2016-09/135062.htm">Linux下搭建树莓派交叉编译环境</a></li>
<li><a href="http://www.cnblogs.com/lazygunner/archive/2011/11/30/2269726.html">Linux + Eclipse 配置交叉编译环境</a></li>
<li><a href="http://blog.csdn.net/tianzhihen_wq/article/details/41872365">配置eclipse linux嵌入式 集成开发环境（编译部分）详细</a></li>
<li><a href="http://m.itboth.com/d/BzIRZz/windows-eclipse-arm">eclipse在windows下的arm交叉编译环境搭建</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>linuxembedded linux</tag>
        <tag>ide</tag>
      </tags>
  </entry>
  <entry>
    <title>基于DHCP建立嵌入式Linux开发环境</title>
    <url>/2017/11/28/1738-dhcp-env/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/02/16/1705-linux-env/">嵌入式linux环境搭建-主机端</a></li>
<li><a href="https://draapho.github.io/2017/02/21/1707-jz2440-env/">嵌入式linux环境搭建-jz2440开发板</a></li>
<li><a href="https://draapho.github.io/2017/11/28/1738-dhcp-env/">基于DHCP建立嵌入式Linux开发环境</a></li>
</ul>
<p>之前的环境搭建都是基于静态IP的. 但有些网络不方便设置静态IP, 而必须使用动态IP.<br>针对这种情况, 介绍一下Windows主机, Ubuntu主机, 以及开发板全部使用DHCP动态IP的方法.</p>
<h1 id="主机端"><a href="#主机端" class="headerlink" title="主机端"></a>主机端</h1><p>Ubuntu安装好后, 默认就是dhcp分配动态IP地址.<br>那么在windows端的Putty, 我们需要使用Ubuntu的hostname, 而不是其IP地址即可.</p>
<p>方法很简单. Ubuntu的bash终端下面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hostname</span><br><span class="line">ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ uname -n</span><br><span class="line">ubuntu</span><br></pre></td></tr></table></figure>

<p>Windows下查看主机名<br>我的电脑-&gt;属性, <code>电脑名称</code>就是主机名<br>或者cmd终端下面, 输入 <code>ipconfig -all</code><br>第一行就是 <code>Host Name</code>.</p>
<p>这样putty端直接使用 <code>hostname</code> 或者 <code>user@hostname</code> 就可以使用ssh远程登录了.</p>
<h1 id="开发板DHCP"><a href="#开发板DHCP" class="headerlink" title="开发板DHCP"></a>开发板DHCP</h1><p>开发板要支持dhcp比较复杂一点.<br>基本思路如下:</p>
<ul>
<li>嵌入式linux启动后, 自动启动dhcp联网.</li>
<li>嵌入式linux安装nfs client, 挂载Ubuntu上的nfs文件.</li>
<li>内核和文件系统需要烧录到开发板.</li>
<li>此方法适用于开发驱动和应用层软件.</li>
<li>新版本的uboot肯定支持dhcp, 但老版本的不确定, 不去吃螃蟹了.</li>
<li>有兴趣的参考 <a href="https://www.emcraft.com/som/using-dhcp"><br>Using DHCP Client in U-Boot for Loading Linux Images via Network</a></li>
</ul>
<h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><p>首先需要内核支持更多的网络特性.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pwd = linux-2.6.22.6</span></span><br><span class="line">cp config_ok .config</span><br><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行如下配置</span></span><br><span class="line">Networking  ---&gt;</span><br><span class="line">    [*] Networking support</span><br><span class="line">        Networking options  ---&gt;</span><br><span class="line">        &lt;* &gt; Packet socket                 <span class="comment"># 使能CONFIG_PACKET, socket包</span></span><br><span class="line">        [ * ]     IP: DHCP support         <span class="comment"># 使能DHCP</span></span><br><span class="line">        [ * ] Network packet filtering framework (Netfilter)  ---&gt;  <span class="comment"># 使能</span></span><br><span class="line">        <span class="comment"># 后面子选项可不选</span></span><br><span class="line"><span class="comment"># 保存并退回到终端</span></span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line">make uImage</span><br></pre></td></tr></table></figure>

<p>然后烧录新的内核到开发板.</p>
<ul>
<li>内核的编译和烧录可参考 <a href="https://draapho.github.io/2017/09/01/1722-kernel-compile/">kernel之编译体验</a></li>
<li>如果内核没有支持上述特性, 后面执行udhcpc时会报错: <code>Address family not supported by protocol</code></li>
</ul>
<h2 id="编译Busybox"><a href="#编译Busybox" class="headerlink" title="编译Busybox"></a><del>编译Busybox</del></h2><p>jz2440提供的文件系统包含udhcpc命令, 所以不用重新配置编译了.<br><strong>可跳过此步骤</strong>.</p>
<p>如果要自己做, 注意勾选下面的选项(有的版本默认支持dhcp指令)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Busybox Settings  ---&gt;</span><br><span class="line">    Busybox Library Tuning  ---&gt;</span><br><span class="line">    [*]   Tab completion                <span class="comment"># 指令自动填充, 非常必要的属性, 默认关闭...</span></span><br><span class="line"></span><br><span class="line">Networking Utilities  ---&gt;</span><br><span class="line">    [] udhcp Server (udhcpd)            <span class="comment"># 在此不作服务端，故不选。生成udhcpd命令</span></span><br><span class="line">    [*] udhcp Client (udhcpc)           <span class="comment"># 生成udhcpc命令</span></span><br></pre></td></tr></table></figure>

<p>针对嵌入式系统, 由于是交叉编译, Busybox编译和安装有特别的要求, 可参考:</p>
<ul>
<li><a href="https://draapho.github.io/2017/11/02/1730-fs-busybox/">fs之BusyBox的使用与编译</a></li>
</ul>
<h2 id="完善文件系统"><a href="#完善文件系统" class="headerlink" title="完善文件系统"></a>完善文件系统</h2><p>自己构建文件系统也很麻烦. 可以参考 <a href="https://draapho.github.io/2017/11/03/1731-fs-build/">fs之创建文件系统</a></p>
<p>我是基于jz2440提供的 <code>fs_mini_mdev</code> 修改后, 使其支持dhcp的<br>busybox包含的udhcpc没有提供运行脚本, 直接运行会报错:<br><code>udhcpc: exec /usr/share/udhcpc/default.script: No such file or directory</code></p>
<p>因此对整个文件系统的改造有如下步骤</p>
<ul>
<li>建立udhcpc要用的default.script</li>
<li>加入可执行属性</li>
<li>启动自动执行udhcpc指令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pwd = fs_mini_mdev_dhcp/</span></span><br><span class="line"></span><br><span class="line">mkdir -p ./usr/share/udhcpc/     <span class="comment"># 自动建立多层目录</span></span><br><span class="line">vim ./usr/share/udhcpc/default.script</span><br><span class="line"></span><br><span class="line"><span class="comment"># ===== 打开vim, 写入如下内容 =====</span></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">[ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Error: should be called from udhcpc&quot;</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line">RESOLV_CONF=<span class="string">&quot;/etc/resolv.conf&quot;</span></span><br><span class="line">[ -n <span class="string">&quot;<span class="variable">$broadcast</span>&quot;</span> ] &amp;&amp; BROADCAST=<span class="string">&quot;broadcast <span class="variable">$broadcast</span>&quot;</span></span><br><span class="line">[ -n <span class="string">&quot;<span class="variable">$subnet</span>&quot;</span> ] &amp;&amp; NETMASK=<span class="string">&quot;netmask <span class="variable">$subnet</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  deconfig)</span><br><span class="line">    /sbin/ifconfig <span class="variable">$interface</span> 0.0.0.0</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">  renew|bound)</span><br><span class="line">    /sbin/ifconfig <span class="variable">$interface</span> <span class="variable">$ip</span> <span class="variable">$BROADCAST</span> <span class="variable">$NETMASK</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$router</span>&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;deleting routers&quot;</span></span><br><span class="line">      <span class="keyword">while</span> route del default gw 0.0.0.0 dev <span class="variable">$interface</span> ; <span class="keyword">do</span></span><br><span class="line">        :</span><br><span class="line">      <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$router</span> ; <span class="keyword">do</span></span><br><span class="line">        route add default gw <span class="variable">$i</span> dev <span class="variable">$interface</span></span><br><span class="line">      <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> -n &gt; <span class="variable">$RESOLV_CONF</span></span><br><span class="line">    [ -n <span class="string">&quot;<span class="variable">$domain</span>&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> search <span class="variable">$domain</span> &gt;&gt; <span class="variable">$RESOLV_CONF</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$dns</span> ; <span class="keyword">do</span></span><br><span class="line">      <span class="built_in">echo</span> adding dns <span class="variable">$i</span></span><br><span class="line">      <span class="built_in">echo</span> nameserver <span class="variable">$i</span> &gt;&gt; <span class="variable">$RESOLV_CONF</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line"><span class="comment"># ===== wq保存文件, 退出 =====</span></span><br><span class="line"></span><br><span class="line">chmod +x ./usr/share/udhcpc/default.script       <span class="comment"># 加入可执行属性</span></span><br><span class="line"></span><br><span class="line">vim ./etc/init.d/rcS             <span class="comment"># 开机自动执行udhcpc. S是大写!</span></span><br><span class="line"><span class="comment"># ===== 打开vim, 修改/增加如下内容 =====</span></span><br><span class="line"><span class="comment"># ifconfig eth0 192.168.1.17</span></span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc eth0</span><br><span class="line"><span class="comment"># 上述两行放在最前面. 这样才能成功自动挂载nfs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ===== wq保存文件, 退出 =====</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim ./etc/fstab</span><br><span class="line"><span class="comment"># ===== 打开vim, 增加如下内容 =====</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件最后加入这样一句nfs模板, 便于日后修改</span></span><br><span class="line"><span class="comment"># 192.168.1.100:/home/share /mnt/share nfs rsize=1024,wsize=1024,timeo=14,intr,nolock 0 0</span></span><br><span class="line"><span class="comment"># ===== wq保存文件, 退出 =====</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 制作文件系统</span></span><br><span class="line"><span class="comment"># pwd = fs_mini_mdev_dhcp/..</span></span><br><span class="line">mkyaffs2image fs_mini_mdev_dhcp fs_mini_mdev_dhcp.yaffs2</span><br></pre></td></tr></table></figure>

<p>上述工作完成后, 烧录到开发板即可. 详情可参考:<a href="https://draapho.github.io/2017/11/03/1731-fs-build/">fs之创建文件系统</a></p>
<h2 id="开发板测试"><a href="#开发板测试" class="headerlink" title="开发板测试"></a>开发板测试</h2><p>烧录好内核和文件系统后, 开机测试一下.<br>注意, udhcpc比较傻, 如果不能联网, 开机就会死在 <code>Sending discover...</code><br>成功启动后, 使用 <code>ifconfig</code> 就可以看到dhcp自动分配的ip地址了.</p>
<p>所以也有人用别的方式实现dhcp. 我没有尝试, 列在这里供参考</p>
<ul>
<li><a href="http://www.linuxidc.com/Linux/2011-05/36038.htm">成功移植DHCP客户端到mini2440</a>, 用的 dhclient 指令</li>
<li><a href="https://wenku.baidu.com/view/bca0c470e418964bcf84b9d528ea81c758f52ed1.html">jz2440自动获取ip地址</a>, 源码编译udhcpc, 估计里面会有 default.script 文件.</li>
</ul>
<h1 id="开发板挂载nfs"><a href="#开发板挂载nfs" class="headerlink" title="开发板挂载nfs"></a>开发板挂载nfs</h1><p>主机端 nfs环境搭建参考: <a href="https://draapho.github.io/2017/11/29/1739-ubuntu-nfs/">Ubuntu 16.04安装配置NFS</a></p>
<p>在开发板上挂载服务器共享的目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pwd = /</span></span><br><span class="line">$ mkdir mnt/share          <span class="comment"># 挂载点</span></span><br><span class="line">$ ln -s mnt/share share    <span class="comment"># 创建软连接</span></span><br><span class="line"></span><br><span class="line">$ mount -t nfs -o nolock 192.168.1.100:/home/share /mnt/share/</span><br><span class="line">$ df -h                     <span class="comment"># 查看挂载的文件系统.</span></span><br><span class="line">$ ls share                  <span class="comment"># 查看一下是否可以看到共享内容了.</span></span><br></pre></td></tr></table></figure>


<p>每次开机敲一长串 mount 指令也挺麻烦的, 进一步偷懒, 让它开机自启动.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板终端, 修改fstab, 让 mount -a 自动加载nfs</span></span><br><span class="line">$ vi /etc/fstab</span><br><span class="line"><span class="comment"># ===== 打开vi, 修改/增加如下内容 =====</span></span><br><span class="line">192.168.1.111:/home/share /mnt/share nfs rsize=1024,wsize=1024,timeo=14,intr,nolock 0 0</span><br><span class="line"><span class="comment"># ===== wq保存文件, 退出 =====</span></span><br><span class="line"></span><br><span class="line">$ mount -a                  <span class="comment"># 重新加载</span></span><br><span class="line">$ df -h                     <span class="comment"># 查看挂载的文件系统.</span></span><br><span class="line">$ ls share                  <span class="comment"># 查看一下是否可以看到共享内容了.</span></span><br></pre></td></tr></table></figure>

<p>下次重启就能自动加载nfs了. <strong>如果加载失败, 看看是不是主机动态IP变掉了</strong>.<br>jz2440启动后, 加载nfs失败时, 需要等待一段时间才能进入终端界面!</p>
<h2 id="使用hostname"><a href="#使用hostname" class="headerlink" title="使用hostname"></a>使用hostname</h2><p>这里, 最理想的情况是使用 hostname 而不是IP地址.<br>但网上搜索了一下, 没有找到让jz2440支持hostname的方法.<br>动态IP也不会更换的太频繁, 所以是一个可以忍受的缺点, 就不去深究了.<br>关键点是 <code>/etc/resolv.conf</code>, 应该可以由udhcpc自动生成内容的…<br>找了如下相关信息:</p>
<ul>
<li><a href="http://blog.csdn.net/mybelief321/article/details/10049429">linux根文件系统 /etc/resolv.conf 文件详解</a></li>
<li><a href="http://www.voidcn.com/article/p-yruxiyxx-nk.html">linux系统2440开发板域名解析问题</a></li>
<li><a href="http://www.cnblogs.com/zjzsky/p/3559367.html">JZ2440开发笔记（4）——设置静态IP</a></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://blog.csdn.net/ruglcc/article/details/7802077">ubuntu永久修改主机名</a></li>
<li><a href="http://felix-lin.com/linux/busybox-%E6%87%89%E7%94%A8-udhcpc/">BusyBox 應用 – udhcpc</a></li>
<li><a href="https://wenku.baidu.com/view/bca0c470e418964bcf84b9d528ea81c758f52ed1.html">jz2440自动获取ip地址</a></li>
<li><a href="https://linoxide.com/file-system/example-linux-nfs-mount-entry-in-fstab-etcfstab/">Linux NFS Mount Entry In fstab ( /etc/fstab ) With Example</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_76c545390100sscr.html">ubuntu下 mini2440的NFS挂载【终极版】</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>linuxembedded linux</tag>
        <tag>env</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04安装配置NFS</title>
    <url>/2017/11/29/1739-ubuntu-nfs/</url>
    <content><![CDATA[<p>转载自 <a href="http://blog.topspeedsnail.com/archives/908">Ubuntu 16.04安装配置NFS</a><br><strong>略有改动和增加</strong></p>
<hr>
<p>NFS允许用户通过网络分享目录和文件，客户端用户可以像操作本地文件一样操作服务端文件。</p>
<h1 id="NFS服务端"><a href="#NFS服务端" class="headerlink" title="NFS服务端"></a>NFS服务端</h1><p>安装nfs-kernel-server：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install nfs-kernel-server</span><br></pre></td></tr></table></figure>

<h1 id="NFS客户端"><a href="#NFS客户端" class="headerlink" title="NFS客户端"></a>NFS客户端</h1><p>安装 nfs-common：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install nfs-common</span><br></pre></td></tr></table></figure>

<h1 id="服务端创建共享目录"><a href="#服务端创建共享目录" class="headerlink" title="服务端创建共享目录"></a>服务端创建共享目录</h1><p>客户端通过远程挂载的方式访问服务端共享目录，为了说明两种不同的文件权限，我会使用不同的选项创建两个共享目录。</p>
<ul>
<li>默认情况下客户端不允许在NFS共享目录上执行root操作，如：更改文件所有权等。</li>
<li>但是有时用户需要用root权限操作NFS共享目录，这可以通过配置实现。</li>
</ul>
<h2 id="创建默认配置的共享目录"><a href="#创建默认配置的共享目录" class="headerlink" title="创建默认配置的共享目录"></a>创建默认配置的共享目录</h2><p>创建一个目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo mkdir -p /var/nfs/sharedir</span><br></pre></td></tr></table></figure>

<p>更改目录权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo chown nobody:nogroup /var/nfs/sharedir</span><br></pre></td></tr></table></figure>

<h2 id="以root权限共享home目录"><a href="#以root权限共享home目录" class="headerlink" title="以root权限共享home目录"></a>以root权限共享home目录</h2><p>配置NFS：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo vim &#x2F;etc&#x2F;exports</span><br></pre></td></tr></table></figure>

<p>如下格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;var&#x2F;nfs&#x2F;sharedir   *(rw,sync,no_subtree_check)</span><br><span class="line">&#x2F;home               *(rw,sync,no_root_squash,no_subtree_check)</span><br><span class="line"></span><br><span class="line"># 要限制客户端IP</span><br><span class="line"># &#x2F;var&#x2F;nfs&#x2F;sharedir 122.111.222.111(rw,sync,no_subtree_check)</span><br><span class="line"># &#x2F;home             122.111.222.111(rw,sync,no_root_squash,no_subtree_check)</span><br></pre></td></tr></table></figure>

<p>下面是一些NFS共享的常用参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>rw</td>
<td>可读写的权限</td>
</tr>
<tr>
<td>ro</td>
<td>只读的权限</td>
</tr>
<tr>
<td>no_root_squash</td>
<td>权限不压缩, 远程客户端拥有root权限. (不安全, 但嵌入式要用!)</td>
</tr>
<tr>
<td>root_squash</td>
<td>权限压缩, 远程客户端root权限压缩成为匿名使用者(默认)</td>
</tr>
<tr>
<td>sync</td>
<td>资料同步写入到内存与硬盘当中</td>
</tr>
<tr>
<td>async</td>
<td>资料会先暂存于内存当中，而非直接写入硬盘</td>
</tr>
<tr>
<td>hide</td>
<td>不共享子目录</td>
</tr>
<tr>
<td>no_hide</td>
<td>共享子目录</td>
</tr>
<tr>
<td>subtree_check</td>
<td>共享子目录时, 检查父目录的权限(默认)</td>
</tr>
<tr>
<td>no_subtree_check</td>
<td>共享子目录时, 不检查父目录的权限</td>
</tr>
</tbody></table>
<p>重启nfs-kernel-server：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl restart nfs-kernel-server</span><br></pre></td></tr></table></figure>
<p>如果开启了防火墙，打开NFS的2049端口。</p>
<p>查看共享文件情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ showmount -e</span><br><span class="line">/home *</span><br></pre></td></tr></table></figure>


<h1 id="客户端挂载共享目录"><a href="#客户端挂载共享目录" class="headerlink" title="客户端挂载共享目录"></a>客户端挂载共享目录</h1><p><strong>此方法不适用于嵌入式Linux!</strong></p>
<p>创建两个挂载点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo mkdir -p /nfs/sharedir</span><br><span class="line">$ sudo mkdir -p /nfs/home</span><br></pre></td></tr></table></figure>

<p>挂载远程共享目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo mount nfs_server_ip:/var/nfs/sharedir /nfs/sharedir</span><br><span class="line">$ sudo mount nfs_server_ip:/home /nfs/home</span><br></pre></td></tr></table></figure>

<p>查看挂载点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ df -h</span><br><span class="line">Filesystem                       Size  Used Avail Use% Mounted on</span><br><span class="line">udev                             861M     0  861M   0% /dev</span><br><span class="line">...</span><br><span class="line">192.168.0.100:/var/nfs/sharedir   29G  4.5G   23G  17% /nfs/sharedir</span><br><span class="line">192.168.0.100:/home               29G  4.5G   23G  17% /nfs/home</span><br></pre></td></tr></table></figure>
<p>现在你可以使用共享目录了。</p>
<p>使用完之后不要忘了卸载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo umount /nfs/home</span><br><span class="line">$ sudo umount /nfs/sharedir</span><br></pre></td></tr></table></figure>


<h1 id="开机自动挂载NFS共享目录"><a href="#开机自动挂载NFS共享目录" class="headerlink" title="开机自动挂载NFS共享目录"></a>开机自动挂载NFS共享目录</h1><p>编辑fstab文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/fstab</span><br></pre></td></tr></table></figure>

<p>添加如下两行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">your_nfs_server_Ip:&#x2F;var&#x2F;nfs&#x2F;sharedir    &#x2F;nfs&#x2F;sharedir   nfs auto,nofail,noatime,nolock,intr,tcp,actimeo&#x3D;1800 0 0</span><br><span class="line">your_nfs_server_Ip:&#x2F;home                &#x2F;nfs&#x2F;home       nfs auto,nofail,noatime,nolock,intr,tcp,actimeo&#x3D;1800 0 0</span><br></pre></td></tr></table></figure>

<p>或者使用hostname</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nfs_server_hostname:&#x2F;var&#x2F;nfs&#x2F;sharedir   &#x2F;nfs&#x2F;sharedir   nfs auto,nofail,noatime,nolock,intr,tcp,actimeo&#x3D;1800 0 0</span><br><span class="line">nfs_server_hostname:&#x2F;home               &#x2F;nfs&#x2F;home       nfs auto,nofail,noatime,nolock,intr,tcp,actimeo&#x3D;1800 0 0</span><br></pre></td></tr></table></figure>


<hr>
<p>转载自 <a href="http://blog.topspeedsnail.com/archives/908">Ubuntu 16.04安装配置NFS</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>nfs</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之基于LinK+设计按键驱动</title>
    <url>/2017/11/30/1740-drv-chr2/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/11/22/1733-drv-chr1/">驱动之字符设备-框架</a></li>
<li><a href="https://draapho.github.io/2017/11/30/1740-drv-chr2/">驱动之基于LinK+设计按键驱动</a></li>
<li><a href="https://draapho.github.io/2017/12/07/1741-drv-chr3/">驱动之基于中断设计按键驱动</a></li>
<li><a href="https://draapho.github.io/2017/12/11/1742-drv-chr4/">驱动之poll机制</a></li>
<li><a href="https://draapho.github.io/2017/12/12/1743-drv-chr5/">驱动之异步通知</a></li>
<li><a href="https://draapho.github.io/2017/12/13/1744-drv-chr6/">驱动之同步互斥阻塞</a></li>
<li><a href="https://draapho.github.io/2018/01/04/1801-drv-chr7/">驱动之定时器按键防抖</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<p>上文<a href="https://draapho.github.io/2017/11/22/1733-drv-chr1/">驱动之字符设备-框架</a>是根据jz2440教程书写的. 整个过程比较繁杂.<br>在此期间, 搜索了一下Linux内核开发工具, 寻得一款非常好用的 Link+IDE, 安装配置见 <a href="https://draapho.github.io/2017/11/27/1737-linux-ide/">LinK+, 一款Linux内核开发IDE</a>.<br>这款软件可以自动生成Linux驱动开发的软件模板, 可以大大减少工作量, 提高效率!<br>因此, 此文基于LinK+的生成的驱动框架, 对按键驱动进行开发.</p>
<h1 id="使用LinK-生成驱动模板"><a href="#使用LinK-生成驱动模板" class="headerlink" title="使用LinK+生成驱动模板"></a>使用LinK+生成驱动模板</h1><p>打开 LinK+IDE, 新建工程, 选择 <code>Linux Kernel Development(LinK+)</code> 下面的 <code>Device Driver Project</code><br>然后如图配置即可.</p>
<p><img src="https://draapho.github.io/images/1740/LinKDriverWizard1.JPG" alt="LinKDriverWizard1.JPG"></p>
<p><img src="https://draapho.github.io/images/1740/LinKDriverWizard2.JPG" alt="LinKDriverWizard2.JPG"></p>
<p>确定后, LinK+IDE会自动生成代码, 基于这个代码模板, 去实现按键功能函数即可.</p>
<p><strong>注意</strong> 自动生成的模板中, 函数<code>device_create</code>和linux-2.6.22.6不兼容, 需要去掉最后一个NULL!<br>不修改的话, 编译时有个警告, 尝试加载模块时会报错:<br><code>Unable to handle kernel NULL pointer dereference at virtual address 00000000</code></p>
<h2 id="加载已有工程"><a href="#加载已有工程" class="headerlink" title="加载已有工程"></a>加载已有工程</h2><p>如果已有驱动工程, 需要加入 LinK+. 核心思路就是基于Makefile编译, 而不是用Eclipse自带的工具链编译.<br>基本过程可以参考<a href="https://draapho.github.io/2017/11/27/1737-linux-ide/">LinK+, 一款Linux内核开发IDE</a>, 但比内核的设置要简单的多.</p>
<ul>
<li><code>New Project...</code> -&gt; <code>C/C++</code>下<code>Makefile Project with Existing Code</code> -&gt; 选好项目路径, <code>Finish</code> 打开</li>
<li>右键工程 <code>Properties</code><ul>
<li>选中<code>C/C++ Build</code>-&gt;右边<code>Builder Settings</code>标签:<ul>
<li>取消 <del><code>Use default build command</code></del>, 编译命令就是 <code>make</code></li>
<li>确定 <code>Build directory</code> 路径是makefile所在的路径, 如 <code>$&#123;workspace_loc:/drv_key/KERN_SRC&#125;</code></li>
</ul>
</li>
<li>选中<code>C/C++ Build</code>-&gt;右边<code>Behaviour</code>标签:<ul>
<li><code>Build(incremental build)</code>, 改为 <code>modules</code>. 组成编译指令 <code>make modules</code></li>
</ul>
</li>
<li>展开<code>C/C++ General</code>-&gt;选中<code>Paths and Symbols</code>-&gt;右边<code>Includes</code>标签<ul>
<li><code>Add...</code>, 新增 <code>/linux-2.6.22.6/include</code> 路径到所有配置, 所有语言.</li>
</ul>
</li>
</ul>
</li>
<li>右键工程 <code>Clean Project</code>, 相当于执行 <code>make clean</code></li>
<li>右键工程 <code>Build Project</code>, 相当于执行 <code>make modules</code>, 编译完成.</li>
</ul>
<h1 id="驱动源码"><a href="#驱动源码" class="headerlink" title="驱动源码"></a>驱动源码</h1><h2 id="drv-key-c"><a href="#drv-key-c" class="headerlink" title="drv_key.c"></a>drv_key.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">Driver Name     :       drv_key</span></span><br><span class="line"><span class="comment">Author          :       DRAAPHO</span></span><br><span class="line"><span class="comment">License         :       GPL</span></span><br><span class="line"><span class="comment">Description     :       LINUX DEVICE DRIVER PROJECT</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;drv_key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEY_N_MINORS 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEY_FIRST_MINOR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEY_NODE_NAME <span class="meta-string">&quot;key&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEY_BUFF_SIZE 1</span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> drv_key_major=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">dev_t</span> drv_key_device_num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">drv_key_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">privatedata</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nMinor;</span><br><span class="line">    <span class="keyword">char</span> buff[DRV_KEY_BUFF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">drv_key_device</span>;</span></span><br><span class="line">&#125; drv_key_private;</span><br><span class="line"></span><br><span class="line">drv_key_private devices[DRV_KEY_N_MINORS];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_key_open</span><span class="params">(struct inode *inode,struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function */</span></span><br><span class="line">    drv_key_private *priv = container_of(inode-&gt;i_cdev ,</span><br><span class="line">                                    drv_key_private ,cdev);</span><br><span class="line">    filp-&gt;private_data = priv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((priv-&gt;nMinor == <span class="number">0</span>) || (priv-&gt;nMinor == <span class="number">1</span>))</span><br><span class="line">        s3c2410_gpio_cfgpin(S3C2410_GPF0, S3C2410_GPF0_INP);</span><br><span class="line">    <span class="keyword">if</span> ((priv-&gt;nMinor == <span class="number">0</span>) || (priv-&gt;nMinor == <span class="number">2</span>))</span><br><span class="line">        s3c2410_gpio_cfgpin(S3C2410_GPF2, S3C2410_GPF2_INP);</span><br><span class="line">    <span class="keyword">if</span> ((priv-&gt;nMinor == <span class="number">0</span>) || (priv-&gt;nMinor == <span class="number">3</span>))</span><br><span class="line">        s3c2410_gpio_cfgpin(S3C2410_GPG3, S3C2410_GPG3_INP);</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;minor=%d\n&quot;</span>, priv-&gt;nMinor);</span><br><span class="line">    PINFO(<span class="string">&quot;In char driver open() function\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static int drv_key_release(struct inode *inode,struct file *filp)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//  /* TODO Auto-generated Function */</span></span><br><span class="line"><span class="comment">//  drv_key_private *priv;</span></span><br><span class="line"><span class="comment">//  priv=filp-&gt;private_data;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  PINFO(&quot;In char driver release() function\n&quot;);</span></span><br><span class="line"><span class="comment">//  return 0;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">drv_key_read</span><span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span> __user *ubuff,<span class="keyword">size_t</span> count,<span class="keyword">loff_t</span> *offp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function */</span></span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> key_vals[<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    drv_key_private *priv;</span><br><span class="line">    priv = filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((priv-&gt;nMinor == <span class="number">0</span>) || (priv-&gt;nMinor == <span class="number">1</span>))</span><br><span class="line">        key_vals[<span class="number">0</span>] = !s3c2410_gpio_getpin(S3C2410_GPF0);</span><br><span class="line">    <span class="keyword">if</span> ((priv-&gt;nMinor == <span class="number">0</span>) || (priv-&gt;nMinor == <span class="number">2</span>))</span><br><span class="line">        key_vals[<span class="number">1</span>] = !s3c2410_gpio_getpin(S3C2410_GPF2);</span><br><span class="line">    <span class="keyword">if</span> ((priv-&gt;nMinor == <span class="number">0</span>) || (priv-&gt;nMinor == <span class="number">3</span>))</span><br><span class="line">        key_vals[<span class="number">2</span>] = !s3c2410_gpio_getpin(S3C2410_GPG3);</span><br><span class="line">    copy_to_user(ubuff, key_vals, <span class="keyword">sizeof</span>(key_vals));</span><br><span class="line"></span><br><span class="line"><span class="comment">//  PINFO(&quot;In char driver read() function\n&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">drv_key_fops</span>=</span> &#123;</span><br><span class="line">    .owner              = THIS_MODULE,</span><br><span class="line">    .open               = drv_key_open,</span><br><span class="line"><span class="comment">//  .release            = drv_key_release,</span></span><br><span class="line">    .read               = drv_key_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">drv_key_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    res = alloc_chrdev_region(&amp;drv_key_device_num,DRV_KEY_FIRST_MINOR,DRV_KEY_N_MINORS ,DRIVER_NAME);</span><br><span class="line">    <span class="keyword">if</span>(res) &#123;</span><br><span class="line">        PERR(<span class="string">&quot;register device no failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    drv_key_major = MAJOR(drv_key_device_num);</span><br><span class="line">    drv_key_class = class_create(THIS_MODULE , DRIVER_NAME);</span><br><span class="line">    <span class="keyword">if</span>(!drv_key_class) &#123;</span><br><span class="line">        PERR(<span class="string">&quot;class creation failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;DRV_KEY_N_MINORS;i++) &#123;</span><br><span class="line">        drv_key_device_num= MKDEV(drv_key_major ,DRV_KEY_FIRST_MINOR+i);</span><br><span class="line">        cdev_init(&amp;devices[i].cdev , &amp;drv_key_fops);</span><br><span class="line">        cdev_add(&amp;devices[i].cdev,drv_key_device_num,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        devices[i].drv_key_device  =</span><br><span class="line">                <span class="comment">// BE CARE, device_create has different parameters...</span></span><br><span class="line"><span class="comment">//              device_create(drv_key_class , NULL ,drv_key_device_num ,</span></span><br><span class="line"><span class="comment">//                          NULL ,DRV_KEY_NODE_NAME&quot;%d&quot;,DRV_KEY_FIRST_MINOR+i);</span></span><br><span class="line">                device_create(drv_key_class , <span class="literal">NULL</span> ,drv_key_device_num ,</span><br><span class="line">                            DRV_KEY_NODE_NAME<span class="string">&quot;%d&quot;</span>,DRV_KEY_FIRST_MINOR+i);</span><br><span class="line">        <span class="keyword">if</span>(!devices[i].drv_key_device) &#123;</span><br><span class="line">            class_destroy(drv_key_class);</span><br><span class="line">            PERR(<span class="string">&quot;device creation failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        devices[i].nMinor = DRV_KEY_FIRST_MINOR+i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;INIT\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">drv_key_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    PINFO(<span class="string">&quot;EXIT\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;DRV_KEY_N_MINORS;i++) &#123;</span><br><span class="line">        drv_key_device_num= MKDEV(drv_key_major ,DRV_KEY_FIRST_MINOR+i);</span><br><span class="line"></span><br><span class="line">        cdev_del(&amp;devices[i].cdev);</span><br><span class="line"></span><br><span class="line">        device_destroy(drv_key_class ,drv_key_device_num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    class_destroy(drv_key_class);</span><br><span class="line">    unregister_chrdev_region(drv_key_device_num ,DRV_KEY_N_MINORS);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(drv_key_init);</span><br><span class="line">module_exit(drv_key_exit);</span><br></pre></td></tr></table></figure>

<h2 id="drv-key-h"><a href="#drv-key-h" class="headerlink" title="drv_key.h"></a>drv_key.h</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_NAME <span class="meta-string">&quot;drv_key&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDEBUG(fmt,args...) printk(KERN_DEBUG<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERR(fmt,args...) printk(KERN_ERR<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME,##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINFO(fmt,args...) printk(KERN_INFO<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/hardware.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m       := drv_key.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">install:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules_install</span><br><span class="line">    depmod -a</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<h2 id="测试文件-drv-key-test-c"><a href="#测试文件-drv-key-test-c" class="headerlink" title="测试文件 drv_key_test.c"></a>测试文件 drv_key_test.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_usage</span><span class="params">(<span class="keyword">char</span> *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s &lt;dev&gt;\n&quot;</span>,file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;eg. \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s /dev/key0\n&quot;</span>, file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s /dev/key1\n&quot;</span>, file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span>* filename;</span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;                        <span class="comment">// 输入错误, 打印帮助信息</span></span><br><span class="line">        print_usage(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    filename = argv[<span class="number">1</span>];</span><br><span class="line">    fd = open(filename, O_RDWR);            <span class="comment">// 打开设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error, can&#x27;t open %s\n&quot;</span>, filename);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> key_vals[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            read(fd, key_vals, <span class="keyword">sizeof</span>(key_vals));</span><br><span class="line">            <span class="keyword">if</span> (key_vals[<span class="number">0</span>] || key_vals[<span class="number">1</span>] || key_vals[<span class="number">2</span>]) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%04d key pressed: %d %d %d\n&quot;</span>, cnt++, key_vals[<span class="number">0</span>], key_vals[<span class="number">1</span>], key_vals[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="编译并测试"><a href="#编译并测试" class="headerlink" title="编译并测试"></a>编译并测试</h1><h2 id="Ubuntu主机端"><a href="#Ubuntu主机端" class="headerlink" title="Ubuntu主机端"></a>Ubuntu主机端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主机端, 编译源码</span></span><br><span class="line"><span class="comment"># pwd = /home/draapho/share/drv/drv_key/KERN_SRC    # 驱动源码路径, share是nfs共享文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译驱动</span></span><br><span class="line">$ make clean</span><br><span class="line">$ make modules                  <span class="comment"># LinK+的Makefile使用的是 make modules 而不是 make all</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译测试代码</span></span><br><span class="line">$ arm-linux-gcc drv_key_test.c -o drv_key_test</span><br></pre></td></tr></table></figure>


<h2 id="开发板端"><a href="#开发板端" class="headerlink" title="开发板端"></a>开发板端</h2><p>开发环境上, 开发板烧录好内核, 使用nfs挂载共享文件. 所以无需任何文件传输的步骤.<br>开发环境的具体配置可参考: <a href="https://draapho.github.io/2017/11/28/1738-dhcp-env/">基于DHCP建立嵌入式Linux开发环境</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板端, 测试模块加载情况</span></span><br><span class="line"><span class="comment"># pwd = /home/draapho/share/drv/drv_key/KERN_SRC    # 驱动源码路径, share是nfs共享文件夹</span></span><br><span class="line"></span><br><span class="line">$ insmod drv_key.ko     <span class="comment"># 加载模块</span></span><br><span class="line">drv_key:INIT</span><br><span class="line"></span><br><span class="line">$ cat /proc/devices     <span class="comment"># 查看设备</span></span><br><span class="line">249 drv_key</span><br><span class="line">250 drv_key</span><br><span class="line">251 drv_key</span><br><span class="line">252 drv_key</span><br><span class="line"></span><br><span class="line">$ ls /dev/key*          <span class="comment"># 查看设备节点</span></span><br><span class="line">/dev/key0  /dev/key1  /dev/key2  /dev/key3</span><br><span class="line"></span><br><span class="line">$ ls /sys/class/drv_key/            <span class="comment"># 查看设备的类</span></span><br><span class="line">key0  key1  key2  key3</span><br><span class="line">$ cat /sys/class/drv_key/key3/dev   <span class="comment"># 查看设备号</span></span><br><span class="line">249:3</span><br><span class="line"></span><br><span class="line">$ rmmod drv_key.ko      <span class="comment"># 移除模块</span></span><br><span class="line">drv_key:EXIT</span><br></pre></td></tr></table></figure>

<p>下面进行按键测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板端, 测试驱动功能</span></span><br><span class="line"><span class="comment"># pwd = /home/draapho/share/drv/drv_key/KERN_SRC    # 驱动源码路径, share是nfs共享文件夹</span></span><br><span class="line"></span><br><span class="line">$ insmod drv_key.ko     <span class="comment"># 加载模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># key0-&gt;all, key1-&gt;s2, key2-&gt;s3, key3-&gt;s4</span></span><br><span class="line">$ ./drv_key_test /dev/key0          <span class="comment"># 检测所有按键</span></span><br><span class="line">drv_key:minor=0                     <span class="comment"># 打印信息</span></span><br><span class="line">drv_key:In char driver open() <span class="keyword">function</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># jz2440开发板按下按键, 就会打印按键信息. 1表示按下. 0表示松开.</span></span><br><span class="line"><span class="comment"># 按ctrl+c 终止进程</span></span><br><span class="line"></span><br><span class="line">$ ./drv_key_test /dev/key0 &amp;        <span class="comment"># 后台运行</span></span><br><span class="line">$ top                               <span class="comment"># 查看系统资源情况</span></span><br><span class="line"><span class="comment"># 可以看到 ./drv_key_test /dev/key0 进程表现还不错. %MEM=2% %CPU=0%</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">kill</span> &lt;PID&gt;                        <span class="comment"># 杀掉指定进程</span></span><br><span class="line"><span class="comment"># 这是因为我在测试代码的死循环里加了100ms的延时, 去掉usleep这行, 再测的话会变成:</span></span><br><span class="line"><span class="comment"># %CPU=99%</span></span><br></pre></td></tr></table></figure>

<p>结论: 这种方式的按键驱动是有巨大风险的, 因为其性能取决于应用层怎么写, 这是不可接受的!<br>实际开发中, 按键多半采用中断或poll方式.</p>
<h1 id="驱动框架的比较"><a href="#驱动框架的比较" class="headerlink" title="驱动框架的比较"></a>驱动框架的比较</h1><p>LinK+自动生成的框架和jz2440教程的框架主要有如下区别:</p>
<ul>
<li><code>alloc_chrdev_region</code> or <code>register_chrdev_region</code> vs <code>register_chrdev</code><ul>
<li>本质上没啥区别, 都会调用 <code>__register_chrdev_region()</code></li>
<li><a href="http://blog.csdn.net/freenaut/article/details/4298174">字符设备 register_chrdev_region()、alloc_chrdev_region() 和 register_chrdev()</a></li>
</ul>
</li>
<li><code>device_create</code> vs <code>class_device_create</code><ul>
<li>似乎是历史遗留问题, <code>device_create</code> 函数用于替换 <code>class_device_create</code>.</li>
<li><a href="http://blog.csdn.net/yuzaipiaofei/article/details/6790689">class_create(),class_device_create()或device_create()自动创建设备文件结点</a></li>
</ul>
</li>
<li>子设备号Minor获取上的区别.<ul>
<li>使用 private_data 更符合linux的规范</li>
</ul>
</li>
</ul>
<p>总体而言, jz2440的教程使用的框架比较老, LinK+使用的框架更合适高版本的linux内核.</p>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>linuxembedded linux</tag>
        <tag>drv</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之基于中断设计按键驱动</title>
    <url>/2017/12/07/1741-drv-chr3/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/11/22/1733-drv-chr1/">驱动之字符设备-框架</a></li>
<li><a href="https://draapho.github.io/2017/11/30/1740-drv-chr2/">驱动之基于LinK+设计按键驱动</a></li>
<li><a href="https://draapho.github.io/2017/12/07/1741-drv-chr3/">驱动之基于中断设计按键驱动</a></li>
<li><a href="https://draapho.github.io/2017/12/11/1742-drv-chr4/">驱动之poll机制</a></li>
<li><a href="https://draapho.github.io/2017/12/12/1743-drv-chr5/">驱动之异步通知</a></li>
<li><a href="https://draapho.github.io/2017/12/13/1744-drv-chr6/">驱动之同步互斥阻塞</a></li>
<li><a href="https://draapho.github.io/2018/01/04/1801-drv-chr7/">驱动之定时器按键防抖</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="Linux的中断实现"><a href="#Linux的中断实现" class="headerlink" title="Linux的中断实现"></a>Linux的中断实现</h1><h2 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h2><ul>
<li><code>trap_init</code>, 构造异常向量表<ul>
<li>位于 <code>arch/arm/kernel/traps.c</code>, 三个memcpy函数</li>
</ul>
</li>
<li><code>s3c24xx_init_irq</code> 芯片初始化 <code>struct irq_desc</code> 结构体.<ul>
<li>由 <code>MACHINE_START(S3C2440, &quot;SMDK2440&quot;)</code> 宏定义加入系统的初始化数据段 <code>&quot;.arch.info.init&quot;</code>.</li>
<li>位于 <code>arch/arm/plat-s3c24xx/irq.c</code></li>
<li><code>s3c24xx_init_irq</code> 会调用函数 <code>set_irq_chip</code>, <code>set_irq_handler</code> 完成irq的初始化</li>
</ul>
</li>
<li>cpu发生中断，跳到异常向量入口执行(<code>b vector_irq + stubs_offset</code>)<ul>
<li>位于 <code>arch/arm/kernel/entry-armv.S</code></li>
</ul>
</li>
<li><code>vector_irq</code> 用宏实现保存,执行(<code>asm_do_IRQ</code>),恢复.<ul>
<li><code>vector_irq</code> 由宏定义 <code>vector_stub</code> 而来</li>
<li>函数调用 <code>__irq_usr</code>-&gt;<code>irq_handler</code>-&gt;<code>asm_do_IRQ</code></li>
</ul>
</li>
<li><code>asm_do_IRQ</code> 根据中断号irq=(EINT4~EINT23)调用irq_desc[irq].handle_irq=(handle_edge_irq)<ul>
<li>位于 <code>arch/arm/kernel/irq.c</code>, 调用 <code>desc_handle_irq</code> 函数</li>
<li>handle_irq 的初始化由 <code>s3c24xx_init_irq</code> 完成, 位于 <code>arch/arm/plat-s3c24xx/irq.c</code></li>
</ul>
</li>
<li><code>handle_edge_irq</code> 使用chip成员中的函数=&amp;s3c_irqext_chip来设置硬件<ul>
<li>函数 <code>set_irq_chip</code>, 指定 <code>struct irq_chip</code> 结构,</li>
<li>此结构定义了中断的基本操作, 譬如启动, 关闭, 使能, 禁止, 触发条件, 响应(ack), mask 等等.</li>
</ul>
</li>
<li><code>handle_edge_irq</code> 逐个调用用户在irq_desc[irq].action连表中注册的处理函数<ul>
<li>函数 <code>set_irq_handler</code>, 实际调用 <code>__set_irq_handler</code></li>
<li>此函数指定了 <code>struct irq_desc</code> 结构, 其中 <code>action</code> 维护用户回调函数链表.</li>
</ul>
</li>
<li>用户注册中断服务程序 <code>request_irq</code>include/linux/irq.h<ul>
<li>供内核驱动代码调用</li>
<li>分配一个 <code>irqaction</code> 结构</li>
<li>将其加入<code>irq_desc[irq].action</code>中</li>
<li>设置中断触发方式和引脚状态 <code>desc-&gt;chip-&gt;set_type()</code></li>
<li>使能中断</li>
</ul>
</li>
<li>卸载中断服务程序 <code>free_irq</code><ul>
<li>供内核驱动代码调用</li>
<li>由irq号定位action链表, 然后将其删掉</li>
<li>关闭中断</li>
</ul>
</li>
</ul>
<h2 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h2><ul>
<li><a href="http://blog.csdn.net/czg13548930186/article/details/77715829">字符设备驱动-Linux内核异常处理体系结构</a></li>
<li><a href="http://blog.csdn.net/czg13548930186/article/details/77751916">字符设备驱动-中断方式操控按键</a></li>
<li><a href="http://www.wowotech.net/irq_subsystem/irq_handler.html">Linux kernel的中断子系统之（六）：ARM中断处理过程</a></li>
</ul>
<h1 id="驱动源码"><a href="#驱动源码" class="headerlink" title="驱动源码"></a>驱动源码</h1><h2 id="核心点"><a href="#核心点" class="headerlink" title="核心点"></a>核心点</h2><p>此次为中断的驱动源码, 核心点有2个地方</p>
<ul>
<li><code>request_irq</code> <code>free_irq</code><ul>
<li>这两个函数用于注册和释放中断号, 重点说注册</li>
<li>调用<code>request_irq</code>后, 对应的中断会自动初始化并使能.</li>
<li>相应的调用<code>free_irq</code>后, 对应的中断会自动被屏蔽掉.</li>
<li><code>irq</code>, 中断号. 见<code>#include &lt;asm/arch-s3c2410/irqs.h&gt;</code></li>
<li><code>handler</code>, 由驱动编程人员实现的回调函数</li>
<li><code>irqflags</code>, 中断触发类型, 见<code>#include &lt;asm/arch-s3c2410/irqs.h&gt;</code></li>
<li><code>*devname</code>, 自己给中断取个名字, 和驱动的设备名称无关. 会在 <code>cat /proc/interrupts</code> 下面显示出来.</li>
<li><code>*dev_id</code>, 可以认为是中断设备的ID号, 但此处习惯于导入驱动自用的数据结构指针.</li>
</ul>
</li>
<li><code>wake_up_interruptible</code> <code>wait_event_interruptible</code><ul>
<li>用了这两个函数, 才会真正提高系统的运行效率.</li>
<li>其概念是, 中断触发时, 调用 <code>wake_up_interruptible</code>, 告知中断发生, 需要处理</li>
<li>此时, <code>wait_event_interruptible</code> 就会被唤醒, 判断条件后, 决定是继续执行还是进程睡眠.</li>
</ul>
</li>
</ul>
<h2 id="drv-key-int-c"><a href="#drv-key-int-c" class="headerlink" title="drv_key_int.c"></a>drv_key_int.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">Driver Name     :       drv_key_int</span></span><br><span class="line"><span class="comment">Author          :       DRAAPHO</span></span><br><span class="line"><span class="comment">License         :       GPL</span></span><br><span class="line"><span class="comment">Description     :       LINUX DEVICE DRIVER PROJECT, 由LinK+生成模板, 部分修改而来.</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;drv_key_int.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEY_INT_N_MINORS 1              <span class="comment">// 三个按键, 但作为一个字符设备就可以了.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEY_INT_FIRST_MINOR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEY_INT_NODE_NAME <span class="meta-string">&quot;key_int&quot;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> drv_key_int_major=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dev_t</span> drv_key_int_device_num;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">drv_key_int_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">privatedata</span> &#123;</span>                <span class="comment">// 驱动私有结构, 模板生成, 此驱动没用.</span></span><br><span class="line">    <span class="keyword">int</span> nMinor;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">drv_key_int_device</span>;</span></span><br><span class="line">&#125; drv_key_int_private;</span><br><span class="line"></span><br><span class="line">drv_key_int_private devices[DRV_KEY_INT_N_MINORS];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 中断驱动增加的代码 =====</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(key_waitq)</span></span>;  <span class="comment">// 作用类似于信号量, 这里是向系统加入一个等待列表.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> ev_press = <span class="number">0</span>;           <span class="comment">// 中断事件标记, 手动值1或者清0</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> keys_val;              <span class="comment">// 记录按键值</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pin_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pin;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> key_val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pin_desc</span> <span class="title">pins_desc</span>[3] =</span> &#123;            <span class="comment">// 设置好按键的引脚和对应的值</span></span><br><span class="line">    &#123;S3C2410_GPF0, <span class="number">0x01</span>&#125;,</span><br><span class="line">    &#123;S3C2410_GPF2, <span class="number">0x02</span>&#125;,</span><br><span class="line">    &#123;S3C2410_GPG3, <span class="number">0x04</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">keys_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pin_desc</span> * <span class="title">pindesc</span> =</span> (struct pin_desc *)dev_id;  <span class="comment">// 获取自用的数据指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pinval;</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;keys_irq, irq=%d\n&quot;</span>, irq);</span><br><span class="line">    pinval = s3c2410_gpio_getpin(pindesc-&gt;pin);             <span class="comment">// 读取按键电平</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pinval) &#123;                                           <span class="comment">// 松开</span></span><br><span class="line">        keys_val &amp;= ~pindesc-&gt;key_val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                <span class="comment">// 按下</span></span><br><span class="line">        keys_val |= pindesc-&gt;key_val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ev_press = <span class="number">1</span>;                                           <span class="comment">// 表示中断发生</span></span><br><span class="line">    wake_up_interruptible(&amp;key_waitq);                      <span class="comment">// 唤醒休眠的进程</span></span><br><span class="line">    <span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 部分修改模板代码 =====</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_key_int_open</span><span class="params">(struct inode *inode,struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function */</span></span><br><span class="line">    drv_key_int_private *priv = container_of(inode-&gt;i_cdev ,</span><br><span class="line">                                    drv_key_int_private ,cdev);</span><br><span class="line">    filp-&gt;private_data = priv;</span><br><span class="line">    PINFO(<span class="string">&quot;In char driver open() function\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册中断号, 设置中断类型, 设置中断名称(和设备名称无关), 传入自用的数据指针</span></span><br><span class="line">    ret  = request_irq(IRQ_EINT0, keys_irq, IRQT_BOTHEDGE, <span class="string">&quot;S2&quot;</span>, &amp;pins_desc[<span class="number">0</span>]);</span><br><span class="line">    ret |= request_irq(IRQ_EINT2, keys_irq, IRQT_BOTHEDGE, <span class="string">&quot;S3&quot;</span>, &amp;pins_desc[<span class="number">1</span>]);</span><br><span class="line">    ret |= request_irq(IRQ_EINT11, keys_irq, IRQT_BOTHEDGE, <span class="string">&quot;S4&quot;</span>, &amp;pins_desc[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_key_int_release</span><span class="params">(struct inode *inode,struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function */</span></span><br><span class="line">    drv_key_int_private *priv;</span><br><span class="line">    priv=filp-&gt;private_data;</span><br><span class="line">    PINFO(<span class="string">&quot;In char driver release() function\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    free_irq(IRQ_EINT11, &amp;pins_desc[<span class="number">2</span>]);                    <span class="comment">// 注销中断</span></span><br><span class="line">    free_irq(IRQ_EINT2, &amp;pins_desc[<span class="number">1</span>]);</span><br><span class="line">    free_irq(IRQ_EINT0, &amp;pins_desc[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">drv_key_int_read</span><span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span> __user *ubuff,<span class="keyword">size_t</span> count,<span class="keyword">loff_t</span> *offp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function */</span></span><br><span class="line">    drv_key_int_private *priv;</span><br><span class="line">    priv = filp-&gt;private_data;</span><br><span class="line">    PINFO(<span class="string">&quot;In char driver read() function\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ev_press, 用于判断是否可以让当前进程睡眠(让出CPU, 进程切换)</span></span><br><span class="line">    wait_event_interruptible(key_waitq, ev_press);</span><br><span class="line">    ev_press = <span class="number">0</span>;                                           <span class="comment">// 运行后, 立刻清零</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ubuff, &amp;keys_val, <span class="number">1</span>)) &#123;                <span class="comment">// 传回按键值</span></span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 模板代码, 没有修改 =====</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">drv_key_int_fops</span>=</span> &#123;</span><br><span class="line">    .owner              = THIS_MODULE,</span><br><span class="line">    .open               = drv_key_int_open,</span><br><span class="line">    .release            = drv_key_int_release,</span><br><span class="line">    .read               = drv_key_int_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">drv_key_int_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    res = alloc_chrdev_region(&amp;drv_key_int_device_num,DRV_KEY_INT_FIRST_MINOR,DRV_KEY_INT_N_MINORS ,DRIVER_NAME);</span><br><span class="line">    <span class="keyword">if</span>(res) &#123;</span><br><span class="line">        PERR(<span class="string">&quot;register device no failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    drv_key_int_major = MAJOR(drv_key_int_device_num);</span><br><span class="line"></span><br><span class="line">    drv_key_int_class = class_create(THIS_MODULE , DRIVER_NAME);</span><br><span class="line">    <span class="keyword">if</span>(!drv_key_int_class) &#123;</span><br><span class="line">        PERR(<span class="string">&quot;class creation failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;DRV_KEY_INT_N_MINORS;i++) &#123;</span><br><span class="line">        drv_key_int_device_num= MKDEV(drv_key_int_major ,DRV_KEY_INT_FIRST_MINOR+i);</span><br><span class="line">        cdev_init(&amp;devices[i].cdev , &amp;drv_key_int_fops);</span><br><span class="line">        cdev_add(&amp;devices[i].cdev,drv_key_int_device_num,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        devices[i].drv_key_int_device  =</span><br><span class="line">                device_create(drv_key_int_class , <span class="literal">NULL</span> ,drv_key_int_device_num ,</span><br><span class="line">                            DRV_KEY_INT_NODE_NAME<span class="string">&quot;%d&quot;</span>,DRV_KEY_INT_FIRST_MINOR+i);</span><br><span class="line">        <span class="keyword">if</span>(!devices[i].drv_key_int_device) &#123;</span><br><span class="line">            class_destroy(drv_key_int_class);</span><br><span class="line">            PERR(<span class="string">&quot;device creation failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        devices[i].nMinor = DRV_KEY_INT_FIRST_MINOR+i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;INIT\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">drv_key_int_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;EXIT\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;DRV_KEY_INT_N_MINORS;i++) &#123;</span><br><span class="line">        drv_key_int_device_num= MKDEV(drv_key_int_major ,DRV_KEY_INT_FIRST_MINOR+i);</span><br><span class="line"></span><br><span class="line">        cdev_del(&amp;devices[i].cdev);</span><br><span class="line"></span><br><span class="line">        device_destroy(drv_key_int_class ,drv_key_int_device_num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class_destroy(drv_key_int_class);</span><br><span class="line"></span><br><span class="line">    unregister_chrdev_region(drv_key_int_device_num ,DRV_KEY_INT_N_MINORS);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(drv_key_int_init);</span><br><span class="line">module_exit(drv_key_int_exit);</span><br></pre></td></tr></table></figure>

<h2 id="drv-key-int-h"><a href="#drv-key-int-h" class="headerlink" title="drv_key_int.h"></a>drv_key_int.h</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_NAME <span class="meta-string">&quot;drv_key_int&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDEBUG(fmt,args...) printk(KERN_DEBUG<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERR(fmt,args...) printk(KERN_ERR<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME,##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINFO(fmt,args...) printk(KERN_INFO<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch-s3c2410/irqs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/hardware.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m       := drv_key_int.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">install:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules_install</span><br><span class="line">    depmod -a</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<h2 id="测试文件-test-drv-key-int-c"><a href="#测试文件-test-drv-key-int-c" class="headerlink" title="测试文件 test_drv_key_int.c"></a>测试文件 test_drv_key_int.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> keys_val;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/key_int0&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        read(fd, &amp;keys_val, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;keys_val = 0x%x\n&quot;</span>, keys_val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="编译并测试"><a href="#编译并测试" class="headerlink" title="编译并测试"></a>编译并测试</h1><h2 id="Ubuntu主机端"><a href="#Ubuntu主机端" class="headerlink" title="Ubuntu主机端"></a>Ubuntu主机端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主机端, 编译源码</span></span><br><span class="line"><span class="comment"># pwd = /home/draapho/share/drv/drv_key_int/KERN_SRC    # 驱动源码路径, share是nfs共享文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译驱动</span></span><br><span class="line">$ make clean</span><br><span class="line">$ make modules                      <span class="comment"># 也可以在LinK+里面直接编译, 更方便</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译测试代码</span></span><br><span class="line">$ arm-linux-gcc test_drv_key_int.c -o test_drv_key_int</span><br></pre></td></tr></table></figure>

<h2 id="开发板端"><a href="#开发板端" class="headerlink" title="开发板端"></a>开发板端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板端, 测试模块和中断加载情况</span></span><br><span class="line"><span class="comment"># pwd = /home/draapho/share/drv/drv_key_int/KERN_SRC    # 驱动源码路径, share是nfs共享文件夹</span></span><br><span class="line"></span><br><span class="line">$ insmod drv_key_int.ko             <span class="comment"># 加载模块</span></span><br><span class="line">drv_key_int:INIT</span><br><span class="line"></span><br><span class="line">$ cat /proc/devices                 <span class="comment"># 查看设备, 可以看到 drv_key_int</span></span><br><span class="line">$ cat /proc/interrupts              <span class="comment"># 查看中断设备, 没有 s2,s3,s4</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">exec</span> 5&lt;/dev/key_int0              <span class="comment"># 打开设备, 相当于open.</span></span><br><span class="line">drv_key_int:In char driver open() <span class="keyword">function</span></span><br><span class="line"><span class="comment"># 5是文件描述符, 其它数字也可以. ls -l /proc/self/fd/ 下可以查看文件描述符</span></span><br><span class="line"></span><br><span class="line">$ cat /proc/interrupts              <span class="comment"># 再查看中断设备, 可以看到 s2,s3,s4 了!</span></span><br><span class="line"><span class="comment"># 此时按下按键的话, 会触发中断, 打印 drv_key_int:keys_irq, irq=16/18/55</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">exec</span> 5&lt;&amp;-                         <span class="comment"># 关闭设备, 相当于close</span></span><br><span class="line">drv_key_int:In char driver release() <span class="keyword">function</span></span><br><span class="line"></span><br><span class="line">$ rmmod drv_key_int.ko              <span class="comment"># 移除模块</span></span><br><span class="line">drv_key_int:EXIT</span><br></pre></td></tr></table></figure>

<p>下面, 使用测试文件进行测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板端, 测试驱动功能</span></span><br><span class="line"><span class="comment"># pwd = /home/draapho/share/drv/drv_key_int/KERN_SRC    # 驱动源码路径, share是nfs共享文件夹</span></span><br><span class="line"></span><br><span class="line">$ insmod drv_key_int.ko             <span class="comment"># 加载模块</span></span><br><span class="line">drv_key_int:INIT</span><br><span class="line"></span><br><span class="line">$ ./test_drv_key_int                <span class="comment"># 检测按键中断</span></span><br><span class="line"><span class="comment"># 可以发现, 打印有时候有点乱, 那是因为中断的关系</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按ctrl+c 终止进程</span></span><br><span class="line"></span><br><span class="line">$ ./test_drv_key_int &amp;              <span class="comment"># 后台运行</span></span><br><span class="line">$ top                               <span class="comment"># 查看系统资源情况</span></span><br><span class="line"><span class="comment"># 可以看到 ./test_drv_key_int 进程占用很少的资源.</span></span><br></pre></td></tr></table></figure>

<p>分析测试代码, 在死循环里面, 会调用到 <code>wait_event_interruptible</code>, 当没有中断发生时, 就会切换用户进程.<br>当中断发生后, 驱动通过 <code>wake_up_interruptible</code> 唤醒用户进程, 继续执行.<br>然后由于, 用户的printf和内核的printk相互独立, 所以最终打印可能会有点乱.</p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>linuxembedded linux</tag>
        <tag>drv</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之poll机制</title>
    <url>/2017/12/11/1742-drv-chr4/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/11/22/1733-drv-chr1/">驱动之字符设备-框架</a></li>
<li><a href="https://draapho.github.io/2017/11/30/1740-drv-chr2/">驱动之基于LinK+设计按键驱动</a></li>
<li><a href="https://draapho.github.io/2017/12/07/1741-drv-chr3/">驱动之基于中断设计按键驱动</a></li>
<li><a href="https://draapho.github.io/2017/12/11/1742-drv-chr4/">驱动之poll机制</a></li>
<li><a href="https://draapho.github.io/2017/12/12/1743-drv-chr5/">驱动之异步通知</a></li>
<li><a href="https://draapho.github.io/2017/12/13/1744-drv-chr6/">驱动之同步互斥阻塞</a></li>
<li><a href="https://draapho.github.io/2018/01/04/1801-drv-chr7/">驱动之定时器按键防抖</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="POLL机制分析"><a href="#POLL机制分析" class="headerlink" title="POLL机制分析"></a>POLL机制分析</h1><h2 id="三种按键驱动的比较"><a href="#三种按键驱动的比较" class="headerlink" title="三种按键驱动的比较"></a>三种按键驱动的比较</h2><ul>
<li>查询方式: 依赖于应用程序的编写方式, 写的不好会非常耗费CPU资源</li>
<li>中断方式: 解决了CPU资源问题, 但是应用程序会阻塞在读取函数上</li>
<li>poll方式: 应用程序上, 实现了非阻塞读取. 先poll判断是否发生事件, 有事件处理, 无事件可以做其它事情.</li>
</ul>
<h2 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h2><p>基本流程如下:</p>
<ul>
<li>应用程序调用poll &gt; sys_poll &gt; <code>do_sys_poll</code> &gt; do_poll &gt; do_pollfd &gt; 驱动程序poll</li>
<li>从 <code>do_sys_poll</code> 函数深入分析:<ul>
<li>先调用 <code>poll_initwait</code>, 注册一下 <code>__pollwait</code> 函数.</li>
<li>再调用 <code>do_poll</code> 判断条件. 这里会调用驱动函数的poll<ul>
<li>调用 <code>do_pollfd</code> 函数, 实际上就是调用驱动的poll函数</li>
<li>返回值为1或等待超时或触发信号, 执行 <code>__set_current_state</code> 继续运行当前进程.</li>
<li>返回值为0, 则执行 <code>schedule_timeout</code> 当前进程睡眠, 切换到其它进程.</li>
</ul>
</li>
</ul>
</li>
<li>驱动函数里的poll会调用 <code>poll_wait</code>, 只是把当前的进程加入到 button_waitq 队列里去, 并没有立刻切换进程<ul>
<li><code>poll_wait</code> 调用 <code>p-&gt;qproc(filp, wait_address, p);</code>, 实际就是调用了 <code>__pollwait</code> 函数</li>
<li>进程并不会阻塞在 <code>poll_wait</code> 函数. (这个函数的命名容易让人误解, 因此特此强调!)</li>
<li>整个进程会根据驱动的poll返回值确定是休眠还是继续运行.</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">app: poll, 会去调用 sys_poll. 共三个参数</span><br><span class="line">    <span class="comment">// 1. *ufds, 文件指针. 需要查询的驱动文件列表</span></span><br><span class="line">    <span class="comment">// 2. nfds, 文件个数.</span></span><br><span class="line">    <span class="comment">// 3. timeout_msecs, 超时时间.</span></span><br><span class="line">kernel: sys_poll    <span class="comment">// 位于 /fs/select.c</span></span><br><span class="line">            do_sys_poll(..., timeout_jiffies)</span><br><span class="line">                poll_initwait(&amp;table);</span><br><span class="line">                    init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait);</span><br><span class="line">                    <span class="comment">// table-&gt;pt-&gt;qproc = __pollwait. 相当于注册一下 __pollwait.</span></span><br><span class="line">                    <span class="comment">// __pollwait 是系统函数, 用于初始化一个 poll_wqueues 的 table</span></span><br><span class="line">                    <span class="comment">// 驱动程序的poll函数会调用__pollwait函数.</span></span><br><span class="line">                do_poll(nfds, head, &amp;table, timeout)</span><br><span class="line">                    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (do_pollfd(ftd, pt)) &#123;</span><br><span class="line">                            <span class="comment">// 进入函数 do_pollfd, 有如下两句:</span></span><br><span class="line">                            mask = file-&gt;f_op-&gt;poll(file, pwait);</span><br><span class="line">                                <span class="comment">// 实际上, 就是调用驱动代码里的poll, 驱动代码里会调用</span></span><br><span class="line">                                pollwait(filp, &amp;button_waitq, p) &#123;</span><br><span class="line">                                    <span class="comment">// 把当前的进程挂到button_waitq队列里去</span></span><br><span class="line">                                    <span class="comment">// 整个进程并不会阻塞在 pollwait 这里!</span></span><br><span class="line">                                    p-&gt;qproc(filp, wait_address, p);    <span class="comment">// 相当于调用 __pollwait</span></span><br><span class="line">                                    <span class="comment">// 这里我有过疑惑, 为何不直接指定 __pollwait 这么一个系统函数, 而是用初始化函数指针再调用的晦涩方法.</span></span><br><span class="line">                                    <span class="comment">// 搜索 init_poll_funcptr 后, 就可以知道, 这也是一个系统架构, 不同的地方会有不同的函数.</span></span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 驱动poll函数给出返回值. 赋值给mask</span></span><br><span class="line">                                <span class="comment">// 因此整个进程会在调用完驱动poll函数后, 根据返回值进行休眠或继续运行.</span></span><br><span class="line">                            <span class="keyword">return</span> mask;</span><br><span class="line">                            count++; <span class="comment">// 如果驱动的poll返回非0值, 那么count++</span></span><br><span class="line">                            pt = <span class="literal">NULL</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// break的条件: count非0, 超时, 有信号在等待处理</span></span><br><span class="line">                        <span class="keyword">if</span> (count || !*timeout || signal_pending(current))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 休眠 __timeout</span></span><br><span class="line">                        __timeout = schedule_timeout(__timeout);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 设置当前进程为运行态</span></span><br><span class="line">                    __set_current_state(TASK_RUNNING);</span><br></pre></td></tr></table></figure>


<h1 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h1><ul>
<li><a href="http://blog.csdn.net/rockrockwu/article/details/7310518">linux poll 和 等待队列休眠的关系</a></li>
<li><a href="http://blog.csdn.net/lizhiguo0532/article/details/6568964">select(poll)系统调用实现解析(一)</a></li>
<li><a href="http://blog.csdn.net/lizhiguo0532/article/details/6568968">select(poll)系统调用实现解析(二)</a></li>
<li><a href="http://blog.csdn.net/lizhiguo0532/article/details/6568969">select(poll)系统调用实现解析(三)</a></li>
<li><a href="http://www.cnblogs.com/jack204/archive/2011/10/30/2229331.html">linux的poll的工作机制</a></li>
<li><a href="http://blog.csdn.net/czg13548930186/article/details/77825262">字符设备驱动-poll机制</a></li>
</ul>
<h1 id="驱动源码"><a href="#驱动源码" class="headerlink" title="驱动源码"></a>驱动源码</h1><p>驱动源码基于 <a href="https://draapho.github.io/2017/12/07/1741-drv-chr3/">驱动之基于中断设计按键驱动</a> 增加poll函数即可.<br>然后应用层的测试文件改动较大.<br><strong>注意驱动层和应用层的poll函数写法就可以了, 都是固定的结构</strong></p>
<h2 id="drv-key-poll-c"><a href="#drv-key-poll-c" class="headerlink" title="drv_key_poll.c"></a>drv_key_poll.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于 驱动之基于中断设计按键驱动 源码增加而来. 只显示新增和修改的部分. 这样更直观易懂.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;drv_key_poll.h&quot;</span>                    <span class="comment">// 头文件改一下</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEY_INT_NODE_NAME <span class="meta-string">&quot;key_poll&quot;</span>    <span class="comment">// 名称改一下</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="title">drv_key_poll</span><span class="params">(struct file *file, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">    poll_wait(file, &amp;key_waitq, wait);      <span class="comment">// 这里不会休眠. 进程不阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ev_press)</span><br><span class="line">        mask |= POLLIN | POLLRDNORM;        <span class="comment">// 关键是返回值, 返回值为0, 进程可能休眠.</span></span><br><span class="line">        <span class="comment">// POLLIN, 是标准的事件值, 测试程序就基于此判断.</span></span><br><span class="line">        <span class="comment">// POLLRDNORM, Normal data may be read without blocking. 作用应该是告知应用程序类型和后续动作.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">drv_key_int_fops</span>=</span> &#123;</span><br><span class="line">    .owner              = THIS_MODULE,</span><br><span class="line">    .open               = drv_key_int_open,</span><br><span class="line">    .release            = drv_key_int_release,</span><br><span class="line">    .read               = drv_key_int_read,</span><br><span class="line">    .poll               = drv_key_poll,     <span class="comment">// 新增这一行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="drv-key-poll-h"><a href="#drv-key-poll-h" class="headerlink" title="drv_key_poll.h"></a>drv_key_poll.h</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_NAME <span class="meta-string">&quot;drv_key_poll&quot;</span>          <span class="comment">// 名称改一下</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDEBUG(fmt,args...) printk(KERN_DEBUG<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERR(fmt,args...) printk(KERN_ERR<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME,##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINFO(fmt,args...) printk(KERN_INFO<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/poll.h&gt;                     // 新增poll头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch-s3c2410/irqs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/hardware.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m       := drv_key_poll.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">install:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules_install</span><br><span class="line">    depmod -a</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<h2 id="测试文件-test-drv-key-int-c"><a href="#测试文件-test-drv-key-int-c" class="headerlink" title="测试文件 test_drv_key_int.c"></a>测试文件 test_drv_key_int.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, ret;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> keys_val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span>                   <span class="comment">// poll 关联的文件, 可多个文件</span></span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/key_poll0&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fds[<span class="number">0</span>].fd     = fd;                     <span class="comment">// 关联的驱动文件</span></span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN;                 <span class="comment">// 事件类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ret = poll(fds, <span class="number">1</span>, <span class="number">5000</span>);           <span class="comment">// 执行poll. 最多阻塞5s (有按键事件会立刻返回)</span></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;time out\n&quot;</span>);           <span class="comment">// 5s后超时</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            read(fd, &amp;keys_val, <span class="number">1</span>);         <span class="comment">// 有按键, 读取按键值</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;keys_val = 0x%x\n&quot;</span>, keys_val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="编译并测试"><a href="#编译并测试" class="headerlink" title="编译并测试"></a>编译并测试</h1><h2 id="Ubuntu主机端"><a href="#Ubuntu主机端" class="headerlink" title="Ubuntu主机端"></a>Ubuntu主机端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主机端, 编译源码</span></span><br><span class="line"><span class="comment"># pwd = /home/draapho/share/drv/drv_key_poll/KERN_SRC   # 驱动源码路径, share是nfs共享文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译驱动</span></span><br><span class="line">$ make clean</span><br><span class="line">$ make modules                      <span class="comment"># 也可以在LinK+里面直接编译, 更方便</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译测试代码</span></span><br><span class="line">$ arm-linux-gcc test_drv_key_poll.c -o test_drv_key_poll</span><br></pre></td></tr></table></figure>

<h2 id="开发板端"><a href="#开发板端" class="headerlink" title="开发板端"></a>开发板端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板端, 测试驱动功能</span></span><br><span class="line"><span class="comment"># pwd = /home/draapho/share/drv/drv_key_poll/KERN_SRC   # 驱动源码路径, share是nfs共享文件夹</span></span><br><span class="line"></span><br><span class="line">$ insmod drv_key_poll.ko            <span class="comment"># 加载模块</span></span><br><span class="line">drv_key_int:INIT</span><br><span class="line"></span><br><span class="line">$ ./test_drv_key_poll               <span class="comment"># 检测按键中断</span></span><br><span class="line">drv_key_poll:In char driver open() <span class="keyword">function</span></span><br><span class="line"><span class="comment"># 无按键时, 每5s打印 time out</span></span><br><span class="line"><span class="comment"># 有按键时, 立刻打印按键值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按ctrl+c 终止进程</span></span><br><span class="line"></span><br><span class="line">$ ./test_drv_key_poll &amp;             <span class="comment"># 后台运行</span></span><br><span class="line">$ top                               <span class="comment"># 查看系统资源情况</span></span><br><span class="line"><span class="comment"># 可以看到 ./test_drv_key_poll 进程占用很少的资源.</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>linuxembedded linux</tag>
        <tag>drv</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之异步通知</title>
    <url>/2017/12/12/1743-drv-chr5/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/11/22/1733-drv-chr1/">驱动之字符设备-框架</a></li>
<li><a href="https://draapho.github.io/2017/11/30/1740-drv-chr2/">驱动之基于LinK+设计按键驱动</a></li>
<li><a href="https://draapho.github.io/2017/12/07/1741-drv-chr3/">驱动之基于中断设计按键驱动</a></li>
<li><a href="https://draapho.github.io/2017/12/11/1742-drv-chr4/">驱动之poll机制</a></li>
<li><a href="https://draapho.github.io/2017/12/12/1743-drv-chr5/">驱动之异步通知</a></li>
<li><a href="https://draapho.github.io/2017/12/13/1744-drv-chr6/">驱动之同步互斥阻塞</a></li>
<li><a href="https://draapho.github.io/2018/01/04/1801-drv-chr7/">驱动之定时器按键防抖</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="异步通知范例"><a href="#异步通知范例" class="headerlink" title="异步通知范例"></a>异步通知范例</h1><h2 id="范例源码"><a href="#范例源码" class="headerlink" title="范例源码"></a>范例源码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_signal</span><span class="params">(<span class="keyword">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;signal=%d, %d times\n&quot;</span>, signum, ++cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main start\n&quot;</span>);</span><br><span class="line">    signal(SIGUSR1, get_signal);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wait signal\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="范例测试"><a href="#范例测试" class="headerlink" title="范例测试"></a>范例测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu主机端</span></span><br><span class="line">$ arm-linux-gcc signal.c -o signal</span><br><span class="line"></span><br><span class="line"><span class="comment"># jz2440端</span></span><br><span class="line">$ ./signal &amp;        <span class="comment"># 背景运行</span></span><br><span class="line">main start</span><br><span class="line"><span class="built_in">wait</span> signal         <span class="comment"># 程序顺序执行</span></span><br><span class="line">$ ps                <span class="comment"># 查看进程</span></span><br><span class="line">790 0          1312 S   ./signal</span><br><span class="line">$ <span class="built_in">kill</span> -SIGUSR1 790 <span class="comment"># 发送SIGUSR1信号</span></span><br><span class="line">signal=10, 1 <span class="built_in">times</span>  <span class="comment"># 直接调用的 get_signal, 打印信息</span></span><br><span class="line">$ <span class="built_in">kill</span> -10 790      <span class="comment"># 发送SIGUSR1信号</span></span><br><span class="line">signal=10, 1 <span class="built_in">times</span>  <span class="comment"># 直接调用的 get_signal, 打印信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里说明一下kill指令, 其本意是发送signal给进程, 而不是杀死进程.</span></span><br><span class="line"><span class="comment"># 但如果进程没有对应的signal处理, 其默认方式就是结束进程.</span></span><br><span class="line"><span class="comment"># 可以在ubuntu主机端查看详情:</span></span><br><span class="line">$ man <span class="built_in">kill</span>          <span class="comment"># kill的帮助信息</span></span><br><span class="line">$ <span class="built_in">kill</span> -l           <span class="comment"># 列出所有signal值, 其中:</span></span><br><span class="line">10) SIGUSR1</span><br></pre></td></tr></table></figure>

<h2 id="异步机制核心点"><a href="#异步机制核心点" class="headerlink" title="异步机制核心点"></a>异步机制核心点</h2><ul>
<li>异步机制使得应用层代码可以获得有如”中断”处理一般的能力!<ul>
<li>注册好signal和函数</li>
<li>主代码始终自己管自己运行</li>
<li>signal触发后, 系统会自动调用注册好的函数.</li>
</ul>
</li>
<li>异步通知的四个要点:<ul>
<li>注册处理函数: 应用程序中注册</li>
<li>谁来发? 驱动来发</li>
<li>发给谁? 驱动发给应用程序</li>
<li>怎么发? 驱动调用 <code>kill_fasyn()</code></li>
</ul>
</li>
</ul>
<h1 id="驱动源码"><a href="#驱动源码" class="headerlink" title="驱动源码"></a>驱动源码</h1><p>驱动源码基于 <a href="https://draapho.github.io/2017/12/07/1741-drv-chr3/">驱动之基于中断设计按键驱动</a><br>增加fasync函数, 发送SIGIO信号.<br>然后应用层的测试文件改动较大.</p>
<h2 id="drv-key-async-c"><a href="#drv-key-async-c" class="headerlink" title="drv_key_async.c"></a>drv_key_async.c</h2><p>为了使设备支持异步通知机制, 驱动程序涉及以下3项工作:</p>
<ul>
<li>应用程序调用 <code>fcntl(fd, F_SETOWN, pid)</code> 时. 能在这个控制命令处理中设置 filp-&gt;f_owner为对应进程ID. 此工作已由内核完成</li>
<li>应用程序调用 <code>fcntl(fd, F_SETFL, oflags | FASYNC)</code> 后, FASYNC标志改变, 会调用驱动的fasync函数. 驱动需要实现fasync.</li>
<li>在设备资源可获得时, 调用 <code>kill_fasync()</code> 函数触发信号.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于 驱动之基于中断设计按键驱动 源码增加而来. 只显示新增和修改的部分. 这样更直观易懂.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;drv_key_async.h&quot;</span>                           <span class="comment">// 头文件改一下</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEY_INT_NODE_NAME <span class="meta-string">&quot;key_async&quot;</span>           <span class="comment">// 名称改一下</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">keys_async</span>;</span>            <span class="comment">// 新增, kill_fasync使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">keys_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    ev_press = <span class="number">1</span>;</span><br><span class="line">    wake_up_interruptible(&amp;key_waitq);</span><br><span class="line">    kill_fasync(&amp;keys_async, SIGIO, POLL_IN);           <span class="comment">// 新增, 发送SIGIO信号</span></span><br><span class="line">    <span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_key_fasync</span> <span class="params">(<span class="keyword">int</span> fd, struct file *filp, <span class="keyword">int</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PINFO(<span class="string">&quot;drv_key_fasync\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> fasync_helper (fd, filp, on, &amp;keys_async);   <span class="comment">// 初始化keys_async</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">drv_key_int_fops</span>=</span> &#123;</span><br><span class="line">    .owner              = THIS_MODULE,</span><br><span class="line">    .open               = drv_key_int_open,</span><br><span class="line">    .release            = drv_key_int_release,</span><br><span class="line">    .read               = drv_key_int_read,</span><br><span class="line">    .fasync             = drv_key_fasync,               <span class="comment">// 新增fasync</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="drv-key-async-h"><a href="#drv-key-async-h" class="headerlink" title="drv_key_async.h"></a>drv_key_async.h</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_NAME <span class="meta-string">&quot;drv_key_async&quot;</span>     <span class="comment">// 名称改一下</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m       := drv_key_async.o          <span class="comment"># 目标名称改一下</span></span><br></pre></td></tr></table></figure>


<h2 id="测试文件-test-drv-key-async-c"><a href="#测试文件-test-drv-key-async-c" class="headerlink" title="测试文件 test_drv_key_async.c"></a>测试文件 test_drv_key_async.c</h2><p>为了使设备支持异步通知机制, 应用层程序涉及以下工作:</p>
<ul>
<li>调用 <code>fcntl(fd, F_SETOWN, getpid())</code>, 告诉内核, 发给谁</li>
<li>调用 <code>fcntl(fd, F_SETFL, oflags | FASYNC)</code>, 改变fasync标记.</li>
<li>此时, 内核会调用驱动的fasync函数, 通过 <code>fasync_helper</code> 完成初始化.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keys_signal_handler</span><span class="params">(<span class="keyword">int</span> signum)</span>        <span class="comment">// 信号中断处理函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> key_val = <span class="number">0</span>;</span><br><span class="line">    read(fd,&amp;key_val,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key_val: 0x%x\n&quot;</span>,key_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> oflags;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/key_async0&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signal(SIGIO, keys_signal_handler);     <span class="comment">// 注册信号中断处理函数</span></span><br><span class="line">    fcntl(fd,F_SETOWN,getpid());            <span class="comment">// 告诉内核，发给本进程</span></span><br><span class="line">    oflags = fcntl(fd,F_GETFL);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before fcntl\n&quot;</span>);</span><br><span class="line">    fcntl(fd, F_SETFL, oflags | FASYNC);    <span class="comment">// 改变fasync标记, 内核会调用驱动fasync, 完成初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after fcntl\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;                              <span class="comment">// 开始主任务</span></span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="编译并测试"><a href="#编译并测试" class="headerlink" title="编译并测试"></a>编译并测试</h1><h2 id="Ubuntu主机端"><a href="#Ubuntu主机端" class="headerlink" title="Ubuntu主机端"></a>Ubuntu主机端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主机端, 编译源码</span></span><br><span class="line"><span class="comment"># pwd = /home/draapho/share/drv/drv_key_async/KERN_SRC   # 驱动源码路径, share是nfs共享文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译驱动</span></span><br><span class="line">$ make clean</span><br><span class="line">$ make modules                      <span class="comment"># 也可以在LinK+里面直接编译, 更方便</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译测试代码</span></span><br><span class="line">$ arm-linux-gcc test_drv_key_async.c -o test_drv_key_async</span><br></pre></td></tr></table></figure>

<h2 id="开发板端"><a href="#开发板端" class="headerlink" title="开发板端"></a>开发板端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板端, 测试驱动功能</span></span><br><span class="line"><span class="comment"># pwd = /home/draapho/share/drv/drv_key_async/KERN_SRC  # 驱动源码路径, share是nfs共享文件夹</span></span><br><span class="line"></span><br><span class="line">$ insmod drv_key_async.ko           <span class="comment"># 加载模块</span></span><br><span class="line">drv_key_async:INIT</span><br><span class="line"></span><br><span class="line">$ ./test_drv_key_async              <span class="comment"># 运行测试代码</span></span><br><span class="line">drv_key_async:In char driver open() <span class="keyword">function</span></span><br><span class="line">before fcntl</span><br><span class="line">drv_key_async:drv_key_fasync        <span class="comment"># 运行fcntl后, 驱动调用async函数</span></span><br><span class="line">after fcntl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按下按键, 应用程序就会调用 keys_signal_handler 函数.</span></span><br><span class="line"><span class="comment"># 打印出按键信息, 譬如 key_val: 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按ctrl+c 终止进程</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>linuxembedded linux</tag>
        <tag>drv</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之同步互斥阻塞</title>
    <url>/2017/12/13/1744-drv-chr6/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/11/22/1733-drv-chr1/">驱动之字符设备-框架</a></li>
<li><a href="https://draapho.github.io/2017/11/30/1740-drv-chr2/">驱动之基于LinK+设计按键驱动</a></li>
<li><a href="https://draapho.github.io/2017/12/07/1741-drv-chr3/">驱动之基于中断设计按键驱动</a></li>
<li><a href="https://draapho.github.io/2017/12/11/1742-drv-chr4/">驱动之poll机制</a></li>
<li><a href="https://draapho.github.io/2017/12/12/1743-drv-chr5/">驱动之异步通知</a></li>
<li><a href="https://draapho.github.io/2017/12/13/1744-drv-chr6/">驱动之同步互斥阻塞</a></li>
<li><a href="https://draapho.github.io/2018/01/04/1801-drv-chr7/">驱动之定时器按键防抖</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.<br>硬件具备唯一性, 因此某一时刻应该只有一个应用程序能对驱动进行操作.</p>
<h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><p><strong>原子操作指的是在执行过程中不会被别的进程或中断所打断的操作</strong><br>底层实现就是 <code>raw_local_irq_save</code> <code>raw_local_irq_restore</code>, 保存中断并禁止, 操作完成后, 恢复.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常用的原子操作函数</span></span><br><span class="line"><span class="keyword">atomic_t</span> v = ATOMIC_INIT(<span class="number">0</span>);            <span class="comment">// 定义原子变量v并初始化为0</span></span><br><span class="line">atomic_read(<span class="keyword">atomic_t</span> *v);               <span class="comment">// 返回原子变量的值</span></span><br><span class="line">atomic_inc(<span class="keyword">atomic_t</span> *v);                <span class="comment">// 原子变量增加1</span></span><br><span class="line">atomic_dec(<span class="keyword">atomic_t</span> *v);                <span class="comment">// 原子变量减少1</span></span><br><span class="line">atomic_dec_and_test(<span class="keyword">atomic_t</span> *v);       <span class="comment">// 自减操作后测试其是否为0，为0则返回true，否则返回false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更多宏定义可参考 /linux/include/asm/atomic.h</span></span><br></pre></td></tr></table></figure>

<h2 id="drv-sem-c"><a href="#drv-sem-c" class="headerlink" title="drv_sem.c"></a>drv_sem.c</h2><p>源码基于 <a href="https://draapho.github.io/2017/12/07/1741-drv-chr3/">驱动之基于中断设计按键驱动</a>, 部分修改而来<br>只显示新增和修改的部分. 这样更直观易懂.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;drv_sem.h&quot;</span>                                 <span class="comment">// 头文件改一下</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEY_INT_NODE_NAME <span class="meta-string">&quot;drv_sem&quot;</span>             <span class="comment">// 名称改一下</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">atomic_t</span> canopen = ATOMIC_INIT(<span class="number">1</span>);                  <span class="comment">// 定义原子变量canopen并初始化为1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_key_int_open</span><span class="params">(struct inode *inode,struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!atomic_dec_and_test(&amp;canopen)) &#123;           <span class="comment">// 新增的原子操作判断</span></span><br><span class="line">        atomic_inc(&amp;canopen);                       <span class="comment">// 打开失败, 恢复到0</span></span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为这一句的存在, 就算没有原子操作 应用程序无法调用此驱动多次. 先注释掉.</span></span><br><span class="line">    <span class="comment">// if (ret) return -EINVAL;</span></span><br><span class="line">    <span class="comment">// else return 0;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                       <span class="comment">// 为了测试, 直接返回0.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_key_int_release</span><span class="params">(struct inode *inode,struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    atomic_inc(&amp;canopen);                           <span class="comment">// 恢复原子操作为1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="drv-sem-h"><a href="#drv-sem-h" class="headerlink" title="drv_sem.h"></a>drv_sem.h</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_NAME <span class="meta-string">&quot;drv_sem&quot;</span>       <span class="comment">// 名称改一下</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m       := drv_sem.o            <span class="comment"># 目标名称改一下</span></span><br></pre></td></tr></table></figure>

<h2 id="测试文件-test-drv-sem-c"><a href="#测试文件-test-drv-sem-c" class="headerlink" title="测试文件 test_drv_sem.c"></a>测试文件 test_drv_sem.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> keys_val;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/drv_sem0&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        read(fd, &amp;keys_val, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;keys_val=0x%x, pid=%d\n&quot;</span>, keys_val, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译并测试"><a href="#编译并测试" class="headerlink" title="编译并测试"></a>编译并测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu主机端, 编译驱动和测试文件</span></span><br><span class="line"><span class="comment"># pwd = /home/draapho/share/drv/drv_sem/KERN_SRC    # 驱动源码路径, share是nfs共享文件夹</span></span><br><span class="line"></span><br><span class="line">$ make clean</span><br><span class="line">$ make modules</span><br><span class="line">$ arm-linux-gcc test_drv_sem.c -o test_drv_sem</span><br><span class="line"></span><br><span class="line"><span class="comment"># jz2440端</span></span><br><span class="line">$ insmod drv_sem.ko</span><br><span class="line">drv_sem:INIT</span><br><span class="line"></span><br><span class="line">$ ./test_drv_sem &amp;      <span class="comment"># 第一次运行</span></span><br><span class="line">$ top</span><br><span class="line">789   779 0        S     1312   2%   0% ./test_drv_sem</span><br><span class="line"><span class="comment"># 显示当前进程信息.</span></span><br><span class="line">$ ./test_drv_sem &amp;      <span class="comment"># 第二次运行</span></span><br><span class="line">can<span class="string">&#x27;t open!             # 打开文件失败</span></span><br><span class="line"><span class="string">$ top</span></span><br><span class="line"><span class="string">789   779 0        S     1312   2%   0% ./test_drv_sem</span></span><br><span class="line"><span class="string"># 依旧只有一个处于睡眠状态的测试程序.</span></span><br></pre></td></tr></table></figure>


<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>信号量是用于保护临界区的一种常用方法, 只有得到信号量进程才能执行临界区代码.<br>与原子操作不同的是, 当获取不到信号量是, <strong>进程进入休眠等待状态!</strong><br>一但其他进程释放信号量, 该进程获得信号量后, 会恢复运行.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义信号量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span>                       <span class="comment">// 信号量</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_MUTEX</span><span class="params">(lock)</span></span>;                 <span class="comment">// 定义互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_init</span> <span class="params">(struct semaphore *sem, <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_MUTEX</span><span class="params">(struct semaphore *sem)</span></span>;     <span class="comment">// 初始化为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(struct semaphore * sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">down_interruptible</span><span class="params">(struct semaphore * sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">down_trylock</span><span class="params">(struct semaphore * sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(struct semaphore * sem)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="drv-sem-c-1"><a href="#drv-sem-c-1" class="headerlink" title="drv_sem.c"></a>drv_sem.c</h2><p>源码基于 <a href="https://draapho.github.io/2017/12/07/1741-drv-chr3/">驱动之基于中断设计按键驱动</a>, 部分修改而来<br>只显示新增和修改的部分. 这样更直观易懂.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;drv_sem.h&quot;</span>                                 <span class="comment">// 头文件改一下</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEY_INT_NODE_NAME <span class="meta-string">&quot;drv_sem&quot;</span>             <span class="comment">// 名称改一下</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">atomic_t</span> canopen = ATOMIC_INIT(<span class="number">1</span>);                  <span class="comment">// 定义原子变量canopen并初始化为1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_MUTEX</span><span class="params">(key_lock)</span></span>;                     <span class="comment">// 定义互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_key_int_open</span><span class="params">(struct inode *inode,struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">if</span> (!atomic_dec_and_test(&amp;canopen)) &#123;           <span class="comment">// 新增的原子操作判断</span></span><br><span class="line">        atomic_inc(&amp;canopen);                       <span class="comment">// 打开失败, 恢复到0</span></span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    down(&amp;key_lock);                                <span class="comment">// 获取信号量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为这一句的存在, 就算没有原子操作 应用程序无法调用此驱动多次. 先注释掉.</span></span><br><span class="line">    <span class="comment">// if (ret) return -EINVAL;</span></span><br><span class="line">    <span class="comment">// else return 0;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                       <span class="comment">// 为了测试, 直接返回0.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_key_int_release</span><span class="params">(struct inode *inode,struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    atomic_inc(&amp;canopen);                           <span class="comment">// 恢复原子操作为1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    up(&amp;key_lock);                                  <span class="comment">// 释放信号量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它文件 <code>drv_sem.h</code> <code>Makefile</code> <code>test_drv_sem.c</code> 和原子操作的部分一样. 不用修改</p>
<h2 id="编译并测试-1"><a href="#编译并测试-1" class="headerlink" title="编译并测试"></a>编译并测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu主机端, 编译驱动和测试文件</span></span><br><span class="line"><span class="comment"># pwd = /home/draapho/share/drv/drv_sem/KERN_SRC    # 驱动源码路径, share是nfs共享文件夹</span></span><br><span class="line"></span><br><span class="line">$ make clean</span><br><span class="line">$ make modules</span><br><span class="line">$ arm-linux-gcc test_drv_sem.c -o test_drv_sem</span><br><span class="line"></span><br><span class="line"><span class="comment"># jz2440端</span></span><br><span class="line">$ insmod drv_sem.ko</span><br><span class="line">drv_sem:INIT</span><br><span class="line"></span><br><span class="line">$ ./test_drv_sem &amp;      <span class="comment"># 第一次运行</span></span><br><span class="line">$ top</span><br><span class="line">789   779 0        S     1312   2%   0% ./test_drv_sem</span><br><span class="line"><span class="comment"># 显示当前进程信息.</span></span><br><span class="line">$ ./test_drv_sem &amp;      <span class="comment"># 第二次运行</span></span><br><span class="line"><span class="comment"># 并不会显示 can&#x27;t open!, 此进程实际上在等待获取信号量</span></span><br><span class="line">$ top</span><br><span class="line">789   779 0        S     1312   2%   0% ./test_drv_sem</span><br><span class="line">791   779 0        D     1308   2%   0% ./test_drv_sem</span><br><span class="line"><span class="comment"># 789 是第一个进程, 处于S, 可中断的睡眠状态, 在等待按键中断</span></span><br><span class="line"><span class="comment"># 791 是第二个进程, 处于D, 不可中断的睡眠状态, 在等待获取信号量</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">kill</span> 789</span><br><span class="line">$ top                   <span class="comment"># 结束第一个进程, 再看进程表</span></span><br><span class="line">791   779 0        S     1308   2%   0% ./test_drv_sem</span><br><span class="line"><span class="comment"># 791 是第二进程, 获取信号量成功后开始运行, 处于S状态.</span></span><br></pre></td></tr></table></figure>

<h1 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h1><ul>
<li>阻塞操作<ul>
<li>系统默认就是阻塞操作</li>
<li>是指在执行设备操作时若不能获得资源则挂起进程，直到满足可操作的条件后再进行操作。</li>
<li>被挂起的进程进入休眠状态，被从调度器的运行队列移走，直到等待的条件被满足。</li>
</ul>
</li>
<li>非阻塞操作<ul>
<li>使用宏定义 <code>O_NONBLOCK</code></li>
<li>进程在不能进行设备操作时并不挂起，它或者放弃，或者不停地查询，直至可以进行操作为止。</li>
</ul>
</li>
</ul>
<h2 id="drv-sem-c-2"><a href="#drv-sem-c-2" class="headerlink" title="drv_sem.c"></a>drv_sem.c</h2><p>源码基于 <a href="https://draapho.github.io/2017/12/07/1741-drv-chr3/">驱动之基于中断设计按键驱动</a>, 部分修改而来<br>只显示新增和修改的部分. 这样更直观易懂.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;drv_sem.h&quot;</span>                                 <span class="comment">// 头文件改一下</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEY_INT_NODE_NAME <span class="meta-string">&quot;drv_sem&quot;</span>             <span class="comment">// 名称改一下</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">atomic_t</span> canopen = ATOMIC_INIT(<span class="number">1</span>);                  <span class="comment">// 定义原子变量canopen并初始化为1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_MUTEX</span><span class="params">(key_lock)</span></span>;                     <span class="comment">// 定义互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_key_int_open</span><span class="params">(struct inode *inode,struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">if</span> (!atomic_dec_and_test(&amp;canopen)) &#123;</span><br><span class="line">        atomic_inc(&amp;canopen);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;               <span class="comment">// 非阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (down_trylock(&amp;key_lock))                <span class="comment">// 尝试获取信号量</span></span><br><span class="line">            <span class="keyword">return</span> -EBUSY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        down(&amp;key_lock);                            <span class="comment">// 获取信号量, 阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为这一句的存在, 就算没有原子操作 应用程序无法调用此驱动多次. 先注释掉.</span></span><br><span class="line">    <span class="comment">// if (ret) return -EINVAL;</span></span><br><span class="line">    <span class="comment">// else return 0;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                       <span class="comment">// 为了测试, 直接返回0.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">drv_key_int_read</span><span class="params">(struct file *filp,  <span class="comment">// 读取函数也需要修改一下!</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span> __user *ubuff,<span class="keyword">size_t</span> count,<span class="keyword">loff_t</span> *offp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (count != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;               <span class="comment">// 非阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (!ev_press)                              <span class="comment">// 无按键, 立刻返回</span></span><br><span class="line">            <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ev_press, 用于判断是否可以让当前进程睡眠(让出CPU, 进程切换)</span></span><br><span class="line">        wait_event_interruptible(key_waitq, ev_press);      <span class="comment">// 阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ev_press = <span class="number">0</span>;                                           <span class="comment">// 运行后, 立刻清零</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ubuff, &amp;keys_val, <span class="number">1</span>)) &#123;                <span class="comment">// 传回按键值</span></span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_key_int_release</span><span class="params">(struct inode *inode,struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    atomic_inc(&amp;canopen);                           <span class="comment">// 恢复原子操作为1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    up(&amp;key_lock);                                  <span class="comment">// 释放信号量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件 <code>drv_sem.h</code> <code>Makefile</code> 和信号量的部分一样. 不用修改<br>阻塞是open函数的默认值, 其测试就不写了, 因为之前写的按键驱动测试都是阻塞的.</p>
<h2 id="测试文件-unblock-drv-sem-c"><a href="#测试文件-unblock-drv-sem-c" class="headerlink" title="测试文件 unblock_drv_sem.c"></a>测试文件 unblock_drv_sem.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret, fd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> keys_val;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/drv_sem0&quot;</span>, O_RDWR | O_NONBLOCK);    <span class="comment">// O_NONBLOCK 非阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ret = read(fd, &amp;keys_val, <span class="number">1</span>);                   <span class="comment">// 读取函数是否阻塞取决于open函数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;keys_val=0x%x, ret=%d\n&quot;</span>,keys_val,ret);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译并测试-2"><a href="#编译并测试-2" class="headerlink" title="编译并测试"></a>编译并测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu主机端, 编译驱动和测试文件</span></span><br><span class="line"><span class="comment"># pwd = /home/draapho/share/drv/drv_sem/KERN_SRC    # 驱动源码路径, share是nfs共享文件夹</span></span><br><span class="line"></span><br><span class="line">$ make clean</span><br><span class="line">$ make modules</span><br><span class="line">$ arm-linux-gcc unblock_drv_sem.c -o unblock_drv_sem</span><br><span class="line"></span><br><span class="line"><span class="comment"># jz2440端</span></span><br><span class="line">$ insmod drv_sem.ko</span><br><span class="line">drv_sem:INIT</span><br><span class="line"></span><br><span class="line">$ ./unblock_drv_sem &amp;       <span class="comment"># 第一次运行</span></span><br><span class="line">key_val=0x0, ret=-1         <span class="comment"># 无按键, 返回值 -EAGAIN</span></span><br><span class="line">key_val=0x0, ret=-1         <span class="comment"># 无按键, 返回值 -EAGAIN</span></span><br><span class="line">key_val=0x1, ret=1          <span class="comment"># 有按键, 返回值为1</span></span><br><span class="line">$ top</span><br><span class="line">789   779 0        S     1312   2%   0% ./unblock_drv_sem</span><br><span class="line"><span class="comment"># 显示当前进程信息.</span></span><br><span class="line">$ ./unblock_drv_sem &amp;      <span class="comment"># 第二次运行</span></span><br><span class="line"><span class="comment"># 显示 can&#x27;t open!, 非阻塞进程, 尝试获取信号量失败后, 返回给应用程序 -EBUSY</span></span><br><span class="line">$ top</span><br><span class="line">789   779 0        S     1312   2%   0% ./unblock_drv_sem</span><br><span class="line"><span class="comment"># 依旧只有一个789进程</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>linuxembedded linux</tag>
        <tag>drv</tag>
      </tags>
  </entry>
  <entry>
    <title>Yocto 的安装与体验</title>
    <url>/2017/12/15/1745-yocto-install/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Yocto的简介就不抄写了, 反正我光看介绍并不明白Yocto到底是干吗的.<br>但应该确确实实让定制和开发嵌入式Linux系统变得更方便, 招聘要求里会Yocto都是加分项.<br>所以决定动手实践一下, 先有个感性认识再说.</p>
<p>下文基本按照官网的 <a href="https://www.yoctoproject.org/docs/current/yocto-project-qs/yocto-project-qs.html">Yocto Project Quick Start</a> 步骤而来.</p>
<h1 id="第一步-安装-Yocto-Project"><a href="#第一步-安装-Yocto-Project" class="headerlink" title="第一步, 安装 Yocto Project"></a>第一步, 安装 Yocto Project</h1><p>安装 Yocto Project 有两个方法:</p>
<ul>
<li>使用 CROPS (CROss PlatformS), 直观的说, 就是基于Docker平台进行安装<ul>
<li>我并没有采用这种方法, 因为手头已经有现成的Ubuntu系统了</li>
<li>Docker相关内容, 可以参考我的笔记 <a href="https://draapho.github.io/2017/02/23/1708-docker/">Docker 初学笔记</a></li>
</ul>
</li>
<li>第二个方法就是基于Linux系统安装<ul>
<li>此文基于 Ubuntu 16.04 32bit 桌面版</li>
<li>基本要求: 50G的硬盘空间, 建议预留100G</li>
<li>支持主流Linux系统, 如 Fedora, CentOS, Debian, Ubuntu</li>
<li>Git 1.8.3.1或以上版本</li>
<li>tar 1.27或以上版本</li>
<li>python 3.4.0或以上版本</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu, 安装软件</span></span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib \</span><br><span class="line">    build-essential chrpath socat cpio python python3 python3-pip python3-pexpect \</span><br><span class="line">    xz-utils debianutils iputils-ping libsdl1.2-dev xterm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认一下软件版本</span></span><br><span class="line">$ git --version</span><br><span class="line">git version 2.7.4</span><br><span class="line">$ tar --version</span><br><span class="line">tar (GNU tar) 1.28</span><br><span class="line">$ python3</span><br><span class="line">Python 3.5.2</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">exit</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有装好, 可单独安装</span></span><br><span class="line">$ sudo apt install git</span><br><span class="line">$ sudo apt install tar</span><br><span class="line">$ sudo apt install python3</span><br></pre></td></tr></table></figure>

<p>这样就准备好了安装环境. 然后安装 Yocto Project</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一下yocto目录, 整个项目就放在此目录下面</span></span><br><span class="line">$ mkdir ~/yocto</span><br><span class="line">$ <span class="built_in">cd</span> ~/yocto</span><br><span class="line"></span><br><span class="line"><span class="comment"># git获取工程</span></span><br><span class="line">$ git <span class="built_in">clone</span> git://git.yoctoproject.org/poky</span><br><span class="line">...</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载完成后, 有个poky文件夹.</span></span><br><span class="line"><span class="comment"># 如果是从别处下载再拷贝进Ubuntu的, 可能需要改个权限</span></span><br><span class="line"><span class="comment"># 因为后面的bitbake命令不允许已root用户操作.</span></span><br><span class="line">$ sudo chmod -R +777 poky/</span><br></pre></td></tr></table></figure>


<h1 id="第二步-定制Linux镜像文件"><a href="#第二步-定制Linux镜像文件" class="headerlink" title="第二步, 定制Linux镜像文件"></a>第二步, 定制Linux镜像文件</h1><p>安装好 Yocto Project 后, 就需要体验一把定制Linux镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># pwd &#x3D; ~&#x2F;yocto&#x2F;poky&#x2F;</span><br><span class="line"></span><br><span class="line"># 创建一个git分支, 基于此分支制作自己的Linux镜像</span><br><span class="line">$ sudo git checkout -b rocko origin&#x2F;rocko</span><br><span class="line">$ git branch</span><br><span class="line">  master</span><br><span class="line">* rocko</span><br><span class="line"></span><br><span class="line"># 执行脚本, 创建了一些默认配置</span><br><span class="line">$ source oe-init-build-env</span><br><span class="line">You can now run &#39;bitbake &lt;target&gt;&#39;</span><br><span class="line">Common targets are:</span><br><span class="line">    core-image-minimal</span><br><span class="line">    core-image-sato</span><br><span class="line">    meta-toolchain</span><br><span class="line">    meta-ide-support</span><br><span class="line"># 显示后续操作的说明, 并自动进入 build 目录</span><br><span class="line"></span><br><span class="line"># pwd &#x3D; ~&#x2F;yocto&#x2F;poky&#x2F;build</span><br><span class="line">$ ls conf&#x2F;</span><br><span class="line"># 三个.conf文件, 教程简单介绍了一下 local.conf 里的 MACHINE 和 PACKAGE_CLASSES</span><br><span class="line">$ vim conf&#x2F;local.conf</span><br><span class="line"># 看一下配置文件, 有个直观感受. 先用默认值, 不去修改</span><br><span class="line"></span><br><span class="line">$ bitbake core-image-sato</span><br><span class="line"># 第一次的话, 会非常非常慢, 下载源码加编译, 可能花费几个小时...</span><br><span class="line"></span><br><span class="line"># 烘焙(bitbake)好image后, 在虚拟环境QEMU下看看效果</span><br><span class="line">$ runqemu qemux86</span><br></pre></td></tr></table></figure>

<p>至此, 体验完成. 实际硬件环境的流程基本一致, 就是还要考虑烧录和启动的问题.<br>这是嵌入式Linux开发的基本能力, 略过不表.</p>
<h1 id="一些弯路"><a href="#一些弯路" class="headerlink" title="一些弯路"></a><del>一些弯路</del></h1><p>第一个弯路是python版本问题, 造成安装软件失败<br>直接运行python, 默认是2.7. 然后想着需要改成3.5版本的.<br>按照网上教程, 修改python软链接, 但会导致apt安装软件失败.<br>原因是有些软件依赖于python2.7, 改为3.5后, 安装过程会发生语法错误.<br>具体可参考 <a href="https://draapho.github.io/2017/11/26/1736-linux-apt/">linux软件的安装和管理</a> 的 <code>X not fully installed or removed</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ll /usr/bin/python*</span><br><span class="line">lrwxrwxrwx 1 root root       9 Nov 24 07:18 /usr/bin/python -&gt; python2.7*</span><br><span class="line">$ sudo rm /usr/bin/python</span><br><span class="line">$ sudo ln -s /usr/bin/python3.5 /usr/bin/python</span><br><span class="line">$ ll /usr/bin/python*</span><br><span class="line">lrwxrwxrwx 1 root root       9 Nov 24 07:18 /usr/bin/python -&gt; python3.5*</span><br><span class="line">$ python</span><br><span class="line">Python 3.5.2 (default, Nov 23 2017, 16:37:01)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样改完以后, 再去安装 libsdl1.2-dev 会报错! 解决方法是改回来...</span></span><br></pre></td></tr></table></figure>

<p>第二个弯路是安装虚拟机的时候, 只给了20G的空间. 扩盘的方法如下:<br><a href="https://lzw.me/a/vmware-ubuntu-disk-space.html">扩大Vmware虚拟机中Ubuntu系统磁盘空间的方法</a>, 建议直接用可视化的软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt install gparted</span><br><span class="line">$ sudo gparted</span><br><span class="line"></span><br><span class="line"># 重启后自动挂载, 可以格式化并重命名为 extend</span><br><span class="line"># 自动挂载路径为 &#x2F;media&#x2F;user-name&#x2F;extend, 没有重命名的话, 是一长串ID</span><br><span class="line">$ sudo chmod +777 &#x2F;media&#x2F;draapho&#x2F;extend</span><br><span class="line">$ sudo ln -s &#x2F;media&#x2F;draapho&#x2F;extend ~&#x2F;share&#x2F;extend</span><br><span class="line"># 改下权限, 建立软连接方便操作.</span><br><span class="line"># 由于空间要求, yocto项目就放在这个盘里面.</span><br></pre></td></tr></table></figure>





<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.yoctoproject.org/docs/current/yocto-project-qs/yocto-project-qs.html">Yocto Project Quick Start</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-yocto-linux/index.html">使用 Yocto Project 构建自定义嵌入式 Linux 发行版</a></li>
<li><a href="http://www.sohu.com/a/134506616_468740">在MIPS平台上如何使用Yocto框架来定制嵌入式Linux发行版</a>, 里面有个视频, 介绍了yocto的好处</li>
<li><a href="http://www.eeskill.com/article/id/2761">基于Yocto Project的嵌入式应用设计</a></li>
</ul>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>linuxembedded linux</tag>
        <tag>yocto</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式linux环境搭建-QQ物联</title>
    <url>/2017/12/18/1746-qqiot-env/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/12/18/1746-qqiot-env/">嵌入式linux环境搭建-QQ物联</a></li>
<li><a href="https://draapho.github.io/2017/12/22/1748-qqiot-procedure/">QQ物联开发步骤简介</a></li>
<li><a href="https://draapho.github.io/2017/12/20/1747-qqiot-bind/">QQ物联绑定分析</a></li>
<li><a href="https://draapho.github.io/2017/12/23/1749-qqiot-demo/">QQ物联演示项目</a></li>
</ul>
<p>为学习QQ物联而搭建的jz2440开发环境.<br>需要升级交叉编译环境, 然后编译和烧录<br>使用如下软件版本:</p>
<ul>
<li>u-boot-1.1.6</li>
<li>linux-3.4.2</li>
<li>arm-linux-gcc-4.3.2</li>
</ul>
<p>另可参考:</p>
<ul>
<li><a href="https://draapho.github.io/2017/02/16/1705-linux-env/">嵌入式linux环境搭建-主机端</a>, 搭建Ubuntu开发环境</li>
<li><a href="https://draapho.github.io/2017/02/21/1707-jz2440-env/">嵌入式linux环境搭建-jz2440开发板</a>, 基于2.6.22内核的编译和烧录</li>
<li><a href="https://draapho.github.io/2017/11/28/1738-dhcp-env/">基于DHCP建立嵌入式Linux开发环境</a>, 修改jz2440的内核和文件系统以支持DHCP</li>
</ul>
<h1 id="安装交叉编译工具链"><a href="#安装交叉编译工具链" class="headerlink" title="安装交叉编译工具链"></a>安装交叉编译工具链</h1><p>新的linux内核需要用 arm-linux-gcc-4.3.2 这个版本的交叉编译.<br>对已安装的arm-linux-gcc-3.4.5, 无需删除, 但需要从环境变量中去除.<br>因此整个过程需要安装新软件, 重新设置一下Ubuntu的环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接拷贝解压 arm-linux-gcc-4.3.2.tar.bz2, 提供的压缩包包含了路径 /usr/local/arm/4.3.2</span></span><br><span class="line">$ sudo tar xjf arm-linux-gcc-4.3.2.tar.bz2 -C /</span><br><span class="line"><span class="comment"># 添加路径到环境变量, 记得去掉 gcc-3.4.5-glibc-2.3.6</span></span><br><span class="line">$ sudo vim /etc/bash.bashrc</span><br><span class="line">    <span class="comment"># ===== 文件内容, 末尾加入如下语句 =====</span></span><br><span class="line">    <span class="comment"># if [ -d /usr/local/gcc-3.4.5-glibc-2.3.6 ] ; then</span></span><br><span class="line">    <span class="comment">#   PATH=/usr/local/gcc-3.4.5-glibc-2.3.6/bin:&quot;$&#123;PATH&#125;&quot;</span></span><br><span class="line">    <span class="comment"># fi</span></span><br><span class="line">    <span class="keyword">if</span> [ -d /usr/<span class="built_in">local</span>/arm/4.3.2 ] ; <span class="keyword">then</span></span><br><span class="line">        PATH=/usr/<span class="built_in">local</span>/arm/4.3.2/bin:<span class="string">&quot;<span class="variable">$&#123;PATH&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line"><span class="comment"># 如果直接修改 /etc/environment 文件也可以.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试安装结果</span></span><br><span class="line">$ <span class="built_in">source</span> /etc/bash.bashrc                           <span class="comment"># 不重启更新PATH</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span>                                        <span class="comment"># 查看PATH</span></span><br><span class="line">$ arm-linux-gcc -v                                  <span class="comment"># 测试是否安装成功</span></span><br><span class="line">gcc version 4.3.2</span><br></pre></td></tr></table></figure>

<h1 id="uboot的编译和烧录"><a href="#uboot的编译和烧录" class="headerlink" title="uboot的编译和烧录"></a>uboot的编译和烧录</h1><h2 id="编译uboot"><a href="#编译uboot" class="headerlink" title="编译uboot"></a>编译uboot</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu shell</span></span><br><span class="line"></span><br><span class="line">tar xjvf u-boot-1.1.6.tar.bz2               <span class="comment"># 解压uboot源码</span></span><br><span class="line"><span class="built_in">cd</span> u-boot-1.1.6                             <span class="comment"># 进入uboot源码目录</span></span><br><span class="line">patch -p1 &lt; ../u-boot-1.1.6_20161226_all.patch</span><br><span class="line">make clean</span><br><span class="line">make 100ask24x0_config                      <span class="comment"># uboot config文件</span></span><br><span class="line">make                                        <span class="comment"># uboot 编译, 得到u-boot.bin文件</span></span><br></pre></td></tr></table></figure>

<h2 id="烧录uboot"><a href="#烧录uboot" class="headerlink" title="烧录uboot"></a>烧录uboot</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"><span class="comment"># 打开 jz2440 开发板串口终端, 启动时输入空格键, 进入如下菜单</span></span><br><span class="line"><span class="comment">##### 100ask Bootloader for OpenJTAG #####</span></span><br><span class="line">[n] Download u-boot to Nand Flash</span><br><span class="line">...</span><br><span class="line">Enter your selection: n / o                 <span class="comment"># 输入n 或者 o, 烧录uboot</span></span><br><span class="line">USB host is connected. Waiting a download.  <span class="comment"># 提示连接成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 Ubuntu 终端, 输入</span></span><br><span class="line"><span class="comment"># pwd = ./u-boot-1.1.6                      # 确保在 uboot 源码路径下</span></span><br><span class="line">sudo dnw u-boot.bin                         <span class="comment"># 使用dnw烧录uboot</span></span><br></pre></td></tr></table></figure>

<h2 id="设置uboot"><a href="#设置uboot" class="headerlink" title="设置uboot"></a>设置uboot</h2><p>如果希望通过uboot直接加载nfs文件系统, 还需进行如下设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"><span class="comment"># 设置ip地址, 在OpenJTAG&gt; 提示符下</span></span><br><span class="line"><span class="built_in">set</span> ipaddr 10.0.0.111           <span class="comment"># 设置开发板的ip地址</span></span><br><span class="line"><span class="built_in">set</span> serverip 10.0.0.138</span><br><span class="line">save                            <span class="comment"># 保存</span></span><br><span class="line">printenv                        <span class="comment"># 打印环境变量, 查看设置结果</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> bootargs noinitrd root=/dev/nfs nfsroot=10.0.0.98:/fs ip=10.0.0.111:10.0.0.98:10.0.0.138:255.255.255.0::eth0:off init=/linuxrc console=ttySAC0</span><br><span class="line"><span class="comment"># (简化ip: &#x27;set bootargs noinitrd root=/dev/nfs nfsroot=10.0.0.98:/fs ip=10.0.0.111 init=/linuxrc console=ttySAC0&#x27; 也可以工作)</span></span><br><span class="line">save        <span class="comment"># 保存修改</span></span><br><span class="line">reset       <span class="comment"># 重启. (稍后再重启, 先修改好 filesystem 内的初始化文件)</span></span><br><span class="line"><span class="comment"># 参数简要说明:</span></span><br><span class="line"><span class="comment"># &#x27;root=/dev/nfs&#x27; 加载nfs文件系统</span></span><br><span class="line"><span class="comment"># &#x27;nfsroot=10.0.0.98:/fs&#x27; nfs文件系统的来源, 此处是由win10当nfs服务器, 共享出/fs文件夹</span></span><br><span class="line"><span class="comment"># &#x27;ip=10.0.0.111:10.0.0.98:10.0.0.138:255.255.255.0::eth0:off&#x27; 分别表示:</span></span><br><span class="line"><span class="comment">#  ip= 开发板ip : nfs服务器ip: 网关ip : 子网掩码 :: 开发板网口 : off</span></span><br></pre></td></tr></table></figure>

<h1 id="kernel的编译和烧录"><a href="#kernel的编译和烧录" class="headerlink" title="kernel的编译和烧录"></a>kernel的编译和烧录</h1><h2 id="编译kernel"><a href="#编译kernel" class="headerlink" title="编译kernel"></a>编译kernel</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu shell</span></span><br><span class="line"></span><br><span class="line">tar xjvf linux-3.4.2.tar.bz2                <span class="comment"># 解压kernel源码</span></span><br><span class="line"><span class="built_in">cd</span> linux-3.4.2                              <span class="comment"># 进入kernel源码目录</span></span><br><span class="line">patch -p1 &lt; ../linux-3.4.2_20161226_all.patch  <span class="comment"># 打补丁文件, p1表忽略patch文件内的1层目录</span></span><br><span class="line"></span><br><span class="line">make clean                                  <span class="comment"># 清空 (先清空再在SI内查看)</span></span><br><span class="line">cp config_jz2440 .config                    <span class="comment"># 设置config文件, 此配置文件已支持dhcp</span></span><br><span class="line">make uImage                                 <span class="comment"># 编译获得内核image</span></span><br></pre></td></tr></table></figure>

<p>编译时, 遇到一个错误: <code>Can&#39;t use &#39;defined(@array)&#39; (Maybe you should just omit the defined()?) at kernel/timeconst.pl line 373.</code><br>参考 <a href="http://sunyongfeng.com/201701/programmer/linux/kernel_compile_fail.html">Linux kernel 编译问题记录</a>. 原因是perl版本升级了.<br>将 <code>if (!defined(@val))</code> 改为 <code>if (!@val)</code> 再次编译就可以了.</p>
<h2 id="烧录kernel"><a href="#烧录kernel" class="headerlink" title="烧录kernel"></a>烧录kernel</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"><span class="comment"># 打开 jz2440 开发板串口终端, 启动时输入空格键, 进入如下菜单</span></span><br><span class="line"><span class="comment">##### 100ask Bootloader for OpenJTAG #####</span></span><br><span class="line">[k] Download Linux kernel uImage</span><br><span class="line">...</span><br><span class="line">Enter your selection: k                     <span class="comment"># 输入k, 烧录 kernel</span></span><br><span class="line">USB host is connected. Waiting a download.  <span class="comment"># 提示连接成功</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 Ubuntu 终端, 输入</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6                    # 确保在 kernel 源码路径下</span></span><br><span class="line">sudo dnw ./arch/arm/boot/uImage             <span class="comment"># 输入dnw指令, 指明烧录文件</span></span><br><span class="line"><span class="comment"># DNW usb device found!                     # 开始烧录</span></span><br></pre></td></tr></table></figure>

<h1 id="filesystem的制作和烧录"><a href="#filesystem的制作和烧录" class="headerlink" title="filesystem的制作和烧录"></a>filesystem的制作和烧录</h1><p><strong>注意</strong>, QQ物联的应用, 文件系统必须烧录到nand flash中, 而不能采用NFS的方式加载.</p>
<h2 id="制作-filesystem"><a href="#制作-filesystem" class="headerlink" title="制作 filesystem"></a>制作 filesystem</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu shell</span></span><br><span class="line">sudo tar xjvf fs_mini_mdev_new_auto_wifi.tar.bz2        <span class="comment"># 解压缩</span></span><br><span class="line">mkyaffs2image fs_mini_mdev_new fs_mini_mdev_new.yaffs2  <span class="comment"># 生成文件系统</span></span><br></pre></td></tr></table></figure>

<h2 id="烧录-filesystem"><a href="#烧录-filesystem" class="headerlink" title="烧录 filesystem"></a>烧录 filesystem</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"><span class="comment"># 打开 jz2440 开发板串口终端, 启动时输入空格键, 进入如下菜单</span></span><br><span class="line"><span class="comment">##### 100ask Bootloader for OpenJTAG #####</span></span><br><span class="line">[y] Download root_yaffs image</span><br><span class="line">...</span><br><span class="line">Enter your selection: y                     <span class="comment"># 输入k, 烧录 root_yaffs</span></span><br><span class="line">USB host is connected. Waiting a download.  <span class="comment"># 提示连接成功</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 Ubuntu 终端, 输入</span></span><br><span class="line">sudo dnw fs_mini_mdev_new.yaffs2            <span class="comment"># 输入dnw指令, 指明烧录文件</span></span><br><span class="line"><span class="comment"># DNW usb device found!                     # 开始烧录</span></span><br><span class="line"><span class="comment"># 这样就成功把文件系统烧录到 jz2440 开发板中了.</span></span><br></pre></td></tr></table></figure>

<h1 id="查看分区"><a href="#查看分区" class="headerlink" title="查看分区"></a><del>查看分区</del></h1><ul>
<li>bootloader, 512k</li>
<li>params, 128k</li>
<li>kernel, 4m</li>
<li>rootfs, 剩下的空间</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot, 进入命令行模式</span></span><br><span class="line">&gt; printenv</span><br><span class="line">mtdparts=mtdparts=nandflash0:512k@0(bootloader),128k(params),4m(kernel),-(root)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ubuntu端, kernel 源码下</span></span><br><span class="line">$ vim arch/arm/mach-s3c24xx/common-smdk.c</span><br><span class="line"><span class="comment"># 查看 smdk_default_nand_part 可知分区情况</span></span><br><span class="line">static struct mtd_partition smdk_default_nand_part[] = &#123;</span><br><span class="line">        [0] = &#123;</span><br><span class="line">                .name   = <span class="string">&quot;bootloader&quot;</span>,</span><br><span class="line">                .size   = SZ_512K,</span><br><span class="line">                .offset = 0,</span><br><span class="line">        &#125;,</span><br><span class="line">        [1] = &#123;</span><br><span class="line">                .name   = <span class="string">&quot;params&quot;</span>,</span><br><span class="line">                .offset = MTDPART_OFS_APPEND,</span><br><span class="line">                .size   = SZ_128K,</span><br><span class="line">        &#125;,</span><br><span class="line">        [2] = &#123;</span><br><span class="line">                .name   = <span class="string">&quot;kernel&quot;</span>,</span><br><span class="line">                .offset = MTDPART_OFS_APPEND,</span><br><span class="line">                .size   = SZ_4M,</span><br><span class="line">        &#125;,</span><br><span class="line">        [3] = &#123;</span><br><span class="line">                .name   = <span class="string">&quot;rootfs&quot;</span>,</span><br><span class="line">                .offset = MTDPART_OFS_APPEND,</span><br><span class="line">                .size   = MTDPART_SIZ_FULL,</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="配置网络-支持nfs"><a href="#配置网络-支持nfs" class="headerlink" title="配置网络, 支持nfs"></a>配置网络, 支持nfs</h1><h2 id="实现dhcp功能"><a href="#实现dhcp功能" class="headerlink" title="实现dhcp功能"></a>实现dhcp功能</h2><p>为了正常使用udhcpc, 还需要对文件系统稍加修改. 如下工作即可以在开发板端做, 也可以先在文件系统上做好, 然后编译烧录进开发板</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># udhcpc需要一个脚本文件, 否则无法完整实现dhcp功能. (测试了一下, 这个版本没有脚本也不报错, 但无法正常使用!)</span></span><br><span class="line">mkdir -p /usr/share/udhcpc/     <span class="comment"># 自动建立多层目录</span></span><br><span class="line">vi /usr/share/udhcpc/default.script</span><br><span class="line"><span class="comment"># ===== 打开vim, 写入如下内容 =====</span></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">[ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Error: should be called from udhcpc&quot;</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">RESOLV_CONF=<span class="string">&quot;/etc/resolv.conf&quot;</span></span><br><span class="line">[ -n <span class="string">&quot;<span class="variable">$broadcast</span>&quot;</span> ] &amp;&amp; BROADCAST=<span class="string">&quot;broadcast <span class="variable">$broadcast</span>&quot;</span></span><br><span class="line">[ -n <span class="string">&quot;<span class="variable">$subnet</span>&quot;</span> ] &amp;&amp; NETMASK=<span class="string">&quot;netmask <span class="variable">$subnet</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  deconfig)</span><br><span class="line">    /sbin/ifconfig <span class="variable">$interface</span> 0.0.0.0</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">  renew|bound)</span><br><span class="line">    /sbin/ifconfig <span class="variable">$interface</span> <span class="variable">$ip</span> <span class="variable">$BROADCAST</span> <span class="variable">$NETMASK</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$router</span>&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;deleting routers&quot;</span></span><br><span class="line">      <span class="keyword">while</span> route del default gw 0.0.0.0 dev <span class="variable">$interface</span> ; <span class="keyword">do</span></span><br><span class="line">        :</span><br><span class="line">      <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$router</span> ; <span class="keyword">do</span></span><br><span class="line">        route add default gw <span class="variable">$i</span> dev <span class="variable">$interface</span></span><br><span class="line">      <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> -n &gt; <span class="variable">$RESOLV_CONF</span></span><br><span class="line">    [ -n <span class="string">&quot;<span class="variable">$domain</span>&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> search <span class="variable">$domain</span> &gt;&gt; <span class="variable">$RESOLV_CONF</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$dns</span> ; <span class="keyword">do</span></span><br><span class="line">      <span class="built_in">echo</span> adding dns <span class="variable">$i</span></span><br><span class="line">      <span class="built_in">echo</span> nameserver <span class="variable">$i</span> &gt;&gt; <span class="variable">$RESOLV_CONF</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line"><span class="comment"># ===== wq保存文件, 退出 =====</span></span><br><span class="line">chmod +x /usr/share/udhcpc/default.script       <span class="comment"># 加入可执行属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后测试一下</span></span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc eth0</span><br><span class="line"><span class="comment"># 如果没有脚本文件, 只能获得IP地址, 没有dns的信息!</span></span><br><span class="line">ifconfig</span><br><span class="line"><span class="comment"># 能看到IP地址, 广播地址, 子网掩码信息</span></span><br><span class="line">ping 192.168.1.100</span><br><span class="line"><span class="comment"># 能ping通ubuntu主机</span></span><br></pre></td></tr></table></figure>

<h2 id="开机自动挂载nfs"><a href="#开机自动挂载nfs" class="headerlink" title="开机自动挂载nfs"></a>开机自动挂载nfs</h2><p>要使用nfs, Ubuntu主机首先必须支持nfs. 主机端配置详情见 <a href="https://draapho.github.io/2017/11/29/1739-ubuntu-nfs/">Ubuntu 16.04安装配置NFS</a><br>使用 <code>ifconfig</code> 查看主机IP地址, <code>vim /etc/exports</code> 查看共享目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># jz2440开发板</span></span><br><span class="line">vi /etc/init.d/rcS             <span class="comment"># 开机自动执行udhcpc. S是大写!</span></span><br><span class="line"><span class="comment"># ===== 打开vim, 修改/增加如下内容 =====</span></span><br><span class="line"><span class="comment">#ifconfig eth0 192.168.1.17</span></span><br><span class="line"></span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc eth0</span><br><span class="line"><span class="comment"># 上述两行放在最前面. 这样才能成功自动挂载nfs</span></span><br><span class="line"><span class="comment"># ===== wq保存文件, 退出 =====</span></span><br><span class="line"></span><br><span class="line">vi /etc/fstab</span><br><span class="line"><span class="comment"># ===== 打开vim, 增加如下内容 =====</span></span><br><span class="line"><span class="comment"># 文件最后加入这样一句nfs模板, 便于日后修改</span></span><br><span class="line"><span class="comment"># 192.168.1.100:/home/draapho/share /mnt/share nfs rsize=1024,wsize=1024,timeo=14,intr,nolock 0 0</span></span><br><span class="line"><span class="comment"># ===== wq保存文件, 退出 =====</span></span><br><span class="line"></span><br><span class="line">mkdir /mnt/share                <span class="comment"># 创建挂载点</span></span><br><span class="line">mount -a                        <span class="comment"># 不重启挂载, 测试一下</span></span><br></pre></td></tr></table></figure>

<h1 id="编译并测试驱动模块"><a href="#编译并测试驱动模块" class="headerlink" title="编译并测试驱动模块"></a>编译并测试驱动模块</h1><p>默认提供的驱动关联了 <code>/work/system/linux-3.4.2</code>作为内核关联.<br>另外, 可以把编译好的驱动拷贝到jz2440 flash中, 统一放在 <code>/lib/modules/3.4.2</code> 目录下面.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># jz2440开发板</span></span><br><span class="line">mkdir -p /lib/modules/3.4.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu端firstdrvtest.c</span></span><br><span class="line">sudo mkdir -p /work/system/</span><br><span class="line">firstdrvtest.c</span><br></pre></td></tr></table></figure>

<h2 id="LED驱动"><a href="#LED驱动" class="headerlink" title="LED驱动"></a>LED驱动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu端</span></span><br><span class="line"><span class="comment"># pwd = ./jz2440/first_drv                  # nfs共享文件</span></span><br><span class="line">make</span><br><span class="line">arm-linux-gcc firstdrvtest.c -o firstdrvtest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># jz2440开发板</span></span><br><span class="line"><span class="comment"># pwd = /mnt/share/.../jz2440/first_drv     # nfs共享文件</span></span><br><span class="line">cp first_drv.ko /lib/modules/3.4.2/</span><br><span class="line">ls /lib/modules/3.4.2/                      <span class="comment"># 查看拷贝结果</span></span><br><span class="line">insmod first_drv.ko</span><br><span class="line">lsmod                                       <span class="comment"># 列出已加载模块</span></span><br><span class="line">./firstdrvtest on                           <span class="comment"># 测试</span></span><br><span class="line">./firstdrvtest off</span><br></pre></td></tr></table></figure>

<h2 id="按键驱动"><a href="#按键驱动" class="headerlink" title="按键驱动"></a>按键驱动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu端</span></span><br><span class="line"><span class="comment"># pwd = ./jz2440/7th_buttons_all                # nfs共享文件</span></span><br><span class="line">make</span><br><span class="line">arm-linux-gcc buttons_test.c -o buttons_test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># jz2440开发板</span></span><br><span class="line"><span class="comment"># pwd = /mnt/share/.../jz2440/7th_buttons_all   # nfs共享文件</span></span><br><span class="line">cp buttons.ko /lib/modules/3.4.2/</span><br><span class="line">ls /lib/modules/3.4.2/                          <span class="comment"># 查看拷贝结果</span></span><br><span class="line">insmod buttons.ko</span><br><span class="line">lsmod                                           <span class="comment"># 列出已加载模块</span></span><br><span class="line">./buttons_test                                  <span class="comment"># 测试</span></span><br></pre></td></tr></table></figure>


<h2 id="LCD驱动"><a href="#LCD驱动" class="headerlink" title="LCD驱动"></a>LCD驱动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu端</span></span><br><span class="line"><span class="comment"># pwd = ./jz2440/10th_lcd                       # nfs共享文件, 屏幕驱动</span></span><br><span class="line">cp lcd_4.3.c lcd.c                              <span class="comment"># jz2440, 用的4.3寸屏</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># pwd = ./jz2440/fb_test                        # nfs共享文件, 屏幕测试</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># jz2440开发板</span></span><br><span class="line"><span class="comment"># pwd = /mnt/share/.../jz2440/10th_lcd          # nfs共享文件, 屏幕驱动</span></span><br><span class="line">cp lcd.ko /lib/modules/3.4.2/</span><br><span class="line">ls /lib/modules/3.4.2/                          <span class="comment"># 查看拷贝结果</span></span><br><span class="line">insmod lcd.ko</span><br><span class="line">lsmod                                           <span class="comment"># 列出已加载模块</span></span><br><span class="line"><span class="comment"># pwd = /mnt/share/.../jz2440/fb_test           # nfs共享文件, 屏幕测试</span></span><br><span class="line">./fb_test                                       <span class="comment"># 测试, 显示用法</span></span><br><span class="line">ls /dev/fb*                                     <span class="comment"># 显示设备</span></span><br><span class="line">./fb_test /dev/fb0                              <span class="comment"># 测试指定设备</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>qqiot</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>qqiot</tag>
      </tags>
  </entry>
  <entry>
    <title>QQ物联绑定分析</title>
    <url>/2017/12/20/1747-qqiot-bind/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/12/18/1746-qqiot-env/">嵌入式linux环境搭建-QQ物联</a></li>
<li><a href="https://draapho.github.io/2017/12/22/1748-qqiot-procedure/">QQ物联开发步骤简介</a></li>
<li><a href="https://draapho.github.io/2017/12/20/1747-qqiot-bind/">QQ物联绑定分析</a></li>
<li><a href="https://draapho.github.io/2017/12/23/1749-qqiot-demo/">QQ物联演示项目</a></li>
</ul>
<p>本文使用 linux-3.4.2 内核, 使用jz2440开发板.</p>
<h1 id="demo-bind-c-的分析与测试"><a href="#demo-bind-c-的分析与测试" class="headerlink" title="demo_bind.c 的分析与测试"></a>demo_bind.c 的分析与测试</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>打开demo_bind.c, 说明很详细, 主要流程如下</p>
<ul>
<li>调用 <code>tx_init_device</code> 初始化设备信息. 可理解为将设备在QQ服务器上注册一下</li>
<li>打开QQ, 保证和设备连在同一个路由器上且能上网.</li>
<li>然后就可以在QQ我的设备中, 点击搜索新设备.</li>
<li>扫描设备并绑定成功后, 即触发设备的登录逻辑. 调用指定的回调函数.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initDevice</span><span class="params">()</span> </span>&#123;                 <span class="comment">// bind的核心函数, 初始化设备</span></span><br><span class="line">    <span class="comment">// 先读取三个重要文件</span></span><br><span class="line">    <span class="comment">// license, 认证文件. 文件名 ./licence.sign.file.txt</span></span><br><span class="line">    <span class="comment">// guid, 即SN设备序列号. 文件名 ./GUID_file.txt</span></span><br><span class="line">    <span class="comment">// svrPubkey变量中, 公钥. 文件名 ./1000000004.pem</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置设备的基本信息</span></span><br><span class="line">    tx_device_info info = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    info.os_platform            = <span class="string">&quot;Linux&quot;</span>;              <span class="comment">// os平台</span></span><br><span class="line"></span><br><span class="line">    info.device_name            = <span class="string">&quot;demo1&quot;</span>;              <span class="comment">// 设备名称</span></span><br><span class="line">    info.device_serial_number   = guid;                 <span class="comment">// 设备SN</span></span><br><span class="line">    info.device_license         = license;              <span class="comment">// 由SN生成的LICENSE</span></span><br><span class="line">    info.product_version        = <span class="number">1</span>;</span><br><span class="line">    info.network_type           = network_type_wifi;    <span class="comment">// 入网方式</span></span><br><span class="line">    info.product_id             = <span class="number">1000000004</span>;           <span class="comment">// PID, QQ分配</span></span><br><span class="line">    info.server_pub_key         = svrPubkey;            <span class="comment">// 公钥</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置回调函数</span></span><br><span class="line">    tx_device_notify notify      = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    notify.on_login_complete     = on_login_complete;   <span class="comment">// 登录完成</span></span><br><span class="line">    notify.on_online_status      = on_online_status;    <span class="comment">// 状态改变</span></span><br><span class="line">    notify.on_binder_list_change = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置目录和文件大小</span></span><br><span class="line">    tx_init_path init_path = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心语句, 向QQ服务器注册此设备.</span></span><br><span class="line">    <span class="keyword">int</span> ret = tx_init_device(&amp;info, &amp;notify, &amp;init_path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>示例里面的 <code>readBufferFromFile</code> 已经对license和SN进行文件化管理了.<br>为了以后的批量生产, 这里将必要的配置信息再打包一层, 统一放入一个配置文件.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu端</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立一个分支, 用来修改和测试bind</span></span><br><span class="line">sudo cp -rf Tencent_iot_SDK/ bind_test/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压获得的QQ物联相关文件, 包括 licence, sn和公钥</span></span><br><span class="line">sudo tar xzf 1700003137001488.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名后放到测试目录</span></span><br><span class="line">sudo mv 1700003137001488/ conf/</span><br><span class="line">sudo mv conf/ bind_test/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改下权限</span></span><br><span class="line">sudo chmod -R 777 bind_test/</span><br></pre></td></tr></table></figure>

<p>然后打开 <code>./bind_test/demo_bind.c</code> 文件, 仿照readBufferFromFile进行修改</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新增如下内容</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conf_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>  pid;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> pubkey_file[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> guid_file[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> license_file[<span class="number">128</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conf_info</span> <span class="title">configInfo</span> =</span> &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;, &#123;<span class="number">0</span>&#125;, &#123;<span class="number">0</span>&#125;, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">readConfigFromFile</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> read;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">char</span> *pconf[] = &#123;configInfo.pubkey_file, configInfo.guid_file,  configInfo.license_file&#125;;</span><br><span class="line">    <span class="comment">// 尝试打开目录下的配置文件</span></span><br><span class="line">    FILE * file = fopen(<span class="string">&quot;./conf/config&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open ./conf/config failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取第一行的数据, PID信息</span></span><br><span class="line">    read = getline(&amp;line, &amp;len, file);</span><br><span class="line">    <span class="keyword">if</span> (read &gt; <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">        ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read PID failed...\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(buf,line,read<span class="number">-1</span>);</span><br><span class="line">        buf[read]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        configInfo.pid = atoi(buf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;PID=%d\n&quot;</span>,configInfo.pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取第二行的数据, Name信息</span></span><br><span class="line">    read = getline(&amp;line, &amp;len, file);</span><br><span class="line">    <span class="keyword">if</span> (read &gt; <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">        ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read Name failed...\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(buf,line,read<span class="number">-1</span>);</span><br><span class="line">        buf[read]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">sprintf</span>(configInfo.name, buf);</span><br><span class="line">        <span class="comment">// printf(&quot;Name=%s\n&quot;,configInfo.name);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取剩下的行, 都是文件数据</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(pconf)/<span class="keyword">sizeof</span>(<span class="keyword">char</span> *); i++) &#123;</span><br><span class="line">        read = getline(&amp;line, &amp;len, file);</span><br><span class="line">        <span class="keyword">if</span> (read &gt; <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">            ret = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read line%d failed...\n&quot;</span>, i+<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(buf,line,read<span class="number">-1</span>);</span><br><span class="line">            buf[read]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (access(buf, R_OK)) &#123;</span><br><span class="line">                ret = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;fail to read %s\n&quot;</span>,buf);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(pconf[i], buf);</span><br><span class="line">                <span class="comment">// printf(&quot;line%d: %s\n&quot;, i+2, pconf[i]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;                                  <span class="comment">// 调试检查</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NAME=%s\n&quot;</span>,configInfo.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;PEM =%s\n&quot;</span>,configInfo.pubkey_file);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GUID=%s\n&quot;</span>,configInfo.guid_file);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LICENSE=%s\n&quot;</span>,configInfo.license_file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (line) <span class="built_in">free</span>(line);</span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改如下内容, -为原内容, +为修改后的内容</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initDevice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">+   <span class="keyword">if</span>(readConfigFromFile() == <span class="literal">false</span>)&#123;</span><br><span class="line">+       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">+   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 license</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> license[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> nLicenseSize = <span class="number">0</span>;</span><br><span class="line">-   <span class="keyword">if</span> (!readBufferFromFile(<span class="string">&quot;./licence.sign.file.txt&quot;</span>, license, <span class="keyword">sizeof</span>(license), &amp;nLicenseSize)) &#123;</span><br><span class="line">+   <span class="keyword">if</span> (!readBufferFromFile(configInfo.license_file, license, <span class="keyword">sizeof</span>(license), &amp;nLicenseSize)) &#123;</span><br><span class="line"></span><br><span class="line">-   <span class="keyword">if</span>(!readBufferFromFile(<span class="string">&quot;./GUID_file.txt&quot;</span>, guid, <span class="keyword">sizeof</span>(guid), &amp;nGUIDSize)) &#123;</span><br><span class="line">+   <span class="keyword">if</span> (!readBufferFromFile(configInfo.guid_file, guid, <span class="keyword">sizeof</span>(guid), &amp;nGUIDSize)) &#123;</span><br><span class="line"></span><br><span class="line">-   <span class="keyword">if</span> (!readBufferFromFile(<span class="string">&quot;./1000000004.pem&quot;</span>, svrPubkey, <span class="keyword">sizeof</span>(svrPubkey), &amp;nPubkeySize))</span><br><span class="line">+   <span class="keyword">if</span> (!readBufferFromFile(configInfo.pubkey_file, svrPubkey, <span class="keyword">sizeof</span>(svrPubkey), &amp;nPubkeySize))</span><br><span class="line"></span><br><span class="line">-   info.device_name            = <span class="string">&quot;demo1&quot;</span>;</span><br><span class="line">+   info.device_name            = configInfo.name;</span><br><span class="line">    info.device_serial_number   = guid;</span><br><span class="line">    info.device_license         = license;</span><br><span class="line">    info.product_version        = <span class="number">1</span>;</span><br><span class="line">    info.network_type           = network_type_wifi;</span><br><span class="line">-   info.product_id             = <span class="number">1000000004</span>;</span><br><span class="line">+   info.product_id             = configInfo.pid;</span><br><span class="line">    info.server_pub_key         = svrPubkey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后, 需要修改makefile文件, 用的交叉编译. (注意空格改为TAB)</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 改为交叉编译!</span></span><br><span class="line">CROSS_COMPILE = arm-linux-</span><br><span class="line">CC  = <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line"></span><br><span class="line"><span class="section">all:app1</span></span><br><span class="line">    @echo build complete</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    -rm SDKDemo_bind</span><br><span class="line"></span><br><span class="line"><span class="section">app1:demo_bind.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> demo_bind.c -o SDKDemo_bind -O0 -g3 -I<span class="string">&quot;./include&quot;</span> -L<span class="string">&quot;./lib&quot;</span> -ltxdevicesdk -lpthread -ldl -lstdc++</span><br></pre></td></tr></table></figure>


<p>最后, 设置conf文件.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1700003137</span><br><span class="line">jz2440_bind_demo</span><br><span class="line">.&#x2F;conf&#x2F;1700003137.pem</span><br><span class="line">.&#x2F;conf&#x2F;GUID_file[1700003137001488].txt</span><br><span class="line">.&#x2F;conf&#x2F;licence.sign.file[1700003137001488].txt</span><br></pre></td></tr></table></figure>


<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu端</span></span><br><span class="line"><span class="comment"># pwd = share/.../bind_test         # 共享文件夹下的bind_test目录</span></span><br><span class="line">$ make                              <span class="comment"># 编译</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># jz2440端</span></span><br><span class="line"><span class="comment"># pwd = mnt/share/.../bind_test     # 共享文件夹下的bind_test目录</span></span><br><span class="line">$ cp ./lib/libtxdevicesdk.so /lib   <span class="comment"># 拷贝动态库到开发板本地lib</span></span><br><span class="line">$ ls -l /lib/libtxdevicesdk.so      <span class="comment"># 检查一下</span></span><br><span class="line"></span><br><span class="line">$ mkdir /qqiot</span><br><span class="line">$ cp SDKDemo_bind /qqiot            <span class="comment"># 拷贝执行文件</span></span><br><span class="line">$ cp -rf conf/ /qqiot               <span class="comment"># 拷贝配置文件</span></span><br><span class="line">$ <span class="built_in">cd</span> /qqiot                         <span class="comment"># 切换目录</span></span><br><span class="line">$ ls                                <span class="comment"># 查看结果</span></span><br><span class="line"></span><br><span class="line">$ ./SDKDemo_bind                    <span class="comment"># 运行范例</span></span><br><span class="line"><span class="comment"># 会打印很多信息. 查看是否有如下类似信息</span></span><br><span class="line">WLAN connection with tencent iot server ... is setting up</span><br><span class="line">xpnet_gethostbyname: Begin gethostbyname device msf.3g.qq.com</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:<br>必须正确设置开发板的网络. 我已设置开发板为dhcp, 因此没有遇到网络方面的问题.<br>如果使用的是静态IP, 记得设置一下网关等信息.<br>可以用 <code>route</code> 指令查看网络路由表</p>
<p>然后, 打开手机端QQ, 保证手机和开发板在同一局域网下.<br>联系人-&gt;设备-&gt;发现新设备-&gt;绑定设备…就能看到jz2440_demo设备的界面了.</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://iot.open.qq.com/wiki/index.html">QQ物联资料库</a></li>
</ul>
]]></content>
      <categories>
        <category>qqiot</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>qqiot</tag>
      </tags>
  </entry>
  <entry>
    <title>QQ物联开发步骤简介</title>
    <url>/2017/12/22/1748-qqiot-procedure/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/12/18/1746-qqiot-env/">嵌入式linux环境搭建-QQ物联</a></li>
<li><a href="https://draapho.github.io/2017/12/22/1748-qqiot-procedure/">QQ物联开发步骤简介</a></li>
<li><a href="https://draapho.github.io/2017/12/20/1747-qqiot-bind/">QQ物联绑定分析</a></li>
<li><a href="https://draapho.github.io/2017/12/23/1749-qqiot-demo/">QQ物联演示项目</a></li>
</ul>
<p>本文使用 linux-3.4.2 内核, 使用jz2440开发板.</p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="硬件设备概念"><a href="#硬件设备概念" class="headerlink" title="硬件设备概念"></a>硬件设备概念</h2><ul>
<li>SN (serial number), 序列号<ul>
<li>由产品开发商提供, 但QQ规定了格式要求</li>
<li>需要保证唯一性. 即同一种类的单品都有其唯一的SN</li>
<li>格式: 16个字符长度. 由字母, 数字, 下划线, 连词符, 冒号组成.</li>
<li>譬如 <code>ABC-0032-1234567</code></li>
<li>历史原因, 源码里面的名称是 <code>guid</code></li>
</ul>
</li>
<li>LICENSE, 数字签名<ul>
<li>license 是对sn的数字签名, 所以与sn是一一对应的关系</li>
<li>license由腾讯提供的工具来实现, 输入sn即可</li>
<li>其目的就是保护设备信息, 避免设备被山寨.</li>
</ul>
</li>
<li>PID(product identify), 产品ID.<ul>
<li>即产品类别ID, 类似于超市商品的二维码, 表明产品类别</li>
<li>有了PID和SN后, QQ就可以唯一确定一台智能设备</li>
<li>QQ物联的设备二维码就是由PID和SN这两个信息组成的</li>
<li>QQ会提供PID值</li>
</ul>
</li>
<li>DIN(device identify number), 设备ID<ul>
<li>可以认为就是此设备的QQ号码, 64位长度.</li>
<li>DIN 由 PID + SN + LICENSE 产生.</li>
<li>QQ会保证DIN的唯一性</li>
</ul>
</li>
<li>SDK, 开发套件<ul>
<li>分为设备SDK和应用SDK</li>
<li>设备SDK, 就是给智能硬件使用的开发套件. 以后学习的重点是在这里.</li>
<li>应用SDK, 如果要开发独立APP, 就需要此SDK. 提供QQ开放接口. 此处略过不表.</li>
</ul>
</li>
</ul>
<h2 id="QQ云端概念"><a href="#QQ云端概念" class="headerlink" title="QQ云端概念"></a>QQ云端概念</h2><ul>
<li>datapoint, 数据点<ul>
<li>理解为QQ指定的一套数据格式规范即可.</li>
</ul>
</li>
<li>PropertyID, 属性ID<ul>
<li>每个datapoint都有自己的id, 用于表明此数值的属性.</li>
<li>譬如property_id (200001), 表示摄像头分辨率.</li>
<li>简单的理解, datapoint传输整个键值对. PropertyID是key.</li>
</ul>
</li>
</ul>
<h2 id="轻APP前端"><a href="#轻APP前端" class="headerlink" title="轻APP前端"></a>轻APP前端</h2><p>QQ物联轻APP是手机QQ里“我的设备”控制器内嵌的HTML5页面（模板），分为通用/公共模板和开发商自定义模板</p>
<ul>
<li>通用/公共模板<ul>
<li>公共模板的样式不可自定义, 但可以自行配置功能控件.</li>
<li>可节省软件端的研发和维护成本, 缩短产品研发周期.</li>
</ul>
</li>
<li>自定义模板<ul>
<li>使用Html5, 根据QQ物联提供的设计规范和接口实现定制化用户界面 (内嵌在QQ里)</li>
<li>自定义模板需要开发者将页面发布到自有的服务器, 然后将url地址提交到平台.</li>
</ul>
</li>
<li>deviceAPI<ul>
<li>QQ物联提供的给自定义模板调用的JS接口.</li>
<li>注意, 目前其对视屏功能仅部分支持.</li>
</ul>
</li>
</ul>
<h2 id="手机APP"><a href="#手机APP" class="headerlink" title="手机APP"></a>手机APP</h2><p>手机端概念只有在需要自己开发app, 调用应用SDK时, 才会用到!</p>
<ul>
<li>AppID<ul>
<li>标识APP, 此App使用QQ登录组件. 即调用了QQ的应用SDK</li>
</ul>
</li>
<li>OpenID<ul>
<li>等同于用户QQ号码的身份. 长度128bit</li>
<li>OpenID 由 appid + qq号码 产生</li>
</ul>
</li>
<li>TinyID (Tiny OpenID)<ul>
<li>QQ内部由于兼容问题, 对OpenID的一个缩略, 使用64bit长度</li>
</ul>
</li>
</ul>
<h2 id="配网方式-wifi下"><a href="#配网方式-wifi下" class="headerlink" title="配网方式(wifi下)"></a>配网方式(wifi下)</h2><p>不少硬件设备是没有屏幕的, 如何接入wifi就成为一个大问题. QQ物联提供如下几种方式</p>
<ul>
<li>WiFi Router： 设备自行解决入网问题，适用于有屏幕的智能设备</li>
<li>SmartLink： 博通合作方案, 其wifi芯片支持Monitor模式(可实现数据包注入), 内置了AES-CCM加密库</li>
<li>SmartLinkEx: 额外采用声波通讯技术协同配网, 提高极端环境下的配网成功率. 适合有麦克风的设备</li>
<li>QQLink： SmartLink的弱加密版本, 安全性没有SmartLink方案高.</li>
<li>QQLinkEx： 额外采用声波通讯技术协同配网. 适合有麦克风的设备</li>
</ul>
<h1 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h1><ol>
<li>建立企业开发账号.<ul>
<li><a href="http://iot.open.qq.com/wiki/index.html#!FUNC/Register_On_WebSite.md">Step1. 申请开发者账号</a>, 申请一个公司用QQ</li>
<li><a href="http://iot.open.qq.com/wiki/index.html#!FUNC/Register_On_WebSite.md">Step2. 申请加入白名单</a>, 需等待审核结果.</li>
<li><a href="http://iot.open.qq.com/wiki/index.html#!FUNC/Register_On_WebSite.md">Step3. 进入配置平台</a>, 成功后, 就有开发配置平台了.</li>
</ul>
</li>
<li>创建新设备.<ul>
<li>在配置平台里面, 可以创建新设备.</li>
<li>慎重选择设备类型, 不同的设备类型提供不同的后台功能!</li>
<li>测试环境不要点击 <code>提交上线</code>, 最多有100台设备任意调试.</li>
<li>如果提交上线, 设备就会被锁定, 等待QQ审核结果. 此过程无法开发调试!</li>
<li>开发和测试完成后, 再去 <code>提交上线</code>, 等待审核结果.</li>
<li>已审核通过的产品如果还要更改配置页面, 则需要再次通过腾讯审核.</li>
</ul>
</li>
<li>配置设备后台<ul>
<li>新建设备之设备类型: 决定QQ物联设备大致需要的功能(控制/音视频).</li>
<li>设备信息之公钥上传: 用工具生成<code>public.pem</code>, 然后上传. 用于认证GUID/SN号.</li>
<li>设备信息之联网方式: 如果设备有界面可以自行入网, 可以选择自行入网. 如果没有输入界面, 则需要选wifi配网方式.</li>
<li>功能配置之公有功能: 设定手机QQ和QQ物联设备的收发内容</li>
<li>功能配置之特殊功能: 用来定义手机QQ与QQ物联设备两者之间特殊消息的数据格式<ul>
<li>显示类型：只能是QQ物联设备向手机QQ发送用于显示的的数据</li>
<li>控制类型：QQ物联设备与手机QQ可以互传控制消息的数据</li>
<li>设置好后, 会获得一个ID值! 数据传输格式是腾讯的 datapoint</li>
<li><strong>功能描述</strong>:  自定义数据的组织格式. 参考 <a href="http://iot.open.qq.com/wiki/index.html#!FUNC/DataPoint_Custom_CMD.md">自定义指令</a> 里的说明</li>
</ul>
</li>
<li>控制器设置: 配置手机QQ的控制UI界面<ul>
<li>自动生成控制器, 就是使用QQ提供的通用模板. 模板里的元素可以自定义</li>
<li>自定义控制器, 就是自定义模板. 需要HTML5开发并放到自己的服务器端</li>
</ul>
</li>
</ul>
</li>
<li>创建设备序列号和密钥<ul>
<li>整个过程有两组公钥私钥配对.</li>
<li>服务器生成的公钥私钥, 开发者需下载公钥<code>170000xxxx.pem</code>. 此配对用于加密数据, 保证通讯安全.</li>
<li>开发者生成的公钥私钥, 开发者需上传公钥<code>public.pem</code>. 保证私钥安全性. 此配对用于认证设备SN没有被盗用.</li>
<li>设备SN的认证方法是, 开发者用私钥加密SN生成license, 将SN和license传给QQ服务器, QQ服务器会用上传的公钥去检查SN合法性.</li>
<li>license最好也保存好. 因为如果别人获取license和SN后, 可以仿冒特定的设备.</li>
<li><code>公钥&amp;证书工具</code>, 在设备信息的公钥上传里提供了下载.</li>
</ul>
</li>
<li>QQ物联设备端功能开发<ul>
<li><a href="http://iot.open.qq.com/wiki/#!FUNC/DataPoint_Common_CMD.md">控制指令</a></li>
<li><a href="http://iot.open.qq.com/wiki/#!FUNC/DataPoint_Custom_CMD.md">自定义指令</a></li>
<li><a href="http://iot.open.qq.com/wiki/#!FUNC/DataPoint_Sync_Status.md">状态同步</a></li>
</ul>
</li>
<li>开发者测试</li>
<li>交给QQ物联官方审核</li>
<li>发布产品</li>
</ol>
<h1 id="收发消息的过程"><a href="#收发消息的过程" class="headerlink" title="收发消息的过程"></a>收发消息的过程</h1><h2 id="QQ物联设备接收消息"><a href="#QQ物联设备接收消息" class="headerlink" title="QQ物联设备接收消息"></a>QQ物联设备接收消息</h2><p>datapoint的主要函数:</p>
<ul>
<li><code>tx_init_data_point</code>: 初始化</li>
<li><code>tx_report_data_point</code>: 上报</li>
<li><code>tx_ack_data_point</code>: 回应</li>
</ul>
<p>QQ物联设备端, 对消息处理的主要过程如下:</p>
<ul>
<li><code>tx_init_data_point</code> 进行初始化后, 并定义回调函数 <code>on_receive_datapoint</code></li>
<li>手机QQ发送datapoint消息给QQ物联设备</li>
<li>QQ物联设备接收到后, 使用回调函数处理消息</li>
<li>处理方式是通过datapoint的ID来分辨消息类型(特殊功能里设置)</li>
</ul>
<h2 id="QQ物联设备发送消息"><a href="#QQ物联设备发送消息" class="headerlink" title="QQ物联设备发送消息"></a>QQ物联设备发送消息</h2><ul>
<li>QQ设备发送消息给QQ服务器<ul>
<li><code>tx_send_text_msg</code> 发送文本</li>
<li><code>tx_send_structuring_msg</code> 发送图文和音视频</li>
</ul>
</li>
<li>QQ服务器更具配置情况(触发器-动作-模板), 只转发满足条件的消息给手机QQ</li>
<li>触发器页面: 设置过滤条件并制定动作<ul>
<li>该消息由哪个QQ物联设备发送来的</li>
<li>该消息的ID号</li>
<li>触发后要执行的动作</li>
</ul>
</li>
<li>动作页面: 动作制定模板(文本/图片/语音/视频)</li>
<li>QQ服务器根据模板构造发送给手机QQ的消息</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://iot.open.qq.com/wiki/index.html">QQ物联资料库</a></li>
</ul>
]]></content>
      <categories>
        <category>qqiot</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>qqiot</tag>
      </tags>
  </entry>
  <entry>
    <title>QQ物联演示项目</title>
    <url>/2017/12/23/1749-qqiot-demo/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/12/18/1746-qqiot-env/">嵌入式linux环境搭建-QQ物联</a></li>
<li><a href="https://draapho.github.io/2017/12/22/1748-qqiot-procedure/">QQ物联开发步骤简介</a></li>
<li><a href="https://draapho.github.io/2017/12/20/1747-qqiot-bind/">QQ物联绑定分析</a></li>
<li><a href="https://draapho.github.io/2017/12/23/1749-qqiot-demo/">QQ物联演示项目</a></li>
</ul>
<p>本文使用 linux-3.4.2 内核, 使用jz2440开发板.</p>
<h1 id="编译和安装驱动"><a href="#编译和安装驱动" class="headerlink" title="编译和安装驱动"></a>编译和安装驱动</h1><p>先编译安装一下LED, 测试一下LCD功能</p>
<h2 id="LED驱动"><a href="#LED驱动" class="headerlink" title="LED驱动"></a>LED驱动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu主机端</span></span><br><span class="line"></span><br><span class="line">unzip led_driver.zip</span><br><span class="line"><span class="built_in">cd</span> led_driver/</span><br><span class="line">ll /work/system/linux-3.4.2/            <span class="comment"># 确定内核目录存在, 编译要用到</span></span><br><span class="line">make                                    <span class="comment"># 编译LED驱动</span></span><br><span class="line">arm-linux-gcc jz2440_led_app.c -o jz2440_led_app    <span class="comment"># 编译测试文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># jz2440开发板</span></span><br><span class="line"><span class="comment">#pwd = .../share/.../led_driver/        # 共享文件进入ubuntu下的驱动目录</span></span><br><span class="line">cp jz2440_led_drv.ko /lib/modules/3.4.2/</span><br><span class="line">insmod jz2440_led_drv.ko</span><br><span class="line">./jz2440_led_app</span><br><span class="line"><span class="comment"># 可以看到打印信息, 并且开发板的LED灯亮灭.</span></span><br><span class="line">rmmod jz2440_led_drv.ko                 <span class="comment"># 卸载设备模块</span></span><br></pre></td></tr></table></figure>

<h2 id="LCD测试"><a href="#LCD测试" class="headerlink" title="LCD测试"></a>LCD测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu主机端</span></span><br><span class="line"></span><br><span class="line">unzip lcd_gui_simple.zip</span><br><span class="line"><span class="built_in">cd</span> lcd_gui_simple/</span><br><span class="line">make                                    <span class="comment"># 编译LED测试源码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># jz2440开发板</span></span><br><span class="line"><span class="comment">#pwd = .../share/.../lcd_gui_simple/    # 共享文件进入ubuntu下的驱动目录</span></span><br><span class="line">ls /dev/fb0                             <span class="comment"># 确认已存在设备fb0</span></span><br><span class="line">./lcd_gui_simple                        <span class="comment"># 测试屏幕</span></span><br></pre></td></tr></table></figure>

<h1 id="演示项目"><a href="#演示项目" class="headerlink" title="演示项目"></a>演示项目</h1><h2 id="编译和测试"><a href="#编译和测试" class="headerlink" title="编译和测试"></a>编译和测试</h2><p>必须将应用程序需要用到的文件都准备好, 这样才能正常原型.<br>有如下重点:</p>
<ul>
<li>密钥文件放到 <code>/etc/qq_iot/demo_bind/</code></li>
<li>QQ SDK动态库放到 <code>/lib/</code></li>
<li>应用文件和资源文件放在一起, 譬如 <code>/qqiot/</code></li>
<li>准备好开发板必要驱动, 这里是led驱动. 其它驱动已经打包进内核.</li>
<li>确保网络正确, 能ping通外网.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu主机端</span></span><br><span class="line">unzip net_bind_detector.zip</span><br><span class="line"><span class="built_in">cd</span> net_bind_detector/</span><br><span class="line"><span class="comment"># 确认一下./lib/libtxdevicesdk.so的版本. 保证所有代码用的同一个库</span></span><br><span class="line">make clean</span><br><span class="line">make                                    <span class="comment"># 生成 net_bind_detector</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># jz2440开发板</span></span><br><span class="line"><span class="comment">#pwd=.../share/.../密钥文件目录/</span></span><br><span class="line">mkdir -p /etc/qq_iot/demo_bind/</span><br><span class="line">tar xzf 1700003137001488.tar.gz         <span class="comment"># 解压密钥文件</span></span><br><span class="line">mv 1700003137001488/* /etc/qq_iot/demo_bind/</span><br><span class="line">rm -r 1700003137001488</span><br><span class="line">ls /etc/qq_iot/demo_bind/               <span class="comment"># 确认一下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pwd=.../share/.../net_bind_detector/   # 共享文件进入ubuntu下的驱动目录</span></span><br><span class="line">cp net_bind_detector /qqiot/            <span class="comment"># 拷贝到开发板flash中</span></span><br><span class="line">cp lib/libtxdevicesdk.so /lib/          <span class="comment"># 拷贝QQ SKD库</span></span><br><span class="line">cp -rfd res/ /qqiot/                    <span class="comment"># 拷贝测试用资源, d表示忽略软连接</span></span><br><span class="line">ls /qqiot</span><br><span class="line">ls /qqiot/res                           <span class="comment"># 确认拷贝结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始测试</span></span><br><span class="line"><span class="built_in">cd</span> /qqiot/</span><br><span class="line">insmod /lib/modules/3.4.2/jz2440_led_drv.ko     <span class="comment"># 加载led模块</span></span><br><span class="line">./net_bind_detector</span><br><span class="line"><span class="comment"># 开始演示, 在QQ界面上操作, 开发板屏幕或LED就会有响应</span></span><br><span class="line"><span class="comment"># 然后测试QQ物联设备给手机QQ发送消息 (需要QQ服务器端正确配置)</span></span><br><span class="line">sendtextmsg                             <span class="comment"># 测试文本的发送</span></span><br><span class="line">sendpic                                 <span class="comment"># 测试图片文件的发送</span></span><br><span class="line">sendaudio                               <span class="comment"># 测试音频文件的发送</span></span><br><span class="line">sendvideo                               <span class="comment"># 测试视频文件的发送</span></span><br></pre></td></tr></table></figure>

<p>如果要实现开机自启动, 把相关命令放在 <code>/etc/init.d/rcS</code> 结尾处即可.<br>注意, 此程序用到了相对路径. 如果直接用 <code>/qqiot/net_bind_detector</code>, 加载相对路径文件时就会失败!</p>
<h1 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h1><p>这里就不分析了, 仅列出其文件结构</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>led</td>
<td>led的应用程序(很简单)</td>
</tr>
<tr>
<td>framebuffer</td>
<td>framebuffer底层实现</td>
</tr>
<tr>
<td>gui</td>
<td>自制gui</td>
</tr>
<tr>
<td>lib</td>
<td>腾讯QQ物联SDK的库文件存放位置</td>
</tr>
<tr>
<td>include</td>
<td>头文件</td>
</tr>
<tr>
<td>… qq_dev_sdk</td>
<td>腾讯QQ物联SDK的头文件存放位置</td>
</tr>
<tr>
<td>initDevice</td>
<td>设备初始化</td>
</tr>
<tr>
<td>DataPoint</td>
<td>实现 <code>tx_init_data_point</code> <code>tx_ack_data_point</code> <code>tx_report_data_point</code></td>
</tr>
<tr>
<td>fileTransfer</td>
<td>实现 <code>tx_init_file_transfer</code></td>
</tr>
<tr>
<td>msg</td>
<td>实现 <code>tx_send_text_msg</code> <code>tx_send_structuring_msg</code></td>
</tr>
<tr>
<td>res</td>
<td>存放图片文件, 音频文件, 视频文件</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>qqiot</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>qqiot</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之platform概念</title>
    <url>/2018/01/08/1803-drv-platform/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a></li>
<li><a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a></li>
<li><a href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">驱动之RTC分析</a></li>
<li><a href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">驱动之LCD驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/11/1806-drv-ts/">驱动之触摸屏驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">驱动之USB基础概念和框架</a></li>
<li><a href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">驱动之USB设备驱动程序</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="platform概念"><a href="#platform概念" class="headerlink" title="platform概念"></a>platform概念</h1><p><img src="https://draapho.github.io/images/1803/bus.png" alt="bus.png"></p>
<p>platform 的主要作用是给开发人员搭好了框架.<br>便于将底层驱动的通用部分放在 <code>driver</code> 端实现, 而硬件高度相关部分放在 <code>device</code> 端实现.<br>由于只是架构, 因此这里 <code>driver</code> 和 <code>device</code> 两个部分都是自己写代码实现的, platform自动完成匹配.</p>
<p>这种架构特别适用于总线设备! 将总线设备的共性提炼成 driver 文件.<br>而正对支持总线的不同硬件, 分别单独写 device 即可.<br>因此一般情况下, platform的driver对应多个device.<br>linux基于platform的概念, 已经帮我们实现了常用总线的driver如: I2C, SPI, USB等</p>
<p>要更细致的了解linux platform 分离分层的概念, 建议参考如下博文:</p>
<ul>
<li><a href="http://www.wowotech.net/gpio_subsystem/io-port-control.html">linux内核中的GPIO系统之（1）：软件框架</a></li>
<li><a href="http://www.wowotech.net/linux_kenrel/platform_device.html">Linux设备模型(8)_platform设备</a></li>
</ul>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>LinK+软件也支持配置platform设备, 但是生成的源码放在了同一个文件, 不便于理解.<br>为了便于理解, 采用点led来说明platform概念. 为保持代码简介, 忽略错误判断, 不支持多个device.<br>实际开发中, 自己用到platform的机会不多, 因为linux已经将常用的总线写好了.</p>
<h2 id="led-driver-c-硬件通用代码"><a href="#led-driver-c-硬件通用代码" class="headerlink" title="led_driver.c (硬件通用代码)"></a>led_driver.c (硬件通用代码)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;led_platform.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> led_major=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">led_class</span>=</span><span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *gpio_con;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *gpio_dat;</span><br><span class="line"><span class="keyword">int</span> pin;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== led driver 通用文件操作 =====</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_driver_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PINFO(<span class="string">&quot;led_driver_open\n&quot;</span>);</span><br><span class="line">    *gpio_con &amp;= ~(<span class="number">0x3</span>&lt;&lt;(pin*<span class="number">2</span>));       <span class="comment">// 配置为输出</span></span><br><span class="line">    *gpio_con |= (<span class="number">0x1</span>&lt;&lt;(pin*<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">led_driver_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> * ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    PINFO(<span class="string">&quot;led_driver_write\n&quot;</span>);</span><br><span class="line">    copy_from_user(&amp;val, buf, count);</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="number">1</span>)</span><br><span class="line">        *gpio_dat &amp;= ~(<span class="number">1</span>&lt;&lt;pin);         <span class="comment">// 点灯</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *gpio_dat |= (<span class="number">1</span>&lt;&lt;pin);          <span class="comment">// 灭灯</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_driver_release</span> <span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PINFO(<span class="string">&quot;led_driver_release\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_fops</span>=</span> &#123;</span><br><span class="line">    .owner              = THIS_MODULE,</span><br><span class="line">    .open               = led_driver_open,</span><br><span class="line">    .write              = led_driver_write,</span><br><span class="line">    .release            = led_driver_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== platform 框架使用的函数 =====</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_driver_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">resource</span>;</span></span><br><span class="line">    PINFO(<span class="string">&quot;led_driver_probe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据platform_device的资源进行ioremap</span></span><br><span class="line">    resource = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    gpio_con = ioremap(resource-&gt;start, resource-&gt;end - resource-&gt;start + <span class="number">1</span>);</span><br><span class="line">    gpio_dat = gpio_con + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    resource = platform_get_resource(pdev, IORESOURCE_IRQ, <span class="number">0</span>);</span><br><span class="line">    pin = resource-&gt;start;              <span class="comment">// 这里只是借用IRQ获取PIN值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_driver_remove</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iounmap(gpio_con);</span><br><span class="line">    PINFO(<span class="string">&quot;led_platform_remove\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">led_driver</span> =</span> &#123;</span><br><span class="line">        .driver = &#123;</span><br><span class="line">            .name   = DRIVER_NAME,</span><br><span class="line">            .owner  = THIS_MODULE,</span><br><span class="line">        &#125;,</span><br><span class="line">        .probe      = led_driver_probe,</span><br><span class="line">        .remove     = led_driver_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">led_driver_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PINFO(<span class="string">&quot;led_driver_init\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册字符设备驱动程序.</span></span><br><span class="line">    <span class="comment">// 由于driver和device可以是一对多的关系. 因此注册工作不能放在probe里, 否则会被注册多次.</span></span><br><span class="line">    led_major = register_chrdev(<span class="number">0</span>, DRIVER_NAME, &amp;led_fops);</span><br><span class="line">    led_class = class_create(THIS_MODULE, DRIVER_NAME);</span><br><span class="line">    class_device_create(led_class, <span class="literal">NULL</span>, MKDEV(led_major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;led&quot;</span>); <span class="comment">// /dev/led</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册platform的driver</span></span><br><span class="line">    platform_driver_register(&amp;led_driver);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">led_driver_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注销platform的driver</span></span><br><span class="line">    platform_driver_unregister(&amp;led_driver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卸载字符设备驱动程序</span></span><br><span class="line">    class_device_destroy(led_class, MKDEV(led_major, <span class="number">0</span>));</span><br><span class="line">    class_destroy(led_class);</span><br><span class="line">    unregister_chrdev(led_major, DRIVER_NAME);</span><br><span class="line">    PINFO(<span class="string">&quot;led_platform_exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_driver_init);</span><br><span class="line">module_exit(led_driver_exit);</span><br></pre></td></tr></table></figure>

<h2 id="led-device-c-硬件专用代码"><a href="#led-device-c-硬件专用代码" class="headerlink" title="led_device.c (硬件专用代码)"></a>led_device.c (硬件专用代码)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;led_platform.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">led_devs_res1</span>[] =</span> &#123;         <span class="comment">// 硬件专用资源信息</span></span><br><span class="line">    &#123;</span><br><span class="line">        .start  = <span class="number">0x56000050</span>,</span><br><span class="line">        .end    = <span class="number">0x56000050</span> + <span class="number">8</span> - <span class="number">1</span>,</span><br><span class="line">        .flags  = IORESOURCE_MEM,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .start  = <span class="number">5</span>,                        <span class="comment">// 借用IRQ表示PIN引脚</span></span><br><span class="line">        .flags  = IORESOURCE_IRQ,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">led_dev_release</span><span class="params">(struct device * dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PINFO(<span class="string">&quot;led_dev_release\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">led_devs1</span> =</span> &#123;</span><br><span class="line">    .name           = DRIVER_NAME,</span><br><span class="line">    .resource       = led_devs_res1,</span><br><span class="line">    .num_resources  = ARRAY_SIZE(led_devs_res1),</span><br><span class="line">    .id             = <span class="number">0</span>,</span><br><span class="line">    .dev = &#123;</span><br><span class="line">        .release = led_dev_release,         <span class="comment">// 必须实现, 否则报错</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PINFO(<span class="string">&quot;led_dev_init\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 注册device</span></span><br><span class="line">    platform_device_register(&amp;led_devs1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">led_dev_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注销device</span></span><br><span class="line">    platform_device_unregister(&amp;led_devs1);</span><br><span class="line">    PINFO(<span class="string">&quot;led_dev_exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_dev_init);</span><br><span class="line">module_exit(led_dev_exit);</span><br></pre></td></tr></table></figure>

<h2 id="led-platform-h"><a href="#led-platform-h" class="headerlink" title="led_platform.h"></a>led_platform.h</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_NAME <span class="meta-string">&quot;led_platform&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDEBUG(fmt,args...) printk(KERN_DEBUG<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERR(fmt,args...) printk(KERN_ERR<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME,##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINFO(fmt,args...) printk(KERN_INFO<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="led-test-c"><a href="#led-test-c" class="headerlink" title="led_test.c"></a>led_test.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* led_test on</span></span><br><span class="line"><span class="comment"> * led_test off</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/led&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage :\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &lt;on|off&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;on&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        val  = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write(fd, &amp;val, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TEST_FILE   := led_test</span><br><span class="line">obj-m       += led_driver.o</span><br><span class="line">obj-m       += led_device.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">install:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules_install</span><br><span class="line">    depmod -a</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br><span class="line">    rm -f <span class="variable">$(TEST_FILE)</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">    arm-linux-gcc <span class="variable">$(TEST_FILE)</span>.c -o <span class="variable">$(TEST_FILE)</span></span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu主机端, 编译所有源码</span></span><br><span class="line">$ make clean</span><br><span class="line">$ make modules</span><br><span class="line">$ make <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端</span></span><br><span class="line">$ insmod led_driver.ko              <span class="comment"># driver和device的调用顺序不重要</span></span><br><span class="line">led_platform:led_driver_init</span><br><span class="line">$ insmod led_device.ko</span><br><span class="line">led_platform:led_dev_init</span><br><span class="line">led_platform:led_driver_probe       <span class="comment"># platform 在匹配driver和device后, 调用probe</span></span><br><span class="line">$ ./led_test on</span><br><span class="line">led_platform:led_driver_open        <span class="comment"># open</span></span><br><span class="line">led_platform:led_driver_write       <span class="comment"># write</span></span><br><span class="line">led_platform:led_driver_release     <span class="comment"># close</span></span><br><span class="line">$ ./led_test off</span><br><span class="line">led_platform:led_driver_open</span><br><span class="line">led_platform:led_driver_write</span><br><span class="line">led_platform:led_driver_release</span><br><span class="line">$ rmmod led_device.ko</span><br><span class="line">led_platform:led_platform_remove    <span class="comment"># 解绑后, 自动调用remove</span></span><br><span class="line">led_platform:led_dev_release</span><br><span class="line">led_platform:led_dev_exit</span><br><span class="line">$ rmmod led_driver.ko</span><br><span class="line">led_platform:led_platform_exit</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://blog.csdn.net/tianzhihen_wq/article/details/42176467">linux驱动之分离分层的概念</a></li>
<li><a href="http://www.wowotech.net/gpio_subsystem/io-port-control.html">linux内核中的GPIO系统之（1）：软件框架</a></li>
<li><a href="http://www.wowotech.net/linux_kenrel/platform_device.html">Linux设备模型(8)_platform设备</a></li>
</ul>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>linuxembedded linux</tag>
        <tag>drv</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之USB基础概念和框架</title>
    <url>/2018/01/18/1807-drv-usb1/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a></li>
<li><a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a></li>
<li><a href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">驱动之RTC分析</a></li>
<li><a href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">驱动之LCD驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/11/1806-drv-ts/">驱动之触摸屏驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">驱动之USB基础概念和框架</a></li>
<li><a href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">驱动之USB设备驱动程序</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="USB基础知识"><a href="#USB基础知识" class="headerlink" title="USB基础知识"></a>USB基础知识</h1><ul>
<li>USB是主从结构的<ul>
<li>所有的USB传输，都是从USB主机这方发起! USB设备没有”主动”通知USB主机的能力。</li>
<li>例子：USB鼠标滑动一下立刻产生数据，但是它没有能力通知PC机来读数据，只能被动地等得PC机来读。</li>
</ul>
</li>
<li>USB的传输类型:<ul>
<li>控制传输(Control Transfers)：可靠，时间有保证，比如：USB设备的识别过程</li>
<li>批量传输(Bulk Transfers):可靠, 时间没有保证, 比如：U盘</li>
<li>中断传输(Interrupt Transfers)：可靠，实时，比如：USB鼠标</li>
<li>实时传输(Isochronous Transfers)：不可靠，实时，比如：USB摄像头</li>
</ul>
</li>
<li>USB的识别过程<ul>
<li>硬件上(USB2.0)<ul>
<li>USB主机端D-和D+接有15K下拉电阻, 未接USB设备时为低电平.</li>
<li>USB设备端D-或D+接有1.5K上拉电阻.</li>
<li>当USB设备插入USB主机端口时, 就会把D-或D+拉高, 让主机知道有设备接入了</li>
<li>把D-拉高是低速设备, 把D+拉高是高速设备</li>
</ul>
</li>
<li>软件上<ul>
<li>USB核心驱动程序负责: 识别USB设备, 给USB设备找到对应的驱动程序</li>
<li>当USB设备接入USB主机端后, 其默认的address是0. PC使用此adress与之通讯.</li>
<li>建立通讯后, USB核心驱动会给它分配一个新的address, 并查找有没有对应的驱动.</li>
</ul>
</li>
</ul>
</li>
<li>USB通讯速率<ul>
<li>低速设备(USB1.1, Low speed): 1.5Mb/s</li>
<li>全速设备(USB1.1, Full speed): 12Mb/s</li>
<li>高速设备(USB2.0, High speed): 480Mb/s</li>
<li>超高速设备(USB3.0, Super speed): 5Gb/s, 全双工</li>
</ul>
</li>
</ul>
<h1 id="USB主机端驱动框架"><a href="#USB主机端驱动框架" class="headerlink" title="USB主机端驱动框架"></a>USB主机端驱动框架</h1><p><img src="https://draapho.github.io/images/1807/usb_layer.png" alt="usb_layer.png"></p>
<p>各层作用如下:</p>
<ul>
<li>USB设备驱动 (USB Device Driver):<ol>
<li>让USB主机知道特定设备的数据含义</li>
<li>linux USB驱动开发就是在这一层. 更底层都是由linux内核完成的.</li>
</ol>
</li>
<li>USB核心层 (USB Core):<ol>
<li>识别USB设备: 分配并设置USB设备的address, 然后发出命令获取描述符.</li>
<li>查找并安装匹配的设备驱动</li>
<li>提供USB读写函数 (只是一个接口, 不知道数据含义)</li>
</ol>
</li>
<li>USB主机控制器 (USB HCD):<ol>
<li>需要支持的USB接口规范, 譬如USB2.0的设备要向下兼容必须包含USB1.1</li>
<li>OHCI: USB1.1 microsoft等创立的标准. 硬件功能强于软件功能</li>
<li>UHCI: USB1.1 intel创立的标准. 软件功能强于硬件功能, 因此芯片价格更低</li>
<li>EHCI: USB2.0</li>
<li>xHCI: USB3.0</li>
</ol>
</li>
</ul>
<h1 id="USB设备端概念"><a href="#USB设备端概念" class="headerlink" title="USB设备端概念"></a>USB设备端概念</h1><p><img src="https://draapho.github.io/images/1807/usb_dev.png" alt="usb_dev.png"></p>
<p>在USB从设备的结构中，从上到下分为:</p>
<ul>
<li>设备(device)<ul>
<li>设备即硬件概念上的USB从设备.</li>
<li><code>address</code> 的概念就是对设备而言的. 一条USB总线最多外接127个USB设备.</li>
<li>软件数据结构 <code>usb_device</code> <code>usb_device_descriptor</code></li>
</ul>
</li>
<li>配置(config)<ul>
<li>设备可以有一个或多个配置. 但任一时刻只有一个有效配置.</li>
<li>这里其实不难理解. 一个USB硬件设备可以允许多种功能.</li>
<li>个典型的例子是手机, 目前手机自动连接后, 都会弹出问你要用哪种模式连接电脑. 对应了不同的配置</li>
<li>因此选中一个配置后, 就从软件上决定了该USB设备的具体功能.</li>
<li>软件数据结构  <code>usb_device</code> <code>usb_host_config</code> <code>usb_config_descriptor</code></li>
</ul>
</li>
<li>接口(interface)<ul>
<li>接口表示逻辑设备, 包含零个或多个endpoint打包.</li>
<li>Linux的USB设备驱动是绑定到接口上的, 每个接口在主机看来都是一个独立的功能设备.</li>
<li>譬如录音接口, 播放接口, 数据接口等等.</li>
<li>软件数据结构  <code>usb_host_interface</code> <code>usb_interface_descriptor</code>.</li>
</ul>
</li>
<li>端点(endpoint)<ul>
<li>传输数据时, USB使用的就是endpoint概念. endpoint是数据通道.</li>
<li><code>endpoint0</code> 用于控制传输, 可双向传输.</li>
<li>除了 <code>endpoint0</code> 以外, 每个端点只支持一个方向的数据传输.</li>
<li>每个 endpoint 都有传输类型和传输方向.</li>
<li>传输类型: 控制传输, 批量传输, 中断传输, 实时传输.</li>
<li>传输方向: 输入(IN), 输出(OUT). 注意, 都是基于USB主机来说的! 读U盘, 数据方向就是输入.</li>
<li>譬如”读写U盘”, 软件上的概念是: 把数据写到U盘的 endpoint1 上去, 从U盘的 endpoint2 里读数据.</li>
<li>软件数据结构  <code>usb_device</code> <code>usb_host_endpoint</code> <code>usb_endpoint_descriptor</code></li>
</ul>
</li>
</ul>
<h1 id="Linux的USB驱动框架"><a href="#Linux的USB驱动框架" class="headerlink" title="Linux的USB驱动框架"></a>Linux的USB驱动框架</h1><p>以下我们用“usb_skel”的USB接口驱动实例（Linux/drivers/usb/usb-skeleton.c）来看看Linux的USB驱动框架：</p>
<p><img src="https://draapho.github.io/images/1807/usb_skel.png" alt="usb_skel.png"></p>
<h1 id="USB核心层源码分析"><a href="#USB核心层源码分析" class="headerlink" title="USB核心层源码分析"></a>USB核心层源码分析</h1><p>把USB设备接到开发板上，看输出信息:</p>
<blockquote>
<p>usb 1-1: new full speed USB device using s3c2410-ohci and address 2<br>usb 1-1: configuration #1 chosen from 1 choice</p>
</blockquote>
<p>拔掉后, 显示断开</p>
<blockquote>
<p>usb 1-1: USB disconnect, address 2</p>
</blockquote>
<p>尝试寻找源码: <code>grep &quot;USB device using&quot; -nR</code>, 找到 <code>drivers/usb/core/hub.c:2186</code> 文件.<br>由此开始分析.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hub_irq                                 <span class="comment">// 硬件检测到USB总线状态变化</span></span><br><span class="line">    kick_khubd                          <span class="comment">// 踢一脚唤醒, 很形象</span></span><br><span class="line">        wake_up(&amp;khubd_wait);           <span class="comment">// 唤醒 hub_thread</span></span><br><span class="line"></span><br><span class="line">hub_thread</span><br><span class="line">    hub_events</span><br><span class="line">        hub_port_connect_change         <span class="comment">// USB总线状态改变事件处理函数</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">hdev</span> =</span> hub-&gt;hdev             <span class="comment">// 处理usb hub的, 忽略</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">udev</span>;</span>                        <span class="comment">// usb设备, 后面具体分析 usb_device 数据结构</span></span><br><span class="line">            udev = usb_alloc_dev(hdev, hdev-&gt;bus, port1);   <span class="comment">// 申请usb设备, 然后初始化一些参数</span></span><br><span class="line">            choose_address(udev);                           <span class="comment">// 挑出一个空闲的address, 但没有告知这个USB设备</span></span><br><span class="line">            hub_port_init                                   <span class="comment">// 开始对新接入的usb设备进行初始化设置</span></span><br><span class="line">                dev_info                                    <span class="comment">// 打印了如下信息:</span></span><br><span class="line">                <span class="comment">// usb 1-1: new full speed USB device using s3c2410-ohci and address 2</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_descriptor</span> *<span class="title">buf</span>;</span>          <span class="comment">// buf 用于取出 bMaxPacketSize0 的大小</span></span><br><span class="line">                hub_set_address                             <span class="comment">// 这里, 才真正把address告诉USB设备</span></span><br><span class="line">                usb_get_device_descriptor(udev, <span class="number">8</span>);         <span class="comment">// 获取设备描述符, 兼容性考虑</span></span><br><span class="line">                usb_get_device_descriptor(udev, USB_DT_DEVICE_SIZE); <span class="comment">// 获取设备描述符</span></span><br><span class="line"></span><br><span class="line">            usb_new_device(udev)                            <span class="comment">// 查找USB设备驱动</span></span><br><span class="line">                usb_get_configuration(udev);                <span class="comment">// 把所有的描述符都读出来，并解析</span></span><br><span class="line">                    usb_get_descriptor                      <span class="comment">// 读描述符</span></span><br><span class="line">                    usb_parse_configuration                 <span class="comment">// 解析配置</span></span><br><span class="line">                device_add                                  <span class="comment">// platform概念的device部分函数.</span></span><br><span class="line">                <span class="comment">// 很熟悉的一个函数了, 见 &quot;驱动之platform概念&quot;</span></span><br><span class="line">                <span class="comment">// 1. 把device放入usb_bus_type的dev链表,</span></span><br><span class="line">                <span class="comment">// 2. 从usb_bus_type的driver链表里取出usb_driver, 把usb_interface和usb_driver的id_table比较</span></span><br><span class="line">                <span class="comment">// 3. 如果能匹配，调用usb_driver的probe</span></span><br></pre></td></tr></table></figure>

<p>下面, 简单分析一下USB的几个描述符结构体<br>结构体内各个变量的具体含义可参考: <a href="http://www.beyondlogic.org/usbnutshell/usb5.shtml">USB Descriptors</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usb_device 和 usb_host_XXX 可以在 include\linux\usb.h 看到</span></span><br><span class="line"><span class="comment">// usb_XXX_descriptor 可以在 include\linux\usb\Ch9.h 看到</span></span><br><span class="line"><span class="comment">// Ch9.h 就是 Chapter9 的缩写, 表示USB协议规范第9章</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> &#123;</span>                         <span class="comment">// usb设备数据结构</span></span><br><span class="line">    <span class="keyword">int</span>     devnum;                         <span class="comment">/* Address on USB bus */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">usb_device_state</span>   <span class="title">state</span>;</span>          <span class="comment">/* configured, not attached, etc */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">usb_device_speed</span>   <span class="title">speed</span>;</span>          <span class="comment">/* high/full/low (or error) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// usb_host_*** 里面就包含了 usb 描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span> <span class="title">ep0</span>;</span>           <span class="comment">// 特殊的 endpoint0 可双向传输</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_descriptor</span> <span class="title">descriptor</span>;</span><span class="comment">/* Descriptor */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_config</span> *<span class="title">config</span>;</span>         <span class="comment">/* All of the configs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_config</span> *<span class="title">actconfig</span>;</span>      <span class="comment">/* the active configuration */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span> *<span class="title">ep_in</span>[16];</span>    <span class="comment">// 用做输入的 endpoint</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span> *<span class="title">ep_out</span>[16];</span>   <span class="comment">// 用做输出的 endpoint</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* static strings from the device */</span></span><br><span class="line">    <span class="keyword">char</span> *product;                          <span class="comment">/* iProduct string, if present */</span></span><br><span class="line">    <span class="keyword">char</span> *manufacturer;                     <span class="comment">/* iManufacturer string, if present */</span></span><br><span class="line">    <span class="keyword">char</span> *serial;                           <span class="comment">/* iSerialNumber string, if present */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个USB描述符的数据结构框架如下:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span>                   // <span class="title">usb</span>设备</span></span><br><span class="line"><span class="class">    <span class="keyword">struct</span> <span class="title">usb_device_descriptor</span>        // <span class="title">device</span> 描述符</span></span><br><span class="line"><span class="class">        __<span class="title">le16</span> <span class="title">bcdUSB</span>;</span>                      <span class="comment">// 设备支持的最高USB版本</span></span><br><span class="line">        __u8  bDeviceClass;                 <span class="comment">// 设备类别</span></span><br><span class="line">        __u8  bDeviceSubClass;              <span class="comment">// 设备子类</span></span><br><span class="line">        __u8  bDeviceProtocol;              <span class="comment">// 通信协议</span></span><br><span class="line">        __u8  bMaxPacketSize0;              <span class="comment">// endpoint0 通讯支持的最大数据量</span></span><br><span class="line">        __le16 idVendor;                    <span class="comment">// 经销商ID, 由USB机构分配给厂家</span></span><br><span class="line">        __le16 idProduct;                   <span class="comment">// 产品ID, 由USB厂家自己分配</span></span><br><span class="line">        __u8  iSerialNumber;                <span class="comment">// 产品序列号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_config</span>              // 主机记录的<span class="title">config</span>信息</span></span><br><span class="line"><span class="class">        <span class="keyword">struct</span> <span class="title">usb_config_descriptor</span>        // <span class="title">config</span> 描述符</span></span><br><span class="line"><span class="class">            __<span class="title">le16</span> <span class="title">wTotalLength</span>;</span>                <span class="comment">// config 总数据长度</span></span><br><span class="line">            __u8  bNumInterfaces;               <span class="comment">// config包含的interface数量</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">usb_interface</span>                // <span class="title">USB</span> <span class="title">interface</span></span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">usb_host_interface</span>           // 主机记录的<span class="title">interface</span>信息</span></span><br><span class="line"><span class="class">                <span class="keyword">struct</span> <span class="title">usb_interface_descriptor</span>     // <span class="title">interface</span>描述符</span></span><br><span class="line"><span class="class">                    __<span class="title">u8</span>  <span class="title">bInterfaceNumber</span>;</span>             <span class="comment">// interface编号</span></span><br><span class="line">                    __u8  bNumEndpoints;                <span class="comment">// 包含的endpoint数量</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span>            // 该<span class="title">interface</span>包含的<span class="title">endpoint</span></span></span><br><span class="line"><span class="class">            <span class="title">int</span> <span class="title">minor</span>;</span>                          <span class="comment">// 该USB interface的子设备号</span></span><br><span class="line">            <span class="comment">// 这里可以看出, Linux下, USB设备驱动是被绑到 USB interface 这一层的.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span>            // 主机记录的该<span class="title">USB</span>设备所有的<span class="title">endpoint</span></span></span><br><span class="line"><span class="class">        <span class="keyword">struct</span> <span class="title">usb_endpoint_descriptor</span>      // <span class="title">endpoint</span> 描述符</span></span><br><span class="line"><span class="class">            __<span class="title">u8</span>  <span class="title">bEndpointAddress</span>;</span>             <span class="comment">// endpoint 地址</span></span><br><span class="line">            __le16 wMaxPacketSize;              <span class="comment">// 支持的数据包大小</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">urb_list</span>;</span>          <span class="comment">// URB列表, USB Request Block.</span></span><br><span class="line">        <span class="comment">// URB 是linux内核给USB底层通讯抽象出来一种方法. 类似于TCP/IP协议里的socket方法.</span></span><br></pre></td></tr></table></figure>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://blog.csdn.net/ahskx/article/details/50618983">Linux的USB驱动分析</a></li>
<li><a href="http://www.embeddedlinux.org.cn/emb-linux/kernel-driver/201710/25-7669.html">Linux USB驱动工作流程</a></li>
<li><a href="http://blog.csdn.net/u014276460/article/details/47292427">浅谈USB驱动架构</a></li>
<li><a href="http://www.cnblogs.com/xiaojiang1025/p/6500574.html">Linux usb子系统(一) _写一个usb鼠标驱动</a></li>
<li><a href="http://www.beyondlogic.org/usbnutshell/usb4.shtml">USB in a NutShell</a></li>
<li><a href="http://www.beyondlogic.org/usbnutshell/usb5.shtml">USB Descriptors</a></li>
<li><a href="https://www.crifan.com/files/doc/docbook/usb_basic/release/webhelp/four_hci_relations.html">USB控制器类型：OHCI，UHCI，EHCI，xHCI</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之块设备-框架</title>
    <url>/2018/01/22/1809-drv-blk/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/22/1809-drv-blk/">驱动之块设备-框架</a></li>
<li><a href="https://draapho.github.io/2018/01/24/1810-drv-nand1/">驱动之NAND Flash框架</a></li>
<li><a href="https://draapho.github.io/2018/01/25/1811-drv-nand2/">驱动之NAND Flash源码</a></li>
<li>[驱动之NOR Flash](<a href="https://draapho.github.io/2018/01/26/1812-drv-nor/">https://draapho.github.io/2018/01/26/1812-drv-nor/</a></li>
<li><a href="https://draapho.github.io/2018/02/06/1813-drv-net/">驱动之网卡驱动</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="块设备的驱动框架"><a href="#块设备的驱动框架" class="headerlink" title="块设备的驱动框架"></a>块设备的驱动框架</h1><h2 id="驱动框架"><a href="#驱动框架" class="headerlink" title="驱动框架"></a>驱动框架</h2><p><img src="https://draapho.github.io/images/1809/block.png" alt="block.png"></p>
<p><img src="https://draapho.github.io/images/1809/block_fun.png" alt="block_fun.png"></p>
<ul>
<li><code>ll_rw_block</code>: Low Level Read/Write block device</li>
<li><code>submit_bh</code>: submit Buffer Head</li>
<li><code>submit_bio</code>: submit Block IO (Input/Output)</li>
<li><code>elv_merge</code>: elevator merge. 用电梯算法合并数据</li>
</ul>
<h2 id="硬盘基础概念"><a href="#硬盘基础概念" class="headerlink" title="硬盘基础概念"></a>硬盘基础概念</h2><p>块设备为了兼容机械结构的硬盘, 使用了一些硬盘特有的概念.</p>
<p><img src="https://draapho.github.io/images/1809/Platter.jpg" alt="Platter.jpg"></p>
<p><img src="https://draapho.github.io/images/1809/Cylinder.png" alt="Cylinder.png"></p>
<ul>
<li><code>存储容量 = 磁头数 x 柱面数 x 扇区数 x 512(扇区字节数)</code></li>
<li><code>存储容量 = 柱面大小 x 柱面数</code></li>
<li><code>柱面大小 = 磁头数 x 扇区数 x 512(扇区字节数)</code></li>
</ul>
<table>
<thead>
<tr>
<th>英语</th>
<th>中文</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Disk</td>
<td>磁盘</td>
<td>就是硬盘</td>
</tr>
<tr>
<td>Platter</td>
<td>圆盘</td>
<td>硬盘的盘片</td>
</tr>
<tr>
<td>Head</td>
<td>磁头</td>
<td>盘片有2面: 2磁头/圆盘</td>
</tr>
<tr>
<td>Track</td>
<td>磁道</td>
<td>圆盘被分割为多个同心圆, 即磁道</td>
</tr>
<tr>
<td>Sector</td>
<td>扇区</td>
<td>磁道被分割后的扇形区域</td>
</tr>
<tr>
<td>Cylinder</td>
<td>柱面</td>
<td>由多个圆盘的同一磁道构成</td>
</tr>
<tr>
<td>Partition</td>
<td>分区</td>
<td>软件概念, 以柱面为单位</td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://draapho.github.io/2017/02/01/1704-linux-source4/">Linux 0.11 源码阅读笔记-设备驱动程序</a></li>
<li><a href="http://blog.csdn.net/zdy0_2004/article/details/78206395">Linux-块设备驱动之框架详细分析(详解)</a></li>
<li><a href="http://blog.csdn.net/hustfoxy/article/details/8723178">Linux块设备驱动</a></li>
<li><a href="http://blog.chinaunix.net/uid-23069658-id-3413957.html">硬盘的存储原理和内部架构</a></li>
<li><a href="http://www.bijishequ.com/detail/193530">计算机机械硬盘的结构和工作原理</a></li>
<li><a href="http://www.dongcoder.com/detail-473552.html">磁盘的组成</a></li>
<li><a href="http://www.cnblogs.com/joydinghappy/articles/2511948.html">磁盘结构简介</a></li>
</ul>
<h1 id="块设备驱动范例"><a href="#块设备驱动范例" class="headerlink" title="块设备驱动范例"></a>块设备驱动范例</h1><p>块设备驱动的实现更为简单. Linux内核做掉了大部分工作, 驱动层只需要专注于硬件的块读写功能.<br>而且其框架相对固定, 不像字符设备有多种不同的框架组合.</p>
<p>可以参考内核里的两个文件</p>
<ul>
<li><code>drivers\block\xd.c</code> 用于 XT hard disk.</li>
<li><code>drivers\block\z2ram.c</code> ram disk.</li>
<li>给出的源码没有做返回值判断, <strong>实际使用时务必参考上面的范例实现错误处理</strong>.</li>
</ul>
<p>基本步骤如下:</p>
<ol>
<li>分配gendisk: <code>alloc_disk</code></li>
<li>设置<br> 2.1 分配/设置缓冲队列. <code>blk_init_queue</code><br> 2.2 设置gendisk其他信息, 用于提供硬件属性, 如容量</li>
<li>硬件初始化操作</li>
<li>注册: <code>add_disk</code></li>
</ol>
<h2 id="ramblock-c"><a href="#ramblock-c" class="headerlink" title="ramblock.c"></a>ramblock.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/vmalloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/blkdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/hdreg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NAME <span class="meta-string">&quot;RAMDISK&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAMBLOCK_SIZE (1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> major;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> *<span class="title">ramblock_disk</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">request_queue_t</span> *ramblock_queue;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_SPINLOCK</span><span class="params">(ramblock_lock)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *ramblock_buf;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区需要知道&quot;硬盘&quot;的几何结构(geometry), 这里虚拟一下即可.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ramblock_getgeo</span><span class="params">(struct block_device *bdev, struct hd_geometry *geo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    geo-&gt;heads     = <span class="number">2</span>;                                     <span class="comment">// 磁头数=盘面数*2</span></span><br><span class="line">    geo-&gt;cylinders = <span class="number">32</span>;                                    <span class="comment">// 柱面数</span></span><br><span class="line">    geo-&gt;sectors   = RAMBLOCK_SIZE/<span class="number">2</span>/<span class="number">32</span>/<span class="number">512</span>;                <span class="comment">// 扇区数. 利用公式: 存储容量=磁头数x柱面数x扇区数x512</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> <span class="title">ramblock_fops</span> =</span> &#123;</span><br><span class="line">    .owner  = THIS_MODULE,</span><br><span class="line">    .getgeo = ramblock_getgeo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现扇区的读写操作</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_ramblock_request</span><span class="params">(<span class="keyword">request_queue_t</span> * q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> r_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> w_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((req = elv_next_request(q)) != <span class="literal">NULL</span>) &#123;           <span class="comment">// 取出要处理的数据(连续的扇区数据, 即簇)</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> offset = req-&gt;sector*<span class="number">512</span>;             <span class="comment">// 读写的目标地址</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> len = req-&gt;current_nr_sectors*<span class="number">512</span>;    <span class="comment">// 长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rq_data_dir(req) == READ) &#123;                     <span class="comment">// 读操作</span></span><br><span class="line">            printk(<span class="string">&quot;do_ramblock_request read %d\n&quot;</span>, ++r_cnt);</span><br><span class="line">            <span class="built_in">memcpy</span>(req-&gt;buffer, ramblock_buf+offset, len);  <span class="comment">// 直接读 ramblock_buf</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                            <span class="comment">// 写操作</span></span><br><span class="line">            printk(<span class="string">&quot;do_ramblock_request write %d\n&quot;</span>, ++w_cnt);</span><br><span class="line">            <span class="built_in">memcpy</span>(ramblock_buf+offset, req-&gt;buffer, len);  <span class="comment">// 直接写 ramblock_buf</span></span><br><span class="line">        &#125;</span><br><span class="line">        end_request(req, <span class="number">1</span>);                                <span class="comment">// 告知操作完成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ramblock_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 1. 分配一个gendisk结构体 */</span></span><br><span class="line">    ramblock_disk = alloc_disk(<span class="number">16</span>);                         <span class="comment">// 次设备号个数, 也是允许的最大分区个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 设置 */</span></span><br><span class="line">    <span class="comment">/* 2.1 分配/设置缓冲队列 */</span></span><br><span class="line">    ramblock_queue = blk_init_queue(do_ramblock_request, &amp;ramblock_lock);</span><br><span class="line">    ramblock_disk-&gt;<span class="built_in">queue</span> = ramblock_queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2.2 设置其他属性: 比如容量 */</span></span><br><span class="line">    major = register_blkdev(<span class="number">0</span>, DEVICE_NAME);                <span class="comment">// cat /proc/devices 查看块设备</span></span><br><span class="line">    ramblock_disk-&gt;major       = major;                     <span class="comment">// 主设备号</span></span><br><span class="line">    ramblock_disk-&gt;first_minor = <span class="number">0</span>;                         <span class="comment">// 次设备号起始值</span></span><br><span class="line">    <span class="built_in">sprintf</span>(ramblock_disk-&gt;disk_name, <span class="string">&quot;ramblock&quot;</span>);</span><br><span class="line">    ramblock_disk-&gt;fops        = &amp;ramblock_fops;</span><br><span class="line">    set_capacity(ramblock_disk, RAMBLOCK_SIZE / <span class="number">512</span>);       <span class="comment">// 设置扇区的数量, 不是字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 硬件初始化操作 */</span></span><br><span class="line">    ramblock_buf = kzalloc(RAMBLOCK_SIZE, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. 注册 */</span></span><br><span class="line">    add_disk(ramblock_disk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ramblock_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    del_gendisk(ramblock_disk);                     <span class="comment">// 对应 add_disk</span></span><br><span class="line">    put_disk(ramblock_disk);                        <span class="comment">// 对应 blk_init_queue</span></span><br><span class="line">    blk_cleanup_queue(ramblock_queue);              <span class="comment">// 对应 blk_init_queue</span></span><br><span class="line">    unregister_blkdev(major, DEVICE_NAME);          <span class="comment">// 对应 register_blkdev</span></span><br><span class="line">    kfree(ramblock_buf);                            <span class="comment">// 安全起见, 最后释放buf</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(ramblock_init);</span><br><span class="line">module_exit(ramblock_exit);</span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m       := ramblock.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu主机端</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/drv_blk/         # 块设备驱动目录</span></span><br><span class="line">$ make modules                                  <span class="comment"># 生成 ramblock.ko</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/drv_blk/         # 块设备驱动目录, nfs</span></span><br><span class="line">$ insmod ramblock.ko</span><br><span class="line"> ramblock:do_ramblock_request <span class="built_in">read</span> 1</span><br><span class="line"> unknown partition table                        <span class="comment"># ramblock_buf 全是0, 所以显示无效分区表.</span></span><br><span class="line"></span><br><span class="line">$ ls /dev/ramblock*                             <span class="comment"># 可以看到 ramblock 设备了</span></span><br><span class="line">$ cat /proc/devices</span><br><span class="line">254 RAMDISK                                     <span class="comment"># register_blkdev产生的块设备信息</span></span><br><span class="line"></span><br><span class="line">$ mkdosfs /dev/ramblock                         <span class="comment"># 格式化. 没有mkfs指令, 用mkdosfs</span></span><br><span class="line">$ mount /dev/ramblock /tmp                      <span class="comment"># 挂载为 /tmp</span></span><br><span class="line"></span><br><span class="line">$ vi /tmp/<span class="built_in">test</span>                                  <span class="comment"># 在ramblock_disk里读写文件</span></span><br><span class="line">do_ramblock_request <span class="built_in">read</span> 43                     <span class="comment"># 退出后, 只是读取块, 然后在缓冲区修改. 没有真正写入!</span></span><br><span class="line">$ sync                                          <span class="comment"># 多等一会, 或者输入sync同步指令, 开始写入磁盘</span></span><br><span class="line">do_ramblock_request write 6</span><br><span class="line">do_ramblock_request write 7 ......</span><br><span class="line"></span><br><span class="line">$ cp ramblock.c /tmp/                           <span class="comment"># 随便拷贝一个文件</span></span><br><span class="line"><span class="comment"># 没有打印 do_ramblock_request write 说明文件还没有被真正写入磁盘</span></span><br><span class="line">$ sync                                          <span class="comment"># 多等一会, 或者输入sync同步指令, 开始写入磁盘</span></span><br><span class="line">do_ramblock_request write 11</span><br><span class="line">do_ramblock_request write 12 ......</span><br><span class="line"></span><br><span class="line">$ ls /tmp                                       <span class="comment"># 显示 ramblock 里的文件</span></span><br><span class="line">ramblock.c  <span class="built_in">test</span></span><br><span class="line">$ umount /tmp                                   <span class="comment"># 卸载 /tmp</span></span><br><span class="line">do_ramblock_request write 16 ......             <span class="comment"># 如果有未写入的数据, 此时会写入.</span></span><br><span class="line">$ ls /tmp                                       <span class="comment"># 这时候, tmp文件夹就是空的了.</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$cat</span> /dev/ramblock &gt; ./ramblock.bin             <span class="comment"># 把整个磁盘打包成文件. 当前路径是ubuntu的nfs</span></span><br><span class="line">do_ramblock_request <span class="built_in">read</span> ......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后切换到 Ubuntu主机端</span></span><br><span class="line">$ sudo mount -o loop ramblock.bin /mnt          <span class="comment"># -o loop 表示挂载指定文件, 挂载到/mnt目录下</span></span><br><span class="line">$ ls /mnt                                       <span class="comment"># 显示了之前 ramblock 里的内容.</span></span><br><span class="line">ramblock.c  <span class="built_in">test</span></span><br><span class="line">$ sudo umount /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 开发板端</span></span><br><span class="line">$ mkdir /ramdisk</span><br><span class="line">$ mount /dev/ramblock /ramdisk                  <span class="comment"># 重新挂载为 /ramdisk</span></span><br><span class="line">$ ls /ramdisk                                   <span class="comment"># 显示 ramblock 里的文件</span></span><br><span class="line">ramblock.c  <span class="built_in">test</span></span><br><span class="line">$ df                                            <span class="comment"># 可以查看文件系统信息.</span></span><br><span class="line">Filesystem           1k-blocks      Used Available Use% Mounted on</span><br><span class="line">/dev/ramblock             1004         6       998   1% /ramdisk</span><br><span class="line"></span><br><span class="line">$ umount /ramdisk                               <span class="comment"># 卸载ramdisk, 否则无法卸载驱动</span></span><br><span class="line">$ rmdir /ramdisk</span><br><span class="line">$ rmmod ramblock                                <span class="comment"># 卸载驱动, 里面数据就没有了!</span></span><br><span class="line"><span class="comment"># 观察打印信息 do_ramblock_request 可得: 块设备操作都是批量的读或者批量的写.</span></span><br><span class="line"><span class="comment"># 这是由电梯算法实现的, 能大大提高硬盘的物理读写速度, 减缓由磁盘操作造成的速度下降</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始做fdisk分区测试 (分区指令需要 geometry 信息)</span></span><br><span class="line">$ insmod ramblock.ko</span><br><span class="line">$ ls /dev/ramblock*                             <span class="comment"># 查看设备</span></span><br><span class="line">/dev/ramblock                                   <span class="comment"># 没有分区, 只有一个总的磁盘设备</span></span><br><span class="line">$ fdisk /dev/ramblock</span><br><span class="line">m                                               <span class="comment"># m for help</span></span><br><span class="line">n p Partition number: 1 cylinder value: 1-8     <span class="comment"># 增加一个主分区</span></span><br><span class="line">n p Partition number: 2 cylinder value: 9-32    <span class="comment"># 再增加一个主分区</span></span><br><span class="line">p                                               <span class="comment"># 查看设置的分区情况</span></span><br><span class="line">w                                               <span class="comment"># 执行上述配置</span></span><br><span class="line"></span><br><span class="line">$ ls /dev/ramblock* -l                          <span class="comment"># 再次查看设备, b表示块设备</span></span><br><span class="line">brw-rw----    1 0        0        254,   0 Jan  1 00:01 /dev/ramblock   <span class="comment"># 整个磁盘设备</span></span><br><span class="line">brw-rw----    1 0        0        254,   1 Jan  1 00:01 /dev/ramblock1  <span class="comment"># 分区一</span></span><br><span class="line">brw-rw----    1 0        0        254,   2 Jan  1 00:01 /dev/ramblock2  <span class="comment"># 分区二</span></span><br><span class="line"></span><br><span class="line">$ mkdosfs /dev/ramblock1                        <span class="comment"># 格式化</span></span><br><span class="line">$ mkdosfs /dev/ramblock2</span><br><span class="line">$ mkdir /mnt/ramdisk1                           <span class="comment"># 创建挂载文件点</span></span><br><span class="line">$ mkdir /mnt/ramdisk2</span><br><span class="line">$ mount /dev/ramblock1 /mnt/ramdisk1            <span class="comment"># 挂载</span></span><br><span class="line">$ mount /dev/ramblock2 /mnt/ramdisk2</span><br><span class="line"><span class="comment"># 做一些操作, 如读写/拷贝文件...</span></span><br><span class="line">$ mkdosfs /dev/ramblock                         <span class="comment"># 危险操作!!! 依旧能格式化整个磁盘.</span></span><br><span class="line"></span><br><span class="line">$ umount /mnt/ramdisk1</span><br><span class="line">$ umount /mnt/ramdisk2</span><br><span class="line">$ rmdir /mnt/ramdisk1</span><br><span class="line">$ rmdir /mnt/ramdisk2</span><br></pre></td></tr></table></figure>

<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之NAND Flash框架</title>
    <url>/2018/01/24/1810-drv-nand1/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/22/1809-drv-blk/">驱动之块设备-框架</a></li>
<li><a href="https://draapho.github.io/2018/01/24/1810-drv-nand1/">驱动之NAND Flash框架</a></li>
<li><a href="https://draapho.github.io/2018/01/25/1811-drv-nand2/">驱动之NAND Flash源码</a></li>
<li>[驱动之NOR Flash](<a href="https://draapho.github.io/2018/01/26/1812-drv-nor/">https://draapho.github.io/2018/01/26/1812-drv-nor/</a></li>
<li><a href="https://draapho.github.io/2018/02/06/1813-drv-net/">驱动之网卡驱动</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="NAND-Flash-基础知识"><a href="#NAND-Flash-基础知识" class="headerlink" title="NAND Flash 基础知识"></a>NAND Flash 基础知识</h1><h2 id="NAND-和-NOR-Flash的比较"><a href="#NAND-和-NOR-Flash的比较" class="headerlink" title="NAND 和 NOR Flash的比较"></a>NAND 和 NOR Flash的比较</h2><table>
<thead>
<tr>
<th>NOR FLASH</th>
<th>NAND FLASH</th>
</tr>
</thead>
<tbody><tr>
<td>接口时序同SRAM,易使用</td>
<td>地址/数据线复用，数据位较窄</td>
</tr>
<tr>
<td>读取速度较快</td>
<td>读取速度较慢</td>
</tr>
<tr>
<td>擦除速度慢，以64-128KB的块为单位</td>
<td>擦除速度快，以8－32KB的块为单位</td>
</tr>
<tr>
<td>写入速度慢</td>
<td>写入速度快</td>
</tr>
<tr>
<td>随机存取速度较快，支持XIP(eXecute In Place，芯片内执行)，适用于代码存储。在嵌入式系统中，常用于存放引导程序、根文件系统等。</td>
<td>顺序读取速度较快，随机存取速度慢，适用于数据存储(如大容量的多媒体应用)。在嵌入式系统中，常用于存放用户文件系统等。</td>
</tr>
<tr>
<td>单片容量较小，1-32MB</td>
<td>单片容量较大，8-128MB，提高了单元密度</td>
</tr>
<tr>
<td>最大擦写次数10万次</td>
<td>最大擦写次数100万次</td>
</tr>
</tbody></table>
<h2 id="硬件接口和时序"><a href="#硬件接口和时序" class="headerlink" title="硬件接口和时序"></a>硬件接口和时序</h2><p>看相关数据手册, 以jz2440v3开发板为例:</p>
<ul>
<li><code>K9F2G08U0C.pdf</code> NAND Flash 数据手册</li>
<li><code>S3C2440A_UserManual_Rev13.pdf</code> CPU 数据手册</li>
</ul>
<p>NAND Flash的硬件引脚基本固定, 下面列出各个引脚的含义</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>英文原意</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>I/O</td>
<td>data Inputs/Outputs</td>
<td>数据收发, 8bit或16bit</td>
</tr>
<tr>
<td>CLE</td>
<td>Command Latch Enable</td>
<td>传的是指令, 高电平有效</td>
</tr>
<tr>
<td>ALE</td>
<td>Address Latch Enable</td>
<td>传的是地址, 高电平有效</td>
</tr>
<tr>
<td>_CE 或 nCE</td>
<td>Chip Enable</td>
<td>片选信号, 低电平有效</td>
</tr>
<tr>
<td>_RE 或 nRE</td>
<td>Read Enable</td>
<td>读数据, 低电平有效</td>
</tr>
<tr>
<td>_WE 或 nWE</td>
<td>Write Enable</td>
<td>写数据, 低电平有效</td>
</tr>
<tr>
<td>R/_B 或 R/nB</td>
<td>Ready/Busy</td>
<td>空闲/忙信号, 忙为低电平</td>
</tr>
</tbody></table>
<p>查看三星S3C2440数据手册 <code>NAND Flash Controller</code> 章节可知, 已将nand flash的时序操作打包成了寄存器操作.<br>u-boot里面, 可以使用 <code>md</code> <code>mw</code> 直接对memroy进行操作. 因此可在u-boot下面直接用指令来操作nand flash的时序</p>
<ul>
<li><code>md</code>, Memory Display. 显示指定内存地址的内容. <code>.b</code>表Byte, 字节. <code>.w</code>表Word, 2字节. <code>.l</code>表Long, 4字节.</li>
<li><code>mw</code>, Memory Write. 写入内容到指定内存地址. <code>.b</code>表Byte, 字节. <code>.w</code>表Word, 2字节. <code>.l</code>表Long, 4字节.</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>物理操作</th>
<th>S3C2440 寄存器操作</th>
<th>u-boot 直接操作对应的寄存器地址</th>
</tr>
</thead>
<tbody><tr>
<td>片选</td>
<td>_CE低</td>
<td>NFCONT bit1=0</td>
<td>md.l 读一下, mw.l 0x4E000004 回写bit1=0</td>
</tr>
<tr>
<td>发命令</td>
<td>CLE高, ALE低, I/O命令值, _WE高变低</td>
<td>NFCMMD=命令值</td>
<td>mw.b 0x4E000008 命令值</td>
</tr>
<tr>
<td>发地址</td>
<td>ALE高, CLE低, I/O地址值, _WE高变低</td>
<td>NFADDR=地址值</td>
<td>mw.b 0x4E00000C 地址值</td>
</tr>
<tr>
<td>发数据</td>
<td>CLE低, ALE低, I/O数据值, _WE高变低</td>
<td>NFDATA=数据值</td>
<td>mw.b 0x4E000010 数据值</td>
</tr>
<tr>
<td>读数据</td>
<td>CLE低, ALE低, _RE高变低, 取I/O值</td>
<td>数据值=NFDATA</td>
<td>md.b 0x4E000010 1</td>
</tr>
</tbody></table>
<h2 id="读写实验"><a href="#读写实验" class="headerlink" title="读写实验"></a>读写实验</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot 命令行, 最好是从 NAND Flash 启动的uboot.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 读取 ID, 查看 K9F2G08U0C 数据手册 5.5 Read ID 时序图.</span></span><br><span class="line">md.l 0x4E000004 1           <span class="comment"># 读取 NFCONT 寄存器值. 1表示长度, 就读一个数据. 默认值是16</span></span><br><span class="line">mw.l 0x4E000004 1           <span class="comment"># 置 bit1=0 后, 回写</span></span><br><span class="line">mw.b 0x4E000008 0x90        <span class="comment"># 发命令 NFCMMD=0x90</span></span><br><span class="line">mw.b 0x4E00000C 0x00        <span class="comment"># 发地址 NFADDR=0x00</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 读数据 NFDATA, 应该得到 ec</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 继续读 NFDATA, 应该得到device code, da</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 继续读 NFDATA, 应该得到device code, 10</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 继续读 NFDATA, 应该得到device code, 15 (这里返回了95, 先不管)</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 继续读 NFDATA, 应该得到device code, 44</span></span><br><span class="line"><span class="comment"># 这里不能使用指令 md.b 0x4E000010 5 读取5个字节. 因为其含义是读 0x4E000010-0x4E000014 的寄存器值, 必然是错的.</span></span><br><span class="line">mw.b 0x4E000008 0xff        <span class="comment"># 发RESET命令 NFCMMD=0xFF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 读取0地址的数据, 查看 K9F2G08U0C 数据手册 5.1 Page Read 时序图</span></span><br><span class="line">nand dump 0                 <span class="comment"># 先用nand指令直接读取nand flash的页, 后面在用寄存器操作的方式读一遍来对比</span></span><br><span class="line">17 00 00 ea 14 f0 9f e5  14 f0 9f e5 14 f0 9f e5</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">md.l 0x4E000004 1           <span class="comment"># 读取 NFCONT 寄存器值. 1表示长度, 就读一个数据. 默认值是16</span></span><br><span class="line">mw.l 0x4E000004 1           <span class="comment"># 置 bit1=0 后, 回写</span></span><br><span class="line">mw.b 0x4E000008 0x00        <span class="comment"># 写命令 NFCMMD=0x00</span></span><br><span class="line">mw.b 0x4E00000C 0x00        <span class="comment"># 写地址 NFADDR=0x00</span></span><br><span class="line">mw.b 0x4E00000C 0x00        <span class="comment"># 写地址 NFADDR=0x00</span></span><br><span class="line">mw.b 0x4E00000C 0x00        <span class="comment"># 写地址 NFADDR=0x00</span></span><br><span class="line">mw.b 0x4E00000C 0x00        <span class="comment"># 写地址 NFADDR=0x00</span></span><br><span class="line">mw.b 0x4E00000C 0x00        <span class="comment"># 写地址 NFADDR=0x00</span></span><br><span class="line"><span class="comment"># 这款nand总线是8位, 时序图要求5个周期. 由2字节的列地址和3字节的行地址组成.</span></span><br><span class="line">mw.b 0x4E000008 0x30        <span class="comment"># 读命令 NFCMMD=0x30</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 读数据 NFDATA</span></span><br><span class="line">......                      <span class="comment"># 重复多次这个指令, 譬如16次</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 读数据 NFDATA, 得到的数据应该和 nand dump 0 的一样</span></span><br><span class="line"><span class="comment"># 16此返回值应该和 nand dump 的结果一样: 17 00 00 ea 14 f0 9f e5  14 f0 9f e5 14 f0 9f e5</span></span><br><span class="line"><span class="comment"># 这里不能使用指令 md.b 0x4E000010 16 读取16个字节. 因为其含义是读 0x4E000010-0x4E000020 的寄存器值, 必然是错的.</span></span><br><span class="line">mw.b 0x4E000008 0xff        <span class="comment"># 发RESET命令 NFCMMD=0xFF</span></span><br></pre></td></tr></table></figure>

<h1 id="NAND-Flash-系统框架"><a href="#NAND-Flash-系统框架" class="headerlink" title="NAND Flash 系统框架"></a>NAND Flash 系统框架</h1><p><img src="https://draapho.github.io/images/1810/nand1.jpg" alt="nand1"></p>
<p><img src="https://draapho.github.io/images/1810/nand2.png" alt="nand2"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由Linux系统启动时的打印信息, 可以抓取到 NAND FLASH 相关的初始化信息和分区信息.</span></span><br><span class="line"><span class="comment">// 可得 &quot;S3C24XX NAND Driver, ...&quot; 搜索后, 定位到文件 &quot;/drivers/mtd/nand/s3c2410.c&quot;</span></span><br><span class="line"><span class="comment">// mtd: Memory Technology Device. 记忆体技术设备, 也就是 nand/nor flash.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----&gt; /drivers/mtd/nand/s3c2410.c</span></span><br><span class="line">s3c2410_nand_init                                               <span class="comment">// 看驱动文件, 从 module_init 开始</span></span><br><span class="line">    platform_driver_register(&amp;s3c2440_nand_driver);             <span class="comment">// 很明显用了 platform 框架</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----&gt; /arch/arm/plat-s3c24xx/common-smdk.c              // 这里是 platform 框架的 device 配置</span></span><br><span class="line">    smdk_machine_init</span><br><span class="line">        s3c_device_nand.dev.platform_data = &amp;smdk_nand_info;</span><br><span class="line">        platform_add_devices(smdk_devs);                        <span class="comment">// 找到了 platform 的 devices 端.</span></span><br><span class="line">        <span class="comment">// 这里看下 smdk_nand_info, smdk_devs的s3c_device_nand 就都明白了. 配置nand的名称和参数.</span></span><br><span class="line">    <span class="comment">// -----&gt; 结束, common-smdk.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看完了platform框架, 匹配后就是调用probe函数. 几次跳转后, 最终调用:</span></span><br><span class="line">s3c24xx_nand_probe</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s3c2410_platform_nand</span> *<span class="title">plat</span> =</span> to_nand_plat(pdev);    <span class="comment">// 取出了 smdk_nand_info 的配置信息</span></span><br><span class="line">    s3c2410_nand_inithw                                         <span class="comment">// 初始化硬件, 如时序</span></span><br><span class="line">    s3c2410_nand_init_chip                                      <span class="comment">// 初始化通讯, 如缓冲区, 寄存器值</span></span><br><span class="line">    nand_scan                                                   <span class="comment">// 开始通讯, 检查 nand flash</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----&gt; /drivers/mtd/nand/nand_base.c                     // NAND FLASH 操作的通用文件</span></span><br><span class="line">    nand_scan</span><br><span class="line">        nand_scan_ident                                         <span class="comment">// 第一阶段的初始化, 检查flash硬件</span></span><br><span class="line">            nand_set_defaults                                   <span class="comment">// nand 通信使用默认参数</span></span><br><span class="line">            nand_get_flash_type                                 <span class="comment">// 获取第一块 nand 的ID值</span></span><br><span class="line">                nand_flash_ids                                  <span class="comment">// 常用的 nand flash 表. 可见内核都支持了</span></span><br><span class="line">            printk(KERN_INFO <span class="string">&quot;%d NAND chips detected\n&quot;</span>, i);    <span class="comment">// 接了多块nand的话, 必须是同型号的</span></span><br><span class="line">            mtd-&gt;size = i * chip-&gt;chipsize;                     <span class="comment">// 总容量 = nand数量*单片容量</span></span><br><span class="line">        nand_scan_tail                                          <span class="comment">// 第二阶段的初始化工作, 软件设置</span></span><br><span class="line">    <span class="comment">// -----&gt; 结束, nand_base.c</span></span><br><span class="line"></span><br><span class="line">    s3c2410_nand_add_partition                                  <span class="comment">// 分区工作</span></span><br><span class="line">        add_mtd_device</span><br><span class="line">        <span class="comment">// -----&gt; /drivers/mtd/mtdcore.c                        // mtd 设备核心</span></span><br><span class="line">        <span class="comment">// add_mtd_partitions 最终也调用了 add_mtd_device</span></span><br><span class="line">        add_mtd_device</span><br><span class="line">            <span class="keyword">not</span> = list_entry(<span class="keyword">this</span>, struct mtd_notifier, <span class="built_in">list</span>);  <span class="comment">// struct mtd_notifier 结构体是关键</span></span><br><span class="line">            <span class="keyword">not</span>-&gt;add(mtd);                                      <span class="comment">// 调用了add</span></span><br><span class="line">            <span class="comment">// 搜索 mtd_notifier 查看来源, 可知:</span></span><br><span class="line">            <span class="comment">// 实际调用了 mtd_notify_add         // -----&gt; drivers/mtd/mtdchar.c</span></span><br><span class="line">            <span class="comment">// 实际调用了 blktrans_notify_add    // -----&gt; drivers/mtd/mtd_blkdevs.c</span></span><br><span class="line">        <span class="comment">// -----&gt; 结束, mtdcore.c</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, s3c2410.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----&gt; drivers/mtd/mtdchar.c                                 // 将mtd设备挂载成字符设备</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_notifier</span> <span class="title">notifier</span>;</span>                            <span class="comment">// .add = mtd_notify_add</span></span><br><span class="line">mtd_notify_add</span><br><span class="line">    class_device_create(<span class="string">&quot;mtd%d&quot;</span>)                                <span class="comment">// mtd字符设备, 可读写</span></span><br><span class="line">    class_device_create(<span class="string">&quot;mtd%dro&quot;</span>)                              <span class="comment">// mtd只读字符设备</span></span><br><span class="line">init_mtdchar                                                    <span class="comment">// mtdchar.c 的 module_init</span></span><br><span class="line">    register_chrdev(MTD_CHAR_MAJOR, <span class="string">&quot;mtd&quot;</span>, &amp;mtd_fops)           <span class="comment">// 注册为字符设备</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, mtdchar.c 完成了字符设备的核心步骤.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----&gt; drivers/mtd/mtd_blkdevs.c                             // 将mtd设备挂载成块设备</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_notifier</span> <span class="title">blktrans_notifier</span>;</span>                   <span class="comment">// .add = blktrans_notify_add</span></span><br><span class="line">blktrans_notify_add</span><br><span class="line">    tr = list_entry(<span class="keyword">this</span>, struct mtd_blktrans_ops, <span class="built_in">list</span>);       <span class="comment">// 一样的, 搜索 mtd_blktrans_ops</span></span><br><span class="line">    tr-&gt;add_mtd(tr, mtd);</span><br><span class="line">    <span class="comment">// 可以找到两个文件有初始化, 很明显是块设备读写还是只读的区别. 选取 /drivers/mtd/mtdblock.c</span></span><br><span class="line">    <span class="comment">// 实际调用了 mtdblock_add_mtd</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----&gt; /drivers/mtd/mtdblock.c</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_blktrans_ops</span> <span class="title">mtdblock_tr</span>;</span>                 <span class="comment">// .add_mtd = mtdblock_add_mtd</span></span><br><span class="line">    mtdblock_add_mtd</span><br><span class="line">        add_mtd_blktrans_dev</span><br><span class="line">            alloc_disk                                          <span class="comment">// 分配 gendisk</span></span><br><span class="line">            add_disk                                            <span class="comment">// 注册为块设备</span></span><br><span class="line">    init_mtdblock                                               <span class="comment">// mtdblock.c 的 module_init</span></span><br><span class="line">        register_mtd_blktrans</span><br><span class="line">            register_blkdev                                     <span class="comment">// 获得主设备号</span></span><br><span class="line">            blk_init_queue                                      <span class="comment">// 设置缓冲队列</span></span><br><span class="line">    <span class="comment">// -----&gt; 结束, mtdblock.c 完成了块设备的核心步骤.</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, mtd_blkdevs</span></span><br></pre></td></tr></table></figure>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.cnblogs.com/TaigaCon/archive/2012/11/17/2775057.html">Linux操作系统下 NAND FLASH驱动程序框架</a><br><a href="http://www.linuxidc.com/Linux/2017-03/142206.htm">Linux MTD子系统 _从模型分析到Flash驱动模板</a><br><a href="http://blog.sina.com.cn/s/blog_6683e49d0100o18j.html">LINUX NAND FLASH驱动程序框架分析</a></p>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之NAND Flash源码</title>
    <url>/2018/01/25/1811-drv-nand2/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/22/1809-drv-blk/">驱动之块设备-框架</a></li>
<li><a href="https://draapho.github.io/2018/01/24/1810-drv-nand1/">驱动之NAND Flash框架</a></li>
<li><a href="https://draapho.github.io/2018/01/25/1811-drv-nand2/">驱动之NAND Flash源码</a></li>
<li><a href="https://draapho.github.io/2018/01/26/1812-drv-nor/">驱动之NOR Flash</a></li>
<li><a href="https://draapho.github.io/2018/02/06/1813-drv-net/">驱动之网卡驱动</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>由 <strong>nand flash 系统框架</strong> 分析可知, Linux内核系统以及完成了Nand Flash设备的绝大部分的核心工作.<br>因此Nand Flash驱动真正要做的工作主要就是:</p>
<ul>
<li>分配并初始化 <code>nand_chip</code> 结构体</li>
<li>初始化硬件</li>
<li>调用 <code>nand_scan</code></li>
<li>调用 <code>add_mtd_partitions</code></li>
</ul>
<p>可以参考内核文件的相关源码, 学着写.</p>
<ul>
<li><code>drivers\mtd\nand\at91_nand.c</code></li>
<li><code>drivers\mtd\nand\s3c2410.c</code></li>
</ul>
<p>流程如下图:<br><img src="https://draapho.github.io/images/1810/nand3.jpg" alt="nand3"></p>
<h2 id="s3c-nand-c"><a href="#s3c-nand-c" class="headerlink" title="s3c_nand.c"></a>s3c_nand.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mtd/mtd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mtd/nand.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mtd/partitions.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/clk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-nand.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/nand.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s3c_nand_regs</span> &#123;</span>                              <span class="comment">// 2440芯片NAND Flash相关寄存器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfconf  ;                         <span class="comment">// 物理地址 0x4E000000</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfcont  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfcmd   ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfaddr  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfdata  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfeccd0 ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfeccd1 ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfeccd  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfstat  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfestat0;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfestat1;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfmecc0 ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfmecc1 ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfsecc  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfsblk  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfeblk  ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nand_chip</span> *<span class="title">s3c_nand</span>;</span>                  <span class="comment">// NAND Flash操作的核心结构体</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> *<span class="title">s3c_mtd</span>;</span>                    <span class="comment">// 给两个系统函数使用的结构体</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">s3c_nand_regs</span> *<span class="title">s3c_nand_regs</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_partition</span> <span class="title">s3c_nand_parts</span>[] =</span> &#123;    <span class="comment">// 分区信息</span></span><br><span class="line">    [<span class="number">0</span>] = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;bootloader&quot;</span>,</span><br><span class="line">        .size   = <span class="number">0x00040000</span>,</span><br><span class="line">        .offset = <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">1</span>] = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;params&quot;</span>,</span><br><span class="line">        .offset = MTDPART_OFS_APPEND,</span><br><span class="line">        .size   = <span class="number">0x00020000</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">2</span>] = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;kernel&quot;</span>,</span><br><span class="line">        .offset = MTDPART_OFS_APPEND,</span><br><span class="line">        .size   = <span class="number">0x00200000</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">3</span>] = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;root&quot;</span>,</span><br><span class="line">        .offset = MTDPART_OFS_APPEND,</span><br><span class="line">        .size   = MTDPART_SIZ_FULL,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能用Linux默认的片选函数(nand_set_defaults), 自己根据数据手册写一下.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c2440_select_chip</span><span class="params">(struct mtd_info *mtd, <span class="keyword">int</span> chipnr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (chipnr == <span class="number">-1</span>) &#123;</span><br><span class="line">        s3c_nand_regs-&gt;nfcont |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);            <span class="comment">// NFCONT bit1=1, 取消片选</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s3c_nand_regs-&gt;nfcont &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);           <span class="comment">// NFCONT bit1=0, 使能片选</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c2440_cmd_ctrl</span><span class="params">(struct mtd_info *mtd, <span class="keyword">int</span> dat, <span class="keyword">unsigned</span> <span class="keyword">int</span> ctrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ctrl &amp; NAND_CLE) &#123;</span><br><span class="line">        s3c_nand_regs-&gt;nfcmd = dat;                 <span class="comment">// NFCMMD=dat, 发送命令</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s3c_nand_regs-&gt;nfaddr = dat;                <span class="comment">// NFADDR=dat, 发送地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c2440_dev_ready</span><span class="params">(struct mtd_info *mtd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (s3c_nand_regs-&gt;nfstat &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>));        <span class="comment">// NFSTAT bit0=0, Busy else Ready</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c_nand_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">clk</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 分配nand_chip 和 mtd_info 结构体 */</span></span><br><span class="line">    s3c_nand = kzalloc(<span class="keyword">sizeof</span>(struct nand_chip), GFP_KERNEL);</span><br><span class="line">    s3c_mtd = kzalloc(<span class="keyword">sizeof</span>(struct mtd_info), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得寄存器的虚拟地址. 0x4E000000是这些寄存器的起始物理地址</span></span><br><span class="line">    s3c_nand_regs = ioremap(<span class="number">0x4E000000</span>, <span class="keyword">sizeof</span>(struct s3c_nand_regs));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 设置nand_chip */</span></span><br><span class="line">    <span class="comment">/* nand_chip 需要提供 NAND Flash 操作的基本函数. 通用的函数已经由 nand_set_defaults 设置好了.</span></span><br><span class="line"><span class="comment">     * 需要自己设置的函数主要有: 片选,发指令,发地址,发数据,读数据,判断状态的功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s3c_nand-&gt;select_chip = s3c2440_select_chip;    <span class="comment">// 片选函数</span></span><br><span class="line">    s3c_nand-&gt;cmd_ctrl    = s3c2440_cmd_ctrl;       <span class="comment">// 发送指令/地址</span></span><br><span class="line">    s3c_nand-&gt;IO_ADDR_R   = &amp;s3c_nand_regs-&gt;nfdata; <span class="comment">// 读数据的虚拟地址</span></span><br><span class="line">    s3c_nand-&gt;IO_ADDR_W   = &amp;s3c_nand_regs-&gt;nfdata; <span class="comment">// 发数据的虚拟地址</span></span><br><span class="line">    s3c_nand-&gt;dev_ready   = s3c2440_dev_ready;      <span class="comment">// 芯片Busy/Ready的状态反馈</span></span><br><span class="line">    s3c_nand-&gt;ecc.mode    = NAND_ECC_SOFT;          <span class="comment">// ECC校验方式. 软件或硬件.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 硬件相关的设置: 根据NAND FLASH的手册设置时间参数 */</span></span><br><span class="line">    <span class="comment">// 使能NAND控制器的时钟</span></span><br><span class="line">    clk = clk_get(<span class="literal">NULL</span>, <span class="string">&quot;nand&quot;</span>);                    <span class="comment">// 由名称&quot;nand&quot;获得时钟</span></span><br><span class="line">    clk_enable(clk);                                <span class="comment">// 实际上就是 CLKCON bit[4]=1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 NFCONF 寄存器. 由启动的打印信息可获得 HCLK=100MHz, 设置时序要求.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TACLS    0  <span class="comment">// 发出CLE/ALE之后多长时间才发出nWE信号, 从NAND手册可知CLE/ALE与nWE可以同时发出,所以TACLS=0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWRPH0   1  <span class="comment">// nWE的脉冲宽度, HCLK x ( TWRPH0 + 1 ), 从NAND手册可知它要&gt;=12ns, 所以TWRPH0&gt;=1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWRPH1   0  <span class="comment">// nWE变为高电平后多长时间CLE/ALE才能变为低电平, 从NAND手册可知它要&gt;=5ns, 所以TWRPH1&gt;=0</span></span></span><br><span class="line">    s3c_nand_regs-&gt;nfconf = (TACLS&lt;&lt;<span class="number">12</span>) | (TWRPH0&lt;&lt;<span class="number">8</span>) | (TWRPH1&lt;&lt;<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 NFCONT 寄存器. BIT1=1, 取消片选. BIT0=1, 使能NAND控制器</span></span><br><span class="line">    s3c_nand_regs-&gt;nfcont = (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. 使用: nand_scan */</span></span><br><span class="line">    s3c_mtd-&gt;owner = THIS_MODULE;</span><br><span class="line">    s3c_mtd-&gt;priv  = s3c_nand;</span><br><span class="line">    nand_scan(s3c_mtd, <span class="number">1</span>);                          <span class="comment">// 识别NAND FLASH, 构造mtd_info. 硬件只有1块NAND Flash.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5. add_mtd_partitions</span></span><br><span class="line"><span class="comment">     * 增加 add_mtd_partitions 函数后,</span></span><br><span class="line"><span class="comment">     * 内核必须去掉自带的NAND Flash驱动, 从NFS启动系统.</span></span><br><span class="line"><span class="comment">     * 确认要做这个实验的时候, 再取消下面的注释, 编译测试</span></span><br><span class="line"><span class="comment">     * 如果不需要分区, 只需调用 add_mtd_device(s3c_mtd);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// add_mtd_partitions(s3c_mtd, s3c_nand_parts, 4);  // 告知分区要求, 调用 add_mtd_partitions</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c_nand_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    del_mtd_partitions(s3c_mtd);</span><br><span class="line">    iounmap(s3c_nand_regs);</span><br><span class="line">    kfree(s3c_mtd);</span><br><span class="line">    kfree(s3c_nand);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(s3c_nand_init);</span><br><span class="line">module_exit(s3c_nand_exit);</span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m       := s3c_nand.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<h2 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h2><p>源码没有调用 <code>add_mtd_partitions</code> 时, 简单测试一下NAND Flash是否正常工作了.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nand/            # NAND flash驱动目录</span></span><br><span class="line">$ make modules                                  <span class="comment"># 生成s3c_nand.ko, 忽略 s3c_nand_parts 没有使用的警告信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nand/            # NAND flash驱动目录, nfs</span></span><br><span class="line">$ insmod s3c_nand.ko                            <span class="comment"># 加载驱动</span></span><br><span class="line">NAND device: Manufacturer ID: 0xec, Chip ID: 0xda (Samsung NAND 256MiB 3,3V 8-bit)</span><br><span class="line">Scanning device <span class="keyword">for</span> bad blocks</span><br><span class="line">......</span><br><span class="line"><span class="comment"># 打印信息正确识别了 Nand Flash, 说明底层操作都成功了.</span></span><br></pre></td></tr></table></figure>

<h2 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h2><p>源码调用 <code>add_mtd_partitions</code> 时, 测试过程比较复杂.</p>
<ol>
<li>卸载内核自带的NAND Flash驱动</li>
<li>导致无法从本地Flash启动, 必须设置为从nfs启动</li>
<li>从nfs启动后, 加载 s3c_nand.ko 驱动.</li>
<li>使用工具 <code>mtd-utils</code> 格式化 NAND Flash</li>
<li>格式化后, 就能挂载测试了.</li>
<li>恢复原来的开发环境.</li>
</ol>
<p><strong>这个实验我没有实际去做, 设置和恢复都太麻烦. 而且正常的开发过程是不会这样去操作的.</strong><br>下面给出实验步骤:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 卸载内核自带的NAND Flash驱动</span></span><br><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6_custom  复制一个新的内核源码目录</span></span><br><span class="line"></span><br><span class="line">$ make clean</span><br><span class="line">$ make menuconfig                               <span class="comment"># 去掉自带的HID USB驱动程序</span></span><br><span class="line"><span class="comment"># -&gt; Device Drivers</span></span><br><span class="line"><span class="comment">#   -&gt; Memory Technology Device (MTD) support</span></span><br><span class="line"><span class="comment">#     -&gt; NAND Device Support</span></span><br><span class="line"><span class="comment">#       &lt; &gt; NAND Flash support for S3C2410/S3C2440 SoC  # 取消内置的NAND Flash驱动</span></span><br><span class="line"></span><br><span class="line">$ make uImage</span><br><span class="line"><span class="comment"># 烧录新的uImage</span></span><br><span class="line"><span class="comment"># 重启开发板进入uboot烧录界面, 按k准备烧录内核. 略过不表</span></span><br><span class="line">$ sudo dnw ./arch/arm/boot/uImage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 导致无法从本地Flash启动, 必须设置为从nfs启动.</span><br><span class="line"><span class="comment"># 可参考 &quot;嵌入式linux环境搭建-jz2440开发板&quot; 一文</span></span><br><span class="line"><span class="comment"># 开发板, uboot命令行下</span></span><br><span class="line"><span class="comment"># 要使用nfs功能, 必须正确设置uboot的ip地址, 并且Ubuntu端正确设置了nfs</span></span><br><span class="line"></span><br><span class="line">printenv                                        <span class="comment"># 看下现有的uboot环境, 记好bootargs, 恢复的时候要用的.</span></span><br><span class="line"><span class="comment"># bootargs=noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0</span></span><br><span class="line"><span class="built_in">set</span> bootargs noinitrd root=/dev/nfs nfsroot=10.0.0.98:/fs ip=10.0.0.111:10.0.0.98:10.0.0.138:255.255.255.0::eth0:off init=/linuxrc console=ttySAC0</span><br><span class="line"><span class="comment"># (简化ip: &#x27;set bootargs noinitrd root=/dev/nfs nfsroot=10.0.0.98:/fs ip=10.0.0.111 init=/linuxrc console=ttySAC0&#x27; 也可以工作)</span></span><br><span class="line">save        <span class="comment"># 保存修改</span></span><br><span class="line">reset       <span class="comment"># 重启.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数简要说明:</span></span><br><span class="line"><span class="comment"># &#x27;root=/dev/nfs&#x27; 加载nfs文件系统</span></span><br><span class="line"><span class="comment"># &#x27;nfsroot=10.0.0.98:/fs&#x27; nfs文件系统的来源, 此处是由Ubuntu当nfs服务器, 共享出/fs文件夹</span></span><br><span class="line"><span class="comment"># &#x27;ip=10.0.0.111:10.0.0.98:10.0.0.138:255.255.255.0::eth0:off&#x27; 分别表示:</span></span><br><span class="line"><span class="comment">#  ip= 开发板ip : nfs服务器ip: 网关ip : 子网掩码 :: 开发板网口 : off</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 从nfs启动后, 加载 s3c_nand.ko 驱动.</span><br><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nand/            # NAND flash驱动目录</span></span><br><span class="line">$ make modules                                  <span class="comment"># 生成s3c_nand.ko</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nand/            # NAND flash驱动目录, nfs</span></span><br><span class="line">$ insmod s3c_nand.ko                            <span class="comment"># 加载驱动</span></span><br><span class="line">NAND device: Manufacturer ID: 0xec, Chip ID: 0xda (Samsung NAND 256MiB 3,3V 8-bit)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. 使用工具 mtd-utils 格式化 NAND Flash</span><br><span class="line"><span class="comment"># Ubuntu 主机端, 需要先编译mtd-utils</span></span><br><span class="line">$ tar xjf mtd-utils-05.07.23.tar.bz2</span><br><span class="line">$ <span class="built_in">cd</span> mtd-utils-05.07.23/util</span><br><span class="line">$ vim Makefile</span><br><span class="line">    <span class="comment"># ===== 文件内容, 修改如下内容: =====</span></span><br><span class="line">    <span class="comment">#CROSS=arm-linux-   # 需要交叉编译, 取消注释</span></span><br><span class="line">    CROSS=arm-linux-</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line">$ make</span><br><span class="line"><span class="comment"># 拷贝可执行文件到挂载的nfs文件系统的bin目录下</span></span><br><span class="line">$ cp flash_erase flash_eraseall /home/draapho/share/jz2440/nfs/fs_mini_mdev/bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5. 格式化后, 就能挂载测试了.</span><br><span class="line"><span class="comment"># 开发板端 bash</span></span><br><span class="line">$ ls -l /dev/mtd*                               <span class="comment"># 查看一下分区情况, 有0-3共四个分区</span></span><br><span class="line"><span class="comment"># 应该是用 &quot;flash_eraseall /dev/mtd1&quot; 格式化 &quot;params&quot; 分区, 恢复起来最方便.</span></span><br><span class="line">$ flash_eraseall /dev/mtd3                      <span class="comment"># 格式化 root分区 (用的字符设备), 文件格式为yaffs</span></span><br><span class="line">$ mount -t yaffs /dev/mtdblock3 /tmp            <span class="comment"># 以yaffs格式挂载 root分区</span></span><br><span class="line">$ ls /tmp                                       <span class="comment"># 应该只有一个 lost+found 文件.</span></span><br><span class="line"><span class="comment"># 然后可以对这个分区进行文件创建, 读写的操作了.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6. 恢复原来的开发环境</span><br><span class="line"><span class="comment"># 开发板 uboot:</span></span><br><span class="line"><span class="comment"># 破坏了root区的话, 就恢复root区, 重新烧写文件系统到flash就行了. 猜测使用 params 区做测试是没有影响的.</span></span><br><span class="line"><span class="comment"># 烧录原来的 uImage 到 kernel.</span></span><br><span class="line"><span class="comment"># 改回 uboot 的 bootargs 参数</span></span><br><span class="line"><span class="comment"># 重启, 从NAND Flash正常启动.</span></span><br></pre></td></tr></table></figure>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.cnblogs.com/TaigaCon/archive/2012/11/17/2775057.html">Linux操作系统下 NAND FLASH驱动程序框架</a></p>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之NOR Flash</title>
    <url>/2018/01/26/1812-drv-nor/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/22/1809-drv-blk/">驱动之块设备-框架</a></li>
<li><a href="https://draapho.github.io/2018/01/24/1810-drv-nand1/">驱动之NAND Flash框架</a></li>
<li><a href="https://draapho.github.io/2018/01/25/1811-drv-nand2/">驱动之NAND Flash源码</a></li>
<li><a href="https://draapho.github.io/2018/01/26/1812-drv-nor/">驱动之NOR Flash</a></li>
<li><a href="https://draapho.github.io/2018/02/06/1813-drv-net/">驱动之网卡驱动</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="NOR-Flash-基础知识"><a href="#NOR-Flash-基础知识" class="headerlink" title="NOR Flash 基础知识"></a>NOR Flash 基础知识</h1><h2 id="NAND-和-NOR-Flash的比较"><a href="#NAND-和-NOR-Flash的比较" class="headerlink" title="NAND 和 NOR Flash的比较"></a>NAND 和 NOR Flash的比较</h2><table>
<thead>
<tr>
<th>NOR FLASH</th>
<th>NAND FLASH</th>
</tr>
</thead>
<tbody><tr>
<td>接口时序同SRAM,易使用</td>
<td>地址/数据线复用，数据位较窄</td>
</tr>
<tr>
<td>读取速度较快</td>
<td>读取速度较慢</td>
</tr>
<tr>
<td>擦除速度慢，以64-128KB的块为单位</td>
<td>擦除速度快，以8－32KB的块为单位</td>
</tr>
<tr>
<td>写入速度慢</td>
<td>写入速度快</td>
</tr>
<tr>
<td>随机存取速度较快，支持XIP(eXecute In Place，芯片内执行)，适用于代码存储。在嵌入式系统中，常用于存放引导程序、根文件系统等。</td>
<td>顺序读取速度较快，随机存取速度慢，适用于数据存储(如大容量的多媒体应用)。在嵌入式系统中，常用于存放用户文件系统等。</td>
</tr>
<tr>
<td>单片容量较小，1-32MB</td>
<td>单片容量较大，8-128MB，提高了单元密度</td>
</tr>
<tr>
<td>最大擦写次数10万次</td>
<td>最大擦写次数100万次</td>
</tr>
</tbody></table>
<h2 id="硬件接口"><a href="#硬件接口" class="headerlink" title="硬件接口"></a>硬件接口</h2><p>看相关数据手册, 以jz2440v3开发板为例:</p>
<ul>
<li><code>MX29LV160DBTI-70G.pdf</code> NOR Flash 数据手册</li>
<li><code>S3C2440A_UserManual_Rev13.pdf</code> CPU 数据手册</li>
</ul>
<p><img src="https://draapho.github.io/images/1812/nor1.JPG" alt="nor1.png"></p>
<p>注意几点:</p>
<ul>
<li>NOR Flash 的特性和RAM一样, 可以直接用物理地址来操作.<ul>
<li>当开发板以NOR Flash启动时, 0开始的地址就是指向NOR Flash的.</li>
</ul>
</li>
<li>NOR Flash 数据位宽有两种接法, 16bit 和 8bit. jz2440用的16bit接法<ul>
<li>因此, 用uboot测试时, 需要使用 <code>mw.w</code> <code>md.w</code> 来操作内存地址</li>
<li><code>mw</code> Memory Write. uboot下的写内存指令</li>
<li><code>md</code> Memory Display. uboot下的读内存指令</li>
<li>使用16bit接法时, CPU的地址线0是不接的. 因而指令上有个错位.</li>
<li>譬如: jz2440发出 (555h&lt;&lt;1), NOR Flash才能收到555h这个地址.</li>
</ul>
</li>
<li>NOR Flash 有两种模式, jedec, cfi<ul>
<li>jedec, 无法直接从芯片内读取详细信息, 需要根据芯片ID软件查表.</li>
<li>cfi, Common Flash Interface, 可以直接查询芯片详细信息.</li>
<li>目前大多数 NOR Flash 都支持 cfi 规范.</li>
</ul>
</li>
</ul>
<h2 id="读写实验"><a href="#读写实验" class="headerlink" title="读写实验"></a>读写实验</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot 命令行, 确保是从 NOR Flash 启动的uboot!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 ID. 2440的A1接到NOR的A0，所以2440发出的地址全部要左移一位</span></span><br><span class="line">mw.w aaa aa             <span class="comment"># Addr = 555&lt;&lt;1</span></span><br><span class="line">mw.w 554 55             <span class="comment"># Addr = 2AA&lt;&lt;1</span></span><br><span class="line">mw.w aaa 90             <span class="comment"># Addr = 555&lt;&lt;1</span></span><br><span class="line">md.w 0 1</span><br><span class="line"><span class="comment"># 显示 00c2, Manifacture ID</span></span><br><span class="line">md.w 2 1                <span class="comment"># Addr = 1&lt;&lt;1</span></span><br><span class="line"><span class="comment"># 显示 2249, 表示型号 MX29LV160DB</span></span><br><span class="line">mw.w 0 f0               <span class="comment"># Reset Mode, 退出读ID</span></span><br></pre></td></tr></table></figure>

<h1 id="NOR-Flash-系统框架"><a href="#NOR-Flash-系统框架" class="headerlink" title="NOR Flash 系统框架"></a>NOR Flash 系统框架</h1><h2 id="系统自带驱动"><a href="#系统自带驱动" class="headerlink" title="系统自带驱动"></a>系统自带驱动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6</span></span><br><span class="line"></span><br><span class="line">$ make clean</span><br><span class="line">$ make menuconfig                                       <span class="comment"># 增加对NOR Flash的支持</span></span><br><span class="line"><span class="comment"># -&gt; Device Drivers</span></span><br><span class="line"><span class="comment">#   -&gt; Memory Technology Device (MTD) support</span></span><br><span class="line"><span class="comment">#     -&gt; Mapping drivers for chip access</span></span><br><span class="line"><span class="comment">#       &lt;M&gt; CFI Flash device in physical memory map     # CFI NOR Flash, 直接做物理映射就可以了</span></span><br><span class="line"><span class="comment">#       (0x0) Physical start address of flash mapping   # 物理基地址, 从0开始的</span></span><br><span class="line"><span class="comment">#       (0x2000000) Physical length of flash mapping    # 要映射的长度, 就是芯片的大小</span></span><br><span class="line"><span class="comment">#       (2)   Bank width in octets (NEW)                # 数据线位宽, 2就是2字节,  16bit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较 .config 会发现多了如下配置. 从而可以找到文件 &quot;drivers/mtd/chips/phram.c&quot;</span></span><br><span class="line"><span class="comment"># CONFIG_MTD_PHYSMAP=m</span></span><br><span class="line"><span class="comment"># CONFIG_MTD_PHYSMAP_START=0</span></span><br><span class="line"><span class="comment"># CONFIG_MTD_PHYSMAP_LEN=0x2000000</span></span><br><span class="line"><span class="comment"># CONFIG_MTD_PHYSMAP_BANKWIDTH=2</span></span><br><span class="line"></span><br><span class="line">$ make modules                                          <span class="comment"># 会生成 physmap.ko</span></span><br><span class="line">cp ./drivers/mtd/maps/physmap.ko ~/share/jz2440/drivers/nor/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nor/                     # NOR flash驱动目录, nfs</span></span><br><span class="line">$ ls /dev/mtd*                                          <span class="comment"># 查看一下mtd现有设备</span></span><br><span class="line">$ insmod physmap.ko                                     <span class="comment"># 加载驱动</span></span><br><span class="line">$ ls /dev/mtd*                                          <span class="comment"># 增加了若干mtd设备</span></span><br><span class="line">$ cat /proc/mtd</span><br></pre></td></tr></table></figure>

<h2 id="框架分析"><a href="#框架分析" class="headerlink" title="框架分析"></a>框架分析</h2><p>其基本框架和 NAND Flash 是一样的</p>
<p><img src="https://draapho.github.io/images/1812/nor2.png" alt="nor2.png"></p>
<p>下面, 分析一下 CFI NOR Flash 的内核代码框架</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -----&gt; /drivers/mtd/maps/physmap.c</span></span><br><span class="line">module_init(physmap_init)</span><br><span class="line">    platform_driver_register(&amp;physmap_flash_driver);    <span class="comment">// 上来就是自己玩platform框架</span></span><br><span class="line">    platform_device_register(&amp;physmap_flash);</span><br><span class="line"></span><br><span class="line"># 匹配后, 自然是调用probe函数</span><br><span class="line">physmap_flash_probe</span><br><span class="line">    probe_type = rom_probe_types;                       <span class="comment">// &quot;cfi_probe&quot; &quot;jedec_probe&quot; 都是用于NOR Flash的</span></span><br><span class="line">    do_map_probe(*probe_type, &amp;info-&gt;<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----&gt; /drivers/mtd/chips/chipreg.c</span></span><br><span class="line">    do_map_probe</span><br><span class="line">        drv = get_mtd_chip_driver(name);</span><br><span class="line">            list_entry(pos, typeof(*<span class="keyword">this</span>), <span class="built_in">list</span>)        <span class="comment">// this 是 mtd_chip_driver 类型</span></span><br><span class="line">        drv-&gt;probe(<span class="built_in">map</span>);</span><br><span class="line">        <span class="comment">// 搜索 mtd_chip_driver 查看来源. 可以猜出和文件 cfi_probe.c 有关.</span></span><br><span class="line">        <span class="comment">// 实际调用了 cfi_probe      // -----&gt; drivers/mtd/chips/cfi_probe.c</span></span><br><span class="line">    <span class="comment">// -----&gt; 结束, chipreg.c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// add_mtd_partitions                               // 有分区则进行分区, 最终也会调用 add_mtd_device</span></span><br><span class="line">    add_mtd_device                                      <span class="comment">// 添加mtd设备</span></span><br><span class="line">    <span class="comment">// 然后就会跳到 mtdcore.c 后面和 NAND Flash 一样了. 或参考下面的一个例子</span></span><br><span class="line">    <span class="comment">// 最终会去注册 字符设备 和 块设备</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, physmap.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----&gt; drivers/mtd/chips/cfi_probe.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_chip_driver</span> <span class="title">cfi_chipdrv</span>;</span>              <span class="comment">// .probe = cfi_probe</span></span><br><span class="line">cfi_probe</span><br><span class="line">    mtd_do_chip_probe(<span class="built_in">map</span>, &amp;cfi_chip_probe);            <span class="comment">// 识别cfi设备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----&gt; drivers/mtd/chips/gen_probe.c</span></span><br><span class="line">    mtd_do_chip_probe</span><br><span class="line">        genprobe_ident_chips</span><br><span class="line">            cp-&gt;probe_chip                              <span class="comment">// 调用 cfi_chip_probe.probe_chip</span></span><br><span class="line">            <span class="comment">// 实际调用函数 cfi_probe_chip</span></span><br><span class="line">        check_cmd_set                                   <span class="comment">// 初始化 mtd_info 结构体</span></span><br><span class="line">    <span class="comment">// -----&gt; 结束, gen_probe.c</span></span><br><span class="line"></span><br><span class="line">cfi_probe_chip</span><br><span class="line">    cfi_send_gen_cmd                                    <span class="comment">// 发送CFI指令, 获取芯片信息</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, cfi_probe.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/mtd/chips/jedec_probe.c 有 jedec_probe. 用于jedec设备</span></span><br><span class="line"><span class="comment">// drivers/mtd/chips/map_rom.c 有 map_rom_probe. 应该是用于CPU内置的ROM.</span></span><br></pre></td></tr></table></figure>

<p>这样就比较清楚了, 整个Linux代码尽可能的做到功能上的(代码上没有完全做到)分层分离.<br>大框架下有小框架. 譬如 NOR Flash 属于整个MTD大框架的一部分. 但其内部也有自己的一套小框架.</p>
<p>在 NOR Flash 这个例子里面,<br>将通用的底层驱动代码放在文件 <code>/drivers/mtd/maps/physmap.c</code><br>然后probe时, 具体的硬件操作被拆分三个部分 <code>cfi_probe.c</code> <code>jedec_probe.c</code> <code>map_rom.c</code><br>由于probe里面也有共性的东西, 又被提炼成 <code>gen_probe.c</code> 放在一起.</p>
<p>最后, 看一个最简单的例子, ram模拟mtd设备. 将底层硬件相关操作减到了最少.<br>这个RAM mtd设备和 NAND/NOR Flash 平级, 挂在 <code>mtdcore.c</code> 下.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -----&gt; /drivers/mtd/devices/phram.c</span></span><br><span class="line">module_param_call(phram, phram_setup, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">000</span>);         <span class="comment">// 由uboot传递参数进来</span></span><br><span class="line">phram_setup</span><br><span class="line">    register_device(name, start, len);</span><br><span class="line">        <span class="keyword">new</span>-&gt;mtd.XXX = XXX;                                     <span class="comment">// 初始化 mtd_info 结构体</span></span><br><span class="line">        add_mtd_device                                          <span class="comment">// 添加 mtd设备</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// -----&gt; /drivers/mtd/mtdcore.c                        // mtd 设备核心</span></span><br><span class="line">        add_mtd_device</span><br><span class="line">            <span class="keyword">not</span> = list_entry(<span class="keyword">this</span>, struct mtd_notifier, <span class="built_in">list</span>);  <span class="comment">// struct mtd_notifier 结构体是关键</span></span><br><span class="line">            <span class="keyword">not</span>-&gt;add(mtd);                                      <span class="comment">// 调用了add</span></span><br><span class="line">            <span class="comment">// 搜索 mtd_notifier 查看来源, 可知:</span></span><br><span class="line">            <span class="comment">// 实际调用了 mtd_notify_add         // -----&gt; drivers/mtd/mtdchar.c</span></span><br><span class="line">            <span class="comment">// 实际调用了 blktrans_notify_add    // -----&gt; drivers/mtd/mtd_blkdevs.c</span></span><br><span class="line">        <span class="comment">// -----&gt; 结束, mtdcore.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可见, 核心内容就是 初始化mtd_info结构体, 然后 add_mtd_device</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, phram.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----&gt; drivers/mtd/mtdchar.c                                 // 将mtd设备挂载成字符设备</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_notifier</span> <span class="title">notifier</span>;</span>                            <span class="comment">// .add = mtd_notify_add</span></span><br><span class="line">mtd_notify_add</span><br><span class="line">    class_device_create(<span class="string">&quot;mtd%d&quot;</span>)                                <span class="comment">// mtd字符设备, 可读写</span></span><br><span class="line">    class_device_create(<span class="string">&quot;mtd%dro&quot;</span>)                              <span class="comment">// mtd只读字符设备</span></span><br><span class="line">init_mtdchar                                                    <span class="comment">// mtdchar.c 的 module_init</span></span><br><span class="line">    register_chrdev(MTD_CHAR_MAJOR, <span class="string">&quot;mtd&quot;</span>, &amp;mtd_fops)           <span class="comment">// 注册为字符设备</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, mtdchar.c 完成了字符设备的核心步骤.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----&gt; drivers/mtd/mtd_blkdevs.c                             // 将mtd设备挂载成块设备</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_notifier</span> <span class="title">blktrans_notifier</span>;</span>                   <span class="comment">// .add = blktrans_notify_add</span></span><br><span class="line">blktrans_notify_add</span><br><span class="line">    tr = list_entry(<span class="keyword">this</span>, struct mtd_blktrans_ops, <span class="built_in">list</span>);       <span class="comment">// 一样的, 搜索 mtd_blktrans_ops</span></span><br><span class="line">    tr-&gt;add_mtd(tr, mtd);</span><br><span class="line">    <span class="comment">// 可以找到两个文件有初始化, 很明显是块设备读写还是只读的区别. 选取 /drivers/mtd/mtdblock.c</span></span><br><span class="line">    <span class="comment">// 实际调用了 mtdblock_add_mtd</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----&gt; /drivers/mtd/mtdblock.c</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_blktrans_ops</span> <span class="title">mtdblock_tr</span>;</span>                 <span class="comment">// .add_mtd = mtdblock_add_mtd</span></span><br><span class="line">    mtdblock_add_mtd</span><br><span class="line">        add_mtd_blktrans_dev</span><br><span class="line">            alloc_disk                                          <span class="comment">// 分配 gendisk</span></span><br><span class="line">            add_disk                                            <span class="comment">// 注册为块设备</span></span><br><span class="line">    init_mtdblock                                               <span class="comment">// mtdblock.c 的 module_init</span></span><br><span class="line">        register_mtd_blktrans</span><br><span class="line">            register_blkdev                                     <span class="comment">// 获得主设备号</span></span><br><span class="line">            blk_init_queue                                      <span class="comment">// 设置缓冲队列</span></span><br><span class="line">    <span class="comment">// -----&gt; 结束, mtdblock.c 完成了块设备的核心步骤.</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, mtd_blkdevs</span></span><br></pre></td></tr></table></figure>



<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="s3c-nor-c"><a href="#s3c-nor-c" class="headerlink" title="s3c_nor.c"></a>s3c_nor.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参考 drivers\mtd\maps\physmap.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mtd/mtd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mtd/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mtd/partitions.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">map_info</span> *<span class="title">s3c_nor_map</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> *<span class="title">s3c_nor_mtd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_partition</span> <span class="title">s3c_nor_parts</span>[] =</span> &#123;             <span class="comment">// 复杂一点, 做一个分区信息</span></span><br><span class="line">    [<span class="number">0</span>] = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;bootloader_nor&quot;</span>,</span><br><span class="line">        .size   = <span class="number">0x00040000</span>,</span><br><span class="line">        .offset = <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">1</span>] = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;root_nor&quot;</span>,</span><br><span class="line">        .offset = MTDPART_OFS_APPEND,</span><br><span class="line">        .size   = MTDPART_SIZ_FULL,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c_nor_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 1. 分配map_info结构体 */</span></span><br><span class="line">    s3c_nor_map = kzalloc(<span class="keyword">sizeof</span>(struct map_info), GFP_KERNEL);;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 设置: 物理基地址(phys), 大小(size), 位宽(bankwidth), 虚拟基地址(virt) */</span></span><br><span class="line">    s3c_nor_map-&gt;name = <span class="string">&quot;s3c_nor&quot;</span>;</span><br><span class="line">    s3c_nor_map-&gt;phys = <span class="number">0</span>;                                              <span class="comment">// 对应的物理地址</span></span><br><span class="line">    s3c_nor_map-&gt;size = <span class="number">0x2000000</span>;                                      <span class="comment">// NOR的容量</span></span><br><span class="line">    s3c_nor_map-&gt;bankwidth = <span class="number">2</span>;                                         <span class="comment">// 数据线位宽, 单位字节</span></span><br><span class="line">    s3c_nor_map-&gt;virt = ioremap(s3c_nor_map-&gt;phys, s3c_nor_map-&gt;size);  <span class="comment">// 对应的虚拟地址</span></span><br><span class="line">    simple_map_init(s3c_nor_map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 使用: 调用NOR FLASH协议层提供的函数来识别 */</span></span><br><span class="line">    printk(<span class="string">&quot;use cfi_probe\n&quot;</span>);</span><br><span class="line">    s3c_nor_mtd = do_map_probe(<span class="string">&quot;cfi_probe&quot;</span>, s3c_nor_map);               <span class="comment">// 直接去调用 .probe = cfi_probe</span></span><br><span class="line">    <span class="keyword">if</span> (!s3c_nor_mtd) &#123;</span><br><span class="line">        printk(<span class="string">&quot;use jedec_probe\n&quot;</span>);</span><br><span class="line">        s3c_nor_mtd = do_map_probe(<span class="string">&quot;jedec_probe&quot;</span>, s3c_nor_map);         <span class="comment">// 失败, 尝试 jedec 模式</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s3c_nor_mtd) &#123;</span><br><span class="line">        iounmap(s3c_nor_map-&gt;virt);</span><br><span class="line">        kfree(s3c_nor_map);</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. add_mtd_partitions */</span></span><br><span class="line">    add_mtd_partitions(s3c_nor_mtd, s3c_nor_parts, <span class="number">2</span>);                  <span class="comment">// 里面调用 add_mtd_device</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c_nor_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    del_mtd_partitions(s3c_nor_mtd);</span><br><span class="line">    iounmap(s3c_nor_map-&gt;virt);</span><br><span class="line">    kfree(s3c_nor_map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(s3c_nor_init);</span><br><span class="line">module_exit(s3c_nor_exit);</span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m       := s3c_nor.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nor/         # NOR flash驱动目录</span></span><br><span class="line">$ make modules                              <span class="comment"># 生成s3c_nor.ko</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nor/         # NOR flash驱动目录, nfs</span></span><br><span class="line">$ ls /dev/mtd*                              <span class="comment"># 查看现有的mtd设备</span></span><br><span class="line">$ insmod s3c_nor.ko                         <span class="comment"># 加载驱动</span></span><br><span class="line">$ ls /dev/mtd*                              <span class="comment"># 查看新增的mtd设备</span></span><br><span class="line">$ flash_eraseall -j /dev/mtd5               <span class="comment"># 格式化为 jffs2, 注意新增的不一定是mtd5</span></span><br><span class="line">$ mount -t jffs2 /dev/mtdblock5 /mnt        <span class="comment"># 挂载这个设备到 /mnt</span></span><br><span class="line"><span class="comment"># 在 /mnt 下进行文件的创建和操作, 测试该文件系统.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有 flash_eraseall 指令, 则需要编译mtd格式化工具 mtd-utils</span></span><br><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line">$ tar xjf mtd-utils-05.07.23.tar.bz2</span><br><span class="line">$ <span class="built_in">cd</span> mtd-utils-05.07.23/util</span><br><span class="line">$ vim Makefile</span><br><span class="line">    <span class="comment"># ===== 文件内容, 修改如下内容: =====</span></span><br><span class="line">    <span class="comment">#CROSS=arm-linux-   # 需要交叉编译, 取消注释</span></span><br><span class="line">    CROSS=arm-linux-</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line">$ make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端</span></span><br><span class="line"><span class="comment"># 通过nfs拷贝到bin目录下即可.</span></span><br><span class="line"><span class="comment"># pwd = ./mtd-utils-05.07.23/util           # nfs文件</span></span><br><span class="line">$ cp flash_erase flash_eraseall /bin</span><br></pre></td></tr></table></figure>


<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之RTC分析</title>
    <url>/2018/02/08/1814-drv-rtc/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a></li>
<li><a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a></li>
<li><a href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">驱动之RTC分析</a></li>
<li><a href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">驱动之LCD驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/11/1806-drv-ts/">驱动之触摸屏驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">驱动之USB基础概念和框架</a></li>
<li><a href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">驱动之USB设备驱动程序</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="字符设备驱动另一种写法"><a href="#字符设备驱动另一种写法" class="headerlink" title="字符设备驱动另一种写法"></a>字符设备驱动另一种写法</h1><p>在 <a href="https://draapho.github.io/2017/11/22/1733-drv-chr1/">驱动之字符设备-框架</a> 里, 使用的是函数 <code>register_chrdev</code> 进行注册的.<br>其缺点是, 默认调用了 <code>__register_chrdev_region(major, 0, 256, name);</code>, 也就是会把256个次设备号全部注册掉.<br>为了合理使用次设备号, 就需要另外一种写法.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> major;                               <span class="comment">// 确定主设备号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_fops</span> =</span> &#123;    <span class="comment">// fop数据结构</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = hello_open,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __init hello_init(<span class="keyword">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主设备号已知, 用 register_chrdev_region 即可</span></span><br><span class="line">    <span class="comment">// devid = MKDEV(major, 0);</span></span><br><span class="line">    <span class="comment">// register_chrdev_region(devid, HELLO_CNT, &quot;hello&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主设备号需要系统分配, 用 alloc_chrdev_region 函数</span></span><br><span class="line">    alloc_chrdev_region(&amp;devid, <span class="number">0</span>, HELLO_CNT, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    major = MAJOR(devid);                       <span class="comment">// 提取主设备号</span></span><br><span class="line"></span><br><span class="line">    cls = class_create(THIS_MODULE, <span class="string">&quot;hello&quot;</span>);   <span class="comment">// 创建类</span></span><br><span class="line">    cdev_init(&amp;hello_cdev, &amp;hello_fops);        <span class="comment">// 初始化</span></span><br><span class="line">    cdev_add(&amp;hello_cdev, devid, HELLO_CNT);    <span class="comment">// 添加指定个数的字符设备</span></span><br><span class="line">    device_create(cls , <span class="literal">NULL</span> , MKDEV(major, <span class="number">0</span>), <span class="string">&quot;hello0&quot;</span>);  <span class="comment">// 和 class_device_create 没有本质区别.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质上, 就是自己实现一遍 <code>register_chrdev</code> 函数里的内容, 来控制子设备号个数.<br>博客里 <a href="https://draapho.github.io/2017/11/30/1740-drv-chr2/">驱动之基于LinK+设计按键驱动</a> 这些内容都是由 <code>LinK+</code> 自动实现的.</p>
<h1 id="RTC源码分析"><a href="#RTC源码分析" class="headerlink" title="RTC源码分析"></a>RTC源码分析</h1><p>这里以RTC源码为例进行分析, 用于熟悉字符设备的写法和分离分层即platform的概念</p>
<p><code>/drivers/rtc/rtc-dev.c</code> 提供了所有的RTC驱动层读写函数.<br>里面进一步调用了 <code>/drivers/rtc/class.c</code> 的一些函数.<br>这两个文件是linux内核RTC驱动设备的软件抽象核心.</p>
<p>显然的, 后面的很多文件是芯片厂商提供的硬件相关的RTC部分. 譬如 <code>rtc-s3c.c</code>.<br>也可以通过分析 <code>rtc-dev.c</code> 里的 <code>rtc_dev_add_device</code> 倒过来找到这些文件.</p>
<p>下面, 我们从底层硬件(<code>rtc-s3c.c</code>)往上层进行分析, 看看rtc字符设备的整个注册过程.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// subsys_initcall(rtc_init), 系统初始化时调用</span></span><br><span class="line">rtc_init();                                         <span class="comment">// 此函数位于 &quot;class.c&quot;</span></span><br><span class="line">    class_create(THIS_MODULE, <span class="string">&quot;rtc&quot;</span>);               <span class="comment">// =====&gt; class_create</span></span><br><span class="line">    rtc_dev_init();</span><br><span class="line">        alloc_chrdev_region();                      <span class="comment">// =====&gt; alloc_chrdev_region, 分配 RTC_DEV_MAX 个子设备号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// module_init(s3c_rtc_init), 驱动入口函数. insmod 时被调用</span></span><br><span class="line">s3c_rtc_init();                                     <span class="comment">// 此函数位于 &quot;rtc-s3c.c&quot;</span></span><br><span class="line">    platform_driver_register(&amp;s3c2410_rtcdrv);</span><br><span class="line">    <span class="comment">// 明显用了platform框架, 根据 .name = &quot;s3c2410-rtc&quot; 去找 platform_device_register</span></span><br><span class="line">    <span class="comment">// 在 &quot;/arch/arm/plat-s3c24xx/devs.c&quot; 下找到了 s3c_device_rtc. 但没有被内核调用. 后面再说.</span></span><br><span class="line">s3c_rtc_probe();                                    <span class="comment">// platform 的 driver 和 device 匹配后, 自动调用 probe</span></span><br><span class="line">    <span class="comment">// 一系列的RTC硬件相关操作, 忽略</span></span><br><span class="line">    rtc_device_register();                          <span class="comment">// 此函数位于 &quot;class.c&quot;</span></span><br><span class="line">        rtc_dev_prepare();                          <span class="comment">// 此函数位于 &quot;rtc-dev.c&quot;</span></span><br><span class="line">            rtc-&gt;dev.devt = MKDEV(MAJOR(rtc_devt), rtc-&gt;id);</span><br><span class="line">            cdev_init();                            <span class="comment">// =====&gt; cdev_init</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// device_create 里最终调用的就是 device_register.</span></span><br><span class="line">        <span class="comment">// rtc-&gt;dev.devt 的值已经在 rtc_dev_prepare 设置好了.</span></span><br><span class="line">        device_register();                          <span class="comment">// =====&gt; 等效于 device_create.</span></span><br><span class="line">        rtc_dev_add_device();</span><br><span class="line">            cdev_add();                             <span class="comment">// =====&gt; cdev_add</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这两个函数似乎也和设备注册相关. 详请不明</span></span><br><span class="line">        rtc_sysfs_add_device();</span><br><span class="line">        rtc_proc_add_device();</span><br></pre></td></tr></table></figure>

<h1 id="RTC-测试"><a href="#RTC-测试" class="headerlink" title="RTC 测试"></a>RTC 测试</h1><p>前面的分析源码说过, <code>s3c_device_rtc</code> 没有被调用, 因此当前的系统也无法使用rtc.<br>这里就加入rtc功能, 并测试.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6</span></span><br><span class="line"><span class="comment"># 打开 ./arch/arm/plat-s3c24xx/common-smdk.c</span></span><br><span class="line">    <span class="comment"># 找到数组 static struct platform_device __initdata *smdk_devs[]</span></span><br><span class="line">    <span class="comment"># 加入一行   &amp;s3c_device_rtc,</span></span><br><span class="line">    <span class="comment"># 此数组会被 &quot;smdk_machine_init&quot; 调用, 里面有 &quot;platform_add_devices&quot;,</span></span><br><span class="line">    <span class="comment"># 此函数会对数组里的内容依次进行 &quot;platform_device_register&quot;</span></span><br><span class="line"></span><br><span class="line">$ make clean                                    <span class="comment"># 没把握的话, clean一下</span></span><br><span class="line">$ make uImage</span><br><span class="line"><span class="comment"># 烧录新的uImage</span></span><br><span class="line"><span class="comment"># 重启开发板进入uboot烧录界面, 按k准备烧录内核. 略过不表</span></span><br><span class="line">$ sudo dnw ./arch/arm/boot/uImage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line">$ ls /dev/rtc* -l                               <span class="comment"># 查看设备, 有 rtc0</span></span><br><span class="line">$ date                                          <span class="comment"># 显示系统时间</span></span><br><span class="line">Mon Apr  3 06:53:50 UTC 2006</span><br><span class="line"></span><br><span class="line">$ date 020811002018.30                          <span class="comment"># 设置系统时间 date [MMDDhhmm[[CC]YY][.ss]]</span></span><br><span class="line">Thu Feb  8 11:00:30 UTC 2018</span><br><span class="line">$ hwclock -w                                    <span class="comment"># 把系统时间写入RTC. HardWare CLOCK</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 断电, 重启.</span></span><br><span class="line">$ date</span><br><span class="line">Thu Feb  8 11:02:01 UTC 2018                    <span class="comment"># 设置的时间还在.</span></span><br></pre></td></tr></table></figure>





<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>博客暂停更新</title>
    <url>/2018/04/12/1815-suspend/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
<li><a href="https://draapho.github.io/2021/03/05/2107-tuibeitu1/">万年歌, 马前课, 梅花诗, 推背图 (上)</a></li>
<li><a href="https://draapho.github.io/2021/03/18/2108-tuibeitu2/">万年歌, 马前课, 梅花诗, 推背图 (下)</a></li>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/26/2123-caseofsatori/">见性者体验收集</a></li>
</ul>
<h1 id="本博客暂停更新"><a href="#本博客暂停更新" class="headerlink" title="本博客暂停更新"></a>本博客暂停更新</h1><p>原因的话, 最大的兴趣点始终是在人文和生命本源这一块. 参考 <a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a><br>当下可能找到了一种方法, 让生活和兴趣可以两全. 我需要全力去试一试.</p>
<p>第一阶段, 独善其身:</p>
<ul>
<li>于资本汇聚之地得自由</li>
<li>于人性汇聚之地得自在</li>
<li>万物皆空, 上善若水<ul>
<li>贪嗔痴疑慢, 万物皆烦恼. 舍万物?求信仰? 终是不究竟.</li>
<li>水无所依, 可依万物. 心无所执, 可着万境.</li>
</ul>
</li>
</ul>
<p>第二阶段, 兼济天下:</p>
<ul>
<li>人文学科和生命本源数学化, 理论化.</li>
<li>已有大致思路:<ul>
<li>心为本, 物为载体, 心可改变物.</li>
<li>一切出发点是基本生命体的相互关系, 这种相互关系就是本源, 不随级别改变.</li>
<li>环境的影响首先作用于心, 心影响生命体的相互关系, 从而影响整个群体的行为和特性.</li>
</ul>
</li>
<li>主观上, 我认为佛教的世界观是正确的; 但受限于”客观”的观察要求, 要证明比较困难.<ul>
<li>所谓大千世界, 是指不同级别包含生命体的世界. 每个人, 每朵花, 每个细胞都是一世界. (分子,原子不敢确定)</li>
<li>世界就是玻璃缸, 人是没有什么”客观”的方法去观察玻璃缸外的情况的.</li>
<li>人之所以稍微特殊一点, 是因为以人为基础单位, 明显已经发展出多样的更高层次的生命体(企业, 国家等各种形态的组织)</li>
<li>更重要的, 人有潜能进行星际殖民, 从而把星球发展成为更高级的”基础细胞”.</li>
</ul>
</li>
</ul>
<p>最后, 无论成败, 先在此感谢 <a href="http://blog.sina.com.cn/u/1215172700">缠中说禅</a> 不但指明了实用的生存方法, 更是给予了我无穷的灵感!<br>读君博文, 方觉虚度光阴30载. 愿君彼岸安好.</p>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>杂谈</title>
    <url>/2019/03/19/1901-tittle-tattle/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
<li><a href="https://draapho.github.io/2021/03/05/2107-tuibeitu1/">万年歌, 马前课, 梅花诗, 推背图 (上)</a></li>
<li><a href="https://draapho.github.io/2021/03/18/2108-tuibeitu2/">万年歌, 马前课, 梅花诗, 推背图 (下)</a></li>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/26/2123-caseofsatori/">见性者体验收集</a></li>
</ul>
<h1 id="世界的本质"><a href="#世界的本质" class="headerlink" title="世界的本质"></a>世界的本质</h1><p><img src="https://draapho.github.io/images/1901/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F.png" alt="欧拉公式.png"></p>
<h2 id="0"><a href="#0" class="headerlink" title="0"></a>0</h2><p>左侧的0表示世界的来处, 右侧的0表示世界的去处.<br>这里的世界是任何级别的, 譬如”宇宙”,”地球”,”我”</p>
<p>进一步说明: 来处就是去处, 去处就是来处, 无始无终, 此恒等式本身就是循环.</p>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>1从0中来, 0中生1就是无中生有.<br>关于有无: 道教是从无到有, 佛教是从有到无. 相辅相成.</p>
<h2 id="e"><a href="#e" class="headerlink" title="e"></a>e</h2><p>e的本质是特定维度下的繁衍和生长, 从而形成级别. 对应于原始的欲望.<br>道教的说法是: 一生二, 二生三, 三生万物.<br>同一维度下的事物, 相互间的因果关系还较为简单.</p>
<h2 id="i"><a href="#i" class="headerlink" title="i"></a>i</h2><p>i是维度上的分裂和扩张. 将实数的一维线扩张到复数的二维面.<br>由点到线, 由线到面, 直至无穷维. 多维度让事物和相互关系变得复杂而多样.</p>
<h2 id="π"><a href="#π" class="headerlink" title="π"></a>π</h2><p>π的含义就是圆, 就是循环, 无始无终.<br>我特地将欧拉公式左右都写上0, 就是为了强调循环.</p>
<h2 id=""><a href="#" class="headerlink" title="="></a>=</h2><p>等号的含义就是平衡. 左右两个0表示循环, 两个等号表示平衡, 循环和平衡是最根本的思想!<br>平衡观念在物理上的具体表现是: 动量/角动量守恒(三维空间的不同视角), 能量守恒(四维空间).<br>热寂和能量守恒的矛盾, 说明人类观察到的宇宙是一个开放式系统, 天外有天(更大的时空, 更多的维度).<br>而中国传统哲学充满了平衡的概念: 基本如阴阳, 大如”分久必合, 合久必分”, 可惜只有定性, 缺乏定量!<br>任何的平衡, 从根本上讲都是动态平衡, 都只是暂时的平衡而非永恒的平衡.</p>
<h2 id="博弈"><a href="#博弈" class="headerlink" title="博弈"></a>博弈</h2><p>数学公式没有直接对应于博弈的内容, 但有0, 有1, 要增长要发展要动态平衡, 自然暗含着事物之间的博弈内容.<br>物理学中的博弈结果就是<strong>最小作用量原理</strong>(平衡作用原理), 已经是物理界的信仰了.<br>生物界的博弈情况可以参考演化博弈理论: 纳什均衡的一种应用. 其表现形式: 稳态-稳态被破坏-再稳态, 本质上和电子层是有相似性的.<br>人文科学, 交易市场, 从根本上讲, 就是属于博弈. 如果观察者的级别和智慧足够高, 人类和电子/光子的行为是一样的!<br>要正确理解博弈, 真正困难的是找到博弈的基准<strong>作用量</strong>!</p>
<h2 id="数学的缺陷"><a href="#数学的缺陷" class="headerlink" title="数学的缺陷"></a>数学的缺陷</h2><p>当下的数学体系深陷连续性平滑的陷阱. 平滑曲线只是对现实世界的某种提炼和抽象.<br>目前没有很好的数学工具去解决分形之类的不连续非平滑问题.</p>
<p>物理学由于研究的尺度问题足够小, 所以实际行为表现近似于连续平滑.<br>但看看坑坑洼洼的月球表面, 无线长的海岸线, 形形色色的生物体, 世界一定不是平滑的, 也很可能是不连续的.</p>
<h1 id="观察者的世界"><a href="#观察者的世界" class="headerlink" title="观察者的世界"></a>观察者的世界</h1><p><img src="https://draapho.github.io/images/1901/%E5%8A%A0%E9%80%9F%E8%80%85%E7%9A%84%E6%97%B6%E7%A9%BA%E7%BA%BF.gif" alt="加速者的时空线.gif"></p>
<ul>
<li>上图是快速加速的观察者和时空事件点的相互关系.</li>
<li>竖直方向表示时间,</li>
<li>水平方向表示距离,</li>
<li>虚线是观察者的时空轨迹(世界线).</li>
<li>下四分之一表示观察者可以看到的事件,</li>
<li>上四分之一表示光锥, 观察者将可以看到的事件点.</li>
<li>小点是时空中的简化了的任意事件. (实际上, 事件本身也处在变化中才对)</li>
<li>世界线的斜率给出了相对于观察者的速度.</li>
<li>注意看时空的图像随着观察者加速时的变化。</li>
</ul>
<h2 id="可认知的事物"><a href="#可认知的事物" class="headerlink" title="可认知的事物"></a>可认知的事物</h2><p>涉及到经验主义还是先验主义.<br>经验主义是基础, 有经验才可能发展出一定的先验.</p>
<p>观察者可认知的事物极其有限, 受限于如下条件:</p>
<ul>
<li>事物本身具有稳定性或周期性. (前提条件)</li>
<li>可感知(传感器和数据分析识别)</li>
<li>可重复感知(经验主义的必要条件)</li>
<li>可一致性的重复感知(科学的必要条件)</li>
</ul>
<p>由上分析可知,</p>
<ul>
<li>如果在可观察的视窗期内, 事物本身处在不可观察的状态, 那无论如何都无法被认知.</li>
<li>如果观察者本身能力有限, 事物同样无法被认知. (宗教里的神通/灵异现象, 一般人无法理解, 科学拒绝承认)</li>
<li>科学对观察者和被观察事物的要求都是非常高的! 因而科学可以研究的领域其实并不大. 科学的伟大之处在于局部领域从经验走向了先验, 实现了精确预言!</li>
</ul>
<h2 id="什么是时间"><a href="#什么是时间" class="headerlink" title="什么是时间"></a>什么是时间</h2><p>世界本没有时间, 只有变化和循环, 也就是波动. 有观察者, 才有时间. 相对性才是时间的本质.</p>
<p><img src="https://draapho.github.io/images/1901/%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%97%B6%E9%97%B4.png" alt="事件与时间.png"></p>
<ul>
<li>上图中, 1-8是简化了的稳定事件, 它们”同时”存在.</li>
<li>对一维观察者Y而言, 其发生的顺序是顺序的: 1-&gt;8, 事件间隔的越来越短.</li>
<li>对一维观察者X而言, 其发生的顺序是逆序的: 8-&gt;1, 事件间隔的越来越短.</li>
<li>对一维观察者θ而言, 其发生的顺序是顺序的: 1-&gt;8, 事件间隔是等距的.</li>
<li>对一维观察者r而言, 这一点就是个黑洞, 无法观察到任何区别.</li>
<li>时间的确定是需要参照物的, 上图假定了1-8就是时间的参照物.</li>
<li>观察者和被观察者是相对产生的, 也只是逻辑上的划分.</li>
</ul>
<h2 id="宿命论和决定论"><a href="#宿命论和决定论" class="headerlink" title="宿命论和决定论"></a>宿命论和决定论</h2><ul>
<li>从终极含义上讲(来处和去处), 是宿命论, 但并非处处宿命, 过程是有限选择权.</li>
<li>认识到大趋势, 在趋势中根据自己的立场去做选择.</li>
<li>趋势与立场一致, 则顺势而为, 事半功倍.</li>
<li>趋势与立场相反, 则隐忍不发, 伺机而动.</li>
<li>趋势不明或拐点处, 有能力者自当充分发挥主观能动性去形成新趋势.</li>
<li>正所谓时势造英雄, 可惜成了英雄的, 多半会认为自己造了时势.</li>
</ul>
<h1 id="一切皆相对-本位问题"><a href="#一切皆相对-本位问题" class="headerlink" title="一切皆相对(本位问题)"></a>一切皆相对(本位问题)</h1><p>从观察者角度而言, 一切皆相对! 其核心是一个本位问题.</p>
<ul>
<li>本: 一定范围内的绝对性. 本无本, 为了位而本.</li>
<li>位: 也就是相. 相对性, 相互关系. 本无位, 有了本而有位.</li>
<li>正因为无位可本, 无本可位, 一切相对. 才可以无所位而生其本、无所本而生其位.</li>
</ul>
<h2 id="数学与物理"><a href="#数学与物理" class="headerlink" title="数学与物理"></a>数学与物理</h2><ul>
<li>数学: 先验的本, 基于本推论位. 公理就是本. 不需要位而来的本.</li>
<li>物理学: 位中寻本, 自我突破.<ul>
<li>经典力学, 绝对时空观</li>
<li>相对论, 绝对光速</li>
<li>量子力学, 目前只有位, 没有本. 一切观察的结果皆概率事件.故而难以理解</li>
<li>弦论: 二维波动的弦, 多维度. 思想上离世界的本质非常接近了.</li>
<li>大统一理论: 数学最多只能描述部分世界的部分阶段, 不可能精确描述整个世界的变化过程(过程不可精确预测, 事物是有部分选择权的). 所以所谓的大统一理论也不会是终结, 不过对于没有求得本的西方世界而言, 这种渴求得本的心态是可以理解的.</li>
</ul>
</li>
</ul>
<h2 id="东西方和伊斯兰世界"><a href="#东西方和伊斯兰世界" class="headerlink" title="东西方和伊斯兰世界"></a>东西方和伊斯兰世界</h2><ul>
<li>东方:<ul>
<li>位为先, 本次之.</li>
<li>宗教领域体现在, 佛道的否定一切, 从而求到了本. 佛教是从有到无, 告知否定的过程, 无位可本. 道教从无到有, 告知一切相对, 无本可位.</li>
<li>世俗领域体现在, “王侯将相宁有种乎”(不承认天子为本), 其结果是”成王败寇”(由位生本).</li>
<li>社会双线运行, 世俗为明线, 继续位为先, 人定胜天, 积极地与人与天地斗; 精神为暗线, 得本, 传承文化, 帮助灾后重建.</li>
</ul>
</li>
<li>西方:<ul>
<li>本为大, 位从之.</li>
<li>宗教领域是一神教, 社会领域追求理性的思辨, 数学去求本. 最终结合位, 诞生了科学, 现在依旧在求本的路上. 然后, 科学领域的成功开始反噬宗教领域…</li>
<li>科学方法的诞生对于西方世界有重大的意义: 帮助其认识到 无位可本, 本终究非本! 从而突破了本为大的历史束缚, 走上了位为先(科学实验), 本次之(用实验结果验证理论的本)的道路.</li>
<li>由于西方世界并没有得本, 所以依旧有很多天真而幼稚的想法. 文化领域体现在白左的泛滥, 被资本和其它文化利用而不自知, 屡错而不知反思悔改, 属于求本舍位, 其结果必然是无位无本, 自我灭亡. 经济领域体现在对自由资本主义的纵容, 并事实上形成了财阀是幕后的实际决策者, 但这些财阀也是资本的奴隶, 人人都是资本的奴隶.</li>
<li>西方世界真正值得学习的地方只有两个: 民主和科学. 民主制度本质上是一种有效的反馈机制, 但要考虑反馈力度和有效性, 否则容易过犹不及. 科学方法是本位互相促进的绝佳范本!</li>
</ul>
</li>
<li>伊斯兰:<ul>
<li>古兰经为唯一的本. 古兰经统治了宗教和社会双方面. 稍微结合位修改一下本都不被允许.</li>
</ul>
</li>
<li>中西合璧:<ul>
<li>西方需要从思想上认识到东方的哲学思想更接近世界的本源, 对本的认识进行一次升华.</li>
<li>东方需要从方法上深度学习借鉴西方的数理方法, 对位进行细致无歧义的描述.</li>
<li>中意(东方的思想)西形(西方的研究方法), 方可进一步去逼近世界本源.</li>
<li>中西合璧是发展, 伊斯兰世界是守旧. 人类自己去博弈和选择!</li>
</ul>
</li>
</ul>
<h2 id="当今社会"><a href="#当今社会" class="headerlink" title="当今社会"></a>当今社会</h2><ul>
<li>西方社会:<ul>
<li>本: 资本</li>
<li>位: 一切用资本来衡量. 包括爱情(钻戒, 婚前协议), 亲情和生命(保险), 人/环境/精神(消费主义, 享乐主义)/物质全都服务于资本.</li>
</ul>
</li>
<li>中国社会:<ul>
<li>本: 权利</li>
<li>位: 权利最大, 基于权利体系的社会关系(政治化的儒学)</li>
</ul>
</li>
<li>众生相:<ul>
<li>本就是人性, 由人性之本而产生位.</li>
<li>贪嗔痴, 对他人/其它团体的优越感.(权利, 财富, 荣誉, 知识, 精神, 信仰, 道德)</li>
</ul>
</li>
<li>交易市场:<ul>
<li>本: 逐利 (贪婪与恐惧)</li>
<li>位: 探索获得收益的方法.</li>
<li>本: 确定一套方法 (去除了贪婪与恐惧),</li>
<li>位: 探索方法是否能盈利</li>
</ul>
</li>
<li>人的社会评价:<ul>
<li>英雄: 成功的抄底者. (事实是无数人倒在了抄底的路上)</li>
<li>君子豹变: 大势跟随者.</li>
<li>墙头草: 被诱多诱空了的操作者.</li>
</ul>
</li>
</ul>
<h2 id="为人处事"><a href="#为人处事" class="headerlink" title="为人处事"></a>为人处事</h2><p>在这个一切相对的世界里, 作为个体又如何自处呢?<br>我的答案是: 本中求位. 心中有本, 在大环境中求得自己的位.</p>
<p>对认知而言, 至少需要一个本. 本越少, 人或事就越纯粹.</p>
<ul>
<li>在数学上, 这个本就是公理, 对于公理, 不要问缘由.</li>
<li>任何哲学体系必须有一个最基本的立足点. 譬如物质或精神, 譬如存在或不存在.</li>
<li>交易上, 普通散户的本是自己的情绪, 价值投资者的本是业绩和股价的性价比, 技术派的本是K线图.</li>
</ul>
<p>人的一生, 越早能确定自己心中的本, 越可能处变不惊. 或叱咤风云, 或风轻云淡的过完属于自己的人生. 而本越单纯, 越稳固, 越脱离于人性(贪嗔痴疑慢), 人就越专注, 越乐得其所, 越洒脱自然. 对于普通人, 宗教信仰就是一个不错的本. 对于某些科学狂人, 不断吸取和探索新知识就是他们心中的本.</p>
<h1 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h1><h2 id="生物集群灭绝"><a href="#生物集群灭绝" class="headerlink" title="生物集群灭绝"></a>生物集群灭绝</h2><p><img src="https://draapho.github.io/images/1901/%E7%94%9F%E7%89%A9%E5%8F%91%E5%B1%95%E5%8F%B2.jpg" alt="生物发展史.jpg"></p>
<ul>
<li>第一波生物大辐射到2处, 约2亿年.</li>
<li>平台期有2次大的生物灭绝, 若干次小的生物灭绝, 2处到1处, 同样是约2亿年.</li>
<li>1处是最严重一次生物大灭绝! 随后就开始新一波的生物急速增长. 持续到5处, 也是越2亿年.</li>
<li>内部还有很多次小型的增长和衰退, 许多学者认为小周期是6200万年的波动.</li>
<li>详细划分见 <a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E7%89%A9%E9%9B%86%E7%BE%A4%E7%81%AD%E7%BB%9D">生物集群灭绝</a></li>
</ul>
<h2 id="中国历史周期律"><a href="#中国历史周期律" class="headerlink" title="中国历史周期律"></a>中国历史周期律</h2><p><img src="https://draapho.github.io/images/1901/%E4%B8%AD%E5%9B%BD%E6%9C%9D%E4%BB%A3%E5%8F%B2.png" alt="中国朝代史.png"></p>
<ul>
<li>夏商周历史遥远, 但很明显也有一定的周期性, 夏朝约500年, 商朝约600年, 西周到春秋约500年!</li>
<li>随后的划分就非常明显了, 从乱世开始, 中间会诞生一个统一的短命王朝, 然后是持续200-300年的王朝. 约700年一个周期.</li>
<li>战国被秦统一后, 是大汉. 汉朝初期有吕雉干政. 文景之治始于公元前167年, 即刘邦建立汉朝21年后开始.</li>
<li>三国魏晋南北朝后, 隋朝统一天下, 李氏父子随后建立大唐, 持续300年不到.</li>
<li>五代十国天下大乱, 宋朝虽然经济发达, 但军事上始终受制于周边少数民族. 被强元统一100年后, 开启大明朝.</li>
<li>清朝的统一看似有康乾盛世, 但有如下背景:<ul>
<li>明朝一直到末期都是高度中央集权的政府, 故而没有形成有效的割据势力. 在中央政府被击垮后, 南方无力抵抗清军.</li>
<li>从世界背景看, 清朝在闭关锁国, 正是西方世界突飞猛进之时, 清朝在世界中的位置其实是宋朝!</li>
<li>因而, 清朝对中国历史而言, 其地位对应于主跌浪的乱世, 所谓的康乾盛世也只是强劲一点的B浪反弹, 撑死也就是对应于北宋的位置.</li>
</ul>
</li>
<li>随后的中华民国, 本质是军阀混战, 有个形式上的统一. 随后便是中华人民共和国.<ul>
<li>这段历史和秦汉时期最像! 中华民国对应于秦朝, 江青对应于吕雉, 建国30年后邓小平开始改革开放, 然后有人开始做武帝的梦.</li>
<li>但在历史上也有另一种可能的对应方式, 就是宋元明. 清朝对应于宋朝, 如果日本是稳扎稳打, 就有机会成为元朝.</li>
</ul>
</li>
<li>作为身处游牧民族包围的农业国, 受自然环境影响非常大. <a href="http://www.sohu.com/a/127603366_450598">例外中的例外，是否有人能逃脱历史周期律？</a> 有一张历史温度变化趋势, 很有意思!</li>
<li>可参考 <a href="http://loonta.com/1783.html">中国历史兴衰周期表</a>,</li>
</ul>
<h2 id="上证指数月线"><a href="#上证指数月线" class="headerlink" title="上证指数月线"></a>上证指数月线</h2><p><img src="https://draapho.github.io/images/1901/%E4%B8%8A%E8%AF%81%E6%8C%87%E6%95%B0.png" alt="上证指数.png"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E6%B4%9B%E4%BC%A6%E5%85%B9%E5%8F%98%E6%8D%A2">洛伦兹变换</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_486e105c0100070a.html">《论语》详解：给所有曲解孔子的人 44——子曰∶君子谋道不谋食</a></li>
<li><a href="https://wenku.baidu.com/view/20cb9f0b59fafab069dc5022aaea998fcd22406b">四维空间与能量本质</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_61b34ca30102xct3.html">分形、最小作用量原理、幂律、小世界</a></li>
<li><a href="https://read01.com/zh-my/oLN6R3J.html#.XJDWNCgzaUk">显生宙的五次生物大灭绝—-“Big Five”</a></li>
<li><a href="http://114.xixik.com/chaodai/">中国朝代顺序表</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>交易市场思考</title>
    <url>/2019/03/26/1902-trading-rule/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2019/03/26/1902-trading-rule/">交易市场思考</a></li>
<li><a href="https://draapho.github.io/2019/04/26/1903-wave-principle/">波浪理论简述</a></li>
<li><a href="https://draapho.github.io/2019/06/25/1907-investor/">你将不会成为一个伟大的投资人</a></li>
<li><a href="https://draapho.github.io/2020/02/09/2001-exploration/">交易市场阶段性探索心得</a></li>
<li><a href="https://draapho.github.io/2020/08/06/2005-wave-mnemonic/">波浪理论口诀</a></li>
<li><a href="https://draapho.github.io/2020/08/07/2006-wave-thinking/">波浪理论感悟</a></li>
<li><a href="https://draapho.github.io/2021/02/03/2102-share-skill/">交易市场思路</a></li>
</ul>
<h1 id="指导思想"><a href="#指导思想" class="headerlink" title="指导思想"></a>指导思想</h1><ul>
<li><strong>如果连时间都控制不了(自律), 还谈什么自信!</strong></li>
<li>高手无他, 知道重点(<strong>强弱, 共振</strong>), 深入研究(<strong>结构, 均线, 资金流</strong>)</li>
<li><strong>技术分析核心思想: 若何时何价, 则强/中/弱</strong>, 没有期望, 只有通过实际走势客观判断市场强弱.</li>
<li><strong>技术分析最大的坑: 何时必何价, 预测!</strong>. 由于加入了主观期望后的选择性观察和判断, 故而失去客观性!</li>
<li>大道至简且相通: <strong>减少交易次数, 顺势而为, 讲的是人性!</strong>.</li>
</ul>
<h1 id="知行合一"><a href="#知行合一" class="headerlink" title="知行合一"></a>知行合一</h1><ul>
<li>要在交易市场生存和获利, 最根本的一句话就是: <strong>知行合一</strong></li>
<li>当然首先要有自己的知, 知而后行, 行而后知, 不断进步, 直至知行合一.</li>
<li>炒股级别:<ul>
<li>无知有行: 随心所欲的不断交易.</li>
<li>有知有行: 学了点知识, 但依旧是想当然的交易. 或知的不够, 或执行力不够.</li>
<li>有知无行: 学会了空仓和等待, 只做确定性机会. 但心境依旧波澜起伏, 需要依靠规则和执行力.</li>
<li>知行合一: 知的最高境界就是知道自己的弱点. 行的最高境界就是知行合一. 从而不立于危墙之下, 只赚认知之内的钱.</li>
</ul>
</li>
</ul>
<h2 id="知"><a href="#知" class="headerlink" title="知"></a>知</h2><ul>
<li>当你走进交易市场后, 你将面对如下对手.<ul>
<li>或拥有最敏锐, 最凶狠的头脑;</li>
<li>或拥有勤奋努力, 孜孜不倦的态度;</li>
<li>或拥有说一不二, 严格执行的纪律;</li>
<li>更多的是三者皆备.</li>
<li>请问: 如何在市场上把他们的钱挪到自己口袋里?</li>
</ul>
</li>
<li>自己对交易市场的知是本! 而交易规则, 信仰之类的都是为这个”本”服务的位. 所以:<ul>
<li>别把别人的信仰当成自己的信仰. 譬如”价值投资”</li>
<li>别把别人的军规当成自己的军规. 譬如”3%无条件止损”</li>
<li>很明显, “价值投资”和”无条件止损”是相互矛盾的!</li>
</ul>
</li>
<li>什么是知?<ul>
<li>对交易市场本质的思考和理解</li>
<li>获利方法的学习和掌握, 探索交易模式.</li>
<li>自己主观(性格, 心理)和客观(时间, 精力)情况的分析和改进.</li>
</ul>
</li>
<li>投资, 是市场认知和人性的变现.<ul>
<li>只有市场认知, 最多只能像爬藤植物一般, 可以快速生长, 但无法完成积累!</li>
<li>同时认知市场和人性, 才可能成长为参天大树.</li>
<li>任何事物都有自己的路径依赖. 做投资, 必须一开始就培养成为参天大树的交易习惯.</li>
<li>大道至简: <strong>减少交易次数, 顺势而为.</strong><ul>
<li>抄底逃顶的技术派一般听不进去.</li>
<li>长期持股的价值派自带这种模式.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="行"><a href="#行" class="headerlink" title="行"></a>行</h2><ul>
<li>求知过程本身就是一种行.<ul>
<li>求知过程最重要的一句话是 <strong>高手无他，知道重点深入研究过而已</strong> (百年一人)</li>
</ul>
</li>
<li>交易过程是行.<ul>
<li>交易过程最重要的一句话是 <strong>一致性表现!</strong>, 也就是通过”知”识别出一种可重复的交易模式.</li>
</ul>
</li>
<li>知只是理论, 理论知识再丰富, 不上战场也只是纸上谈兵.</li>
<li>人性的关系, 知行合一非常非常的难! 所以会有一个知而后行, 行而后知, 不断进步的过程.</li>
<li>目前的交易市场, 主角还是人, 靠人性的弱点赚钱.</li>
</ul>
<h2 id="人性弱点"><a href="#人性弱点" class="headerlink" title="人性弱点"></a>人性弱点</h2><ul>
<li>在达到知行合一之前, 所有人的共同弱点就是人性!</li>
<li>贪: 追求利润而忽视风险. 区别是, 有些让本金也在高风险之下, 有些人只会让已有的利润承担高分险.</li>
<li>嗔疑痴: 与预期不一致后的生气,怀疑,拒不认错. 导致无法及时按计划处理错误, 如放弃止损或导致踏空.</li>
<li>惧: 惧是嗔疑痴的后续情绪, 由于一错再错, 就会恐惧, 最终在行为上表现为卖在低位, 买在高位.</li>
<li>慢: 慢的危害最大也最不易察觉! 特别是自认为知行合一, 战无不胜之时!</li>
<li>在交易市场, <strong>克服人性弱点的唯一办法就是承认自己的弱点, 避免自己陷入到不利的处境之中.</strong></li>
</ul>
<h2 id="交易市场本质"><a href="#交易市场本质" class="headerlink" title="交易市场本质"></a>交易市场本质</h2><ul>
<li><strong>成本/价格</strong><ul>
<li>交易者情绪的起伏取决于价格波动, 价格波动又导致了交易者情绪的起伏.<ul>
<li>情绪和价格, 就有如电场和磁场, 交织在一起不断的变化延伸, 画出了K线图.</li>
</ul>
</li>
<li>空仓者没有亏损压力, 故只需克服贪字即可.</li>
<li>更为根本的是持仓成本.<ul>
<li>能承受50%以上亏损的价值投资者恐怕不多.</li>
<li>有资金压力的人对亏损高度敏感.</li>
<li><strong>“恐惧”是写入基因的本能, 别想着去克服, 而是避免让”恐惧”的情况发生.</strong></li>
<li>底部是一个让”恐惧”的资金换手的地方. 只有这样, 未来上涨的阻力才能最小化.</li>
</ul>
</li>
<li>因而, <strong>防止亏损永远比追求盈利重要.</strong></li>
</ul>
</li>
<li><strong>时间</strong><ul>
<li><strong>时间是主宰.</strong></li>
<li>将贪婪的心降低预期至少亏一点, 直至不能再亏.</li>
<li>让恐高的心习以为常, 因为不忍再次踏空而匆匆买入.</li>
<li>直觉上, 应该有类似于牛顿冷却定律的数学公式.</li>
</ul>
</li>
<li><strong>结构</strong><ul>
<li>历史走势形成了交易市场自身的结构, 类似于河床.</li>
<li>未来的资金流只能沿着已有的河床前进, 唯有这样才符合最小作用量原理(花的钱最少, 造成的波动最大)</li>
<li>结构被资金流不断的冲击, 会缓慢的改变.</li>
<li>正如河水只能沿着河床前进, 河床被日积月累的河水冲击而改变. 互为因果.</li>
</ul>
</li>
<li><strong>均线</strong><ul>
<li>均线能体现综合成本.</li>
<li>均线暗含着随时间推移, 人心对当前的股价习以为常.</li>
<li>合适的均线能提炼出K线结构, 显示走势的强弱.</li>
</ul>
</li>
<li>人性<ul>
<li>市场的所有表象, 最终体现的都是人性的本质.</li>
<li>交易市场是一个最公平, 最充分, 最激烈, 也最和平的人性博弈场所.</li>
</ul>
</li>
</ul>
<h1 id="交易模式"><a href="#交易模式" class="headerlink" title="交易模式"></a>交易模式</h1><h2 id="技术派"><a href="#技术派" class="headerlink" title="技术派"></a>技术派</h2><ul>
<li>基于K线分析的流派.</li>
<li>代表人物: 江恩, 百年一人, 詹姆斯•西蒙斯</li>
<li>公理: 股价包容一切.</li>
<li>操作级别:<ul>
<li>日内超短线.<ul>
<li>多用于外汇, 期货市场.</li>
<li>A股市场不支持.</li>
</ul>
</li>
<li>日间短线. 快进快出<ul>
<li>A股市场的最短交易时间, 很多散户高手使用.</li>
<li>优点: 满足高频交易的心理. 适用于与牛熊鹿任何阶段!</li>
<li>缺点: 对操作者要求极高(能力和心理素质, 全职看盘), 资金容量有限.</li>
</ul>
</li>
<li>波段交易<ul>
<li>中期持股, 数周或数月.</li>
<li>优点: 省时省力, 资金容量大. 资金成长性远远高于短线客.</li>
<li>缺点: 对操作者要求极高(正确识别出波段机会, 能中长期空仓等待)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="价值投资派"><a href="#价值投资派" class="headerlink" title="价值投资派"></a>价值投资派</h2><ul>
<li>基于行业发展和企业基本面分析的流派.</li>
<li>代表人物: 巴菲特.</li>
<li>操作级别: 长期持股.<ul>
<li>优点: 由于其忽略股价短时波动的理念, 可以很容易的忽略情绪去买卖.</li>
<li>缺点: 普通投资者缺乏全面的基本面分析能力, 学习手段也有限!</li>
<li>缺点: 散户解决不了风险分散以及何时卖出的问题.</li>
</ul>
</li>
</ul>
<h2 id="盲点套利派"><a href="#盲点套利派" class="headerlink" title="盲点套利派"></a>盲点套利派</h2><ul>
<li>基于思维盲区, 利用规则漏洞或主动攻击他人弱点而获利的流派.</li>
<li>代表人物: 索罗斯, 青木</li>
<li>没这个头脑, 资源和能力, 不做评价.</li>
</ul>
<h2 id="三大系统"><a href="#三大系统" class="headerlink" title="三大系统"></a>三大系统</h2><ul>
<li>技术系统<ul>
<li>预测系统: 不重要!</li>
<li><strong>确认系统</strong>: 解决确定性问题: 开仓标准, 仓位标准, 平仓标准.</li>
<li>确认系统必须是经过测试的, 有自信和把握将其作为唯一性买卖标准!</li>
</ul>
</li>
<li><strong>仓位系统</strong><ul>
<li>应对风险的不二法门, 仓位系统大原则: 始终让自己留在赌桌上.</li>
<li>分仓比例, 单次允许最大的亏损, 开仓数量, 加仓数量.</li>
<li>仓位系统是用来对冲人性弱点的!</li>
</ul>
</li>
<li><strong>心性系统</strong><ul>
<li>心性系统的目标就是知行合一.<ul>
<li>并不是指练就”无欲无求”, “洒脱自然”的出世态度. (那还入交易市场干吗?)</li>
<li>知: 承认自己的贪嗔痴疑慢, 承认人性的弱点.</li>
<li>行: 用交易规则和执行力, 减少和避免不利情况的发生.</li>
</ul>
</li>
<li>能否不为外界所动的坚持标准! (外界指其他人的声音)</li>
<li>市场证明判断错误后, 能否立刻纠错. (认陪比追涨重要的多!)</li>
</ul>
</li>
<li>心性系统三大矛盾<ul>
<li>主观追求确定性与股市不可测的矛盾.<ul>
<li>市场才是老大! 所有交易者都必须遵从市场走势.</li>
</ul>
</li>
<li>期待快速赢利与炒股是持久战的矛盾.<ul>
<li>曲成万物，欲速则不达</li>
<li>想想参天大树和快速生长的爬藤植物, 大象和忙忙碌碌的蜜蜂蚂蚁.</li>
</ul>
</li>
<li>思想在高处与操作行为在低处的矛盾<ul>
<li>希望盈利, 从不亏损入手</li>
<li>希望快速盈利, 从稳定入手</li>
<li>希望买入大牛, 从不能买什么入手</li>
<li>希望提高成功率, 从降低失误率入手</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="我的学习重点"><a href="#我的学习重点" class="headerlink" title="我的学习重点"></a>我的学习重点</h1><ul>
<li>定位: 绩优股波段交易, 价值投机.</li>
<li>基础知识: 道氏理论, 波浪理论, 缠论, 江恩时空平衡.<ul>
<li>铸剑先生, 技术分析, 确认及跟随系统</li>
<li>柳荫解盘, 资金流分析</li>
<li>百年一人, 技术分析, 时间预测</li>
</ul>
</li>
<li><strong>确认及跟随系统</strong>:<ul>
<li><strong>均线</strong><ul>
<li>高手止于均线(百年一人)</li>
<li>均线研究的四个要素: 周期, 大小, 方向和拐点.</li>
<li>一阶均线, 级别分离, 高通滤波.</li>
</ul>
</li>
<li><strong>结构</strong><ul>
<li>股价的最高最低价, 结合时间要素构成N字形结构.</li>
<li>结构要素: 横竖斜, 分别对应持续时间, 股价空间, 速度.</li>
</ul>
</li>
<li><strong>时间周期</strong><ul>
<li>以4和6为数理基础构成的时间序列. (铸剑先生)</li>
<li>顶底循环周期, 均线交叉/拐点周期, 不同级别比例关系, 同级别对称关系.</li>
<li>唯一性靠结构解决: 趋势运行需要时间，时间服从于结构，结构排在第一位！(百年一人)</li>
</ul>
</li>
<li><strong>共振</strong><ul>
<li>级别共振, 注意小服从大.</li>
<li>技术共振: 资金, 结构, 均线, 时间.</li>
<li>横向共振: 金融, 市场, 板块, 基本面.</li>
</ul>
</li>
<li><strong>判断级别和走势属性</strong><ul>
<li>判断出级别, 从而事前确定操作级别.</li>
<li>判断后续走势的属性, 从而决定是否参与以及参与的仓位.</li>
</ul>
</li>
</ul>
</li>
<li><strong>仓位系统</strong>:<ul>
<li>高度看好的股票, 可以建一个跟随仓, 作用类似于侦察兵, 帮助自己随时观察强弱变化.</li>
<li><strong>潜在盈亏比和市场强弱决定开仓比例, 提前确定好主动止损情况和被动止损点.</strong></li>
<li>如果市场和个股走势符合预期, 可以在趋势回调中加仓. 加仓仓位必须单独设置止损点.</li>
<li><strong>要根据市场实际走势的强弱变化来重仓和清仓. 对于预测的顶底, 只允许分仓按短线思维操作!</strong></li>
</ul>
</li>
<li><strong>选股系统</strong>:<ul>
<li>观察资金流<ul>
<li><strong>大资金建仓成本是个股的超级底牌.</strong></li>
<li>技术面和资金面共振做多就是超级牛股.</li>
<li>并不是看一二天的大资金流入流出. 而是像烧水一样有多重铺垫.</li>
<li>在重要的点位, 如阻力位, 尤其要看主力资金是虚砸实接还是虚拉实砸.</li>
</ul>
</li>
<li>强弱对比<ul>
<li>横向比: 当前走势和历史走势比.</li>
<li>纵向比: 个股和板块比, 板块和指数比.</li>
</ul>
</li>
<li>共振<ul>
<li>技术面多级别共振.</li>
<li>不同技术指标共振. (可以归纳为资金,结构,均线)</li>
<li>政策面, 基本面, 资金面, 技术面共振</li>
<li>个股, 板块, 大盘环境共振.</li>
</ul>
</li>
<li>基本面优良<ul>
<li>不会研究基本面, 找行业前三, 国有企业即可.</li>
<li>重点关注内容: 市值大小, 盈利能力, 稳定性, 发展情况.</li>
</ul>
</li>
</ul>
</li>
<li>预测系统:<ul>
<li>暂时不花大力气学习, 稳定盈利靠确认系统和执行力.</li>
<li>最终是要深入研究的, 股票市场可预测等同于人类行为可预测, 对整个人文科学意义重大.</li>
<li>这里的预测, 并不是传统科学理论的”精确”预测, 而是如天气预报, 量子理论的概率预测.</li>
<li>事物和生命是有限选择权, 因此可部分预测. 但精确预测会造成宿命论.</li>
</ul>
</li>
<li>一些体会:<ul>
<li><strong>稳定盈利的四个条件: 休息, 止损, 一致性交易模式, 持续下单能力.</strong><ul>
<li><strong>春种(买入), 夏长(获利), 秋收(卖出), 冬藏(休息)</strong></li>
</ul>
</li>
<li>大小资金各有优劣<ul>
<li>大资金: 主动创造机会, 大主导小; 行动缓慢, 在明处, 只能打阵地战.</li>
<li>小资金: 被动等待机会, 小跟随大; 行动快捷, 在暗处, 可以打游击战, 运动战.</li>
<li>**交易是持久战, 重守正, 轻出奇, 多守正, 少出奇. **</li>
</ul>
</li>
<li><strong>多头分两类, 一种是技术多头, 另一种是资金多头.</strong><ul>
<li>大资金多头往往在技术多头之前就布局好了.</li>
<li>在技术多头情况下, 大资金做空的抛压就会被技术多头化解掉.</li>
<li>简单理解的话, 一浪和五浪属于资金和技术的不和谐, 三浪属于资金和技术的共振.</li>
</ul>
</li>
</ul>
</li>
<li>常见的错误<ul>
<li>过度交易, 自信膨胀, 驾驭市场, 忽视意外.</li>
<li>没到买点就摊平亏损 (事前确定最大亏损额度)</li>
<li>过早获利了结, 过迟认陪 (事前确定操作级别)</li>
<li>逆向交易 (不做次要方向)</li>
<li>追涨杀跌 (永不追高买入, 错过了就欣赏)</li>
<li>冲动交易, 跟着情绪走 (无计划不操作! 按规则严格执行!)</li>
</ul>
</li>
<li>推荐书籍:<ul>
<li>&lt;江恩华尔街45年&gt;</li>
<li>&lt;艾略特波浪理论&gt;</li>
<li>&lt;道氏理论&gt;</li>
<li>&lt;股票趋势技术分析&gt;</li>
<li>&lt;亚当理论&gt;</li>
<li>缠中说禅</li>
<li>铸剑先生</li>
<li>百年一人</li>
<li>&lt;通向财务自由之路&gt; 范.K.撒普</li>
<li>&lt;专业投机原理&gt; 维克托.斯波朗迪</li>
<li>&lt;彼得.林奇点评版 股票作手回忆录&gt; 杰西.利弗莫尔</li>
</ul>
</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>market</category>
      </categories>
      <tags>
        <tag>market</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 错误及解决方法</title>
    <url>/2019/05/19/1904-python-error/</url>
    <content><![CDATA[<h1 id="UnicodeEncodeError-‘charmap’-codec-can’t-encode-characters"><a href="#UnicodeEncodeError-‘charmap’-codec-can’t-encode-characters" class="headerlink" title="UnicodeEncodeError: ‘charmap’ codec can’t encode characters"></a>UnicodeEncodeError: ‘charmap’ codec can’t encode characters</h1><ul>
<li>此问题多发生在windows的区域和开发中用到在字符不匹配. 譬如英文区域的windows要编解码中文字符.</li>
<li>原因及解决方法参考 <a href="https://blog.csdn.net/haiross/article/details/36189103">代码页即地狱</a></li>
</ul>
<p>简单来说, 就是windows底层编码的问题. 要解决这个问题, 只能从windows系统着手.</p>
<p><img src="https://draapho.github.io/images/1904/Region.png" alt="Region"></p>
<h1 id="from-PyQt5-import-QtCore-from-PyQt5-QtGui-import-errors-No-module-named-39-PyQt5-39"><a href="#from-PyQt5-import-QtCore-from-PyQt5-QtGui-import-errors-No-module-named-39-PyQt5-39" class="headerlink" title="from PyQt5 import QtCore from PyQt5.QtGui import * errors No module named &#39;PyQt5&#39;"></a><code>from PyQt5 import QtCore</code> <code>from PyQt5.QtGui import *</code> errors <code>No module named &#39;PyQt5&#39;</code></h1><ul>
<li>python3 和 pyqt5 兼容性问题. 最新版本的 pyqt5 和 python3.6, python3.7 不兼容.</li>
<li>现象为: <code>import PyQt5</code> 调用正常. <code>from PyQt5 import QtCore</code> 提示错误, 无法找到模块 <code>PyQt5</code></li>
<li>解决方法: 试了很多版本组合. 最后成功的是 <code>Python 3.8.8</code> 32位 和 <code>PyQt5 5.15.2</code>.<ul>
<li>先软件安装 <code>Python 3.8.8</code></li>
<li>直接 <code>pip install pyqt5-tools</code> 自动安装的最新版本.</li>
</ul>
</li>
</ul>
<h1 id="Python-2-下-pip-install-pyinstaller-无法安装-编译失败"><a href="#Python-2-下-pip-install-pyinstaller-无法安装-编译失败" class="headerlink" title="Python 2 下 pip install pyinstaller 无法安装, 编译失败."></a>Python 2 下 <code>pip install pyinstaller</code> 无法安装, 编译失败.</h1><ul>
<li>很复杂的兼容性问题. 需要降低 pip 版本以及 pyinstaller 版本</li>
<li>首先, 降低pip版本到18.1: <code>pip install pip==18.1</code></li>
<li>然后, 指定pyinstaller版本为3.4: <code>pip install pyinstaller==3.4</code></li>
<li>检查是否安装成功. <code>pyinstaller -v</code></li>
</ul>
<h1 id="运行编译后的文件-提示-Failed-to-execute-script-pyibooto1-bootstrap-进一步提示-Error-Nonetype-object-has-no-attribute-write"><a href="#运行编译后的文件-提示-Failed-to-execute-script-pyibooto1-bootstrap-进一步提示-Error-Nonetype-object-has-no-attribute-write" class="headerlink" title="运行编译后的文件, 提示: Failed to execute script pyibooto1_bootstrap 进一步提示 Error: Nonetype object has no attribute write"></a>运行编译后的文件, 提示: <code>Failed to execute script pyibooto1_bootstrap</code> 进一步提示 <code>Error: Nonetype object has no attribute write</code></h1><ul>
<li>Python3 下 PyInstaller 自己弄出来的一个错误. 当使能了调试<code>-d all</code>, 而又指定 <code>-w</code> 不需要调试终端时, 自动生成的 <code>.spec</code>文件依旧要求输出sys.stderr. 由于没有终端, 因而提示没法write</li>
<li>参考资料 <a href="https://github.com/pyinstaller/pyinstaller/issues/4213">Program fails at <code>pyiboot01_bootstrap</code> when using <code>--noconsole</code></a></li>
<li>解决方法: 用<code>-d all</code>时, 不能用<code>-w</code>.</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>魔方简易步骤</title>
    <url>/2019/06/03/1906-rubik/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此文目标: 用最少的情况分类和记忆公式, 慢慢的还原三阶魔方.<br>底层为白色, 顶层为黄色. 四个面的中心点颜色是相对固定的,是重要的参考点.</p>
<p>速记符和手法:<br><img src="https://draapho.github.io/images/1906/0_1.png" alt="手法"></p>
<h1 id="一-底层十字"><a href="#一-底层十字" class="headerlink" title="一:底层十字"></a>一:底层十字</h1><p>方法: 现在顶部黄色弄出白色十字小白花, 然后第二层中心颜色对齐</p>
<p><img src="https://draapho.github.io/images/1906/1_1.png" alt="步骤一"></p>
<h1 id="二-底角归位"><a href="#二-底角归位" class="headerlink" title="二:底角归位"></a>二:底角归位</h1><p>方法: 底角三色放到右侧顶角处, 反复一次或多次<code>RUR’</code>即可</p>
<p><img src="https://draapho.github.io/images/1906/2_1.png" alt="步骤二"></p>
<h1 id="三-中棱归位"><a href="#三-中棱归位" class="headerlink" title="三:中棱归位"></a>三:中棱归位</h1><p>方法: 右侧同色倒T字, <code>右上交替, 顶到前, 五逆四顺; 顶到后, 五顺四逆</code>.</p>
<p><img src="https://draapho.github.io/images/1906/3_1.png" alt="步骤三"></p>
<h1 id="四-顶层十字"><a href="#四-顶层十字" class="headerlink" title="四:顶层十字"></a>四:顶层十字</h1><p>起点: 顶层图形, 中心点黄色/右下角/横线</p>
<p><img src="https://draapho.github.io/images/1906/4_1.png" alt="步骤四1"></p>
<p>方法: <code>FRU R’U’F’</code> 重复到黄色十字出现</p>
<p><img src="https://draapho.github.io/images/1906/4_2.png" alt="步骤四2"></p>
<h1 id="五-顶层一色"><a href="#五-顶层一色" class="headerlink" title="五:顶层一色"></a>五:顶层一色</h1><h2 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h2><p>起点: 顶部向下黄色小鱼, 注意侧边黄色要求</p>
<p><img src="https://draapho.github.io/images/1906/5_1.png" alt="步骤五1"></p>
<p>方法: <code>R’U2 RU R’UR</code></p>
<h2 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h2><p>起点: 顶部向上黄色小鱼, 注意侧边黄色要求</p>
<p><img src="https://draapho.github.io/images/1906/5_2.png" alt="步骤五2"></p>
<p>方法: <code>RU2 R’U’ RU’R’</code></p>
<h2 id="其它情况"><a href="#其它情况" class="headerlink" title="其它情况"></a>其它情况</h2><p>起点: 顶部以下图形, 多次使用方法一或方法二, 即可转变为情况一或情况二</p>
<p><img src="https://draapho.github.io/images/1906/5_3.png" alt="步骤五3"></p>
<p>方法: <code>R’U2 RU R’UR</code> 或 <code>RU2 R’U’ RU’R’</code></p>
<h2 id="最终目标"><a href="#最终目标" class="headerlink" title="最终目标"></a>最终目标</h2><p><img src="https://draapho.github.io/images/1906/5_4.png" alt="步骤五4"></p>
<h1 id="六-顶角归位"><a href="#六-顶角归位" class="headerlink" title="六:顶角归位"></a>六:顶角归位</h1><p>起点: 左侧图形, 左上同前色; 前面图形, 左上异色, 左中最好同色.</p>
<p><img src="https://draapho.github.io/images/1906/6_1.png" alt="步骤六1"></p>
<p>方法: <code>LF’LB2 L’FLB2 L2</code></p>
<p><img src="https://draapho.github.io/images/1906/6_2.png" alt="步骤六2"></p>
<h1 id="七-顶棱归位"><a href="#七-顶棱归位" class="headerlink" title="七:顶棱归位"></a>七:顶棱归位</h1><p>起点: 背面同色.<br>方法: <code>RU’ RURU RU’ R’U’R2</code> 顶层的三个中棱顺时针旋转, 重复到三色归位.</p>
<p><img src="https://draapho.github.io/images/1906/7_1.png" alt="步骤七"></p>
<h1 id="速记符"><a href="#速记符" class="headerlink" title="速记符"></a>速记符</h1><p><img src="https://draapho.github.io/images/1906/0_1.png" alt="手法"></p>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>你将不会成为一个伟大的投资人</title>
    <url>/2019/06/25/1907-investor/</url>
    <content><![CDATA[<p><em><strong>转载自 <a href="https://zhuanlan.zhihu.com/p/22051177">马克·塞勒尔：阻碍你成为伟大投资者的七个先天因素</a></strong></em></p>
<hr>
<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2019/03/26/1902-trading-rule/">交易市场思考</a></li>
<li><a href="https://draapho.github.io/2019/04/26/1903-wave-principle/">波浪理论简述</a></li>
<li><a href="https://draapho.github.io/2019/06/25/1907-investor/">你将不会成为一个伟大的投资人</a></li>
<li><a href="https://draapho.github.io/2020/02/09/2001-exploration/">交易市场阶段性探索心得</a></li>
<li><a href="https://draapho.github.io/2020/08/06/2005-wave-mnemonic/">波浪理论口诀</a></li>
<li><a href="https://draapho.github.io/2020/08/07/2006-wave-thinking/">波浪理论感悟</a></li>
<li><a href="https://draapho.github.io/2021/02/03/2102-share-skill/">交易市场思路</a></li>
</ul>
<h1 id="你将不会成为一个伟大的投资人"><a href="#你将不会成为一个伟大的投资人" class="headerlink" title="你将不会成为一个伟大的投资人"></a>你将不会成为一个伟大的投资人</h1><p>我知道这里（哈佛大学）的每一个人都有超越常人的智力，并且是经过艰苦的努力才达到今天的水平。</p>
<p>不过，你们至少应该记住一件事：<strong>你们几乎已经没有机会成为一个伟大的投资人。</strong>这已经考虑到你们都是高智商且工作努力的人，并且很快就能从这个国家最顶级的商学院之一拿到MBA学位的事实。</p>
<p>其原因是，你的智商是多少、看过多少书报杂志、拥有或者在今后的职业中将拥有多少经验，都不起作用。很多人都有这些素质，但几乎没有人在整个职业生涯中使复合回报率达到20%或25%。</p>
<p>一个人能学会如何成为一般级别之上的投资人？</p>
<p>如果你们聪明、勤奋又受过教育，就能做得足够好，在投资界保住一份高薪的好工作。不用成为伟大投资人，你们也可以赚取百万美元。因此无须为我今天说的话而沮丧，即使不是巴菲特，你们也将会有一份真正成功且收入不菲的职业。</p>
<p><strong>我不确定「能够赚取20%的复合回报率」是天生的还是后天习得的能力，但如果你到青少年时期还没有这种特质，那么你就再不会有了。</strong>你读完每一本关于投资的书不会，多年的经验也不会。那些只是你超过其他投资人的必要条件，因为它们都能被竞争对手复制。</p>
<p>作个类比，想想企业界的各种竞争策略吧。你们或许会研习迈克尔·波特的文章和书籍，现在，作为公司的CEO，什么样的优势才能使你们免受残酷的竞争？</p>
<h1 id="建立自己的-“护城河”"><a href="#建立自己的-“护城河”" class="headerlink" title="建立自己的 “护城河”"></a>建立自己的 “护城河”</h1><p>第一、建立巴菲特所说的「经济护城河」(economic moat)？</p>
<p>如果技术是你唯一的优势，那么它并不是建立「护城河」的源头，虽然它是可以、但它最终还是会被复制的。这种情况下，你最好的希望是被收购或者上市，在投资人认识到你并没有可持续性优势之前卖掉你的所有股份。</p>
<p>科技所给你带来的优势是非常有限的。还有比如一个好的管理团队、一场鼓动人心的广告行动，或是一股高热度的流行趋势。这些东西制造的优势都是暂时的，因为它们与时俱变，而且能被竞争者复制。</p>
<p><strong>经济护城河是一种结构性（structural）的优势，即如果你的竞争者知道你的秘密却不能复制，那就是就是一条「护城河」，一种结构性的优势。</strong></p>
<p>在我看来，实际只有四种难以复制且能持久的「经济护城河」。</p>
<ul>
<li>第一种是规模经济，沃尔玛、宝洁、家得宝就是例子；</li>
<li>第二种资源是网络效应，如eBay、万事达或维萨；</li>
<li>第三种是知识产权，比如专利、商标、政府许可或者客户忠诚度，迪斯尼和耐克即是典范；</li>
<li>第四种是高昂的用户转移成本，微软就受益于此，用户转向其他产品的成本实在高昂；</li>
</ul>
<p>就像公司要么建立一条「护城河」，要么就忍受平庸，投资人也需要一些超越竞争者的优势，否则他就沦为平庸。</p>
<h1 id="“护城河”-由何而来？"><a href="#“护城河”-由何而来？" class="headerlink" title="“护城河” 由何而来？"></a>“护城河” 由何而来？</h1><p><strong>首先，大量阅读书籍、杂志、报纸并不是建立「护城河」的有效方式。</strong></p>
<p>投资界的人都有大量阅读的习惯，但是我不认为投资表现与阅读数量之间呈正相关关系，你的知识积累达到某个关键点后，再多的阅读就会呈收益递减效应。事实上，读太多新闻反而会伤害你的投资表现，因为那说明你开始相信记者们为了报纸销量而倾泻的所有废话。</p>
<p>另外，任凭你是顶尖学校的MBA，或者拥有注册金融分析师资格、博士学位、注册会计师证书等等数十种可能得到的学位和证书，都不可能让你成为伟大的投资人。只是让你更容易获得进入这场赌局的邀请而已。</p>
<p><strong>经验是另一件被高估的事情。</strong>虽然经验的确很重要，但它并不能帮你获得竞争优势，它仅仅是另一张必需的入场券，一定程度的经验是玩这个游戏所必需的，但到了一定时候，它就不再有更多帮助。它不是投资人的「护城河」。查理·芒格说过，你们可以辨别出谁能正确地「理解」，但有时这个人可能是一个几乎没有投资经验的人。</p>
<h1 id="伟大的投资人该必备的七个特质"><a href="#伟大的投资人该必备的七个特质" class="headerlink" title="伟大的投资人该必备的七个特质"></a>伟大的投资人该必备的七个特质</h1><p>就像一个公司或者一个行业，投资人的「护城河」也应该是结构性的。它们与一些心理学因素有关，而心理因素是深植在你的脑子里的，是你的一部分，即使你阅读大量相关书籍也无法改变。</p>
<p><strong>我认为，至少有七个特质是伟大投资人的共同特征，是真正的优势资源，而且是你一旦成年就再无法获得的。</strong>事实上，其中几个特质甚至丝毫没有学习的可能，你必须天生具备，若无就此生难寻。</p>
<p><strong>第一个特质是，在他人恐慌时果断买入股票、而在他人盲目乐观时卖掉股票的能力。</strong>每个人都认为自己能做到这一点，但是当1987年10月19日这天到来的时候（历史上著名的「黑色星期一」），市场彻底崩溃，几乎没人有胆量再买入股票。</p>
<p>而在1999年（次年即是纳斯达克大崩盘），市场几乎每天都在上扬，你不会允许自己卖掉股票，因为你担心会落后于他人。绝大多数管理财富的人都有MBA学位和高智商，读过很多书。</p>
<p>到1999年底，这些人也都确信股票被估值过高，但他们不能允许自己把钱撤离赌台，其原因正是巴菲特所说的「制度性强制力」(institutional imperative)。</p>
<p><strong>第二个特质是，伟大投资人是那种极度着迷于此游戏，并有极强获胜欲的人。</strong>他们不只是享受投资的乐趣——投资就是他们的生命。</p>
<p>他们清晨醒来时，即使还在半梦半醒之间，想到的第一件事情就是他们研究过的股票，或者是他们考虑要卖掉的股票，又或者是他们的投资组合将面临的最大风险是什么以及如何规避它。他们通常在个人生活上会陷入困境，尽管他们也许真的喜欢其他人，也没有太多的时间与对方交流。</p>
<p><strong>第三个特质是，从过去所犯错误中吸取教训的强烈意愿。</strong>这点对于人们来说是难以做到的，让伟大投资人脱颖而出的正是这种从自己过去错误中学习以避免重犯的强烈渴望。大多数人都会忽略他们曾做过的愚蠢决定，继续向前冲。</p>
<p>我想用来形容他们的词就是「压抑」（repression）。但是如果你忽略往日的错误而不是全面分析它，毫无疑问你在将来的职业生涯中还会犯相似的错。事实上，即便你确实去分析了，重复犯错也是很难避免的。</p>
<p><strong>第四个特质是，基于常识的与生俱来的风险嗅觉。</strong>大部分人都知道美国长期资本管理公司（1990年代中期的国际四大对冲基金之一，1998年因为俄罗斯金融风暴而濒临破产）的故事，一个由六七十位博士组成的团队，拥有最精妙的风险分析模型，却没能发现事后看来显见的问题：他们承担了过高的风险。</p>
<p>他们从不停下来问自己一句：“嗨，虽然电脑认为这样可行，但在现实生活中是否真的行得通呢？”这种能力在人类中的常见度也许并不像你认为的那样高。</p>
<p>我相信最优秀的风险控制系统就是常识，但是人们却仍会习惯听从电脑的意见，我看到这个错误在投资界一再上演。</p>
<p><strong>第五个特质是，伟大的投资人都对于他们自己的想法怀有绝对的信心，即使是在面对批评的时候。</strong>巴菲特坚持不投身疯狂的网络热潮，尽管人们公开批评他忽略科技股。</p>
<p>当其他人都放弃了价值投资的时候，巴菲特依然岿然不动。《巴伦周刊》为此把他做成了封面人物，标题是「沃伦，你哪儿出错了？」当然，事后这进一步证明了巴菲特的智慧。</p>
<p>就个人而言，我很惊讶于大多数投资人对他们所买股票的信心之微弱。根据凯利公式，投资组合中的20%可以放在一支股票上，但很多投资人只放2%。从数学上来说，运用凯利公式，把2%的投资放在一支股票上，相当于赌它只有51%的上涨可能性，49%的可能性是下跌。</p>
<p>为何要浪费时间去打这个赌呢？这帮人拿着100万美元的年薪，只是去寻找哪些股票有51%的上涨可能性？简直是有病。</p>
<p><strong>第六个特质是，左右脑都很好用，而不仅仅是开动左脑（左脑擅长数学和组织）。</strong>一些非常聪明的人只用一半大脑思考，这样足以让你在世上立足，可是如果要成为一个和主流人群思考方式不同的富有创新精神的企业投资人，这还远远不够。</p>
<p>另一方面，如果你是右脑占主导的人，你很可能讨厌数学，通常就无法进入金融界了。所以金融人士很可能左脑极其发达，我认为这是个问题。我相信一个伟大投资人的两边大脑都发挥作用。</p>
<p><strong>最后最重要的，同时也是最少见的一项特质：在投资过程中，大起大落之中却丝毫不改投资思路的能力。</strong>这对于大多数人而言几乎是不可能做到的。当股票开始下跌，人们很难坚持承受损失而不抛出股票。市场整体下降时，人们很难决定买进更多股票以使成本摊薄，甚至很难决定将钱再投入股票中。</p>
<p>很少有投资人能应对高回报率所必须经历的短期波动。他们将短期波动等同于风险。这是极不理性的。风险意味着你若押错了宝，就得赔钱。而相对短时期内的上下波动并不等于损失，因此也不是风险，除非你在市场跌到谷底时陷入恐慌，被损失吓得大乱阵脚。</p>
<p><strong>我必须申明，人们一旦步入成年期就无法再学到上述特质了。</strong></p>
<p>这个时候，你在日后成为卓越投资人的潜力已经被决定了。这种潜力经过锻炼可以获得，但是无法从头建立，因为这与你脑组织的结构以及孩童时期的经历密切相关。</p>
<p>金融教育、阅读以及投资经验很重要，但只能让你够资格进入这个游戏并玩下去。那些都是可以被任何人复制的东西，而上述7个特质却不可能。</p>
<hr>
<p><em><strong>转载自 <a href="https://zhuanlan.zhihu.com/p/22051177">马克·塞勒尔：阻碍你成为伟大投资者的七个先天因素</a></strong></em></p>
]]></content>
      <categories>
        <category>market</category>
      </categories>
      <tags>
        <tag>market</tag>
      </tags>
  </entry>
  <entry>
    <title>交易市场阶段性探索心得</title>
    <url>/2020/02/09/2001-exploration/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2019/03/26/1902-trading-rule/">交易市场思考</a></li>
<li><a href="https://draapho.github.io/2019/04/26/1903-wave-principle/">波浪理论简述</a></li>
<li><a href="https://draapho.github.io/2019/06/25/1907-investor/">你将不会成为一个伟大的投资人</a></li>
<li><a href="https://draapho.github.io/2020/02/09/2001-exploration/">交易市场阶段性探索心得</a></li>
<li><a href="https://draapho.github.io/2020/08/06/2005-wave-mnemonic/">波浪理论口诀</a></li>
<li><a href="https://draapho.github.io/2020/08/07/2006-wave-thinking/">波浪理论感悟</a></li>
<li><a href="https://draapho.github.io/2021/02/03/2102-share-skill/">交易市场思路</a></li>
</ul>
<h1 id="探索心得"><a href="#探索心得" class="headerlink" title="探索心得"></a>探索心得</h1><p>在 <a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a> 一文中提过自己的兴趣和未来的目标. 其中包含:</p>
<ul>
<li>于资本汇聚之地得自由</li>
<li>人文学科和生命本源数学化, 理论化.</li>
</ul>
<p>如果目标只是财务自由, 根据百年一人的建议:</p>
<ul>
<li>重点研究跟随和确认系统即可, 无须费心研究预测!</li>
<li>横向强弱, 解决选股问题.</li>
<li>均线系统, 解决趋势跟随和转折点问题. (均线比例, 均线交叉, 均线拐点, 均线平移)</li>
<li>波动率, 解决转折点问题.</li>
</ul>
<p>选择股市的原因很简单: 获取数据快捷简单, 数据精度高.<br>可惜的是, 交易市场中, 任何研究出数学化成果的人, 都不可能公布出来.<br>因为公开即失效, 到时交易市场的规律性就需要在更高的维度上进行探索.</p>
<p>交易市场阶段性探索心得</p>
<ul>
<li><p>百年一人, 用数理方法解决了”何时”的问题!</p>
<ul>
<li>百年一人的预测喜欢给出唯一性, 绝对性.</li>
<li>这是他说话方式的缺点. 容易让初学者认为股市是可以精确预测的.</li>
</ul>
</li>
<li><p>江恩和无锡乐水, 用数理方法解决了”何价”的问题; “何时”是基于观察而来的;</p>
</li>
<li><p>结论: 事实上某些情况下, 可以用数学方法解决”何时何价”的预测问题!</p>
<ul>
<li>人是有限选择权, 因此股市的走法并不唯一. 路径可选, 但起点和终点却不可选.</li>
<li>以盈利为目的的交易系统, 必须当成概率上的利弊问题而非判断上对错问题.</li>
</ul>
</li>
<li><p>由于初始态的敏感问题, “正确的起点”是”何价”的关键!</p>
</li>
<li><p>交易市场的如下特性都是有数理基础的, 必须能反映到数理模型之中:</p>
<ul>
<li>能量守恒: 平衡和循环.</li>
<li>上涨是熵减过程, 耗能. 下跌是熵增过程.</li>
<li>最小作用量原理: 已有结构下, 用最小的资金量, 造成最大的价格波动 或 用最大的资金, 造成最小的价格波动.</li>
<li>自激和衰减 或 激发态和基态</li>
<li>上面四条是最核心的内容. 下面都是上述的表象:</li>
<li>斐波那契数列.</li>
<li>黄金比例.</li>
<li>等角螺旋.</li>
<li>等比数列.</li>
<li>横坐标的平方数.</li>
<li>各种各样的对称性.</li>
<li>均线系统.</li>
<li>波动率.</li>
<li>波浪理论.</li>
<li>波动的周期性表现.</li>
<li>波动法则的数学方程.</li>
</ul>
</li>
</ul>
<p>如果要研究交易市场的预测问题, 可重点关注下面几位大师:</p>
<ul>
<li>江恩.<ul>
<li>其信仰来自于&lt;圣经&gt;.</li>
<li>江恩波动法则, 是基于数理基础的. 主要参考借鉴的是天文学知识(可参考开普勒和牛顿)</li>
<li>江恩的时间因子是观察出来的, 江恩本人将其归因于星相学.</li>
</ul>
</li>
<li>艾略特.<ul>
<li>艾略特波浪理论.</li>
<li>对股市发展阶段做了非常好的划分.</li>
<li>缺乏级别和时间, 因而很难定量, 导致千人千浪并活力满满!</li>
</ul>
</li>
<li><a href="https://www.weibo.com/bainianyiren">百年一人</a><ul>
<li>其信仰来自于自信和刻苦. 并不断的自我突破. 因为人还活着, 所以排在第三.</li>
<li>全息未来线: 用数理方程解决时间的问题!</li>
<li>积极致力于”技术分析派”的推广运动, 不求名不求利, 内心极其纯粹的一个人, 哲学思辨层次非常高.</li>
<li>提出了结构第一性, 而非时间第一性! 并举了河水和河床的关系. 非常正确的判断!</li>
<li>我的判断: 更进一步, 观察是第一性的.<ul>
<li>观察和分析导致博弈. (信息论)</li>
<li>重复博弈导致稳定的相互关系, 也就是结构(博弈论)</li>
<li>稳定的结构产生重复性, 重复性让观察者产生时间概念, 因而, 有时间就必有周期/轮回!</li>
<li>解释了混沌理论中, 对初始态的异常敏感问题: 因为初始博弈结果的不确定性! 而不同的初始博弈结果会导致不同的结构, 最终导致不同的周期/轮回.</li>
<li>解释了光速的绝对性和时空相对性的问题. 人类依赖于电磁波观察世界, 因而突破不了电磁波传递信息的速度上限.</li>
<li>解释了量子理论中的种种”怪异”现象, 因为在用粒子观察粒子, 在观察的过程中, 会产生不可忽略的交互作用, 从而影响被观察粒子的原有行为.</li>
</ul>
</li>
</ul>
</li>
<li>铸剑先生.<ul>
<li>高人一枚, 教授过百年一人.</li>
<li>基准尺概念, 四波理论, 控盘均线, 调整的时间周期序列.</li>
<li>对波动法则有深入研究.</li>
</ul>
</li>
<li></li>
<li><a href="https://www.weibo.com/u/1900929194">无锡乐水</a><ul>
<li>其信仰来自于&lt;江恩&gt;.</li>
<li>形数法则, 高概率完全对应江恩的波动法则</li>
<li>灵光周期循环律, 看其取名便可知并不是基于数理基础获得的.</li>
</ul>
</li>
<li><a href="https://www.weibo.com/u/1674016325">猫的时光</a><ul>
<li>会给出部分分析过程的交易高手, 用来学习技术分析很有帮助.</li>
</ul>
</li>
<li>缠师李彪.<ul>
<li>三买, 三卖点, 实际都是未来函数.</li>
<li>网络上号称”狂缠”, 只是把握了网络特性, 为扩大影响, 宣传需要而已.</li>
<li>缠师的思想境界非常高, 尤其是对社会学的判断和本位问题的描述!</li>
<li>已他的资源和能力, 属于操盘手级别而非参与者级别. (有限选择权, 譬如把下跌拉成强横.)</li>
</ul>
</li>
<li>自己.<ul>
<li>必须解决信仰问题, 就是信不信万物同源. 放下一切先入为主的概念, 承认无知和一切可能性(如鬼神, 正确的回答是不知道, 而非不存在!).</li>
<li>相信上述大师的人品: 说的全部是真话! 只是, 真话说一半, 喜欢用比喻.</li>
<li>克服人性的贪嗔, 做市场的跟随者而非主导者.</li>
<li>潜意识里有追求解决预测问题的动力. 如果潜意识是为了赚钱, 重点研究百年一人说的确认问题就够了.</li>
</ul>
</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>market</category>
      </categories>
      <tags>
        <tag>market</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 软件系列-新装系统</title>
    <url>/2020/05/02/2004-WinSoft-new/</url>
    <content><![CDATA[<h1 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h1><ul>
<li>硬件检查: <a href="http://www.kbtool.cn/">卡硬工具箱</a>  (<em><strong>绿色软件</strong></em>)<ul>
<li>综合检测</li>
<li>显示器工具</li>
</ul>
</li>
<li>系统分区: <a href="https://www.disktool.cn/">分区助手</a> (<em><strong>绿色软件</strong></em>)<ul>
<li>设置-&gt;搜索Bitlocker-&gt;关闭<code>Bitlocker</code></li>
<li>软件盘C, SOFT, 120G-250G</li>
<li>数据盘D, DATA</li>
</ul>
</li>
<li>中文以及解决中文乱码<ul>
<li>设置-&gt;语言/Language-&gt;中文</li>
<li>设置-&gt;区域-&gt;国家或地区-&gt;中国</li>
<li>设置-&gt;区域-&gt;区域格式-&gt;中文.</li>
<li>设置-&gt;区域-&gt;其他日期,时间和区域设置-&gt;弹出传统的控制面板界面</li>
<li>更改日期,时间或数字格式-&gt;管理标签-&gt;更改系统区域设置…-&gt;选中国</li>
</ul>
</li>
<li>性能优化<ul>
<li>蓝牙鼠标<ul>
<li>右键开始菜单-&gt;设备管理器-&gt;蓝牙-&gt;无线Bluetooth-&gt;右键属性-&gt;电源选项-&gt;禁止节电!</li>
</ul>
</li>
<li>设置-&gt;电脑信息-&gt;关于页面<ul>
<li>重命名这台电脑-&gt;更改电脑名字.</li>
<li>系统信息-&gt;远程设置-&gt;关闭所有的远程选项.</li>
<li>系统信息-&gt;高级系统设置-&gt;设置性能, 设置启动和故障恢复.</li>
</ul>
</li>
<li>设置-&gt;活动-&gt;活动历史记录<ul>
<li>关闭活动历史记录, 关闭显示账户活动</li>
<li>隐私相关的设置, 全部过一遍</li>
</ul>
</li>
<li>设置-&gt;数据使用量-&gt;后台数据-&gt;开启 限制后台执行的操作</li>
<li>桌面右键-&gt;个性化-&gt;开始 优化一便. 任务栏 优化一便</li>
</ul>
</li>
<li>更改默认路径<ul>
<li>设置-&gt;存储-&gt;更改新内容的保存位置<ul>
<li>应用, 文档, 离线地图, 不修改</li>
<li>音乐, 照片, 视频, 电影, 保存到D盘</li>
</ul>
</li>
<li>我的电脑-&gt;桌面等7个文件-&gt;分别右键属性-&gt;位置<ul>
<li>3D对象,文档-&gt;不修改</li>
<li>视频,图片,音乐,下载,桌面-&gt;移动到D盘</li>
<li>路径格式举例: <code>D:\用户名\桌面</code></li>
</ul>
</li>
</ul>
</li>
<li>快速访问:<ul>
<li>保留最常用的: 下载, 云盘, 用户内容, 生活, 学习, 工作, 家庭, 备份等等</li>
</ul>
</li>
<li>共享 Downloads 文件夹<ul>
<li>设置-&gt;启用或关闭 windows 功能-&gt;勾选 <code>SMB 1.0/CIFS...</code>. 顺手开启NFS服务</li>
<li>设置-&gt;高级共享设置-&gt;启用网络发现, 启用文件和打印机共享. 建议启用密码保护</li>
<li>右键 Downloads 文件夹-&gt;属性-&gt;共享-&gt;共享…-&gt;添加<code>Everyone</code>-&gt;权限改为读取写入.</li>
<li>用无线网络时, 设置-&gt;查看网络连接-&gt;右键网络适配器-&gt;勾选 Microsoft 网络的文件和打印机共享</li>
</ul>
</li>
<li>杀毒软件 ESET<ul>
<li>用国内注册码的话, 区域要改为中国.</li>
<li>依旧不行的话, 用穿梭或快帆翻墙到国内, 变为国内的IP地址.</li>
</ul>
</li>
</ul>
<h1 id="效率软件"><a href="#效率软件" class="headerlink" title="效率软件"></a>效率软件</h1><ul>
<li>quicklook (<em><strong>Microsoft Store</strong></em>)</li>
<li>Keypass. (<em><strong>绿色软件</strong></em>) 密码管理软件</li>
<li>BANDIZIP6.27 (后续版本有广告). 解压软件<ul>
<li>7zip 备选</li>
</ul>
</li>
<li>quicker. 鼠标工具. 使用鼠标的常用操作.<ul>
<li>快捷键 <code>鼠标中键</code> 和 <code>鼠标画圈</code></li>
<li>免费版只支持2台电脑. 可用多账号. 账号间用本地存储同步应用数据</li>
<li>quicker-&gt;…-&gt;工具-&gt;应用数据文件夹. <code>data</code> <code>states</code> 内容</li>
</ul>
</li>
<li>uTool. 键盘工具. 使用关键词的常用和低频操作.<ul>
<li>设置<ul>
<li>快捷键 <code>alt+space</code>. 支持拼音首字母搜索.</li>
<li>插件分离, 插件固定: <code>Ctrl+D</code> 改为 <code>Alt+V</code>.</li>
<li>关闭 自动黏贴. 恢复输入框: 1分钟</li>
<li>启用 搜索本地应用程序</li>
<li>自定义快捷方式目录 <code>.\Green\setting\uTools\shortcuts</code><ul>
<li>常用目录和软件助记快捷方式</li>
</ul>
</li>
</ul>
</li>
<li>PDF转换器</li>
<li>网页快开. 设置网页关键字, 以图搜图, 聚合搜索</li>
<li>我的上网IP</li>
<li>批量重命名</li>
<li>Code计算器. 计算器功能</li>
<li>程序员手册</li>
<li>正则编辑器</li>
<li>编码小助手. 时间转换, UUID, 编码</li>
<li>JSON编辑器</li>
<li>二维码小助手</li>
<li>颜色助手. 取色, 选色.</li>
<li>剪切板. 剪切板历史</li>
<li>聚合翻译</li>
<li>本地搜索. 安装 everything</li>
<li>沙拉查词. 翻译. 导入设置</li>
</ul>
</li>
<li><del>Listary 快速搜索: 配置文件 <code>Preferences.json</code></del><ul>
<li>取消 所有关键字</li>
<li>精简 动作</li>
<li>快捷键, 下一项目: <code>Ctrl+J</code></li>
<li>快捷键, 前一项目: <code>Ctrl+K</code></li>
</ul>
</li>
<li>微软输入法<ul>
<li>设置-&gt;高级键盘设置-&gt;反选 使用桌面语言栏(如果可用)</li>
</ul>
</li>
</ul>
<h1 id="文本办公"><a href="#文本办公" class="headerlink" title="文本办公"></a>文本办公</h1><ul>
<li><a href="https://www.office.com/">MicroSoft Office 365</a><ul>
<li>OneDrive 设置:<ul>
<li>修改路径: 退出软件, 移动OneDrive文件夹到D盘, 重新启动即可重设路径.</li>
<li>可使能 <code>让我使用OneDrive获取我在此电脑上的任何文件</code>, 只能下载单个文件</li>
<li>备份任意文件 (默认只有Desktop, Documents, Pictures):<ul>
<li>管理员权限打开cmd: <code>mklink /d &quot;C:\Users\[Username]\OneDrive\Test&quot; &quot;E:\Test&quot;</code></li>
<li>第一个路径为目标路径, 必须是OneDrive本地文件夹. 第二个路径为需要同步的文件夹.</li>
</ul>
</li>
</ul>
</li>
<li>Excel 插件:<ul>
<li>方方格子.</li>
</ul>
</li>
<li>PowerPoint 插件:<ul>
<li><del>iSlide.  (需要登录, 模板等需要收费)</del></li>
</ul>
</li>
<li>OneNote 插件<ul>
<li><del><a href="https://github.com/elvirbrk/NoteHighlight2016/releases">NoteHighlight2016</a></del>, 代码高亮. 不支持OneNote2010.</li>
</ul>
</li>
</ul>
</li>
<li>Dynalist. 备忘+笔记, 全平台云存储. 支持Markdown. 需要图床才能加载图片.<ul>
<li>类似的软件: WorkFlow, 幕布</li>
</ul>
</li>
<li>typora. markdown文本编辑器</li>
<li>notepad++ (<em><strong>绿色软件</strong></em>)<ul>
<li>点击bat文件注册右键即可. 已完成<a href="https://draapho.github.io/2016/09/30/1603-WinSoft-editor/">配置</a>.</li>
</ul>
</li>
<li>Amazon kindle. 读书软件</li>
<li>越飞读书 Fly Reader (<em><strong>Microsoft Store</strong></em>). 读书软件, 多格式支持<ul>
<li>替代 <del>iReader (<em><strong>Microsoft Store</strong></em>). txt读书软件</del></li>
</ul>
</li>
<li>PDF Reader-Xodo (<em><strong>Microsoft Store</strong></em>)</li>
<li>SumatraPDF (<em><strong>绿色软件</strong></em>). 小巧, 快速, 绿色, 但功能有限.</li>
<li>GoldenDict (<em><strong>绿色软件</strong></em>). 离线翻译软件.</li>
<li>冰点文库下载器 (<em><strong>绿色软件</strong></em>). 免积分下载百度文库、道客巴巴、豆丁网上的资料</li>
</ul>
<h1 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h1><ul>
<li>Audacity (<em><strong>绿色软件</strong></em>). 音频编辑</li>
<li>QQ音乐 (<em><strong>Microsoft Store</strong></em> 设置为中国区才有)</li>
<li>Snipaste (<em><strong>绿色软件</strong></em>). 截图</li>
<li>ShareX (<em><strong>Microsoft Store</strong></em>) 滚动捕捉, 屏幕录制, OCR.</li>
<li>Lightroom CC</li>
<li>Photoshop CC</li>
<li>HONEYVIEW. 图片查看器</li>
<li>PotPlayer. 视频播放器. 设置里关闭自动更新!</li>
<li>UWP爱奇艺  (<em><strong>Microsoft Store</strong></em>)</li>
</ul>
<h1 id="社交网络"><a href="#社交网络" class="headerlink" title="社交网络"></a>社交网络</h1><ul>
<li>Chrome. 网页浏览器<ul>
<li>插件可以自动同步, 但需要分别设置!</li>
<li><code>chrome://extensions/</code> 进行安全性设置<ul>
<li>检查权限, 避免高风险应用, 它会要求访问计算机上所有的数据.</li>
<li>点击时. 低频使用的插件建议此选项, 增加安全性.</li>
<li>在特定网站上. 针对特定网站的高频插件, 建议选用此选项.</li>
<li>在所有网站上. 高频通用性插件, 选此选项. 此为Chrome默认选项.</li>
</ul>
</li>
<li><del>Clip to OneNote. 点击时启用</del>, 登录经常发生问题.</li>
<li><del>EagleGet Free Download. 点击时启用</del></li>
<li>Tampermonkey, 油猴. 脚本方式实现多种功能.<ul>
<li>尽量用Chrome插件代替脚本. 平时只打开常用的脚本. 低频使用的脚本保持关闭状态.</li>
<li>脚本网站: <a href="https://greasyfork.org/zh-CN">greasy fork</a>、<a href="https://openuserjs.org/">openuserJS</a></li>
<li>设置-&gt;通用-&gt;配置模式-&gt;初学者</li>
<li>设置-&gt;同步脚本-&gt;启用TESLA-&gt;浏览器同步.</li>
<li>这样即可跟随Chrome同步脚本, 但脚本配置不会自动同步!</li>
</ul>
</li>
<li>SuperCopy 超级复制. 使能某些顽固网页的复制黏贴. 点击时启用.</li>
<li>IE tab. 转为IE内核. 点击时启用</li>
<li>Infinity new tab pro. 自建导航网页, 管理插件. 点击时启用</li>
<li>Graphitabs. 多标签整理为思维导图模式</li>
<li>octotree. github扩展. 启用隐身模式</li>
<li>Imagus 图片预览, 设置为ctrl使能. 启用隐身模式</li>
<li>AdGuard 广告拦截器, 启用隐身模式</li>
</ul>
</li>
<li>eagleget. 下载软件.</li>
<li>Motrix. 下载软件</li>
<li>微信PC版. 可用于备份手机微信内容</li>
<li>QQ. 按需安装</li>
<li>穿梭或快帆, 翻墙到国内. 收费建议用穿梭.</li>
</ul>
<h1 id="系统软件"><a href="#系统软件" class="headerlink" title="系统软件"></a>系统软件</h1><ul>
<li>eset. 杀毒软件<ul>
<li>此为收费软件. 可选用如下两个免费方案之一代替</li>
<li>windows defender + Avira</li>
<li>windows defender + Malwarebytes</li>
</ul>
</li>
<li>Sandboxie 沙盘工具</li>
<li>FreeFileSync. 文件备份</li>
<li>CCleaner (<em><strong>绿色软件</strong></em>) 文件清理</li>
<li>rufus (<em><strong>绿色软件</strong></em>) 制作启动盘</li>
<li>UltraISO (<em><strong>绿色软件</strong></em>) ISO映像文件</li>
<li>卡硬工具箱 (<em><strong>绿色软件</strong></em>), 包含很多小工具如 Dism++</li>
<li>分区助手 (<em><strong>绿色软件</strong></em>)</li>
<li>轻松备份</li>
</ul>
<h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><ul>
<li>ConEmu (<em><strong>绿色软件</strong></em>)<ul>
<li>已完成<a href="https://draapho.github.io/2016/10/10/1609-WinSoft-terminal/">配置</a>, 相关目录需要加入 <code>环境变量...</code></li>
<li>潜在的替代软件 Windows Terminal (<em><strong>Microsoft Store</strong></em>).</li>
</ul>
</li>
<li>git<ul>
<li>p4vinst64, 只需安装 p4merge.</li>
<li>配置git见: <a href="https://draapho.github.io/2016/10/24/1614-CheatSheet-git/">Git 初始设置及常用命令</a></li>
</ul>
</li>
<li>Node.js<ul>
<li>配置blog见: <a href="https://draapho.github.io/2016/09/24/1601-InitBlog/">Windows下使用github和hexo建独立博客</a></li>
</ul>
</li>
<li><del>Ubuntu (<em><strong>Microsoft Store</strong></em>)</del><ul>
<li>若安装失败 管理员运行 Powershell <code>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</code></li>
<li>不确定稳定性和全功能.</li>
</ul>
</li>
</ul>
<h1 id="系统清理"><a href="#系统清理" class="headerlink" title="系统清理:"></a>系统清理:</h1><ul>
<li>卡硬工具箱-&gt;其他工具-&gt;DISM++ -&gt;依次优化</li>
<li>CCleaner-&gt;清理文件, 清理启动项</li>
<li>RightMenuMgr-&gt;清理右键菜单</li>
<li>管理员运行cmd-&gt;执行 <code>sfc /scannow</code>.  系统文件检查和修复</li>
<li>右键C盘-&gt;属性-&gt;磁盘清理-&gt;清理系统文件. 可安全释放系统盘空间.</li>
<li>轻松备份-&gt;备份C盘</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>波浪理论口诀</title>
    <url>/2020/08/06/2005-wave-mnemonic/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2019/03/26/1902-trading-rule/">交易市场思考</a></li>
<li><a href="https://draapho.github.io/2019/04/26/1903-wave-principle/">波浪理论简述</a></li>
<li><a href="https://draapho.github.io/2019/06/25/1907-investor/">你将不会成为一个伟大的投资人</a></li>
<li><a href="https://draapho.github.io/2020/02/09/2001-exploration/">交易市场阶段性探索心得</a></li>
<li><a href="https://draapho.github.io/2020/08/06/2005-wave-mnemonic/">波浪理论口诀</a></li>
<li><a href="https://draapho.github.io/2020/08/07/2006-wave-thinking/">波浪理论感悟</a></li>
<li><a href="https://draapho.github.io/2021/02/03/2102-share-skill/">交易市场思路</a></li>
</ul>
<p><em><strong>转载, 作者不详</strong></em></p>
<h1 id="口诀及图表"><a href="#口诀及图表" class="headerlink" title="口诀及图表"></a>口诀及图表</h1><h2 id="口诀一-驱动浪"><a href="#口诀一-驱动浪" class="headerlink" title="口诀一, 驱动浪"></a>口诀一, 驱动浪</h2><p>一三五浪可加长，每段细分五小浪；<br>另有等长九段波，顶底不连通道长；<br>三三相隔十五段，五三交错亦寻常；<br>波起浪伏有形状，常见上斜与扩张；</p>
<h2 id="口诀二-调整浪特性"><a href="#口诀二-调整浪特性" class="headerlink" title="口诀二, 调整浪特性"></a>口诀二, 调整浪特性</h2><p>喇叭斜三现一浪，二浪之后走势强；<br>五浪若是此模样，分批减磅远危墙；<br>A浪止住回头看，A3A5不一样；<br>三波之字双回撤，五波右肩做b浪；<br>回撤二次分三五，三波弱来五波强；<br>B浪右肩a-b-c，轻仓快手捕长阳；</p>
<h2 id="口诀三-之字和平坦"><a href="#口诀三-之字和平坦" class="headerlink" title="口诀三, 之字和平坦"></a>口诀三, 之字和平坦</h2><p>调整浪型有三种，之字平坦三角型；<br>之字三段ABC，5-3-5浪要记清；<br>特殊情况双之字，七波两个之字型；<br>平坦都是三三五，略与之字有不同；<br>九种变形不复杂，区别尽在BC中；</p>
<h2 id="口诀四-三角型调整浪"><a href="#口诀四-三角型调整浪" class="headerlink" title="口诀四, 三角型调整浪"></a>口诀四, 三角型调整浪</h2><p>无论直三与斜三，浪型间隔皆3-3；<br>不管扩张与收缩，万变不离是五波；<br>三角整理四形态，怎么进去，怎么出来；</p>
<h2 id="口诀五-复合型调整浪"><a href="#口诀五-复合型调整浪" class="headerlink" title="口诀五, 复合型调整浪"></a>口诀五, 复合型调整浪</h2><p>双三特例七段波，两波调整来组合；<br>待到整固突破后，上下波澜皆壮阔；</p>
<h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><p>共横六竖7个格子图. 图一1标示第一格的小图, 依此类推.<br>以下每张小的浪型图上都有一个字：“推”表示推动浪；“调”表示调整浪；“弹”表示反弹浪；<br><img src="https://draapho.github.io/images/2005/1.png" alt="四十二浪图"></p>
<h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="驱动浪之推动浪"><a href="#驱动浪之推动浪" class="headerlink" title="驱动浪之推动浪"></a>驱动浪之推动浪</h2><ul>
<li><strong>一三五浪可加长，每段细分五小浪</strong><ul>
<li>指的是推动浪的第一子浪，第三子浪和第五子浪都可能有扩展形态，</li>
<li>但有几个注意事项：<ul>
<li>第一，若一子浪加长，即一子浪扩展，则三子浪和五子浪等长；</li>
<li>第二，若三子浪加长，即三子浪扩展，则一子浪和五子浪等长；</li>
<li>第三，若五子浪加长，即五子浪扩展，则一子浪和三子浪等长；</li>
</ul>
</li>
<li>当市场要去完成一个波大的推动浪行情，市场有两种选择<ul>
<li>一种是1浪-3浪-5浪的长度差不多，这样够不成延长，</li>
<li>另一种就是1浪较小，市场选择了3浪或者5浪去出现一个被放大拉长的5波;</li>
<li>若3浪延长，5浪和1浪的长度会接近相等，</li>
<li>若1浪和3浪都没有出现延长，那市场只好选择在5浪去发飙了，而且飙起来一波接一波的没完，更重要的时间不会很短。(艾略特提到的半个月亮型态)</li>
</ul>
</li>
</ul>
</li>
<li><strong>另有等长九段波，顶底不连通道长</strong><ul>
<li>这段口诀的意思是说：<ul>
<li>除了前面讲到的三种推动浪形态以外（图一1, 图一2, 图一3），还有一种特殊的浪型（即图一4），</li>
</ul>
</li>
<li>这种浪型的特点如下：<ul>
<li>第一：该浪分为九个子浪；</li>
<li>第二：一子浪，三子浪，五子浪，七子浪，九子浪全部等长；</li>
<li>第三：四子浪底不破一子浪头，同样的，六底不破三头，八底不破五头，即所谓“顶底不连”。</li>
</ul>
</li>
</ul>
</li>
<li><strong>三三相隔十五段，五三交错亦寻常；</strong><ul>
<li>这句话的含义是指推动浪内部子浪的结构:<ul>
<li>五浪形式的推动浪，都有十五个子浪（请再看一遍图一1, 图一2和图一3，5+5+5=15），</li>
<li>而图四的九浪推动，则是二十七个子浪（图一4, 3*9=27）；</li>
</ul>
</li>
<li>三三相隔: 是指推动与推动之间总是由3波结构相隔的，</li>
<li>五三交错: 是指所有子浪都由三个细浪与五个细浪间隔组成</li>
<li>图一5、图一6，是失败的5浪，但第5浪自身必须具备5浪结构, 或终结倾斜三角型.</li>
</ul>
</li>
</ul>
<h2 id="驱动浪之倾斜三角型"><a href="#驱动浪之倾斜三角型" class="headerlink" title="驱动浪之倾斜三角型"></a>驱动浪之倾斜三角型</h2><ul>
<li><strong>波起浪伏有形状，常见上斜与扩张</strong><ul>
<li>上升楔形（即上斜三角型）和喇叭形（即扩张三角型）是两种很常见的浪型；</li>
</ul>
</li>
<li><strong>喇叭斜三现一浪，二浪之后走势强</strong><ul>
<li>如果喇叭（扩张三角型）或者上升楔形出现在第一浪中，那么后面会有一个很凶悍的二浪回调，</li>
<li>但经过二浪回调之后的三浪，走势将异常凌厉和凶猛！</li>
<li><strong>注意</strong>: 扩张三角型非常少见, 不要提前预判, 等K线自己走出来再确定.</li>
</ul>
</li>
<li><strong>五浪若是此模样，分批减磅远危墙</strong><ul>
<li>如果喇叭（扩张三角型）或者上升楔形出现在第五浪中，那么就要高度警惕了！！因为后面紧跟着的将是直线下跌！</li>
<li><strong>注意</strong>: 扩张三角型非常少见, 不要提前预判, 等K线自己走出来再确定.</li>
<li><strong>注意</strong>: 楔形越是被压缩, 越是容易在后面直接放量.</li>
</ul>
</li>
</ul>
<h2 id="调整浪ABC概述"><a href="#调整浪ABC概述" class="headerlink" title="调整浪ABC概述"></a>调整浪ABC概述</h2><ul>
<li><strong>A浪止住回头看，A3A5不一样</strong><ul>
<li>上升五浪退出之后，会有调整浪A出现（这个大家都知道的）；</li>
<li>这个调整浪A要分清它是由5个子浪组成还是由三个子浪组成，这一点很重要</li>
</ul>
</li>
<li><strong>三波之字双回撤，五波右肩做b浪</strong><ul>
<li>这句话的意思是指：<ul>
<li>如果调整浪A以三波段形式出现，<strong>且之前第五浪延长</strong>, 那么其后的走势将是“双回撤”；</li>
<li>如果调整浪A以五波段形式出现，其后的走势将是“B浪反弹”；</li>
</ul>
</li>
</ul>
</li>
<li><strong>回撤二次分三五，三波弱来五波强</strong><ul>
<li>所谓“双回撤”，是指的两个过程，<ul>
<li>A浪属于第一次回撤，其后的反弹是第二次回撤，并称“双回撤”。</li>
<li>只有三段组成的A浪才有’双回撤’</li>
<li>五浪组成的A浪后面一定是B浪反弹, 不会由第二次回撤</li>
</ul>
</li>
<li>三波弱来五波强是指<ul>
<li>A浪三波下跌, 属于较弱的下跌, 后续的B会相对强势, 会有’双回撤’</li>
<li>A浪五波下跌, 属于强势下跌, 后续的只有很弱的B反, 和强劲的C杀.</li>
</ul>
</li>
<li>两者的区别在于:<ul>
<li>‘双回撤’, <strong>可能</strong>会创新高（注意”可能“二字），有展开新升浪的可能（再次提醒注意”可能“二字）</li>
<li>而B浪反弹后面紧跟着的一定是凶狠的C浪下跌！</li>
</ul>
</li>
</ul>
</li>
<li><strong>B浪右肩a-b-c，轻仓快手捕长阳</strong><ul>
<li>这句话见图五6；讲的是B浪中的子浪abc.</li>
<li>如果A浪由5段组成，已经确定后面只是B浪反弹，不太可能创出新高，可以以较轻的仓位去抢一下反弹，</li>
<li>但切记要快进快出，这个时候的a阳线一般比较长，但持续时间短（因为主力要引诱人在高位接盘）.</li>
<li><strong>个人建议放弃这种机会</strong></li>
</ul>
</li>
</ul>
<h2 id="调整浪分类-之字和平坦"><a href="#调整浪分类-之字和平坦" class="headerlink" title="调整浪分类, 之字和平坦"></a>调整浪分类, 之字和平坦</h2><ul>
<li><strong>调整浪型有三种，之字平坦三角型</strong><ul>
<li>调整浪的浪型分为三种：<ul>
<li>之字型调整浪, 也称之为锯齿型调整浪</li>
<li>平坦型调整浪, 也称之为平台型调整浪</li>
<li>三角型调整浪</li>
</ul>
</li>
</ul>
</li>
<li><strong>之字三段ABC，5-3-5浪要记清</strong><ul>
<li>之字型的调整浪, 由ABC三段构成, 内部子浪结构为5-3-5. 即 A（5）+B（3）+C（5）</li>
<li>即A由5浪构成(只需要5浪, 可以不符合推动浪要求), B由3浪构成, C由5浪构成.</li>
<li>通常C浪跌的凌厉凶狠, 称为C杀.</li>
</ul>
</li>
<li><strong>特殊情况双之字，七波两个之字型</strong><ul>
<li>指的是一个“之字型”调整之后有一个“X”浪，然后再有一个“之字型”调整浪，</li>
<li>这种浪型的结构是 A（5）+B（3）+C（5）+  X  +A（5）+B（3）+C （5）</li>
<li>加在一起以七浪的复杂形式完成调整</li>
</ul>
</li>
<li><strong>平坦都是三三五，略与之字有不同</strong><ul>
<li>平坦型整理的浪型结构是A（3）+B（3）+C（5）</li>
</ul>
</li>
<li><strong>九种变形不复杂，区别尽在BC中</strong><ul>
<li>这一部分是个重点，请大家参考图二4, 图二5, 图二6; 图三4, 图三5, 图三6; 图四4, 图四5, 图四6;</li>
<li>平坦型整理的九种方式分别是：<ul>
<li>1：穿头破底型；</li>
<li>2：穿头平底型；</li>
<li>3：穿头藏底型；</li>
<li>4：平头破底型；</li>
<li>5：平头平底型；</li>
<li>6：平头藏底型；</li>
<li>7：缩头破底型；</li>
<li>8：缩头平底型；</li>
<li>9：缩头藏底型；</li>
</ul>
</li>
<li><strong>注意</strong>：穿头破底型(扩散)的平坦型整理后面的拉升力度最大；</li>
</ul>
</li>
</ul>
<h2 id="三角型调整浪"><a href="#三角型调整浪" class="headerlink" title="三角型调整浪"></a>三角型调整浪</h2><ul>
<li><strong>无论直三与斜三，浪型间隔皆3-3</strong><ul>
<li>三角型调整浪分为四种类型:<ul>
<li>直角三角形整理，</li>
<li>斜三角形整理，也称为上升三角型和下降三角型</li>
<li>收敛三角形整理，也称为对称三角型</li>
<li>扩张三角形整理，也成为反对称三角型</li>
</ul>
</li>
<li>三角型调整浪有一个共性:<ul>
<li>都由a,b,c,d,e五个子浪组成，每个子浪又由三个更低级别的小浪构成</li>
</ul>
</li>
</ul>
</li>
<li><strong>不管扩张与收缩，万变不离是五波</strong><ul>
<li>三角型调整浪有一个共性: 都由a,b,c,d,e五个子浪组成</li>
</ul>
</li>
<li><strong>三角整理四形态，怎么进去，怎么出来</strong><ul>
<li>此句是重点：“怎么进去，怎么出来”，它告诉了我们怎样判断三角形整理的突破方向。</li>
<li>一般来说，三角形在整理完毕之后，突破方向都和整理前的大趋势相同，即与五个子浪中的a子浪方向相反。</li>
</ul>
</li>
<li>三角型调整浪补充说明<ul>
<li>三角型通常出现在第4浪或B浪中，先于主要趋势的最后一轮动作(即先于五浪或C浪)。</li>
<li>因此，在上升趋势中，我们可以说三角型既可能是看涨的，也可能是看跌的。<ul>
<li>讲它看涨，是就它意味着趋势将恢复这层意义而言的。</li>
<li>而说它看跌，则是因为它表明在完成剩下的一个上涨浪之后，市场可能也就到顶了。</li>
</ul>
</li>
<li>三角型的顶点(两条聚拢的直线的交点)常常标志着最后第5浪的完成时间。</li>
</ul>
</li>
</ul>
<h2 id="复合型调整浪"><a href="#复合型调整浪" class="headerlink" title="复合型调整浪"></a>复合型调整浪</h2><ul>
<li><strong>双三特例七段波，两波调整来组合</strong><ul>
<li>所谓“双三”整理，指的是两个三浪整理用一个“X”浪相连接，共同构成一个七浪结构的调整浪</li>
<li>这两个三浪整理可以是之字体整理，也可以是平坦型整理或者三角型整理，可以任意组合</li>
</ul>
</li>
<li><strong>待到整固突破后，上下波澜皆壮阔</strong><ul>
<li>需要注意的是: 这个整理过程非常漫长，而一旦整理完毕，就会将整理之前的趋势进行放大</li>
<li>若整理之前是上升趋势，则整理后有暴涨</li>
<li>若下降趋势中的“双三”整理，则孕育着暴跌！</li>
<li>还有更特殊的“三三”整理，整理后的趋势会更加地强烈，大牛股或大熊股往往从这样的形态里面出现。</li>
</ul>
</li>
</ul>
<hr>
<p><em><strong>转载, 作者不详</strong></em></p>
<hr>
]]></content>
      <categories>
        <category>market</category>
      </categories>
      <tags>
        <tag>market</tag>
      </tags>
  </entry>
  <entry>
    <title>波浪理论感悟</title>
    <url>/2020/08/07/2006-wave-thinking/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2019/03/26/1902-trading-rule/">交易市场思考</a></li>
<li><a href="https://draapho.github.io/2019/04/26/1903-wave-principle/">波浪理论简述</a></li>
<li><a href="https://draapho.github.io/2019/06/25/1907-investor/">你将不会成为一个伟大的投资人</a></li>
<li><a href="https://draapho.github.io/2020/02/09/2001-exploration/">交易市场阶段性探索心得</a></li>
<li><a href="https://draapho.github.io/2020/08/06/2005-wave-mnemonic/">波浪理论口诀</a></li>
<li><a href="https://draapho.github.io/2020/08/07/2006-wave-thinking/">波浪理论感悟</a></li>
<li><a href="https://draapho.github.io/2021/02/03/2102-share-skill/">交易市场思路</a></li>
</ul>
<h1 id="千人千浪"><a href="#千人千浪" class="headerlink" title="千人千浪"></a>千人千浪</h1><ul>
<li>首先, 千人千浪是波浪理论广为传播, 经久不衰的优点.<ul>
<li>广为人知的高确定性理论会导致理论本身确定性大为下降.</li>
</ul>
</li>
<li>艾略特和普莱切特观察侧重点是有区别的.<ul>
<li>艾略特77岁逝世.</li>
<li>普莱切特75年成为美林证券市场分析部的技术分析人员. 78年认识波浪理论大师级人物: 阿尔弗雷德.约翰.弗罗斯特.</li>
<li>因此, 普莱切特对波浪理论的增减是”自说自话”的, 他学了艾略特五浪三浪的形, 但数浪的严谨程度是不及艾略特的!</li>
<li>普莱切特倾向于大级别的形似, 这种形似的模糊性真正导致了千人千浪.</li>
<li><strong>艾略特倾向于小级别的波浪形态对大级别进行波浪划分, 因此有不规则顶和AB底的说法</strong></li>
<li>艾略特是看图说话, 所标示的级别大多是K线图上明显的一段. 普莱切特引入的WXYXZ反而将级别问题复杂化了.</li>
<li>艾略特本人非常注重时间. 强调过:<ul>
<li>时间是宇宙的基本要素之一</li>
<li>就投资而言, 时机是最基本的要素. 买什么很重要, 但何时买更重要.</li>
<li>可惜在现有的波浪理论中, 时间只是辅助作用.</li>
<li><strong>波浪理论加上时间的限制, 会大大提高波浪理论的有效性(级别和转折点)</strong></li>
</ul>
</li>
</ul>
</li>
<li>三重锯齿型调整浪<ul>
<li>艾略特的锯齿型调整浪包含了双重锯齿型, 即 W(5-3-5)-X(3)-Y(5-3-5), 形态上为较为明显的四波下跌.</li>
<li>普莱切特的三重锯齿型, 理论上应该是 W(5-3-5)-X(3)-Y(5-3-5)-X(3)-Z(5-3-5), 型态上为六波. 但多半也能数成一个5浪形态.</li>
</ul>
</li>
<li><strong>小级别的波浪形态决定大级别的波浪划分</strong><ul>
<li><strong>不存在333或533的调整浪. 即C浪如果不是5波, 不要轻易判定调整结束.</strong></li>
<li><strong>推动浪的1,3,5子浪内部必须也是严格的推动浪结构! 三浪的幅度不能最小, 时间不能最短, 速度不能最慢!</strong></li>
<li>在严格按照上述要求数浪后, 就会产生不规则顶和AB底.</li>
<li>AB底是3-3模式, 由于A不是5波推动, 因而不能作为推动浪正确的起始点.</li>
<li>AB底只能事后确认, 即随后产生了强劲的5浪推动结构且级别放大, 方可以认为之前的是AB底. 否则只能是3-3-5调整浪.</li>
</ul>
</li>
</ul>
<h1 id="疑难杂症"><a href="#疑难杂症" class="headerlink" title="疑难杂症"></a>疑难杂症</h1><ul>
<li>三角型波浪<ul>
<li>三角型调整浪要求是3-3-3-3-3或3-3-3-1-1 模式. 但艾略特举例时, 出现过3-3-5-3-3模式.</li>
<li>复杂情况下, 通常是C浪, 会呈现出: 规则平台形, 扩散平台形或多重锯齿形的样子</li>
<li><strong>因而对于三角型调整, 可以优先看上下边界形成的型, 内部子浪C允许偶尔出现5浪或复杂浪结构.</strong></li>
<li><strong>终结倾斜三角型是艾略特提到过的, 应用时, 同样重点考虑上下边界形成的型, 其次看内部子浪结构.</strong></li>
<li><strong>引导倾斜三角型是普莱切特的观点. 可以采用, 但内部子浪必须是严格的5-3-5-3-5结构.</strong></li>
</ul>
</li>
<li>五浪的衰竭/失败<ul>
<li>只有在驱动浪中, 第五浪内部也为推动结构或终结倾斜三角型, 才能判定为五浪衰竭/失败.</li>
<li><strong>四浪调整中的b通常是三波结构, 或疑似五波但不满足推动结构, 此时不能判为五浪衰竭/失败.</strong></li>
<li><strong>五浪是强势股见顶的过程. 强势股往往在指数五浪3时就见顶. 最后的五浪5往往由权重拉升, 热点散乱.</strong></li>
<li>调整浪中的五波是不存在五浪衰竭/失败这个概念的. (大级别C浪除外, 允许五浪失败)</li>
</ul>
</li>
<li>B浪新高vs五浪延长<ul>
<li><strong>成交量可能会提供答案. 如果成交量清淡, 为B浪. 如果成交量放大, 可能是延长浪.</strong></li>
<li><strong>内部结构确定. 五浪要延长, 五浪3必须是严格的推动浪结构, 哪怕五浪3延长, 其子浪1也必须是推动浪结构.</strong><br><img src="https://draapho.github.io/images/2006/2.png" alt="新高"></li>
</ul>
</li>
<li>延长浪中的延长浪<ul>
<li>事前很难判断, 会产生背离再背离, 就是不转势的情况.</li>
<li>应对方法: 同级别均线趋势跟随; 大级别时间转折点预判, 价格极限预判.</li>
</ul>
</li>
<li>混合型调整浪<ul>
<li>下图为艾略特的划分: 按照价格的绝对高低点, 划分为3-7-3结构. 没有解读成5-3-5结构, 即五浪失败不能用于调整浪.</li>
<li><strong>通道型调整浪, 忽略内部划分, 直接数浪, 单重3浪, 双重7浪, 三重11浪.</strong></li>
<li><strong>混合型调整浪若由X浪衔接, 大结构上看, 可能出现3-X-3结构. 即X后是重新开始的调整浪</strong><br><img src="https://draapho.github.io/images/2006/1.png" alt="混合型"></li>
</ul>
</li>
<li>充满歧义的调整浪<ul>
<li>下图: 整体是ABC调整, 但内部结合和结束点在哪里事前是无法确定的.</li>
<li>左侧竖线结束的划分: 3-3-5结构; 5-3-5结构;</li>
<li>右侧竖线结束的划分: 5-3-5结构; 3-5(三角型)-5结构;<br><img src="https://draapho.github.io/images/2006/3.png" alt="歧义1"></li>
<li>下图: 五浪或一浪延长, 解读成3浪结构或5浪结构都是可以的. 优先解读为五浪.<br><img src="https://draapho.github.io/images/2006/4.png" alt="歧义2"></li>
</ul>
</li>
<li>C浪延长<ul>
<li>AB底和不规则顶, 都可以看成是C浪延长, 级别直接小转大造成的特殊现象.</li>
<li>识别AB底和不规则顶的关键: 牢记各种波浪形态的内部子浪判定条件.<br><img src="https://draapho.github.io/images/2006/5.png" alt="AB底"></li>
</ul>
</li>
</ul>
<h1 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h1><ul>
<li><strong>五浪推动是新生, 五浪是结束.</strong><ul>
<li>隐而生, 惑而活, 显而变. 小级别五浪推动是隐而生, 大级别五浪是显而变. 三浪是惑而活.</li>
<li>一鼓作气, 再而衰, 三而竭. 三浪是衰, 五浪是竭.</li>
<li>五浪的三次同方向, 让人们心理上获得了足够的暗示, 形成思维定势.</li>
<li>驱动浪走到一浪5时, 一浪属于大级别一鼓作气+小级别的三而竭. 因而有调整需求.</li>
<li>驱动浪走到五浪5时, 大小级别同时三而竭, 转势.</li>
<li>调整浪abc三浪属于再而衰, 5波结构的浪c属于小级别的三而竭. 反击力度消耗殆尽, 于是原趋势强势延续.</li>
<li>调整浪如果是一个5波结构开始, 说明是调整浪a, 一鼓作气的阶段. 必须出浪c的5波结构才可能结束.</li>
<li><strong>第一个逆势小级别五浪推动结构意味着本级别至少走一次N字形.</strong></li>
</ul>
</li>
<li>推动浪和调整浪<ul>
<li><strong>推动浪的产生, 必须有着天时地利人和, 即结构完美(含价格到位), 时间转折点, 可持续的增量资金三重要素. 属于增量博弈, 可共赢</strong></li>
<li><strong>真正的推动浪是生命形式的等比例放大, 需要向外吸取或释放大量的资金来维持原有的趋势.</strong></li>
<li>调整浪本质上一种存量博弈. 是板块之间争夺有限资金的表现.</li>
<li>如果结构, 价格都已经到位, 但时间上不允许(天时), 就会继续走震荡调整型态, 消耗时间, 形成江恩所说的空转.</li>
<li>**X浪是在满足地利条件时, 由于缺乏天时或人和的条件, 导致趋势反转失败. **<ul>
<li>天时, 表示时间条件; 地利, 表示结构完整; 人和, 表示资金支持.</li>
<li><strong>X浪前已有天时地利, 则必然走出之字形结构, 其本质为缺乏增量资金而无法持续, 是夭折了的推动结构.</strong></li>
<li><strong>X浪前仅满足地利时, X浪可以是任意形式的调整浪</strong></li>
<li><strong>X浪划分的调整浪, 多呈现3-X-3时价对称结构. 即X后是重新开始的调整浪, 等待下一次的天时地利人和的机会实现转势</strong></li>
<li>X浪和B浪的区别:<ul>
<li>B浪是调整的必经过程, 此时缺乏天时地利, 根本没有形成牛市的基础条件. 随后的C必然是五浪推动形式. 因而形式上, B浪运行角度往往弱于A浪.</li>
<li>X浪经常快速而陡峭, 多呈现锯齿浪, 容易被误判为推动浪. 随后的Y浪往往和W浪呈现对称关系, 而非五浪推动的C.</li>
</ul>
</li>
<li>X浪和C浪的区别:<ul>
<li>无论平台型还是锯齿型调整, 最后的C浪必须是推动浪. 如果呈现双锯齿型四波结构或其它普通的调整结构, 那只能是B浪X, 后面还有B浪Y. 随后才是真正的推动浪C.</li>
<li>C浪的调整强度要大于X浪, C浪调整后, 价格到位. X浪的调整较弱, 结构上不是推动浪, 价格上不到位.</li>
</ul>
</li>
</ul>
</li>
<li>综上, 推动浪只能是短暂的. 而调整浪可以调了又调, 调了再调, 默默的在调整中, 等待新生的机会.</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>&lt;艾略特名著集&gt;</li>
<li>&lt;艾略特波浪理论-自然法则&gt;</li>
<li>&lt;艾略特波浪理论:市场行为的关键(20周年纪念版)&gt;</li>
</ul>
]]></content>
      <categories>
        <category>market</category>
      </categories>
      <tags>
        <tag>market</tag>
      </tags>
  </entry>
  <entry>
    <title>交易市场思路</title>
    <url>/2021/02/03/2102-share-skill/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2019/03/26/1902-trading-rule/">交易市场思考</a></li>
<li><a href="https://draapho.github.io/2019/04/26/1903-wave-principle/">波浪理论简述</a></li>
<li><a href="https://draapho.github.io/2019/06/25/1907-investor/">你将不会成为一个伟大的投资人</a></li>
<li><a href="https://draapho.github.io/2020/02/09/2001-exploration/">交易市场阶段性探索心得</a></li>
<li><a href="https://draapho.github.io/2020/08/06/2005-wave-mnemonic/">波浪理论口诀</a></li>
<li><a href="https://draapho.github.io/2020/08/07/2006-wave-thinking/">波浪理论感悟</a></li>
<li><a href="https://draapho.github.io/2021/02/03/2102-share-skill/">交易市场思路</a></li>
</ul>
]]></content>
      <categories>
        <category>market</category>
      </categories>
      <tags>
        <tag>market</tag>
      </tags>
  </entry>
  <entry>
    <title>修道之路-总纲</title>
    <url>/2021/02/14/2105-dao-outline/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>经过一段时间的资料收集和思考, 自己要走的修道之路基本也就定了下来.<br>此系列, 会记录自己修道之路中的探索和心得.</p>
<ul>
<li><strong><a href="https://draapho.github.io/2021/02/14/2105-dao-outline/">修道之路-总纲</a></strong></li>
<li><a href="https://draapho.github.io/2021/03/01/2106-dao-doubt/">修道之路-起疑</a></li>
</ul>
<h1 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h1><p>最先要强调的就是方法论, 因为这是思维/认知的本.<br>因而, 我对待事物和概念, 其本, 也可称之为锚, 就是<strong>本位方法论</strong>.</p>
<p>本位方法论, 大概也可归类于朴素辩证法. 核心要点如下:</p>
<ul>
<li>本: 一定范围内的普适性, 规律性, 绝对性.</li>
<li>位: 相(第四声). 相对性, 相互关系.</li>
<li>无位可本, 无本可位, 本位一体, 本位相生.</li>
<li>本非本, 由位生本.<ul>
<li>没有什么绝对的本, 不存在普世的真理.</li>
<li>本, 只能由一定范围内的位, 总结归纳思辨出一个暂时的本, 也等同于一个暂时的位.</li>
</ul>
</li>
<li>本无位, 由本生位.<ul>
<li>世界上本来是没有位次之分的. 没有本的概念, 也就不会有位的概念.</li>
<li>因为”我”这个想法, “有无”,”美丑”,”善恶”这些个概念, 以及一系列其它的本, 才生成了诸多位次, 相对性. 本位由此相生, 成长.</li>
</ul>
</li>
<li>无所位而生其本, 无所本而生其位.<ul>
<li>此句放在人文环境中更容易理解. 会有自己认为的本和位, 别人认为的本和位之分.</li>
<li>无所位: 不能先入为主的以别人当前所处的位次, 就直接来评判一个人. 即不以任何自以为是的本去判断位. 破除任何前提和固有思维, 客观地观察/体验.</li>
<li>生其本: 这样, 才可能基于客观地观察/体验, 去认识到其他人或事物的较为真实的一面, 找出别人所依赖的本.</li>
<li>无所本: 不以任何自认为的本为本, 放下一切固有观念. 而是找出对方认为的本作为参考体系, 来考察研究对方的行为.</li>
<li>生其位: 只有这样, 即自己心中无本, 以观察对象之本为本, 才能正确的预判他人的位次和自己所处的位次, 并决定后续行动.</li>
<li>举例1, 电视剧 &lt;天道&gt;中的丁元英就是这么一个法无定法, 不拘一格的怪才.<ul>
<li>商战中, 他自身是空的, 自己只有一个无本之位, 即最终目的. 为了这个目的, 他会去分析他人的执着, 以此为本, 分析他人后续可能的判断和行动, 最后再决定自己的行动.</li>
</ul>
</li>
<li>举例2, 王阳明的几次军功. 大多是在兵力的绝对弱势之下, 使用的攻心计.<ul>
<li>绝对弱势下却镇定自若, 敢于”铤而走险”, 说明王阳明是一个放下自我的人, 他的行事方法并没有一个固守的”本”, 而攻心计成功的前提就是识别出他人的”本”.</li>
<li>王阳明南赣剿匪时, 有著名的 &lt;告谕浰头巢贼&gt;, 从内部对土匪进行了分化. 为何只对浰头的巣贼写了劝降书? 敌方有真投降和假投降, 如何区分?</li>
<li>首先, 王阳明没有任何先入为主的概念, 如穷山恶水出刁民, 或者土匪都是十恶不赦的, 只能武力解决. 以此, 才会去思考内部分化的可能性.</li>
<li>再者, 王阳明调查了主要匪患首领的背景, 是自小好逸恶劳, 还是为生计所迫. 以此为本, 区别对待. 结合投降的时间和投降后的行为, 综合判断真降还是假降.</li>
<li>&lt;告谕浰头巢贼&gt;, 也是王阳明在前期剿匪时发现土匪们日子过得真不怎么样, 大多是走投无路, 落草为寇. 换位体察, 有感而发, 情真意切.</li>
</ul>
</li>
</ul>
</li>
<li>本位问题的矛盾和解释<ul>
<li>如果存在绝对真理, 那么本位问题的假设, 本只是一定范围内的本, 就是错的.</li>
<li>如果不存在绝对真理, 那么本位方法论就成了绝对真理, 相互矛盾.</li>
<li>其一: 由于是否存在绝对真理存疑, 因而只能用逼近法. 对我而言, 此方法是当前最好的逼近法, 能始终保持开放的心态去客观观察事物和现象, 从而避免的思维和认知上的作茧自缚.</li>
<li>其二: 矛盾是逻辑学上的概念, 本位方法论默认逻辑学也只是相对真理, 有适用范围. 完全允许出现否定逻辑学的事物和现象. 否定逻辑学后, 不存在绝对真理就是绝对真理, 类似于这样的句式是没有任何问题的!</li>
<li>其三: 如果逻辑学为绝对真理, 那么本位方法论的假设错误, 到时候扔了就是, 一样达到了寻求绝对真理的目的.</li>
<li>综上: 如果绝对真理存在, 用本位方法论可以逼近绝对真理. 如果绝对真理不存在, 那么本位问题的假设正确. 总之, 本位方法论可堪大用!</li>
<li>补充: 逻辑是我获取外部信息时, 极其依赖的理论基础, 是我会坚持的本/锚. 这直接导致了我看很多灵修或宗教类的书籍, 会感觉看不下去.</li>
</ul>
</li>
<li>本位关系应用举例<ul>
<li>哲学. 由本生本. 哲人自己选一个本. 譬如: 存在, 思考等等, 结合少量经验性质的位, 进行一番形而上学的高谈阔论, 形成自认为的本.<ul>
<li>辩证唯物主义, 辩证唯心主义, 在本位方法论下就是个自相矛盾的笑话. 一个唯字, 就预设了前提, 固定了本.</li>
</ul>
</li>
<li>数学. 由本生本. 本就是公理, 是先验的, 无需证明的, 进而基于逻辑学, 推论出一系列的本.<ul>
<li>典型如: 欧氏几何, 罗氏几何, 黎曼几何. 假设的公理不同, 推导的结果也就全然不同.</li>
</ul>
</li>
<li>物理. 本位互生. 目前借助于数学, 本远远走在了前面, 对位的观察手段跟不上了.<ul>
<li>这是我最推崇的一种模式, 这种对”位”的开放包容的心态, 对旧有的”本”的理性质疑, 我愿意称之为科学的精神.</li>
<li>随着科学的普世化, 如今的”科学”二字, 一些人对其我正它邪的维护行为, 越来越像一个守旧的宗教.</li>
</ul>
</li>
<li>人文. 有位无本. 因而人文学科大多数情况是各说各的, 谁也说服不了谁. 在尝试借助数学作为本, 但效果不好.<ul>
<li>人文的本是人性. 以下可以认为是个假说, 但每个人都有机会, 也只能亲自去验证这个假说.</li>
<li>人类内在的本性是: <strong>永不忘却的合一和完美.</strong> 因为皆自道而来, 所以必向道而去.</li>
<li>每个人意识里是孤独和缺失的. 因为只有这样, 才有机会体验合一和完美.</li>
<li><strong>当通过感官和思维向外追寻这份本性时, 必然演化为贪婪和恐惧.</strong><ul>
<li>由于这份缺失感, 就会不停地向外索取, 以填补自己的缺失, 期望以此充实自己. 是为贪婪. 永无止境.</li>
<li>意识以群体为本时, 会希望自己成仁成圣, 救苦救难, 希望所在的群体能达到自己心中的完美, 这也是一种贪婪.</li>
<li>由于这份缺失感, 会觉得失去一些东西时, 自己会变地更不完整, 损害了自己的完美程度. 是为恐惧.</li>
<li>意识以群体为本时, 会自觉维护此群体的利益, 以此获得一种归属感. 本质是一种害怕失去的恐惧.</li>
</ul>
</li>
<li><strong>向内寻求这份本性时. 可以最终体验到自己就是合一和完美. 无需获得更多, 也没什么可以失去.</strong><ul>
<li>亲证感官和思维的断续和生灭.</li>
<li>亲证有物混成, 万有合一的完美.</li>
<li>至此, 逻辑上便是到头了.</li>
<li>再言便是: 无孤独无缺失, 无合一无完美; 无本, 无位; 无对立, 无统一; 无有, 无无, 无他, 无我.</li>
<li>万物当下都展示着自己应有的相面, 处于自己应有的位置, 既完美又缺失, 既天堂又地狱.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="起疑"><a href="#起疑" class="headerlink" title="起疑"></a>起疑</h1><p>思维会作茧自缚式的把自己保护起来.<br>所谓的信息茧房, 是自己的思维造成的. 互联网的分发机制不过是发现了这个需求, 加以强化.<br>这个茧, 他人是破不得的, 从外部破, 那是暴力强拆, 只会激发起自我和思维的抗拒和害怕, 把自己包裹的更紧.<br>只有自己破茧而出, 才能化蛹成蝶.</p>
<h1 id="闻道"><a href="#闻道" class="headerlink" title="闻道"></a>闻道</h1><p>互联网时代, 信息爆炸, 若能开放心态, 放下成见, 加以筛选, 闻道的机遇还是很多的.<br>遇到一本好书, 遇到一个经验分享, 对比不同来源的资料内容, 逐步质疑排除, 从而获得佛/道/神的核心观点并非遥不可及.<br>反而是以前那种拜师学艺的方式, 对入门者而言基本就是碰运气. 能人异士, 高僧大德属于稀缺资源.</p>
<h1 id="明心"><a href="#明心" class="headerlink" title="明心"></a>明心</h1><p>唯”观察”二字. 每个当下的观察, 持之以恒的观察.<br>以达到每时每刻, 不忘不丢, 内化为习惯的”觉知”.</p>
<h1 id="见性"><a href="#见性" class="headerlink" title="见性"></a>见性</h1><p>携诚心, 寻真师, 消融自我.<br>烦恼即是无上菩提, 人世方为究竟道场.<br>所谓”得道”, 不是知识, 不是用来学习和理解的, 是超出思维领域的.<br>必须真正亲自, 去感受道, 去体验道. 这是一段旅程, 这是一份经历.</p>
<h1 id="入道"><a href="#入道" class="headerlink" title="入道"></a>入道</h1><p>辨别隐藏于深处的自我和执念.<br>不好为人师, 不求改变世界, 无善无恶, 众生平等.<br>无我, 无所求, 无分别, 真正的活在每一个当下.</p>
<h1 id="悟后起修"><a href="#悟后起修" class="headerlink" title="悟后起修"></a>悟后起修</h1><p>修行的过程, 弃智绝圣! 坚决不做大脑, 思想, 概念的奴隶.<br>有曰: 道为常道, 法无定法. 即便体验了道, 依旧需要具体问题具体分析和处理.<br>体验了涅槃, 放下了得失心, 不执著于成名成仁成圣, 大脑和思想就可以成为有用的工具.<br>往后的路, 依旧是选择, 真正自由的选择: 如何对待每个当下, 如何走下面的路.<br>生而为人, 是实实在在的位次所在. 无所本而生其位, 当下承担.<br>若能力所及, 希望自己能在灵性和理性之间, 建立起一座桥梁, 成为一名小小的翻译者.</p>
<p>个人求道:</p>
<ul>
<li>身外求物, 身外之物, 身外无物, 可得安心;</li>
<li>心外求身, 心外之身, 心外无身, 可得道门;</li>
<li>道外求心, 道外之心, 道外无心, 可得本源;</li>
<li>弃智绝圣, 当下承担, 物身心道, 不求而得.</li>
</ul>
<p>社会发展:</p>
<ul>
<li>基于人性, 形成理论, 不求大同, 自由博弈;</li>
<li>正向激励, 负向反馈, 人心波动, 遵循数理;</li>
<li>夏虫井蛙, 各有其命, 鸿鹄燕雀, 各安其位;</li>
<li>顺势而为, 主观能动, 实则无为, 皆由天命.</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/wancy86/p/lunyu.html">《论语》详解：给所有曲解孔子的人</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈 - 一切皆相对</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
</ul>
]]></content>
      <categories>
        <category>dao</category>
      </categories>
      <tags>
        <tag>dao</tag>
      </tags>
  </entry>
  <entry>
    <title>天赐问答1</title>
    <url>/2021/04/14/2111-answer1/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/14/2111-answer1/">天赐问答1: 知行合一, 方为真知.</a></li>
<li><a href="https://draapho.github.io/2021/04/15/2112-answer2/">天赐问答2: 总是拖延, 该怎么办?</a></li>
<li><a href="https://draapho.github.io/2021/04/16/2113-answer3/">天赐问答3: 凡夫一向动, 小乘一向静</a></li>
<li><a href="https://draapho.github.io/2021/04/17/2114-answer4/">天赐问答4: 烦恼名众生, 悟解名菩提</a></li>
<li><a href="https://draapho.github.io/2021/04/18/2115-answer5/">天赐问答5: 如何放下对结果的期待</a></li>
<li><a href="https://draapho.github.io/2021/04/19/2116-answer6/">天赐问答6: 为什么真正的境界不会退转?</a></li>
<li><a href="https://draapho.github.io/2021/04/20/2117-answer7/">天赐问答7: 为什么开悟的似乎都是男人, 女人呢?</a></li>
<li><a href="https://draapho.github.io/2021/04/21/2118-answer8/">天赐问答8: 男女欲望该怎么处理?</a></li>
<li><a href="https://draapho.github.io/2021/04/22/2119-answer9/">天赐问答9: 不完美, 才会独一无二</a></li>
<li><a href="https://draapho.github.io/2021/04/23/2120-answer10/">天赐问答10: 不要辜负你的生命</a></li>
<li><a href="https://draapho.github.io/2021/04/24/2121-answer11/">天赐问答11: 100多年前的马克思主义, 过时了吗?</a></li>
<li><a href="https://draapho.github.io/2021/04/25/2122-believe/">我们到底该信什么，不该信什么？</a></li>
</ul>
<p>以上所有内容, 皆转载自微信公众号: 自愈之光.<br>此系列为灵天赐入道开悟后的资料收集.</p>
<hr>
<h1 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h1><p><em><strong>老师，性相一如，虽然理上明白，事上透不过去，还是容易着相，是不是还是定力不够？需要打坐培养定力消习气？</strong></em></p>
<p>答：很多时候，大家对于各种道理，只是自以为明白，其实并没有真的理解。</p>
<p>举个例子：</p>
<p>“天行健，君子以自强不息；地势坤，君子以厚德载物”</p>
<p>这句话人人都知，理解也不难。</p>
<p>不过，绝大部分人，只理解了表面句意。</p>
<p>举个例子，假如你突闻噩耗，孩子/父母/妻子/丈夫遭遇意外而去世，这种情形下，还想得起什么是‘自强不息’吗？</p>
<p>另一个例子，某日你回到家中，惊觉你的妻子/丈夫，正与一名不认识的异性睡在一起，这个时候，还记得起什么是‘厚德载物’吗？</p>
<p>所以，理上的明白，从不是真正的明白。</p>
<p>知行合一，方为真知。</p>
<p>哪怕光从道理上来看，你也没有理解什么是‘性相一如’。</p>
<p>什么是“性”，你真的知道吗？</p>
<p>什么是“相”，你真的明白吗？</p>
<p>为什么，说它们是一如？</p>
<p>如果你真的明白，就不会问后面关于打坐和定力的问题了。</p>
<p>这句话，与‘色即是空，空即是色；色不异空，空不异色’是同一个含义。</p>
<p>性，指一切万物不生不灭的本性所在。</p>
<p>相，指由此性而生出的诸天宇宙外相。</p>
<p>本质层面上，两者没有区别，是一样的。</p>
<p>可以说，万物都是性；也可以说，万物都是相。</p>
<p>因性而显相；因相而应性。</p>
<p>所以，定力是不是相？打坐是不是相？习气是不是相？</p>
<p>你的提问本身，就是在从相的角度提问。</p>
<p>错误的问题，自然不可能求得正确的答案。</p>
<p>要从内而外，重新清理你脑海中似是而非的各种概念、名词、定义。</p>
<p>这些都是你进步的阻碍，要从当下立足，一步一个脚印的往前走。</p>
<p>如何不被习气带着走，用之前那篇文章《开悟，是一种怎样的体验？》，里面提到的观察法。</p>
<p>先去练习观察你的习气就好了。</p>
<p>习气心念、情绪、行为升起的瞬间，你能不被其认同，不被其带走，瞬间观察与认出它。</p>
<p>本身，就是一种强有力的抽离。</p>
<p>先做到第一步，再去考虑其他的吧。</p>
<p><strong>请牢记，知行合一，方为真知。</strong></p>
<h1 id="问：-1"><a href="#问：-1" class="headerlink" title="问："></a>问：</h1><p><em><strong>老师，之好像误打误撞进入过明心，后来因为自己的一些问题从那个状态中退出。当时认识到的问题是自己的资粮不够，还有身体上差一些，生活上也有一些事情需要处理。现在问题解决一些了，但感觉自己的资粮福德差一些，请问老师您当初是如何集自己的资粮的？</strong></em></p>
<p>答：明心、见性、入道，是一个境界的标志。</p>
<p>每一个标志，都像一个台阶，上去很难，可一旦进入就不会下来了。</p>
<p>所以，首先可以肯定，你的状态不是进入明心，最多是触碰到了心。</p>
<p>因为没有详细叙述，我也不确定，你所说的状态是后者，或仅仅是一些大脑的臆想。</p>
<p>毕竟，人的意识，喜欢攀援境界，喜欢对认知之外的信息产生种种误解，将一些体验创造出种种联系，与境界想象到一起。</p>
<p>明心、见性，是对某种状态的描述。</p>
<p>两种状态本身，并不难以进入。</p>
<p>比如，当你被某些事情吓住，一瞬间进入无思无念的空白状态时，这种状态就是思维退潮，心所显现的。</p>
<p>比如，当你与爱人进入‘性高潮’，或者因为做某些事情而进入‘颅内高潮’的状态时，就是自我消去，性所显现的。</p>
<p>两种状态，常人会多次的经历，却往往稍纵即逝，没什么收获。</p>
<p>明心、见性和这种偶然状态的相遇不同，它意识深化后的产物，就像登山一样，来到一个平台上，就再也不会往下滑落了。</p>
<p>我见过无数次了，很多人对于眼前所见的风景，产生误解。</p>
<p>误以为自己因为一时的偶然，已经‘明心’、‘见性’、‘入道’了。</p>
<p>可惜，因为这样那样的原因，导致自己的‘退转’，然后自己特别想回到那种‘境界’之中。</p>
<p>其实，这些都是自我的幻觉。</p>
<p>远远没有到达所谓的境界，退转本身就是一个强有力的提示。</p>
<p>即便你真的体验到了类似的风景，也只是类似的风景。</p>
<p>真正的领悟，是不会退转的。</p>
<p>‘退转’或者失去这些风景，不是因为你退步了，反而是因为你进步了。</p>
<p>这些风景，只是微不足道的前兆。</p>
<p>倘若能放下风景，继续前行，就会有真正进入境界的那一天。</p>
<p>可惜，太多人执着于风景，来回徘徊不愿前进。</p>
<p>只希望后退，再看一眼那‘虚幻而又美好的风景’。</p>
<p>这就叫，认假为真。</p>
<h1 id="问：-2"><a href="#问：-2" class="headerlink" title="问："></a>问：</h1><p><em><strong>天赐兄，你在生起欲望的时候可以觉察到喉咙根部附近的冲突感吗。觉察到这个冲突感它就离开，然后有时离开时会有无限感，以及驱动念头的情绪被释放。有时候临在的时候眼珠也会往上翻。</strong></em></p>
<p>答：你说的这些，是一些主观的躯体感受，执着于这些感受，就叫做‘着相’。</p>
<p>这些东西里，没有秘密可言。</p>
<p>不会有你想象中某种玄妙的‘入道秘诀’，存在于这些躯体感受之中。</p>
<p>它们只是反应，就像你饥饿就想吃饭，渴了就像喝水一样，是一些生理反应。</p>
<p>你在意这些东西，恰恰说明你没有‘活在当下’，你没有进入临在。</p>
<p>什么是临在？</p>
<p>临在就是完全接纳，忘却过去未来，活在当下的表达中。</p>
<p>当你身处这种状态中的时候，眼珠往上翻不翻有关系吗？</p>
<p>只有眼珠往上翻才能进入临在吗？往下翻的时候呢？不翻的时候呢？</p>
<p>不要琢磨这些大惊小怪的东西，里面没有任何秘密。</p>
<p>大道朴实无华，真正秘密，隐藏在你吃饭、拉屎、睡觉的每一个当下，每一个瞬间之中。</p>
<h1 id="问：-3"><a href="#问：-3" class="headerlink" title="问："></a>问：</h1><p><em><strong>先生，我想知道是否会有那一天，所有人都平安喜乐，都合一呢？如果有，接下来又是如何发展的呢？那个终极的尽头是什么？</strong></em></p>
<p>答：我在网上见过一句话，很适合回答这个问题。</p>
<p>“如何让一只蚂蚁去想象，它与京东购物车之间的距离？”</p>
<p>不要试图用已知领域的知识，去模拟未知领域的境界，那是超乎想象的存在。</p>
<p>人类连未来两千年的科技进化，都难以用人脑去模拟。</p>
<p>更何况，是这种超乎时间、空间、存在的终极实相呢？</p>
<p>有没有想过，其实现实已经合一了，所有人都已平安喜乐了。</p>
<p>不过，为了乐趣和探索，于是又创造出这个不合一、不平安喜乐的宇宙世界，来继续享受呢？</p>
<p>你看，连这种可能，你都不一定认真想过。</p>
<p>更何况，所谓的‘终极’呢？</p>
<p>^_^</p>
<hr>
<p>无论点亮或不点亮，喜欢或不喜欢，关注或不关注。</p>
<p>祝你的人生，平安喜乐~</p>
]]></content>
      <categories>
        <category>灵天赐</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>天赐问答6</title>
    <url>/2021/04/19/2116-answer6/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/14/2111-answer1/">天赐问答1: 知行合一, 方为真知.</a></li>
<li><a href="https://draapho.github.io/2021/04/15/2112-answer2/">天赐问答2: 总是拖延, 该怎么办?</a></li>
<li><a href="https://draapho.github.io/2021/04/16/2113-answer3/">天赐问答3: 凡夫一向动, 小乘一向静</a></li>
<li><a href="https://draapho.github.io/2021/04/17/2114-answer4/">天赐问答4: 烦恼名众生, 悟解名菩提</a></li>
<li><a href="https://draapho.github.io/2021/04/18/2115-answer5/">天赐问答5: 如何放下对结果的期待</a></li>
<li><a href="https://draapho.github.io/2021/04/19/2116-answer6/">天赐问答6: 为什么真正的境界不会退转?</a></li>
<li><a href="https://draapho.github.io/2021/04/20/2117-answer7/">天赐问答7: 为什么开悟的似乎都是男人, 女人呢?</a></li>
<li><a href="https://draapho.github.io/2021/04/21/2118-answer8/">天赐问答8: 男女欲望该怎么处理?</a></li>
<li><a href="https://draapho.github.io/2021/04/22/2119-answer9/">天赐问答9: 不完美, 才会独一无二</a></li>
<li><a href="https://draapho.github.io/2021/04/23/2120-answer10/">天赐问答10: 不要辜负你的生命</a></li>
<li><a href="https://draapho.github.io/2021/04/24/2121-answer11/">天赐问答11: 100多年前的马克思主义, 过时了吗?</a></li>
<li><a href="https://draapho.github.io/2021/04/25/2122-believe/">我们到底该信什么，不该信什么？</a></li>
</ul>
<p>以上所有内容, 皆转载自微信公众号: 自愈之光<br>此系列为灵天赐入道开悟后的资料收集.</p>
<hr>
<h1 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h1><p><em><strong>老师你好，我从不同来源的资料里都听说有一个“不退转”的概念，听说一个人一旦悟到某些东西之后，心里就会有根本的改变。一个人是不是明心、见性之后，就不会退回到之前的境界？这是什么原理呢？</strong></em></p>
<p>答：这就是为什么，会有‘境界’一说。</p>
<p>修行和心灵成长，与人生是一样的道理。</p>
<p>人会误以为，人生是一个斜坡，将会一直平稳上涨，直到人生终点。</p>
<p>其实，人生是一个个高度不同的台阶。</p>
<p>有人平步青云，一路到顶；</p>
<p>有人年轻时被挡在某个台阶前，此后终生不得存进。</p>
<p>每个台阶，有每个台阶的攀爬难点。</p>
<p>没有正确的方式，就上不去。</p>
<p>时常在你误以为爬上去的瞬间，一下掉回原地。</p>
<p>可每次爬上一个台阶，人生就会进入一个新的境地。</p>
<p>明心、见性，不是台阶。</p>
<p>是一个平台，像设置在半山腰的观景点。</p>
<p>经过长时间的攀爬后，你终于看见了超乎想象的风景。</p>
<p>它们是一个特殊的节点。</p>
<p>这个节点，对内心的改变，极其巨大。</p>
<p>明心，仿佛是爬到半山腰。</p>
<p>见到山下那些渺小的建筑以及行人，目睹了难以想象的高度以及奇妙风景。</p>
<p>这时，会升起强大的信心。</p>
<p>对峰顶的存在，变得无比笃定。</p>
<p>因眼前的风景，让人坚信峰顶的风景，一定是自己想象不到的宏伟与奇妙。</p>
<p>这个节点，可将恶人转为善人，将愚痴转为智者。</p>
<p>将人的心智，从一种存在状态，不可逆的转化为另一种存在状态。</p>
<p>人们对于修行和心灵觉悟之路，有一个很深的误解。</p>
<p>误以为像打铁一样。</p>
<p>将铁矿石或者铁胚，经高温淬火。</p>
<p>一次次的捶打，再一点一点的除去杂质。</p>
<p>最后，就可以铸就成一柄智慧宝剑。</p>
<p>不是这样的。</p>
<p>修行，是一个不可思议的升华过程。</p>
<p>一开始，你并非铁矿，也不是铁胚。</p>
<p>不过是一截枯树枝。</p>
<p>当你开始修行时，枯树枝日渐坚固，成为坚不可摧的铁木。</p>
<p>明心一刹那，铁木转变为铁矿，日后逐步提纯成为纯铁。</p>
<p>见性一刹那，纯铁转变为金矿，日后逐步提纯成为纯金。</p>
<p>入道一刹那，纯金转变为钻石，日后逐步提纯成为纯钻。</p>
<p>铁矿再怎么退转，也不会变回铁木；</p>
<p>金矿再怎么退转，也不会变回纯铁；</p>
<p>钻石再怎么退转，也不会变回纯金。</p>
<p>这就是为什么，真正的境界，不会退转。</p>
<p>也是为何。</p>
<p>每个阶段有每个阶段的修行方式以及方法。</p>
<p>提纯铁矿的火锻之法，给枯树枝练习，只会将其焚烧殆尽。</p>
<p>有人之所以能一下成为纯金或是纯钻，只因他们早已在以往的人生中。</p>
<p>无意识地，将自己提纯为纯铁或是纯金。</p>
<p>每一个境界，均超乎人脑的想象范畴，更何况得道？</p>
<p>我说的很浅，只说了能说的部分。</p>
<p>真修自证者，看了我说的，自会明白。</p>
<p>关于得道，难以言说，难以想象，不可思议。</p>
<p>我还未至，因我心中，还有众生。</p>
<p>在此，与诸位强说几句。</p>
<p>得道刹那，纯钻消失无踪，万事万物消失无踪。</p>
<p>圣凡一如，凡圣一体。</p>
<p>无人无我无众生，无法无圣也无佛。</p>
<p>《太上老君说清静经》云：</p>
<p><strong>所谓得道，实无所得，为化众生，名为得道。</strong></p>
<p>《金刚般若波罗蜜经》云：</p>
<p><strong>离一切诸相，则名诸佛。</strong></p>
<p>《达摩二入四行论》云：</p>
<p>问：三世诸佛平等教化众生，得道者如恒河沙，此可非是觉？</p>
<p>答：<strong>此亦是梦。但有心分别计较，自心现量者，皆悉是梦。</strong></p>
<p><strong>觉时无梦，梦时无觉。</strong></p>
<p>人世一场梦。</p>
<p>得道，便是从梦中，不可逆转的永远醒来。</p>
<h1 id="问：-1"><a href="#问：-1" class="headerlink" title="问："></a>问：</h1><p><em><strong>灵哥哥，如何写小说？</strong></em></p>
<p>答：写</p>
<h1 id="问：-2"><a href="#问：-2" class="headerlink" title="问："></a>问：</h1><p>*** 请问， 有情来种树，因地果还生。无情既无种，无性也无生 该怎么解释？***</p>
<p>答：你提到的，是禅宗五祖弘忍和尚，传给六祖慧能和尚的一首偈子。</p>
<p>偈子：指禅师以诗词颂唱的文字，传承见地与心法。</p>
<p>简单明了，却又奥妙无穷。</p>
<p>每一首流传下来的偈子，传承的是作者本人的真实见地。</p>
<p>比如，人们耳熟能详的释迦牟尼的两句话：</p>
<p><strong>一切有为法，如梦幻泡影；</strong></p>
<p><strong>如露亦如电，应作如是观。</strong></p>
<p>也是一个偈子，里面是释迦牟尼的究竟见地，以及某种高深奥妙的心法，此处略过不提。</p>
<p>总之，偈子真正的奥秘，是无法从文字上参得的。</p>
<p>只可以心悟，以心见，以心得。</p>
<p>偈子的内容，是修行见地的隐喻。</p>
<p>传递了某种不便直说，无法直讲的实相。</p>
<p>仅仅只限有见地的修行者，才能真正读懂。</p>
<p>你提到的这首偈子，出自禅宗六祖所写的《坛经》。</p>
<p>目前来说，市面上有两个版本的《坛经》。</p>
<p>一个，是现在的普世版《坛经》。</p>
<p>这个版本是六祖慧能去世后的好些年头，由后人整理当时流传的三种不同版本《坛经》，才出现的。</p>
<p>有一些道听途说、或自作主张的改编成分，还有一些人为添加与篡改的内容。</p>
<p>另一个版本是敦煌出土的《坛经》，它要早于普世版《坛经》出现的年代，更靠近六祖慧能活着的时候，因而更为可信。</p>
<p>比如，《坛经》提到，六祖慧能自述，说他当时得到五祖弘忍的半夜传法后。</p>
<p>因五祖弘忍知弟子中，有人会害慧能的性命。</p>
<p>便让慧能带上达摩传承的法衣，半夜三更偷偷离开。</p>
<p>五祖弘忍的弟子们，愤愤不平。</p>
<p>不相信他们师父竟将最珍贵的法衣，传给一个大字不识的少数民族？</p>
<p>前后有几百个弟子，都一路追踪慧能，想抓住六祖慧能，抢夺法衣。</p>
<p>结果，所有人都跑到半路，就回去了。</p>
<p>只有一个和尚，性行粗恶，找到了六祖慧能。</p>
<p>这时，普世版的《坛经》记载：</p>
<p>这和尚名叫陈惠明，曾经是四品将军。</p>
<p>六祖慧在被追赶的过程中，将法衣丢在石头上，然后躲入丛林中。</p>
<p>陈惠顺看到法衣，却怎么捡也捡不起来，于是对着丛林中大喊，我来这里是为了求法，不是为了这件法衣而来。</p>
<p>于是慧能从丛林中走出来，给陈惠顺讲法。</p>
<p>据敦煌版的《坛经》记载：</p>
<p>和尚名叫陈惠顺，曾经是三品将军。</p>
<p>他找到慧能之后，死死抓住六祖慧能，慧能把法衣给他。</p>
<p>陈惠顺不要法衣，他说：“我大老远跑来，只为向你求法，才不要衣服。”</p>
<p>于是，六祖慧能便将法传给了陈惠顺。</p>
<p>前者的记载，显然是一个吸引眼球，让人印象深刻的故事。</p>
<p>可后者，才更符合真实情况。</p>
<p>如果是前者那样的和尚，对法衣有贪，被神通慑服。</p>
<p>六祖慧能肯定是宁可丢掉衣，也绝不愿传法的。</p>
<p>只有后者，诚心只为求法，不为求衣，慧能才愿传法，让对方心开得悟。</p>
<p>也只有这样诚心的修行者，方才有资格心开得悟。</p>
<p>因此，你提问的偈子，要对照两个版本的《坛经》。</p>
<p>在普世版《坛经》中，这首偈子是：</p>
<p><strong>有情来下种，因地果还生，无情亦无种，无性亦无生。</strong></p>
<p>敦煌版的《坛经》中，这首偈子为：</p>
<p><strong>有情来下种，无情花即生，无情又无种，心地亦无生。</strong></p>
<p>对照两首偈子的区别：</p>
<p>普世版：<strong>有情来下种，因地果还生；无情亦无种，无性亦无生。</strong></p>
<p>敦煌版：<strong>有情来下种，无情花即生，无情又无种，心地亦无生。</strong></p>
<p>对照会发现，一共四句话，便已被改了三句。</p>
<p>第二句和第四句，一般用来表述见地，作为结论。</p>
<p>结果，被改得完全变样。</p>
<p>只看偈子，会觉得普世版更容易理解。</p>
<p>在此，我逐句分析：</p>
<p>普世版的前两句：<strong>有情来下种，因地果还生。</strong></p>
<p>意思是，有情才可种下菩提的种子，因地才会因此而长出果子。</p>
<p>普世版的后两句：<strong>无情亦无种，无性亦无生。</strong></p>
<p>意思是，要是没有情，也就不会有种子，没有性（指本性菩提）就更不会结智慧果。</p>
<p>普世版的偈子，朗朗上口。</p>
<p>意思上十分简单，容易理解，符合人的逻辑思维。</p>
<p>可禅宗以心传心，不着文字相。</p>
<p>文字存在的意义，是为传承见地的特殊结构。</p>
<p>绝不会屈从俗世的叙事逻辑，来写偈子。</p>
<p>改一个字，境界都会千差万别，更可况是这样的大改呢？</p>
<p>以见地来说，普世版的偈子，写得也啰嗦。</p>
<p>整个偈子，始终只强调有情的重要性。</p>
<p>内容上，停留在第一句话的见地，从第二句到第四句的内容，一直在机械重复和解释第一句的见地。</p>
<p>敦煌版《坛经》的偈子，乍一看更难理解。</p>
<p>实际，唯有敦煌版，才是修行见地的如实表述。</p>
<p>我为你解一下，你就能看见。</p>
<p><strong>有情来下种，无情花即生。</strong></p>
<p>意思是：人来此世间，因后天之情，而种下了菩提（觉悟、智慧）的种子，当后天之情消亡之时，智慧之花也就顺其自然的诞生了。</p>
<p><strong>无情又无种，心地亦无生。</strong></p>
<p>意思是：智慧之花诞生之后，便会明白；本来没有后天之情，也没有菩提种子；连心地也从没有生出过任何东西。</p>
<p>普世版的偈子，表明五祖的见地，在‘有情’、‘有分别’的阶段。</p>
<p>敦煌版的偈子，表明五祖的见地，已得佛法真谛，进入‘无情’、‘无分别’的阶段，即所谓的‘离一切相’。</p>
<p>这个东西，很深。</p>
<p>有些密意，未逢其人，也不可多讲。</p>
<p>而且，正如达摩的第一个偈子，一花开五叶，结果自然成。</p>
<p>偈子中，真正结果的。</p>
<p>是六祖慧能，而不会是从五祖就结果了。</p>
<p>也是为何，六祖慧能根据达摩的偈子，不再继续往下传法衣。</p>
<p>达摩传法的果已结。</p>
<p>未来，万花齐放。</p>
<p>不再需要，一心一传。</p>
<p>总之，偈子第一句话，强调了有情来下种，说明了烦恼与菩提的同生共灭。</p>
<p>正如达摩所说：</p>
<p><strong>烦恼名众生，悟解名菩提，亦不一不异，只隔迷悟耳。</strong></p>
<p>烦恼即是菩提。</p>
<p>没有烦恼，就不会有智慧和觉悟。</p>
<p>生出智慧与觉悟之花后，烦恼与菩提也会一并消失。</p>
<p>因为，在最究竟处。</p>
<p>连这智慧与觉悟之花，也未曾生出过。</p>
<p>无论烦恼还是菩提，无论善人还是恶人，无论凡夫还是圣人，无论愚痴还是智慧。</p>
<p>终究，只是梦中做戏。</p>
<p><strong>本来无生，本来无灭；</strong></p>
<p><strong>究竟永恒，是为涅槃。</strong></p>
<h1 id="—–有感而发—–"><a href="#—–有感而发—–" class="headerlink" title="—–有感而发—–"></a>—–有感而发—–</h1><p>天赐问答，已到第六期。</p>
<p>有人会发现，哪怕类似的问题。</p>
<p>不同的人，从我这里得到的态度，也截然不同。</p>
<p>相对来说，非修行问题的语气，更柔和一点。</p>
<p>原因，在于提问者的诚心。</p>
<p>不是生活中的真修行者，不建议乱提修行方面的问题。</p>
<p>至少也请就事论事，进行提问。</p>
<p>我只看诚心，标准已放得很低了。</p>
<p>按达摩祖师和禅宗诸祖们的标准，大部分人由于我执妄想，没有听闻此种无上顿教法的机缘。</p>
<p>会不解，会诽谤，会心生怨恨。</p>
<p>所以，向我提修行相关的问题。</p>
<p>我会以修行者的标准，来对待提问者。</p>
<p>常人不理解，修行的巨大付出，以及听闻这些知识需要的无上诚心。</p>
<p>像一个人没有双腿，没有双手，说他想爬到珠穆朗玛峰的峰顶，向我咨询爬山技巧。</p>
<p>这人十分自信，说自己已有丰富的爬山经验。</p>
<p>根据我曾说过的只言片语，判断出他自己曾爬到过珠穆朗玛峰的半山腰。</p>
<p>距离峰顶，应该也差不了多少。</p>
<p>对这些人。</p>
<p>我一直反复说同样的话：</p>
<p>你没有双手，也没有双腿，你也没有攀爬珠穆朗玛峰的经验，因为你甚至不知道珠穆朗玛峰在哪里。</p>
<p>这样子，是不可能爬上去的。</p>
<p>首先，要停止自欺欺人，明白自己没有见过珠穆朗玛峰。</p>
<p>然后，再找来自己的手脚，再找到正确的山。</p>
<p>最后再去考虑，怎么爬的问题。</p>
<p>我的如实陈述。</p>
<p>时常让这些人感到，我在羞辱他们。</p>
<p>提问者不理解，什么是如实陈述。</p>
<p>因为客观事实，本就如此残酷。</p>
<p>无非是提问者本人，不愿听见这样的事实而已。</p>
<p>毕竟，在他们心中。</p>
<p>一直以为珠穆朗玛峰，和他们家后院里的几座假山，是差不多的高度。</p>
<p>他平时闲暇，随便朝着假山往上蹭一蹭，也能勉强爬个半山腰。</p>
<p>估摸着，爬珠穆朗玛峰应该也差不多。</p>
<p>可能难上个三、五倍左右，十倍就顶天了。</p>
<p>要说一百倍，肯定是夸张，不可能的。</p>
<p>因此，而认定我在否认他们的见地。</p>
<p>说我不了解，胡乱指责，恭高我慢，自以为是。 </p>
<p>对此，我只能报以沉默。</p>
<p>人生苦短，故步自封。</p>
<p>无非，又是蹉跎一世。</p>
<p>若有缘人，闻听我说，发无上心，行无上行。</p>
<p>未来，终一天，你会感激我的。</p>
<p>奇迹降临的时刻，你将匍匐在地。</p>
<p>为你眼前所见的真相，而感激到涕泪横流，无法言语。</p>
<p>生命的实相。</p>
<p>远非人脑，所能想象。</p>
]]></content>
      <categories>
        <category>灵天赐</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>天赐问答9</title>
    <url>/2021/04/22/2119-answer9/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/14/2111-answer1/">天赐问答1: 知行合一, 方为真知.</a></li>
<li><a href="https://draapho.github.io/2021/04/15/2112-answer2/">天赐问答2: 总是拖延, 该怎么办?</a></li>
<li><a href="https://draapho.github.io/2021/04/16/2113-answer3/">天赐问答3: 凡夫一向动, 小乘一向静</a></li>
<li><a href="https://draapho.github.io/2021/04/17/2114-answer4/">天赐问答4: 烦恼名众生, 悟解名菩提</a></li>
<li><a href="https://draapho.github.io/2021/04/18/2115-answer5/">天赐问答5: 如何放下对结果的期待</a></li>
<li><a href="https://draapho.github.io/2021/04/19/2116-answer6/">天赐问答6: 为什么真正的境界不会退转?</a></li>
<li><a href="https://draapho.github.io/2021/04/20/2117-answer7/">天赐问答7: 为什么开悟的似乎都是男人, 女人呢?</a></li>
<li><a href="https://draapho.github.io/2021/04/21/2118-answer8/">天赐问答8: 男女欲望该怎么处理?</a></li>
<li><a href="https://draapho.github.io/2021/04/22/2119-answer9/">天赐问答9: 不完美, 才会独一无二</a></li>
<li><a href="https://draapho.github.io/2021/04/23/2120-answer10/">天赐问答10: 不要辜负你的生命</a></li>
<li><a href="https://draapho.github.io/2021/04/24/2121-answer11/">天赐问答11: 100多年前的马克思主义, 过时了吗?</a></li>
<li><a href="https://draapho.github.io/2021/04/25/2122-believe/">我们到底该信什么，不该信什么？</a></li>
</ul>
<p>以上所有内容, 皆转载自微信公众号: 自愈之光<br>此系列为灵天赐入道开悟后的资料收集.</p>
<hr>
<h1 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h1><p><em><strong>该如何进行深层次的思考，怎么进入非心智认同的领域？</strong></em></p>
<p>答：只要你还在思考，你便在心智认同的领域。</p>
<p>因为，思考本就是心智认同领域的功用。</p>
<p>思考，和逻辑是不同的。</p>
<p>逻辑，是大脑的物理性功能；</p>
<p>思考，是建立在后天定义与信息之上的我。</p>
<p>思考，不能没有一个我；</p>
<p>逻辑，从来不需要我的存在。</p>
<p>所谓深层次的思考，其实不是思考，而是让这个‘我’停止作用。</p>
<p>当这个‘我’停止作用的瞬间，大脑功能就会得到释放。</p>
<p>你的逻辑，会进入到另一个你所无法理解的层面，以你没有想象过的方式，你没有想象过的言语，来解决你所面对的问题。</p>
<p>你并不知道，平时你的意识状态，大脑的功能并没有得到真正的释放，而是出于一个‘自我’的压制之下，会本能的拒绝一切与‘自我’不符合的信息。</p>
<p>当你失去这层限制，逻辑这种大脑的功用，就会得到开发。</p>
<p>这就是为什么，我可以在交流群里‘不假思索’的回答你们的任何问题。</p>
<p>这也是为什么，我可以在公众号文章里‘不假思索’的回答所有的问题。</p>
<p>我主要的时间，都花在打字上，而非是斟酌用词，分析问题等等。</p>
<p>对于我而言，没有任何‘自我思考’的过程，我只是停驻在内在的平和之中，一切信息都会以最完美的方式，最完美的表达，最完美的逻辑，出现在面前。</p>
<p>思考的过程，并不一定都是必要的。</p>
<p>你也可以，不假思索的完成事情，不假思索的说话，不假思索的做事。</p>
<p>然后，你会为自己所创造出的东西，所惊讶，所赞叹。</p>
<p>正如任何一位伟大的艺术家，从没有谁不像观众那样，为自己所创造的东西而惊讶的。</p>
<p>因为，在非心智领域，你开启了体内一个更加广阔的智性。</p>
<p>地球上，任何一位真正的精神大师，都明白这个秘密。</p>
<p>停下思考，集中所有注意力，只去成为你自己。</p>
<p>这，就是进入非心智认同领域的秘诀。</p>
<h1 id="问：-1"><a href="#问：-1" class="headerlink" title="问："></a>问：</h1><p><em><strong>说话时我观察不到念头的起落，但是我安静时就又能观察到了，是说话时念头变成话语说出来了吗？还是我掉出了观察状态？</strong></em></p>
<p>答：因为，你说话的时候，你正在‘观察’自己说话；</p>
<p>你观察念头的时候，你在‘观察’自己的念头。</p>
<p>人无法一心多用，只能一心一用。</p>
<p>很多人看似一心多用，也只是因为他的注意力焦点，以极快的速度在不同事物之中切换而已。</p>
<p>并不存在，真正的一心多用。</p>
<p>科学家曾专门找过一个以一心多用而闻名的人，来做一个实验。</p>
<p>让这个人一边面对复杂的路况开车，一边打电话。</p>
<p>并电话里同时计算一些需要马上回答的数学问题。</p>
<p>实验结果显示，这个人连一心两用这件事，也做不到。</p>
<p>观察也是如此，观察是一种注意力聚焦的状态，你每次只需观察一件事就好了。</p>
<p>如果你观察得足够仔细，你会发现，你说话的时候，有两种情况：</p>
<p>第一种，你先有念头，然后把念头说了出来；</p>
<p>第二种，你没有念头，直接张嘴把说了出来。</p>
<h1 id="问：-2"><a href="#问：-2" class="headerlink" title="问："></a>问：</h1><p><em><strong>天赐哥，人每天都会做许许多多的选择，很多时候都会有选择困难症，打字的时候虽然想到了选择要基于爱，而不是因为恐惧，但是自己还是对此只是停留在字面的意思上，基于爱自己还是爱他人呢，先爱自己然后爱他人，还是先爱他人，再爱自己？比如某人喜欢我爱我，比起她我更喜欢别人，但是我偏偏又喜欢被爱的感觉，时常在想我和她结婚的话她能保证会一直爱我吗，而我会对自己的选择不后悔吗。就这样，脑袋里冒出来无数个幻相。所有在做诸如此类的选择的时候，就陷入了一个僵局，不知如何选择，进而没有选择，请问天赐哥，我该如何选择？</strong></em></p>
<p>答：爱最重要的是爱自己，只有学会爱自己，你才会懂得爱别人。</p>
<p>以你的例子举例。</p>
<p>在感情关系中。</p>
<p>如果，你更喜欢另一个女生。</p>
<p>但是，因为有一个女生向你表白而让你为难。</p>
<p>只能说明一件事：</p>
<p>就是你既不爱自己，也不爱向你表白的这个女生。</p>
<p>甚至，你也不爱你所喜欢的那个女生。</p>
<p><strong>第一，你不爱自己。</strong></p>
<p>因为你不相信自己值得被爱，值得更好的。</p>
<p>因为恐惧。</p>
<p>你害怕你喜欢的女生不喜欢你。</p>
<p>所以你才会放不下，这种别人喜欢你的感觉。</p>
<p>在另一个层面上，这也说明你并不喜欢自己；</p>
<p>正因为你不喜欢自己，你才会需要别人来喜欢你，来告诉你，你是值得被喜欢的。</p>
<p><strong>第二，你不爱喜欢你的人。</strong></p>
<p>如果，你真正爱她。</p>
<p>显然，你会毫不犹豫的选择她，而不是会有所谓的另一个选择。</p>
<p>所以，你只是在利用向你表达喜欢的女孩。</p>
<p>如果你真正的爱这个喜欢你的女孩，你反而会坦诚的告诉对方，你并不喜欢她，这才是真正的爱她，和对她好。</p>
<p>因为，就像你喜欢的那个女孩一样。</p>
<p>你肯定希望你喜欢的女孩，也真心的喜欢着你。</p>
<p>而不是因为，你喜欢的女孩其实有个男神，她特别喜欢男神，可惜她的男神不喜欢她。</p>
<p>所以，她才勉为其难的选择了你，将就一下。</p>
<p>很多时候，把别人当成自己，很多看似困难的选择，就可以轻松的迎刃而解。</p>
<p>所以，你不爱这个喜欢的你的女孩。</p>
<p><strong>第三，你不爱你喜欢的女孩。</strong></p>
<p>如果，你真正的爱你喜欢的女孩，你一定会毫不犹豫的告诉对方，一定会毫不犹豫的去选择对方。</p>
<p>不可能因为别人喜欢你，而选择放弃自己喜欢的女孩。</p>
<p>你不这样做，无非是因为害怕被对方拒绝而已。</p>
<p>真正的爱，是什么？</p>
<p>真正的爱，不是占有，而是放手。</p>
<p>即使，你所喜欢的女孩不选择你，对方选择了别人。</p>
<p>你也会微笑着，送出祝福。</p>
<p>因为，你无条件爱她；</p>
<p>所以，你愿意将最好的都给予对方，同时不期待对方的任何回报。</p>
<p>即使对方选择的不是你，你也看出这是对方更好的选择。</p>
<p>因此选择送出祝福，并为对方选择成为真实的自己，而发自内心的感到快乐。</p>
<p>无条件的爱，是一种伟大的爱。</p>
<p>远远超越世俗所以为的男情女爱，这些只是人世间的小爱。</p>
<p>真正的爱，是无条件、无希翼、无要求、无回报的大爱。</p>
<p>所以，你会看见。</p>
<p>你之所以困扰，无非是因为你即不爱自己，也不爱别人。</p>
<p>你也不明白，什么才是真正的爱。</p>
<p>为什么会这样呢？</p>
<p>根本原因，是因为你既不懂得爱，你也不爱自己。</p>
<p>你不相信，自己值得世间的一切美好。</p>
<p>你也因此，体验到了你一直‘不值得’。</p>
<h1 id="问：-3"><a href="#问：-3" class="headerlink" title="问："></a>问：</h1><p><em><strong>大佬，我想问如何找回自我，疗愈自我？是这样的，我从小父母离异，家里还穷，很小就没再见过母亲，一直跟父亲生活，父亲脾气暴躁，动不动吼我，整个童年都是在害怕纠结自卑中度过，性格懦弱，在人群里像一个透明人一样，朋友总说我没存在感，总是在讨好别人，委屈自己。不敢爱不敢恨不敢生气。</strong></em></p>
<p><em><strong>我想很多人跟我一样，单亲家庭的孩子大都很难表达自我，总是讨好别人，在意别人，忽视自己，可能这在童年是生存之道，但是进入社会则是被无限收割欺负而已。</strong></em></p>
<p><em><strong>不知道怎么找回自我，疗愈自我。</strong></em></p>
<p>答：先从现实的点滴，开始做起吧。</p>
<p>学会每天对自己好一点。</p>
<p>能力范围内，去吃得好一点，去睡得好一点，去玩得好一点。</p>
<p>放下对自己的所有期待，放下对未来的希翼。</p>
<p>原谅自己的放纵，原谅自己的愚蠢，原谅自己的不自知。</p>
<p>原谅自己的不完美，原谅自己的讨好别人，原谅自己的没有存在感。</p>
<p>放下这些，把它们全部放下。</p>
<p>每天只做自己喜欢的事情，每天只做自己感兴趣的事情。</p>
<p>不喜欢的事情就不去了，不喜欢的关系就不必维持了。</p>
<p>从一点一滴开始，全然的成为自己；</p>
<p>刚开始，或许有点难。</p>
<p>最开始，或许会慌乱，或许会茫然；</p>
<p>可随着你一点一点的改变自己，你渐渐就会开心起来。</p>
<p>越来越开心，越来与幸福，越来与幸运。</p>
<p>因为，你的心变了。</p>
<p>当你开始爱自己，你就会真正的爱别人；</p>
<p>然后，你就能从每一个地方看到爱。</p>
<p>你也能从每一个地方，得到治愈。</p>
<p>这，就是生命的真谛。</p>
<p>原谅自己，安慰自己，对自己好一点。</p>
<p>除此以外，不需要更多了。</p>
<h1 id="问：-4"><a href="#问：-4" class="headerlink" title="问："></a>问：</h1><p><em><strong>我想问下既然明心见性可以开启人类的智慧，那为什么所有开悟的大师不合作创造出一种更适合明心见性的方法呢？他们集思广益，世界不会越来越美好吗？</strong></em></p>
<p>答：没有更好的方法，只有当下最好的方法；</p>
<p>没有更好的道路，只有当下最好的道路；</p>
<p>每个人都有自己独一无二的觉悟之路，每个人都有自己独一无二的智慧之路。</p>
<p>人们总喜欢追求完美，追求最完美的方式，却不明白他们所以为的完美其实是一种缺陷。</p>
<p>举个例子：</p>
<p>人人都喜欢独一无二，要怎么才能独一无二呢？</p>
<p>不完美，自然就独一无二了。</p>
<p>一个完美的瓶子，完美的瓶身，完美的瓶口，完美的比例，完美的光滑……</p>
<p>这些，只代表了千篇一律以及流水线生产。</p>
<p>如果有一个缺口，那么每一个缺口都会独一无二；</p>
<p>如果有一道裂纹，那么每一个裂纹都会独一无二；</p>
<p>如果有一些歪曲，那么每一个歪曲都会独一无二。</p>
<p>这个世界，正因为不完美而独一无二，也正因为每一个独一无二而如此完美。</p>
<p>只有人类，才会执着于所谓‘一模一样的完美’。</p>
<p>觉悟之路，也是同理。</p>
<h1 id="问：-5"><a href="#问：-5" class="headerlink" title="问："></a>问：</h1><p><em><strong>天赐您好.请问如何分清自我，如果被自我控制时跳不出来又该怎么做？</strong></em></p>
<p>答：观察就好了。</p>
<p>当你观察到‘被自我控制’的瞬间，你其实就已经出来了。</p>
<p>你不可能是你所看见的东西，当你看见‘自己在被自我控制’时，你就已经不再被控制了。</p>
<p>当然，这是一个渐进的过程。</p>
<p>一开始，你只是在每个被自我控制的瞬间；</p>
<p>一次次的认出来，自己正在被自我控制。</p>
<p>有时候，你后知后觉；有时候，你正在知觉；有时候，你提前知觉。</p>
<p>随着你的练习，随着你不断的看见。</p>
<p>觉知之光，就会照入黑暗；</p>
<p>就像一颗暗室中的火柴，忽然被点燃了一样。</p>
<p>光，将会瞬间将你从自我之中解救出来；</p>
<p>这个过程，不需要你刻意的做任何事。</p>
<p>你只需要，一次又一次的认出来，就已经足够了；</p>
<p>因为，当你尝试做其他事情时。</p>
<p>这些举动本身，即是一种对自我的强化。</p>
<p>以自我去压抑自我，只会创造出更多的自我。</p>
<p>只有一次次的不断认出，才会为你带来真正的改变。</p>
<p>去尝试吧，练习得越多，自然会有越来越深的体会。</p>
]]></content>
      <categories>
        <category>灵天赐</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>我们到底该信什么，不该信什么？</title>
    <url>/2021/04/25/2122-believe/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/14/2111-answer1/">天赐问答1: 知行合一, 方为真知.</a></li>
<li><a href="https://draapho.github.io/2021/04/15/2112-answer2/">天赐问答2: 总是拖延, 该怎么办?</a></li>
<li><a href="https://draapho.github.io/2021/04/16/2113-answer3/">天赐问答3: 凡夫一向动, 小乘一向静</a></li>
<li><a href="https://draapho.github.io/2021/04/17/2114-answer4/">天赐问答4: 烦恼名众生, 悟解名菩提</a></li>
<li><a href="https://draapho.github.io/2021/04/18/2115-answer5/">天赐问答5: 如何放下对结果的期待</a></li>
<li><a href="https://draapho.github.io/2021/04/19/2116-answer6/">天赐问答6: 为什么真正的境界不会退转?</a></li>
<li><a href="https://draapho.github.io/2021/04/20/2117-answer7/">天赐问答7: 为什么开悟的似乎都是男人, 女人呢?</a></li>
<li><a href="https://draapho.github.io/2021/04/21/2118-answer8/">天赐问答8: 男女欲望该怎么处理?</a></li>
<li><a href="https://draapho.github.io/2021/04/22/2119-answer9/">天赐问答9: 不完美, 才会独一无二</a></li>
<li><a href="https://draapho.github.io/2021/04/23/2120-answer10/">天赐问答10: 不要辜负你的生命</a></li>
<li><a href="https://draapho.github.io/2021/04/24/2121-answer11/">天赐问答11: 100多年前的马克思主义, 过时了吗?</a></li>
<li><a href="https://draapho.github.io/2021/04/25/2122-believe/">我们到底该信什么，不该信什么？</a></li>
</ul>
<p>以上所有内容, 皆转载自微信公众号: 自愈之光<br>此系列为灵天赐入道开悟后的资料收集.</p>
<hr>
<p>QQ群教导——1：</p>
<p>今天，和大家聊聊关于“信”的问题。<br>寻求心灵成长时，往往面临一个很大的混乱。<br>即——不知道自己什么该信，什么不该信，也不知道自己信的是对的，还是错的。</p>
<p>甚至有些错误的东西，越是深信不疑，伤害自己也就越深。<br>就像不小心跌入一个泥潭之中，越挣扎陷入越深，陷入越深越是自我麻醉，反而拒绝别人伸出的援手。</p>
<p>各种修行相关的资料层出不穷，各种大师每天都在说这个，说那个。<br>这个听起来很厉害，那个听起来也不错，好像什么都没问题，又好像什么都有问题。<br>这种状态，就像一个溺水的人，拼命的试图抓住急流中从自己身边流过的任何事物。<br>却忘记了最重要的事情，就是游到岸边。</p>
<p>事实上，一切教导很重要。<br>一切教导，也没你想的那么重要。</p>
<p>对于这种情况，我的建议是：<br><strong>不要相信</strong></p>
<p>是的，凡是你所无法验证的东西，不要相信。<br>凡是你所无法证实的东西，不要相信。<br>凡是你不能亲见亲证的东西，不要相信。<br>凡是你所不确定的东西，不要相信。</p>
<p>当然，这种不要相信，不是让你自高自傲，自以为是的批判别人、审视别人。<br>而是你必须深刻认识到——自己的无知。<br>同时，不再轻率的将别人的已知，视为自己的已知。<br>抱着谦虚的心态，学习别人的方法，学习别人的练习方式，学习别人的智慧。</p>
<p>对那些你无法验证的，无法亲见的部分。<br>将其视为不存在，不会让你错过任何事情，也不会让你错过任何教导。<br>凡是你所不能亲证的，就说明是你当下不需要的，将其舍去即可。<br>无论你如何舍去，都一定不会犯错。<br>只会让你的路线变得更清晰，让你的道路变得更清晰，让你的成长变得更清晰。</p>
<p>无论发生了什么，无论别人讲了什么，只以你的切身经历为基础。<br>不去相信别人想让你相信的，也不因为别人的言语而动摇自己的经历。<br>这就是一位真修行者所应具备的基础品质——“坚定”。</p>
<p>如释迦牟尼说过，十种不要相信：<br>第一、不因为他人的口传、传说，就信以为真<br>第二、不因为奉行传统就信以为真<br>第三、不因为是正在流传的消息，就信以为真<br>第四、不因为是宗教经典书本，就信以为真<br>第五、不因为根据逻辑-就信以为真<br>第六、不因为根据哲理-就信以为真<br>第七、不因为符合常识-外在推理，就信以为真<br>第八、不因为符合自己的-预测、见解、观念，就信以为真<br>第九、不因为演说者的威信就信以为真<br>第十、不因为他是导师、大师就信以为真</p>
<p>举个实例，如今的汉传佛教中盛行的种种经典，都有待商榷。<br>真正最贴合原意，被篡改最少的经典，并非古人翻译梵文经典，而得到的种种经典。<br>而是现代人，通过科学考据最早的古代巴利文文献，直接翻译出的巴利三藏。<br>如果，是宗教人士。<br>迷信现在的佛教里的各种经典，基本已跑偏到不知哪里去了。</p>
<p>更何况，最狂热的宗教徒，也不得不承认。<br>曾经的释迦牟尼，及其弟子：<br>从不烧香，从不塑像，从不拜泥，从不自残，从不苦行，从不许愿，从不念咒，从不做法，从不算命 ，从不持有金钱。<br>再看现在的佛和子，几乎没有释迦牟尼口中的真沙门，也几乎没有释迦牟尼的真子弟了。</p>
<p><strong>耶稣没有创建基督教，释迦牟尼没有创建佛教，老子没有创建道教。</strong><br><strong>耶稣的教导，被后人反复添加和篡改过；</strong><br><strong>释迦牟尼的教导，被后人反复添加和篡改过。</strong><br><strong>老子的教导，也被后人反复篡改过。</strong></p>
<p><strong>耶稣最惨，因为教导学生而在十字架上被钉死，后人继续借用他‘爱’的名义，去审判与惩罚他们眼中的‘异教徒’。</strong><br><strong>释迦牟尼其次，病逝之后，留下的教导被后人改得面目全非，张冠李戴，自创经典，结果完全变成另外一种非他本意的东西。</strong></p>
<p><strong>至于老子，一生仅留传下一本书，也没收过几个弟子。</strong><br><strong>因而，能被篡改的机会不多，人们只好狠狠改了改《道德经》里的许多字句了事。</strong></p>
<p>任何人，应时常提醒自己，上面黑体字的事实。<br>因此，不要将基督徒、佛教徒、道教徒们的表现，与当初的圣人等同。</p>
<p>圣人之所以是圣人，自有其深邃的智慧。<br>可从现代考据出现的原版经典中，窥探一二。</p>
<p>三位圣人，没有任何一位真的有兴趣去著书立说，有兴趣去扬名立万。<br>他们，只是在教导与分享，他们自己所发现的智慧。</p>
<p>科技是可以被继承的，精神是不能被继承的。<br>因此，圣人们的智慧，代表了人类精神文明所能到达的高度。</p>
<p>现代人类在科技上，已远超当时的古人。<br>然而，在拜物教与现代消费主义的毒害下，精神层面并没有得到多大发展。</p>
<p>连考古发现的，早期的释迦牟尼巴利文三藏，也未必是完全没有被篡改过的东西。<br>任何东西，流传超过一百年，便有人的自我，会忍不住向经典中添加各种自以为是的想法以及见解。</p>
<p>人的自我，仿佛污秽。<br>将人们的心灵层层蒙蔽，并自以为没有问题，觉得一切好极了。<br>以至于，不但不尊敬圣人的知识，反而不断动手涂涂改改，且自认为在做正确的事情。</p>
<p>举个形象的例子：<br>被自我缠身的人，仿佛以粪便涂抹全身，与周围人在一起，只是粪便的多少。<br>这样的人，非但不觉其臭，反而自以为香。</p>
<p>有人实在过臭，以至于其他涂粪的人也受不了。<br>自我共鸣之下，人们便对看不惯的人，展开攻击。</p>
<p>彼此不断纠缠，互相泼粪，误以为自己在不断进步。<br>也是为什么，释迦牟尼讲“不要相信” 的真谛所在。<br>不轻易信以为真，才不会轻易陷入自我之中，与其他自我相互膨胀，彼此助长。</p>
<p>所以，到底什么可以相信？什么不可以相信？</p>
<p>举例：<br>有一个人，教导了种种获得智慧的练习方法，还谈到了轮回以及前世今生。<br>如果，你对这个人的有感应，你觉得这个人是有智慧的。<br>那么，你可以相信他所提到的练习方法，去认真的练习，然后感受这些方法的有效以及无效。<br>有效的便吸纳，无效的便放弃。</p>
<p>至于这个人所讲的轮回、前世今生、宇宙真谛等等你所未曾见证，未曾亲见的事情。<br>不必相信，视其为不存在即可。</p>
<p>如此，你不断做下去。<br>如果这个人讲的方法是真实有效的，那么你的现实之中一定会有相应的效果，从细微到巨大，从微弱到强烈。<br>而他所见的东西，当你拥有了同样的智慧时，也一定可以亲自见证。<br>那些你所无法证实的东西，无论你亲自见证还是没有亲自见证，都不会有任何影响。</p>
<p>如果，这个人讲的都是虚假的，那么他的练习方法也一定无效，现实中给你的效果一定细微而又微弱。<br>连练习的方法都是无效的，无论这个人讲的听起来多么有道理，无论听起来多么真实，都一律不必相信。</p>
<p>即使，他讲的那些你所无法证实的东西，万一都是真的。<br>可这也说明他没有给你真实有效的练习方式，说明这个人心地是坏的。<br>更说明，你完全不必向他学习，这人不是圣者，也不是贤者。</p>
<p>在我这里，也是一样。<br>有时候，有人问我轮回。<br>我讲轮回，是因为我曾亲眼见过轮回到底是怎样的，死后到底是怎样的，所以我才讲我见的部分。<br>你们没有亲眼见证过轮回是怎样的，死后到底是怎样的。<br>即使听我讲了，你们也无法确认我所讲的到底是真实，还是虚假。</p>
<p>除非家里亲人去世，迫切需要知晓一些这方面的。<br>一般，不要问我这方面的问题，对你而言没有任何意义。</p>
<p>没有绝对不变的真理，这也是为什么，释迦牟尼不谈死后是否有灵魂还是没有，也不谈灵魂和身体是相同还是不同。<br>因为，对于不同境界、不同层次、不同视角下，这个答案本身也是不断变化的。</p>
<p>所以，无论你试图去相信，还是试图不去相信，都没有任何意义。<br>只需将这些东西，视为不存在即可。</p>
<p>比如这个世界的底层架构，因我亲眼见过。<br>所以，我才会说。</p>
<p>而你们没有亲见，就不要相信我所说。<br>直到你们自己，真正见证为止。</p>
<p>像我讲的那些你们所无法验证的东西，到底是真是假，与我教给你们的练习方法，没有任何关系。<br>真正听了教导，开始在生活中练习观察的人。<br>不需要一年、两年，哪怕只是一周、两周，你都会感觉到自己和原来的明显不同。<br>随着观察的持续，自然而然就会发觉，你自己的不断变化。<br>去看了我推荐的资料，看完之后。<br>从心态上、认知上还有生活中，都会开始出现好的变化。</p>
<p>这些是真实不虚的，只认这一点就好了。<br>知道这个方法真实有效，就已经足够了。</p>
<p>我所教给你的方法，自然是我曾经练习过的，对我也真实有效的东西。<br>自然，对你也真实有效。<br>那么，总有一天，你会有机会见证我所见证的，知晓我所知晓的。<br>我此刻所说的，是否绝对真实，对于当下的你而言，都不重要。<br>等你真正到达的时候，自然会明白。</p>
<p>如此，心智便摒弃了一切无关干扰，从而能专心走在自己的成长之路上。<br>也正是这种状态，才能真正让你走得更快，而不被书本、经典、老师所疑惑。<br>从而觉醒真正的智慧，而非自以为是的傲慢。</p>
<p>所以，问答不必问我，你所无法验证的事情，对你自己而言，没有任何意义。<br>只问我你所能验证的事情，能对你真正有帮助的事情。<br>这些，才是真正重要的问题。</p>
<p>灵天赐<br>2021年4月23日</p>
]]></content>
      <categories>
        <category>灵天赐</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>Python线程同步机制(Locks, RLocks, Semaphores, Conditions, Events和Queues)</title>
    <url>/2016/11/03/1615-python-ipc/</url>
    <content><![CDATA[<p><em><strong>转载自 <a href="http://yoyzhou.github.io/blog/2013/02/28/python-threads-synchronization-locks/">Zhou’s Blog, Python线程同步机制: Locks, RLocks, Semaphores, Conditions, Events和Queues</a></strong></em><br><em><strong>翻译自 <a href="http://www.laurentluce.com/posts/python-threads-synchronization-locks-rlocks-semaphores-conditions-events-and-queues/">Laurent Luce, Python threads synchronization: Locks, RLocks, Semaphores, Conditions, Events and Queues</a></strong></em></p>
<hr>
<p>本文详细地阐述了Python线程同步机制。你将学习到以下有关Python线程同步机制：Lock，RLock，Semaphore，Condition，Event和Queue，还有Python的内部是如何实现这些机制的。 本文给出的程序的源代码可以在github上找到。</p>
<p>首先让我们来看一个没有使用线程同步的简单程序。</p>
<h1 id="线程（Threading）"><a href="#线程（Threading）" class="headerlink" title="线程（Threading）"></a>线程（Threading）</h1><p>我们希望编程一个从一些URL中获得内容并且将内容写入文件的程序，完成这个程序可以不使用线程，为了加快获取的速度，我们使用2个线程，每个线程处理一半的URL。</p>
<p>注：完成这个程序的最好方式是使用一个URL队列，但是以下面的例子开始我的讲解更加合适。<br>类FetchUrls是threading.Thread的子类，他拥有一个URL列表和一个写URL内容的文件对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FetchUrls</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  下载URL内容的线程</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, urls, output</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构造器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @param urls 需要下载的URL列表</span></span><br><span class="line"><span class="string">    @param output 写URL内容的输出文件</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    threading.Thread.__init__(self)</span><br><span class="line">    self.urls = urls</span><br><span class="line">    self.output = output</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    实现父类Thread的run方法，打开URL，并且一个一个的下载URL的内容</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> self.urls:</span><br><span class="line">      url = self.urls.pop()</span><br><span class="line">      req = urllib2.Request(url)</span><br><span class="line">      <span class="keyword">try</span>:</span><br><span class="line">        d = urllib2.urlopen(req)</span><br><span class="line">      <span class="keyword">except</span> urllib2.URLError, e:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;URL %s failed: %s&#x27;</span> % (url, e.reason)</span><br><span class="line">      self.output.write(d.read())</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;write done by %s&#x27;</span> % self.name</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;URL %s fetched by %s&#x27;</span> % (url, self.name)</span><br></pre></td></tr></table></figure>

<p>main函数启动了两个线程，之后让他们下载URL内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">  <span class="comment"># URL列表1</span></span><br><span class="line">  urls1 = [<span class="string">&#x27;http://www.google.com&#x27;</span>, <span class="string">&#x27;http://www.facebook.com&#x27;</span>]</span><br><span class="line">  <span class="comment"># URL列表2</span></span><br><span class="line">  urls2 = [<span class="string">&#x27;http://www.yahoo.com&#x27;</span>, <span class="string">&#x27;http://www.youtube.com&#x27;</span>]</span><br><span class="line">  f = <span class="built_in">open</span>(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line">  t1 = FetchUrls(urls1, f)</span><br><span class="line">  t2 = FetchUrls(urls2, f)</span><br><span class="line">  t1.start()</span><br><span class="line">  t2.start()</span><br><span class="line">  t1.join()</span><br><span class="line">  t2.join()</span><br><span class="line">  f.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure>

<p>上面的程序将出现两个线程同时写一个文件的情况，导致文件一团乱码。我们需要找到一种在给定的时间里只有一个线程写文件的方法。实现的方法就是使用像锁（Locks）这样的线程同步机制。</p>
<h1 id="锁（Lock）"><a href="#锁（Lock）" class="headerlink" title="锁（Lock）"></a>锁（Lock）</h1><p>锁有两种状态：被锁（locked）和没有被锁（unlocked）。拥有acquire()和release()两种方法，并且遵循一下的规则：</p>
<ul>
<li>如果一个锁的状态是unlocked，调用acquire()方法改变它的状态为locked；</li>
<li>如果一个锁的状态是locked，acquire()方法将会阻塞，直到另一个线程调用release()方法释放了锁；</li>
<li>如果一个锁的状态是unlocked调用release()会抛出RuntimeError异常；</li>
<li>如果一个锁的状态是locked，调用release()方法改变它的状态为unlocked。</li>
</ul>
<p>解决上面两个线程同时写一个文件的问题的方法就是：我们给类FetchUrls的构造器中传入一个锁（lock），使用这个锁来保护文件操作，实现在给定的时间只有一个线程写文件。下面的代码只显示了关于lock部分的修改。完整的源码可以在threads/lock.py中找到。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FetchUrls</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, urls, output, lock</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    self.lock = lock    <span class="comment">#传入的lock对象</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> self.urls:</span><br><span class="line">      ...</span><br><span class="line">      self.lock.acquire()   <span class="comment">#获得lock对象，lock状态变为locked，并且阻塞其他线程获取lock对象（写文件的权利）</span></span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;lock acquired by %s&#x27;</span> % self.name</span><br><span class="line">      self.output.write(d.read())</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;write done by %s&#x27;</span> % self.name</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;lock released by %s&#x27;</span> % self.name</span><br><span class="line">      self.lock.release()   <span class="comment">#释放lock对象，lock状态变为unlocked，其他的线程可以重新获取lock对象</span></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">  ...</span><br><span class="line">  lock = threading.Lock()</span><br><span class="line">  ...</span><br><span class="line">  t1 = FetchUrls(urls1, f, lock)</span><br><span class="line">  t2 = FetchUrls(urls2, f, lock)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p><img src="https://draapho.github.io/images/1615/lock.png" alt="lock"></p>
<p>以下是程序的输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python locks.py</span></span><br><span class="line">lock acquired by Thread-2</span><br><span class="line">write done by Thread-2</span><br><span class="line">lock released by Thread-2</span><br><span class="line">URL http://www.youtube.com fetched by Thread-2</span><br><span class="line">lock acquired by Thread-1</span><br><span class="line">write done by Thread-1</span><br><span class="line">lock released by Thread-1</span><br><span class="line">URL http://www.facebook.com fetched by Thread-1</span><br><span class="line">lock acquired by Thread-2</span><br><span class="line">write done by Thread-2</span><br><span class="line">lock released by Thread-2</span><br><span class="line">URL http://www.yahoo.com fetched by Thread-2</span><br><span class="line">lock acquired by Thread-1</span><br><span class="line">write done by Thread-1</span><br><span class="line">lock released by Thread-1</span><br><span class="line">URL http://www.google.com fetched by Thread-1</span><br></pre></td></tr></table></figure>

<p>从上面的输出我们可以看出，写文件的操作被锁保护，没有出现两个线程同时写一个文件的现象。</p>
<p>下面我们看一下Python内部是如何实现锁（Lock）的。我正在使用的Python版本是Linux操作系统上的Python 2.6.6。</p>
<p>threading模块的Lock()方法就是thread.allocate_lock，代码可以在Lib/threading.py中找到。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Lock = _allocate_lock</span><br><span class="line">_allocate_lock = thread.allocate_lock</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>C的实现在Python/thread_pthread.h中。程序假定你的系统支持POSIX信号量（semaphores）。sem_init()初始化锁（Lock）所在地址的信号量。初始的信号量值是1，意味着锁没有被锁（unlocked）。信号量将在处理器的不同线程之间共享。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyThread_type_lock</span><br><span class="line">PyThread_allocate_lock(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    lock = (<span class="keyword">sem_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">sem_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        status = sem_init(lock,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        CHECK_STATUS(<span class="string">&quot;sem_init&quot;</span>);</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当acquire()方法被调用时，下面的C代码将被执行。默认的waitflag值是1，表示调用将被被阻塞直到锁被释放。sem_wait()方法减少信号量的值或者被阻塞直到信号量大于零。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">PyThread_acquire_lock(PyThread_type_lock lock, <span class="keyword">int</span> waitflag)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (waitflag)</span><br><span class="line">            status = fix_status(sem_wait(thelock));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            status = fix_status(sem_trywait(thelock));</span><br><span class="line">    &#125; <span class="keyword">while</span> (status == EINTR); <span class="comment">/* Retry if interrupted by a signal */</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当release()方法被调用时，下面的C代码将被执行。sem_post()方法增加信号量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">PyThread_release_lock(PyThread_type_lock lock)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    status = sem_post(thelock);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将锁（Lock）与“with”语句一起使用，锁可以作为上下文管理器（context manager）。使用“with”语句的好处是：当程序执行到“with”语句时，acquire()方法将被调用，当程序执行完“with”语句时，release()方法会被调用（译注：这样我们就不用显示地调用acquire()和release()方法，而是由“with”语句根据上下文来管理锁的获取和释放。）下面我们用“with”语句重写FetchUrls类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FetchUrls</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> self.urls:</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">with</span> self.lock:   <span class="comment">#使用“with”语句管理锁的获取和释放</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;lock acquired by %s&#x27;</span> % self.name</span><br><span class="line">        self.output.write(d.read())</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;write done by %s&#x27;</span> % self.name</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;lock released by %s&#x27;</span> % self.name</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>


<h1 id="可重入锁（RLock）"><a href="#可重入锁（RLock）" class="headerlink" title="可重入锁（RLock）"></a>可重入锁（RLock）</h1><p>RLock是可重入锁（reentrant lock），acquire()能够不被阻塞的被同一个线程调用多次。要注意的是release()需要调用与acquire()相同的次数才能释放锁。</p>
<p>使用Lock，下面的代码第二次调用acquire()时将被阻塞：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lock = threading.Lock()</span><br><span class="line">lock.acquire()</span><br><span class="line">lock.acquire()</span><br></pre></td></tr></table></figure>

<p>如果你使用的是RLock，下面的代码第二次调用acquire()不会被阻塞:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rlock = threading.RLock()</span><br><span class="line">rlock.acquire()</span><br><span class="line">rlock.acquire()</span><br></pre></td></tr></table></figure>

<p>RLock使用的同样是thread.allocate_lock()，不同的是他跟踪宿主线程（the owner thread）来实现可重入的特性。下面是RLock的acquire()实现。如果调用acquire()的线程是资源的所有者，记录调用acquire()次数的计数器就会加1。如果不是，就将试图去获取锁。线程第一次获得锁时，锁的拥有者将会被保存，同时计数器初始化为1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire</span>(<span class="params">self, blocking=<span class="number">1</span></span>):</span></span><br><span class="line">    me = _get_ident()</span><br><span class="line">    <span class="keyword">if</span> self.__owner == me:</span><br><span class="line">        self.__count = self.__count + <span class="number">1</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    rc = self.__block.acquire(blocking)</span><br><span class="line">    <span class="keyword">if</span> rc:</span><br><span class="line">        self.__owner = me</span><br><span class="line">        self.__count = <span class="number">1</span></span><br><span class="line">        ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> rc</span><br></pre></td></tr></table></figure>

<p>下面我们看一下可重入锁（RLock）的release()方法。首先它会去确认调用者是否是锁的拥有者。如果是的话，计数器减1；如果计数器为0，那么锁将会被释放，这时其他线程就可以去获取锁了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">release</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">if</span> self.__owner != _get_ident():</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;cannot release un-acquired lock&quot;</span>)</span><br><span class="line">    self.__count = count = self.__count - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> count:</span><br><span class="line">        self.__owner = <span class="literal">None</span></span><br><span class="line">        self.__block.release()</span><br><span class="line">        ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>


<h1 id="条件（Condition）"><a href="#条件（Condition）" class="headerlink" title="条件（Condition）"></a>条件（Condition）</h1><p>条件同步机制是指：一个线程等待特定条件，而另一个线程发出特定条件满足的信号。 解释条件同步机制的一个很好的例子就是生产者/消费者（producer/consumer）模型。生产者随机的往列表中“生产”一个随机整数，而消费者从列表中“消费”整数。完整的源码可以在threads/condition.py中找到</p>
<p>在producer类中，producer获得锁，生产一个随机整数，通知消费者有了可用的“商品”，并且释放锁。producer无限地向列表中添加整数，同时在两个添加操作中间随机的停顿一会儿。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  向列表中生产随机整数</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, integers, condition</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构造器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @param integers 整数列表</span></span><br><span class="line"><span class="string">    @param condition 条件同步对象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    threading.Thread.__init__(self)</span><br><span class="line">    self.integers = integers</span><br><span class="line">    self.condition = condition</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    实现Thread的run方法。在随机时间向列表中添加一个随机整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      integer = random.randint(<span class="number">0</span>, <span class="number">256</span>)</span><br><span class="line">      self.condition.acquire()  <span class="comment">#获取条件锁</span></span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;condition acquired by %s&#x27;</span> % self.name</span><br><span class="line">      self.integers.append(integer)</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;%d appended to list by %s&#x27;</span> % (integer, self.name)</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;condition notified by %s&#x27;</span> % self.name</span><br><span class="line">      self.condition.notify()   <span class="comment">#唤醒消费者线程</span></span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;condition released by %s&#x27;</span> % self.name</span><br><span class="line">      self.condition.release()  <span class="comment">#释放条件锁</span></span><br><span class="line">      time.sleep(<span class="number">1</span>)     <span class="comment">#暂停1秒钟</span></span><br></pre></td></tr></table></figure>

<p>下面是消费者（consumer）类。它获取锁，检查列表中是否有整数，如果没有，等待生产者的通知。当消费者获取整数之后，释放锁。<br>注意在wait()方法中会释放锁，这样生产者就能获得资源并且生产“商品”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  从列表中消费整数</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, integers, condition</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构造器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @param integers 整数列表</span></span><br><span class="line"><span class="string">    @param condition 条件同步对象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    threading.Thread.__init__(self)</span><br><span class="line">    self.integers = integers</span><br><span class="line">    self.condition = condition</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    实现Thread的run()方法，从列表中消费整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      self.condition.acquire()  <span class="comment">#获取条件锁</span></span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;condition acquired by %s&#x27;</span> % self.name</span><br><span class="line">      <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> self.integers:   <span class="comment">#判断是否有整数</span></span><br><span class="line">          integer = self.integers.pop()</span><br><span class="line">          <span class="built_in">print</span> <span class="string">&#x27;%d popped from list by %s&#x27;</span> % (integer, self.name)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;condition wait by %s&#x27;</span> % self.name</span><br><span class="line">        self.condition.wait()   <span class="comment">#等待商品，并且释放资源</span></span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;condition released by %s&#x27;</span> % self.name</span><br><span class="line">      self.condition.release()  <span class="comment">#最后释放条件锁</span></span><br></pre></td></tr></table></figure>

<p><img src="https://draapho.github.io/images/1615/condition.png" alt="condition"></p>
<p>下面我们编写main方法，创建两个线程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">  integers = []</span><br><span class="line">  condition = threading.Condition()</span><br><span class="line">  t1 = Producer(integers, condition)</span><br><span class="line">  t2 = Consumer(integers, condition)</span><br><span class="line">  t1.start()</span><br><span class="line">  t2.start()</span><br><span class="line">  t1.join()</span><br><span class="line">  t2.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure>

<p>下面是程序的输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python condition.py</span></span><br><span class="line">condition acquired by Thread-1</span><br><span class="line">159 appended to list by Thread-1</span><br><span class="line">condition notified by Thread-1</span><br><span class="line">condition released by Thread-1</span><br><span class="line">condition acquired by Thread-2</span><br><span class="line">159 popped from list by Thread-2</span><br><span class="line">condition released by Thread-2</span><br><span class="line">condition acquired by Thread-2</span><br><span class="line">condition wait by Thread-2</span><br><span class="line">condition acquired by Thread-1</span><br><span class="line">116 appended to list by Thread-1</span><br><span class="line">condition notified by Thread-1</span><br><span class="line">condition released by Thread-1</span><br><span class="line">116 popped from list by Thread-2</span><br><span class="line">condition released by Thread-2</span><br><span class="line">condition acquired by Thread-2</span><br><span class="line">condition wait by Thread-2</span><br></pre></td></tr></table></figure>

<p>Thread-1添加159到列表中，通知消费者同时释放锁，Thread-2获得锁，取回159，并且释放锁。此时因为执行time.sleep(1)，生产者正在睡眠，当消费者再次试图获取整数时，列表中并没有整数，这时消费者进入等待状态，等待生产者的通知。当wait()被调用时，它会释放资源，从而生产者能够利用资源生产整数。</p>
<p>下面我们看一下Python内部是如何实现条件同步机制的。如果用户没有传入锁（lock）对象，condition类的构造器创建一个可重入锁（RLock），这个锁将会在调用acquire()和release()时使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Condition</span>(<span class="params">_Verbose</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, lock=<span class="literal">None</span>, verbose=<span class="literal">None</span></span>):</span></span><br><span class="line">        _Verbose.__init__(self, verbose)</span><br><span class="line">        <span class="keyword">if</span> lock <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            lock = RLock()</span><br><span class="line">        self.__lock = lock</span><br></pre></td></tr></table></figure>

<p>接下来是wait()方法。为了简化说明，我们假定在调用wait()方法时不使用timeout参数。wait()方法创建了一个名为waiter的锁，并且设置锁的状态为locked。这个waiter锁用于线程间的通讯，这样生产者（在生产完整数之后）就可以通知消费者释放waiter()锁。锁对象将会被添加到等待者列表，并且在调用waiter.acquire()时被阻塞。一开始condition锁的状态被保存，并且在wait()结束时被恢复。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait</span>(<span class="params">self, timeout=<span class="literal">None</span></span>):</span></span><br><span class="line">    ...</span><br><span class="line">    waiter = _allocate_lock()</span><br><span class="line">    waiter.acquire()</span><br><span class="line">    self.__waiters.append(waiter)</span><br><span class="line">    saved_state = self._release_save()</span><br><span class="line">    <span class="keyword">try</span>:    <span class="comment"># 无论如何恢复状态 (例如, KeyboardInterrupt)</span></span><br><span class="line">        <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            waiter.acquire()</span><br><span class="line">            ...</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self._acquire_restore(saved_state)</span><br></pre></td></tr></table></figure>

<p>当生产者调用notify()方法时，notify()释放waiter锁，唤醒被阻塞的消费者。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">notify</span>(<span class="params">self, n=<span class="number">1</span></span>):</span></span><br><span class="line">    ...</span><br><span class="line">    __waiters = self.__waiters</span><br><span class="line">    waiters = __waiters[:n]</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> waiter <span class="keyword">in</span> waiters:</span><br><span class="line">        waiter.release()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            __waiters.remove(waiter)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>同样Condition对象也可以和“with”语句一起使用，这样“with”语句上下文会帮我们调用acquire()和release()方法。下面的代码使用“with”语句改写了生产者和消费者类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      integer = random.randint(<span class="number">0</span>, <span class="number">256</span>)</span><br><span class="line">      <span class="keyword">with</span> self.condition:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;condition acquired by %s&#x27;</span> % self.name</span><br><span class="line">        self.integers.append(integer)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;%d appended to list by %s&#x27;</span> % (integer, self.name)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;condition notified by %s&#x27;</span> % self.name</span><br><span class="line">        self.condition.notify()</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;condition released by %s&#x27;</span> % self.name</span><br><span class="line">      time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      <span class="keyword">with</span> self.condition:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;condition acquired by %s&#x27;</span> % self.name</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">          <span class="keyword">if</span> self.integers:</span><br><span class="line">            integer = self.integers.pop()</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;%d popped from list by %s&#x27;</span> % (integer, self.name)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          <span class="built_in">print</span> <span class="string">&#x27;condition wait by %s&#x27;</span> % self.name</span><br><span class="line">          self.condition.wait()</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;condition released by %s&#x27;</span> % self.name</span><br></pre></td></tr></table></figure>


<h1 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h1><p>信号量同步基于内部计数器，每调用一次acquire()，计数器减1；每调用一次release()，计数器加1.当计数器为0时，acquire()调用被阻塞。这是迪科斯彻（Dijkstra）信号量概念P()和V()的Python实现。信号量同步机制适用于访问像服务器这样的有限资源。</p>
<p>信号量同步的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">semaphore = threading.Semaphore()</span><br><span class="line">semaphore.acquire()</span><br><span class="line"> <span class="comment"># 使用共享资源</span></span><br><span class="line">...</span><br><span class="line">semaphore.release()</span><br></pre></td></tr></table></figure>

<p>让我们看一下信号量同步在Python内部是如何实现的。构造器使用参数value来表示计数器的初始值，默认值为1。一个条件锁实例用于保护计数器，同时当信号量被释放时通知其他线程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Semaphore</span>(<span class="params">_Verbose</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value=<span class="number">1</span>, verbose=<span class="literal">None</span></span>):</span></span><br><span class="line">        _Verbose.__init__(self, verbose)</span><br><span class="line">        self.__cond = Condition(Lock())</span><br><span class="line">        self.__value = value</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>acquire()方法。如果信号量为0，线程被条件锁的wait()方法阻塞，直到被其他线程唤醒；如果计数器大于0，调用acquire()使计数器减1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire</span>(<span class="params">self, blocking=<span class="number">1</span></span>):</span></span><br><span class="line">    rc = <span class="literal">False</span></span><br><span class="line">    self.__cond.acquire()</span><br><span class="line">    <span class="keyword">while</span> self.__value == <span class="number">0</span>:</span><br><span class="line">        ...</span><br><span class="line">        self.__cond.wait()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.__value = self.__value - <span class="number">1</span></span><br><span class="line">        rc = <span class="literal">True</span></span><br><span class="line">    self.__cond.release()</span><br><span class="line">    <span class="keyword">return</span> rc</span><br></pre></td></tr></table></figure>

<p>信号量类的release()方法增加计数器的值并且唤醒其他线程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">release</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.__cond.acquire()</span><br><span class="line">    self.__value = self.__value + <span class="number">1</span></span><br><span class="line">    self.__cond.notify()</span><br><span class="line">    self.__cond.release()</span><br></pre></td></tr></table></figure>

<p>还有一个“有限”(bounded)信号量类，可以确保release()方法的调用次数不能超过给定的初始信号量数值(value参数)，下面是“有限”信号量类的Python代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BoundedSemaphore</span>(<span class="params">_Semaphore</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;检查release()的调用次数是否小于等于acquire()次数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value=<span class="number">1</span>, verbose=<span class="literal">None</span></span>):</span></span><br><span class="line">        _Semaphore.__init__(self, value, verbose)</span><br><span class="line">        self._initial_value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">release</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self._Semaphore__value &gt;= self._initial_value:</span><br><span class="line">            <span class="keyword">raise</span> ValueError, <span class="string">&quot;Semaphore released too many times&quot;</span></span><br><span class="line">        <span class="keyword">return</span> _Semaphore.release(self)</span><br></pre></td></tr></table></figure>

<p>样信号量(Semaphore)对象可以和“with”一起使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">semaphore = threading.Semaphore()</span><br><span class="line"><span class="keyword">with</span> semaphore:</span><br><span class="line">  <span class="comment"># 使用共享资源</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>


<h1 id="事件（Event）"><a href="#事件（Event）" class="headerlink" title="事件（Event）"></a>事件（Event）</h1><p>基于事件的同步是指：一个线程发送/传递事件，另外的线程等待事件的触发。 让我们再来看看前面的生产者和消费者的例子，现在我们把它转换成使用事件同步而不是条件同步。完整的源码可以在threads/event.py里面找到。</p>
<p>首先是生产者类，我们传入一个Event实例给构造器而不是Condition实例。一旦整数被添加进列表，事件(event)被设置和发送去唤醒消费者。注意事件(event)实例默认是被发送的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  向列表中生产随机整数</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, integers, event</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构造器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @param integers 整数列表</span></span><br><span class="line"><span class="string">    @param event 事件同步对象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    threading.Thread.__init__(self)</span><br><span class="line">    self.integers = integers</span><br><span class="line">    self.event = event</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    实现Thread的run方法。在随机时间向列表中添加一个随机整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      integer = random.randint(<span class="number">0</span>, <span class="number">256</span>)</span><br><span class="line">      self.integers.append(integer)</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;%d appended to list by %s&#x27;</span> % (integer, self.name)</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;event set by %s&#x27;</span> % self.name</span><br><span class="line">      self.event.<span class="built_in">set</span>()      <span class="comment">#设置事件</span></span><br><span class="line">      self.event.clear()    <span class="comment">#发送事件</span></span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;event cleared by %s&#x27;</span> % self.name</span><br><span class="line">      time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>同样我们传入一个Event实例给消费者的构造器，消费者阻塞在wait()方法，等待事件被触发，即有可供消费的整数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   从列表中消费整数</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, integers, event</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构造器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @param integers 整数列表</span></span><br><span class="line"><span class="string">    @param event 事件同步对象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    threading.Thread.__init__(self)</span><br><span class="line">    self.integers = integers</span><br><span class="line">    self.event = event</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    实现Thread的run()方法，从列表中消费整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      self.event.wait() <span class="comment">#等待事件被触发</span></span><br><span class="line">      <span class="keyword">try</span>:</span><br><span class="line">        integer = self.integers.pop()</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;%d popped from list by %s&#x27;</span> % (integer, self.name)</span><br><span class="line">      <span class="keyword">except</span> IndexError:</span><br><span class="line">        <span class="comment"># catch pop on empty list</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://draapho.github.io/images/1615/event.png" alt="event"></p>
<p>下面是程序的输出，Thread-1添加124到整数列表中，然后设置事件并且唤醒消费者。消费者从wait()方法中唤醒，在列表中获取到整数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python event.py</span></span><br><span class="line">124 appended to list by Thread-1</span><br><span class="line">event set by Thread-1</span><br><span class="line">event cleared by Thread-1</span><br><span class="line">124 popped from list by Thread-2</span><br><span class="line">223 appended to list by Thread-1</span><br><span class="line">event set by Thread-1</span><br><span class="line">event cleared by Thread-1</span><br><span class="line">223 popped from list by Thread-2</span><br></pre></td></tr></table></figure>

<p>事件锁的Python内部实现，首先是Event锁的构造器。构造器中创建了一个条件（Condition）锁，来保护事件标志（event flag）,同事唤醒其他线程当事件被设置时。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Event</span>(<span class="params">_Verbose</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, verbose=<span class="literal">None</span></span>):</span></span><br><span class="line">        _Verbose.__init__(self, verbose)</span><br><span class="line">        self.__cond = Condition(Lock())</span><br><span class="line">        self.__flag = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>接下来是set()方法，它设置事件标志为True，并且唤醒其他线程。条件锁对象保护程序修改事件标志状态的关键部分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.__cond.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self.__flag = <span class="literal">True</span></span><br><span class="line">        self.__cond.notify_all()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self.__cond.release()</span><br></pre></td></tr></table></figure>

<p>而clear()方法正好相反，它设置时间标志为False。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clear</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.__cond.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self.__flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self.__cond.release()</span><br></pre></td></tr></table></figure>

<p>最后，wait()方法将阻塞直到调用了set()方法，当事件标志为True时，wait()方法就什么也不做。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait</span>(<span class="params">self, timeout=<span class="literal">None</span></span>):</span></span><br><span class="line">    self.__cond.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.__flag: <span class="comment">#如果flag不为真</span></span><br><span class="line">            self.__cond.wait(timeout)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self.__cond.release()</span><br></pre></td></tr></table></figure>


<h1 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h1><p>队列是一个非常好的线程同步机制，使用队列我们不用关心锁，队列会为我们处理锁的问题。 队列(Queue)有以下4个用户感兴趣的方法：</p>
<ul>
<li>put: 向队列中添加一个项；</li>
<li>get: 从队列中删除并返回一个项；</li>
<li>task_done: 当某一项任务完成时调用；</li>
<li>join: 阻塞直到所有的项目都被处理完。</li>
</ul>
<p>下面我们将上面的生产者/消费者的例子转换成使用队列。源代码可以在threads/queue.py中找到。</p>
<p>首先是生产者类，我们不需要传入一个整数列表，因为我们使用队列就可以存储生成的整数。生产者线程在一个无限循环中生成整数并将生成的整数添加到队列中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  向队列中生产随机整数</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, queue</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构造器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @param integers 整数列表    #译注：不需要这个参数</span></span><br><span class="line"><span class="string">    @param queue 队列同步对象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    threading.Thread.__init__(self)</span><br><span class="line">    self.queue = queue</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    实现Thread的run方法。在随机时间向队列中添加一个随机整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      integer = random.randint(<span class="number">0</span>, <span class="number">256</span>)</span><br><span class="line">      self.queue.put(integer)   <span class="comment">#将生成的整数添加到队列</span></span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;%d put to queue by %s&#x27;</span> % (integer, self.name)</span><br><span class="line">      time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>下面是消费者类。线程从队列中获取整数，并且在任务完成时调用task_done()方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  从队列中消费整数</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, queue</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构造器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @param integers 整数列表    #译注：不需要这个参数</span></span><br><span class="line"><span class="string">    @param queue 队列同步对象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    threading.Thread.__init__(self)</span><br><span class="line">    self.queue = queue</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    实现Thread的run()方法，从队列中消费整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      integer = self.queue.get()</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;%d popped from list by %s&#x27;</span> % (integer, self.name)</span><br><span class="line">      self.queue.task_done()</span><br></pre></td></tr></table></figure>

<p>以下是程序的输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python queue.py</span></span><br><span class="line">61 put to queue by Thread-1</span><br><span class="line">61 popped from list by Thread-2</span><br><span class="line">6 put to queue by Thread-1</span><br><span class="line">6 popped from list by Thread-2</span><br></pre></td></tr></table></figure>

<p>队列同步的最大好处就是队列帮我们处理了锁。现在让我们去看看在Python内部是如何实现队列同步机制的。</p>
<p>队列（Queue）构造器创建一个锁，保护队列元素的添加和删除操作。同时创建了一些条件锁对象处理队列事件，比如队列不空事件（削除get()的阻塞），队列不满事件（削除put()的阻塞）和所有项目都被处理完事件（削除join()的阻塞）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, maxsize=<span class="number">0</span></span>):</span></span><br><span class="line">        ...</span><br><span class="line">        self.mutex = threading.Lock()</span><br><span class="line">        self.not_empty = threading.Condition(self.mutex)</span><br><span class="line">        self.not_full = threading.Condition(self.mutex)</span><br><span class="line">        self.all_tasks_done = threading.Condition(self.mutex)</span><br><span class="line">        self.unfinished_tasks = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>put()方法向队列中添加一个项，或者阻塞如果队列已满。这时队列非空，它唤醒阻塞在get()方法中的线程。更多关于Condition锁的内容请查看上面的讲解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, item, block=<span class="literal">True</span>, timeout=<span class="literal">None</span></span>):</span></span><br><span class="line">    ...</span><br><span class="line">    self.not_full.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> self.maxsize &gt; <span class="number">0</span>:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">elif</span> timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">while</span> self._qsize() == self.maxsize:</span><br><span class="line">                    self.not_full.wait()</span><br><span class="line">        self._put(item)</span><br><span class="line">        self.unfinished_tasks += <span class="number">1</span></span><br><span class="line">        self.not_empty.notify()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self.not_full.release()</span><br></pre></td></tr></table></figure>

<p>get()方法从队列中获得并删除一个项，或者阻塞当队列为空时。这时队列不满，他唤醒阻塞在put()方法中的线程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, block=<span class="literal">True</span>, timeout=<span class="literal">None</span></span>):</span></span><br><span class="line">    ...</span><br><span class="line">    self.not_empty.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">elif</span> timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self._qsize():</span><br><span class="line">                self.not_empty.wait()</span><br><span class="line">        item = self._get()</span><br><span class="line">        self.not_full.notify()</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self.not_empty.release()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当调用task_done()方法时，未完成任务的数量减1。如果未完成任务的数量为0，线程等待队列完成join()方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_done</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.all_tasks_done.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        unfinished = self.unfinished_tasks - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> unfinished &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> unfinished &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">&#x27;task_done() called too many times&#x27;</span>)</span><br><span class="line">            self.all_tasks_done.notify_all()</span><br><span class="line">        self.unfinished_tasks = unfinished</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self.all_tasks_done.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.all_tasks_done.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> self.unfinished_tasks:</span><br><span class="line">            self.all_tasks_done.wait()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self.all_tasks_done.release()</span><br></pre></td></tr></table></figure>

<p><img src="https://draapho.github.io/images/1615/queue.png" alt="queue"></p>
<p>本文到此结束，希望您喜欢这篇文章。欢迎您的留言和反馈。</p>
<hr>
<p><em><strong>转载自 <a href="http://yoyzhou.github.io/blog/2013/02/28/python-threads-synchronization-locks/">Zhou’s Blog, Python线程同步机制: Locks, RLocks, Semaphores, Conditions, Events和Queues</a></strong></em><br><em><strong>翻译自 <a href="http://www.laurentluce.com/posts/python-threads-synchronization-locks-rlocks-semaphores-conditions-events-and-queues/">Laurent Luce, Python threads synchronization: Locks, RLocks, Semaphores, Conditions, Events and Queues</a></strong></em></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>线程同步</tag>
      </tags>
  </entry>
  <entry>
    <title>30 个有关 Python 的小技巧</title>
    <url>/2016/11/22/1619-python-tips/</url>
    <content><![CDATA[<p><em><strong>转载自 <a href="http://sahandsaba.com/thirty-python-language-features-and-tricks-you-may-not-know.html">30 Python Language Features and Tricks You May Not Know About</a></strong></em><br><em><strong>中文版 <a href="http://blog.jobbole.com/63320/">30个有关Python的小技巧</a></strong></em></p>
<hr>
<h1 id="批量赋值"><a href="#批量赋值" class="headerlink" title="批量赋值"></a>批量赋值</h1><h2 id="Unpacking"><a href="#Unpacking" class="headerlink" title="Unpacking"></a>Unpacking</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = (<span class="number">2</span> * i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, (b, c), d = [<span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>), <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="Unpacking-for-swapping-variables"><a href="#Unpacking-for-swapping-variables" class="headerlink" title="Unpacking for swapping variables"></a>Unpacking for swapping variables</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = b, a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Extended-unpacking-Python-3-only"><a href="#Extended-unpacking-Python-3-only" class="headerlink" title="Extended unpacking (Python 3 only)"></a>Extended unpacking (Python 3 only)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *b, c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>



<h1 id="list-amp-dictionary-列表和字典"><a href="#list-amp-dictionary-列表和字典" class="headerlink" title="list &amp; dictionary / 列表和字典"></a>list &amp; dictionary / 列表和字典</h1><h2 id="Negative-indexing"><a href="#Negative-indexing" class="headerlink" title="Negative indexing"></a>Negative indexing</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[-<span class="number">1</span>]</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[-<span class="number">3</span>]</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<h2 id="List-slices-a-start-end"><a href="#List-slices-a-start-end" class="headerlink" title="List slices (a[start:end])"></a>List slices (a[start:end])</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">8</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<h2 id="List-slices-with-negative-indexing"><a href="#List-slices-with-negative-indexing" class="headerlink" title="List slices with negative indexing"></a>List slices with negative indexing</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[-<span class="number">4</span>:-<span class="number">2</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<h2 id="List-slices-with-step-a-start-end-step"><a href="#List-slices-with-step-a-start-end-step" class="headerlink" title="List slices with step (a[start:end:step])"></a>List slices with step (a[start:end:step])</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::<span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::<span class="number">3</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">8</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<h2 id="List-slices-with-negative-step"><a href="#List-slices-with-negative-step" class="headerlink" title="List slices with negative step"></a>List slices with negative step</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::-<span class="number">1</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::-<span class="number">2</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h2 id="List-slice-assignment-切割并赋值"><a href="#List-slice-assignment-切割并赋值" class="headerlink" title="List slice assignment / 切割并赋值"></a>List slice assignment / 切割并赋值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">3</span>] = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:<span class="number">1</span>] = [<span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:-<span class="number">1</span>] = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<h2 id="for循环取list的索引和值-enumerate"><a href="#for循环取list的索引和值-enumerate" class="headerlink" title="for循环取list的索引和值 (enumerate)"></a>for循环取list的索引和值 (enumerate)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;!&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(a):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&#x27;&#123;&#125;: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i, x)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span>: Hello</span><br><span class="line"><span class="number">1</span>: world</span><br><span class="line"><span class="number">2</span>: !</span><br></pre></td></tr></table></figure>

<h2 id="list加入索引值-enumerate"><a href="#list加入索引值-enumerate" class="headerlink" title="list加入索引值 (enumerate)"></a>list加入索引值 (enumerate)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seasons = [<span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>, <span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">&#x27;Spring&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;Summer&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;Fall&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;Winter&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons, start=<span class="number">1</span>))</span><br><span class="line">[(<span class="number">1</span>, <span class="string">&#x27;Spring&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;Summer&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;Fall&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;Winter&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="Naming-slices-slice-start-end-step-给切割操作命名"><a href="#Naming-slices-slice-start-end-step-给切割操作命名" class="headerlink" title="Naming slices (slice(start, end, step)) / 给切割操作命名"></a>Naming slices (slice(start, end, step)) / 给切割操作命名</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LASTTHREE = <span class="built_in">slice</span>(-<span class="number">3</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LASTTHREE</span><br><span class="line"><span class="built_in">slice</span>(-<span class="number">3</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[LASTTHREE]</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Zipping-and-unzipping-lists-and-iterables-列表以及迭代器的压缩和解压缩"><a href="#Zipping-and-unzipping-lists-and-iterables-列表以及迭代器的压缩和解压缩" class="headerlink" title="Zipping and unzipping lists and iterables / 列表以及迭代器的压缩和解压缩"></a>Zipping and unzipping lists and iterables / 列表以及迭代器的压缩和解压缩</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = <span class="built_in">zip</span>(a, b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z</span><br><span class="line">[(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">zip</span>(*z)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="Grouping-adjacent-list-items-using-zip-列表相邻元素压缩器"><a href="#Grouping-adjacent-list-items-using-zip-列表相邻元素压缩器" class="headerlink" title="Grouping adjacent list items using zip / 列表相邻元素压缩器"></a>Grouping adjacent list items using zip / 列表相邻元素压缩器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Using iterators / 使用迭代器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent = <span class="keyword">lambda</span> a, k: <span class="built_in">zip</span>(*([<span class="built_in">iter</span>(a)] * k))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">3</span>)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">2</span>)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">1</span>)</span><br><span class="line">[(<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,), (<span class="number">4</span>,), (<span class="number">5</span>,), (<span class="number">6</span>,)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Using slices / 使用切片</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent = <span class="keyword">lambda</span> a, k: <span class="built_in">zip</span>(*(islice(a, i, <span class="literal">None</span>, k) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">3</span>)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">2</span>)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group_adjacent(a, <span class="number">1</span>)</span><br><span class="line">[(<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,), (<span class="number">4</span>,), (<span class="number">5</span>,), (<span class="number">6</span>,)]</span><br></pre></td></tr></table></figure>

<h2 id="Sliding-windows-n-grams-using-zip-and-iterators-列表元素压缩器-同上方法二"><a href="#Sliding-windows-n-grams-using-zip-and-iterators-列表元素压缩器-同上方法二" class="headerlink" title="Sliding windows (n-grams) using zip and iterators / 列表元素压缩器(同上方法二)"></a>Sliding windows (n-grams) using zip and iterators / 列表元素压缩器(同上方法二)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">n_grams</span>(<span class="params">a, n</span>):</span></span><br><span class="line"><span class="meta">... </span>    z = (islice(a, i, <span class="literal">None</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="built_in">zip</span>(*z)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n_grams(a, <span class="number">3</span>)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n_grams(a, <span class="number">2</span>)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">5</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n_grams(a, <span class="number">4</span>)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="Flattening-lists-列表展开"><a href="#Flattening-lists-列表展开" class="headerlink" title="Flattening lists: / 列表展开"></a>Flattening lists: / 列表展开</h2><p>Note: according to Python’s documentation on sum, itertools.chain.from_iterable is the preferred method for this.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐使用 itertools.chain.from_iterable</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(itertools.chain.from_iterable(a))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐使用 sum</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(a, [])</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> l <span class="keyword">in</span> a <span class="keyword">for</span> x <span class="keyword">in</span> l]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], [[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> l1 <span class="keyword">in</span> a <span class="keyword">for</span> l2 <span class="keyword">in</span> l1 <span class="keyword">for</span> x <span class="keyword">in</span> l2]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], [[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flatten = <span class="keyword">lambda</span> x: [y <span class="keyword">for</span> l <span class="keyword">in</span> x <span class="keyword">for</span> y <span class="keyword">in</span> flatten(l)] <span class="keyword">if</span> <span class="built_in">type</span>(x) <span class="keyword">is</span> <span class="built_in">list</span> <span class="keyword">else</span> [x]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flatten(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<h2 id="for循环取dict的关键字和值-iteritems"><a href="#for循环取dict的关键字和值-iteritems" class="headerlink" title="for循环取dict的关键字和值 (iteritems)"></a>for循环取dict的关键字和值 (iteritems)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> m.iteritems():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&#x27;&#123;&#125;: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(k, v)</span><br><span class="line">...</span><br><span class="line">a: <span class="number">1</span></span><br><span class="line">c: <span class="number">3</span></span><br><span class="line">b: <span class="number">2</span></span><br><span class="line">d: <span class="number">4</span></span><br><span class="line">Note: use <span class="built_in">dict</span>.items <span class="keyword">in</span> Python <span class="number">3.</span></span><br></pre></td></tr></table></figure>

<h2 id="Inverting-a-dictionary-字典与表的转换-以及翻转"><a href="#Inverting-a-dictionary-字典与表的转换-以及翻转" class="headerlink" title="Inverting a dictionary / 字典与表的转换, 以及翻转"></a>Inverting a dictionary / 字典与表的转换, 以及翻转</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># using zip</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.items()</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">zip</span>(m.values(), m.keys())</span><br><span class="line">[(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;d&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mi = <span class="built_in">dict</span>(<span class="built_in">zip</span>(m.values(), m.keys()))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mi</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;c&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># using a dictionary comprehension</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> m.items()&#125;</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;c&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dictionary-comprehensions-快速生成规律性字典"><a href="#Dictionary-comprehensions-快速生成规律性字典" class="headerlink" title="Dictionary comprehensions / 快速生成规律性字典"></a>Dictionary comprehensions / 快速生成规律性字典</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = &#123;x: x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="number">3</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = &#123;x: <span class="string">&#x27;A&#x27;</span> + <span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;A0&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;A1&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;A2&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;A3&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;A4&#x27;</span>, <span class="number">5</span>: <span class="string">&#x27;A5&#x27;</span>, <span class="number">6</span>: <span class="string">&#x27;A6&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;A7&#x27;</span>, <span class="number">8</span>: <span class="string">&#x27;A8&#x27;</span>, <span class="number">9</span>: <span class="string">&#x27;A9&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>


<h1 id="语法上的一些技巧"><a href="#语法上的一些技巧" class="headerlink" title="语法上的一些技巧"></a>语法上的一些技巧</h1><h2 id="双重for循环"><a href="#双重for循环" class="headerlink" title="双重for循环"></a>双重for循环</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (<span class="string">&#x27;la&#x27;</span>,<span class="string">&#x27;luo&#x27;</span>,<span class="string">&#x27;lao&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b =(<span class="string">&#x27;hua&#x27;</span>,<span class="string">&#x27;huo&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> [(x,y) <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">for</span> y <span class="keyword">in</span> b]</span><br><span class="line">[(<span class="string">&#x27;la&#x27;</span>, <span class="string">&#x27;hua&#x27;</span>), (<span class="string">&#x27;la&#x27;</span>, <span class="string">&#x27;huo&#x27;</span>), (<span class="string">&#x27;luo&#x27;</span>, <span class="string">&#x27;hua&#x27;</span>), (<span class="string">&#x27;luo&#x27;</span>, <span class="string">&#x27;huo&#x27;</span>), (<span class="string">&#x27;lao&#x27;</span>, <span class="string">&#x27;hua&#x27;</span>), (<span class="string">&#x27;lao&#x27;</span>, <span class="string">&#x27;huo&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">zip</span>(a,b)</span><br><span class="line">[(<span class="string">&#x27;la&#x27;</span>, <span class="string">&#x27;hua&#x27;</span>), (<span class="string">&#x27;luo&#x27;</span>, <span class="string">&#x27;huo&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="python-中-switch-的替代方案"><a href="#python-中-switch-的替代方案" class="headerlink" title="python 中 switch 的替代方案"></a>python 中 switch 的替代方案</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字典映射</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numbers_to_strings</span>(<span class="params">argument</span>):</span></span><br><span class="line">    switcher = &#123;                                <span class="comment"># switch(argument) &#123;</span></span><br><span class="line">        <span class="number">0</span>: <span class="string">&quot;zero&quot;</span>,                              <span class="comment"># case 0: return &quot;zero&quot;;</span></span><br><span class="line">        <span class="number">1</span>: <span class="string">&quot;one&quot;</span>,                               <span class="comment"># case 1: return &quot;one&quot;;</span></span><br><span class="line">        <span class="number">2</span>: <span class="string">&quot;two&quot;</span>,                               <span class="comment"># case 2: return &quot;two&quot;;</span></span><br><span class="line">    &#125;                                           <span class="comment"># &#125;</span></span><br><span class="line">    <span class="keyword">return</span> switcher.get(argument, <span class="string">&quot;nothing&quot;</span>)    <span class="comment"># default: return &quot;nothing&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数的字典映射</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zero</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;zero&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;one&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numbers_to_functions_to_strings</span>(<span class="params">argument</span>):</span></span><br><span class="line">    switcher = &#123;</span><br><span class="line">        <span class="number">0</span>: zero,</span><br><span class="line">        <span class="number">1</span>: one,</span><br><span class="line">        <span class="number">2</span>: <span class="keyword">lambda</span>: <span class="string">&quot;two&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># Get the function from switcher dictionary</span></span><br><span class="line">    func = switcher.get(argument, <span class="keyword">lambda</span>: <span class="string">&quot;nothing&quot;</span>)</span><br><span class="line">    <span class="comment"># Execute the function</span></span><br><span class="line">    <span class="keyword">return</span> func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类的调度方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switcher</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numbers_to_methods_to_strings</span>(<span class="params">self, argument</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Dispatch method&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># prefix the method_name with &#x27;number_&#x27; because method names</span></span><br><span class="line">        <span class="comment"># cannot begin with an integer.</span></span><br><span class="line">        method_name = <span class="string">&#x27;number_&#x27;</span> + <span class="built_in">str</span>(argument)</span><br><span class="line">        <span class="comment"># Get the method from &#x27;self&#x27;. Default to a lambda.</span></span><br><span class="line">        method = <span class="built_in">getattr</span>(self, method_name, <span class="keyword">lambda</span>: <span class="string">&quot;nothing&quot;</span>)</span><br><span class="line">        <span class="comment"># Call the method as we return it</span></span><br><span class="line">        <span class="keyword">return</span> method()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">number_0</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;zero&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">number_1</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;one&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">number_2</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;two&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="python-仅允许单实例"><a href="#python-仅允许单实例" class="headerlink" title="python 仅允许单实例"></a>python 仅允许单实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="comment"># 关键在于这，每一次实例化的时候，我们都只会返回这同一个instance对象</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&#x27;instance&#x27;</span>):</span><br><span class="line">            cls.instance = <span class="built_in">super</span>(Singleton, cls).__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">obj1 = Singleton()</span><br><span class="line">obj2 = Singleton()</span><br><span class="line">obj1.attr1 = <span class="string">&#x27;value1&#x27;</span></span><br><span class="line"><span class="built_in">print</span> obj1.attr1, obj2.attr1</span><br><span class="line"><span class="built_in">print</span> obj1 <span class="keyword">is</span> obj2</span><br></pre></td></tr></table></figure>

<h2 id="Generator-expressions-生成器表达式"><a href="#Generator-expressions-生成器表达式" class="headerlink" title="Generator expressions / 生成器表达式"></a>Generator expressions / 生成器表达式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(x ** <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">10</span>))</span><br><span class="line"><span class="number">2025</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(x ** <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line"><span class="number">408</span></span><br></pre></td></tr></table></figure>

<h2 id="Learn-the-Zen-of-Python-打印Python之道"><a href="#Learn-the-Zen-of-Python-打印Python之道" class="headerlink" title="Learn the Zen of Python / 打印Python之道"></a>Learn the Zen of Python / 打印Python之道</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful <span class="keyword">is</span> better than ugly.</span><br><span class="line">Explicit <span class="keyword">is</span> better than implicit.</span><br><span class="line">Simple <span class="keyword">is</span> better than <span class="built_in">complex</span>.</span><br><span class="line">Complex <span class="keyword">is</span> better than complicated.</span><br><span class="line">Flat <span class="keyword">is</span> better than nested.</span><br><span class="line">Sparse <span class="keyword">is</span> better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren<span class="string">&#x27;t special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you&#x27;</span>re Dutch.</span><br><span class="line">Now <span class="keyword">is</span> better than never.</span><br><span class="line">Although never <span class="keyword">is</span> often better than *right* now.</span><br><span class="line">If the implementation <span class="keyword">is</span> hard to explain, it<span class="string">&#x27;s a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let&#x27;</span>s do more of those!</span><br></pre></td></tr></table></figure>

<h2 id="使用C语言括号替代缩进"><a href="#使用C语言括号替代缩进" class="headerlink" title="使用C语言括号替代缩进"></a>使用C语言括号替代缩进</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> __future__ <span class="keyword">import</span> braces</span><br></pre></td></tr></table></figure>


<h1 id="collections-的一些数据类型"><a href="#collections-的一些数据类型" class="headerlink" title="collections 的一些数据类型"></a>collections 的一些数据类型</h1><h2 id="Named-tuples-collections-namedtuple-类似于-C-的struct结构"><a href="#Named-tuples-collections-namedtuple-类似于-C-的struct结构" class="headerlink" title="Named tuples (collections.namedtuple) / 类似于 C 的struct结构"></a>Named tuples (collections.namedtuple) / 类似于 C 的struct结构</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> collections</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Point = collections.namedtuple(<span class="string">&#x27;Point&#x27;</span>, [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(x=<span class="number">1.0</span>, y=<span class="number">2.0</span>) <span class="comment"># 这样赋值复杂了, 可以直接 p = Point(1.0, 2.0)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p</span><br><span class="line">Point(x=<span class="number">1.0</span>, y=<span class="number">2.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.x</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.y</span><br><span class="line"><span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">coordinate = collections.namedtuple(<span class="string">&#x27;Coordinate&#x27;</span>, [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">co = coordinate(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>co[<span class="number">0</span>], co[<span class="number">1</span>]</span><br><span class="line">(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>co = coordinate._make([<span class="number">100</span>,<span class="number">200</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>co[<span class="number">0</span>], co[<span class="number">1</span>]</span><br><span class="line">(<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>co = co._replace(x = <span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>co[<span class="number">0</span>], co[<span class="number">1</span>]</span><br><span class="line">(<span class="number">30</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Inheriting-from-named-tuples-自定义-namedtuple-的运算"><a href="#Inheriting-from-named-tuples-自定义-namedtuple-的运算" class="headerlink" title="Inheriting from named tuples: / 自定义 namedtuple 的运算"></a>Inheriting from named tuples: / 自定义 namedtuple 的运算</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Point</span>(<span class="params">collections.namedtuple(<span class="params"><span class="string">&#x27;PointBase&#x27;</span>, [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>]</span>)</span>):</span></span><br><span class="line"><span class="meta">... </span>    __slots__ = ()</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> Point(x=self.x + other.x, y=self.y + other.y)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(x=<span class="number">1.0</span>, y=<span class="number">2.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = Point(x=<span class="number">2.0</span>, y=<span class="number">3.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p + q</span><br><span class="line">Point(x=<span class="number">3.0</span>, y=<span class="number">5.0</span>)   <span class="comment"># 重定义了 + 运算符.</span></span><br><span class="line"><span class="comment"># 默认结果应该是: Point(1.0, 2.0, 2.0, 3.0)</span></span><br></pre></td></tr></table></figure>

<h2 id="Sets-and-set-operations-集合及其操作"><a href="#Sets-and-set-operations-集合及其操作" class="headerlink" title="Sets and set operations / 集合及其操作"></a>Sets and set operations / 集合及其操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A</span><br><span class="line"><span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B</span><br><span class="line"><span class="built_in">set</span>([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A | B</span><br><span class="line"><span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A &amp; B</span><br><span class="line"><span class="built_in">set</span>([<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A - B</span><br><span class="line"><span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B - A</span><br><span class="line"><span class="built_in">set</span>([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A ^ B   <span class="comment"># 集合异或</span></span><br><span class="line"><span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(A ^ B) == ((A - B) | (B - A))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="统计列表中元素出现的次数"><a href="#统计列表中元素出现的次数" class="headerlink" title="统计列表中元素出现的次数"></a>统计列表中元素出现的次数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myset = <span class="built_in">set</span>(mylist)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> myset:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> mylist.count(item), <span class="string">&quot; of &quot;</span>, item, <span class="string">&quot; in list&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="number">6</span>  of  <span class="number">2</span>  <span class="keyword">in</span> <span class="built_in">list</span></span><br><span class="line"><span class="number">4</span>  of  <span class="number">3</span>  <span class="keyword">in</span> <span class="built_in">list</span></span><br></pre></td></tr></table></figure>

<h2 id="Multisets-and-multiset-operations-collections-Counter-多重集合-显示元素个数"><a href="#Multisets-and-multiset-operations-collections-Counter-多重集合-显示元素个数" class="headerlink" title="Multisets and multiset operations (collections.Counter) / 多重集合(显示元素个数)"></a>Multisets and multiset operations (collections.Counter) / 多重集合(显示元素个数)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = collections.Counter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = collections.Counter([<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A</span><br><span class="line">Counter(&#123;<span class="number">2</span>: <span class="number">2</span>, <span class="number">1</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B</span><br><span class="line">Counter(&#123;<span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A | B</span><br><span class="line">Counter(&#123;<span class="number">2</span>: <span class="number">2</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A &amp; B</span><br><span class="line">Counter(&#123;<span class="number">2</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A + B</span><br><span class="line">Counter(&#123;<span class="number">2</span>: <span class="number">4</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A - B</span><br><span class="line">Counter(&#123;<span class="number">1</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B - A</span><br><span class="line">Counter(&#123;<span class="number">3</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Most-common-elements-in-an-iterable-collections-Counter-统计在可迭代器中最常出现的元素"><a href="#Most-common-elements-in-an-iterable-collections-Counter-统计在可迭代器中最常出现的元素" class="headerlink" title="Most common elements in an iterable (collections.Counter) / 统计在可迭代器中最常出现的元素"></a>Most common elements in an iterable (collections.Counter) / 统计在可迭代器中最常出现的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = collections.Counter([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A</span><br><span class="line">Counter(&#123;<span class="number">3</span>: <span class="number">4</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">4</span>: <span class="number">1</span>, <span class="number">5</span>: <span class="number">1</span>, <span class="number">6</span>: <span class="number">1</span>, <span class="number">7</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.most_common(<span class="number">1</span>)</span><br><span class="line">[(<span class="number">3</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.most_common(<span class="number">3</span>)</span><br><span class="line">[(<span class="number">3</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="Double-ended-queue-collections-deque-双向队列-近似于双向链表"><a href="#Double-ended-queue-collections-deque-双向队列-近似于双向链表" class="headerlink" title="Double-ended queue (collections.deque) / 双向队列, 近似于双向链表"></a>Double-ended queue (collections.deque) / 双向队列, 近似于双向链表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q = collections.deque()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q.appendleft(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q.extend([<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q.extendleft([<span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q</span><br><span class="line">deque([<span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q.pop()</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q.popleft()</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q</span><br><span class="line">deque([<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q.rotate(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q</span><br><span class="line">deque([<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q.rotate(-<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Q</span><br><span class="line">deque([<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="Double-ended-queue-with-maximum-length-collections-deque-限长的双向队列"><a href="#Double-ended-queue-with-maximum-length-collections-deque-限长的双向队列" class="headerlink" title="Double-ended queue with maximum length (collections.deque) / 限长的双向队列"></a>Double-ended queue with maximum length (collections.deque) / 限长的双向队列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>last_three = collections.deque(maxlen=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    last_three.append(i)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&#x27;, &#x27;</span>.join(<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> last_three)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"><span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line"><span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line"><span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span></span><br><span class="line"><span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span></span><br><span class="line"><span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h2 id="Ordered-dictionaries-collections-OrderedDict-可排序字典"><a href="#Ordered-dictionaries-collections-OrderedDict-可排序字典" class="headerlink" title="Ordered dictionaries (collections.OrderedDict) / 可排序字典"></a>Ordered dictionaries (collections.OrderedDict) / 可排序字典</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 普通字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = <span class="built_in">dict</span>((<span class="built_in">str</span>(x), x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;, &#x27;</span>.join(m.keys())</span><br><span class="line"><span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可排序字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = collections.OrderedDict((<span class="built_in">str</span>(x), x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;, &#x27;</span>.join(m.keys())</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = collections.OrderedDict((<span class="built_in">str</span>(x), x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>, <span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;, &#x27;</span>.join(m.keys())</span><br><span class="line"><span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="Default-dictionaries-collections-defaultdict-默认字典"><a href="#Default-dictionaries-collections-defaultdict-默认字典" class="headerlink" title="Default dictionaries (collections.defaultdict) / 默认字典"></a>Default dictionaries (collections.defaultdict) / 默认字典</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 普通字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = <span class="built_in">dict</span>()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = collections.defaultdict(<span class="built_in">str</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">&#x27;b&#x27;</span>] += <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = collections.defaultdict(<span class="keyword">lambda</span>: <span class="string">&#x27;[default value]&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;[default value]&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;[default value]&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="Using-default-dictionaries-to-represent-simple-trees-默认字典实现树-快速生成xml文件"><a href="#Using-default-dictionaries-to-represent-simple-trees-默认字典实现树-快速生成xml文件" class="headerlink" title="Using default dictionaries to represent simple trees / 默认字典实现树, 快速生成xml文件"></a>Using default dictionaries to represent simple trees / 默认字典实现树, 快速生成xml文件</h2><p>See <a href="https://gist.github.com/hrldcpr/2012250">One-line Tree in Python</a> for more on this.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree = <span class="keyword">lambda</span>: collections.defaultdict(tree)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = tree()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root[<span class="string">&#x27;menu&#x27;</span>][<span class="string">&#x27;id&#x27;</span>] = <span class="string">&#x27;file&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root[<span class="string">&#x27;menu&#x27;</span>][<span class="string">&#x27;value&#x27;</span>] = <span class="string">&#x27;File&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root[<span class="string">&#x27;menu&#x27;</span>][<span class="string">&#x27;menuitems&#x27;</span>][<span class="string">&#x27;new&#x27;</span>][<span class="string">&#x27;value&#x27;</span>] = <span class="string">&#x27;New&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root[<span class="string">&#x27;menu&#x27;</span>][<span class="string">&#x27;menuitems&#x27;</span>][<span class="string">&#x27;new&#x27;</span>][<span class="string">&#x27;onclick&#x27;</span>] = <span class="string">&#x27;new();&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root[<span class="string">&#x27;menu&#x27;</span>][<span class="string">&#x27;menuitems&#x27;</span>][<span class="string">&#x27;open&#x27;</span>][<span class="string">&#x27;value&#x27;</span>] = <span class="string">&#x27;Open&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root[<span class="string">&#x27;menu&#x27;</span>][<span class="string">&#x27;menuitems&#x27;</span>][<span class="string">&#x27;open&#x27;</span>][<span class="string">&#x27;onclick&#x27;</span>] = <span class="string">&#x27;open();&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root[<span class="string">&#x27;menu&#x27;</span>][<span class="string">&#x27;menuitems&#x27;</span>][<span class="string">&#x27;close&#x27;</span>][<span class="string">&#x27;value&#x27;</span>] = <span class="string">&#x27;Close&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root[<span class="string">&#x27;menu&#x27;</span>][<span class="string">&#x27;menuitems&#x27;</span>][<span class="string">&#x27;close&#x27;</span>][<span class="string">&#x27;onclick&#x27;</span>] = <span class="string">&#x27;close();&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> json.dumps(root, sort_keys=<span class="literal">True</span>, indent=<span class="number">4</span>, separators=(<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;: &#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;menu&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;file&quot;</span>,</span><br><span class="line">        <span class="string">&quot;menuitems&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;close&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;onclick&quot;</span>: <span class="string">&quot;close();&quot;</span>,</span><br><span class="line">                <span class="string">&quot;value&quot;</span>: <span class="string">&quot;Close&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;new&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;onclick&quot;</span>: <span class="string">&quot;new();&quot;</span>,</span><br><span class="line">                <span class="string">&quot;value&quot;</span>: <span class="string">&quot;New&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;open&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;onclick&quot;</span>: <span class="string">&quot;open();&quot;</span>,</span><br><span class="line">                <span class="string">&quot;value&quot;</span>: <span class="string">&quot;Open&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: <span class="string">&quot;File&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Mapping-objects-to-unique-counting-numbers-collections-defaultdict-生成对象的唯一索引值"><a href="#Mapping-objects-to-unique-counting-numbers-collections-defaultdict-生成对象的唯一索引值" class="headerlink" title="Mapping objects to unique counting numbers (collections.defaultdict) / 生成对象的唯一索引值"></a>Mapping objects to unique counting numbers (collections.defaultdict) / 生成对象的唯一索引值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools, collections</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>value_to_numeric_map = collections.defaultdict(itertools.count().<span class="built_in">next</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>value_to_numeric_map[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>value_to_numeric_map[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>value_to_numeric_map[<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>value_to_numeric_map[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>value_to_numeric_map[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="Largest-and-smallest-elements-heapq-nlargest-and-heapq-nsmallest-最大和最小的几个列表元素"><a href="#Largest-and-smallest-elements-heapq-nlargest-and-heapq-nsmallest-最大和最小的几个列表元素" class="headerlink" title="Largest and smallest elements (heapq.nlargest and heapq.nsmallest) / 最大和最小的几个列表元素"></a>Largest and smallest elements (heapq.nlargest and heapq.nsmallest) / 最大和最小的几个列表元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [random.randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> __ <span class="keyword">in</span> xrange(<span class="number">100</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.nsmallest(<span class="number">5</span>, a)</span><br><span class="line">[<span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.nlargest(<span class="number">5</span>, a)</span><br><span class="line">[<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">98</span>, <span class="number">98</span>]</span><br></pre></td></tr></table></figure>


<h1 id="itertools-迭代器的一些应用"><a href="#itertools-迭代器的一些应用" class="headerlink" title="itertools 迭代器的一些应用"></a>itertools 迭代器的一些应用</h1><h2 id="Cartesian-products-itertools-product-两个列表的笛卡尔积"><a href="#Cartesian-products-itertools-product-两个列表的笛卡尔积" class="headerlink" title="Cartesian products (itertools.product) / 两个列表的笛卡尔积"></a>Cartesian products (itertools.product) / 两个列表的笛卡尔积</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> p <span class="keyword">in</span> itertools.product([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]):</span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> p <span class="keyword">in</span> itertools.product([<span class="number">0</span>, <span class="number">1</span>], repeat=<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> p)</span><br><span class="line">...</span><br><span class="line"><span class="number">0000</span></span><br><span class="line">0001</span><br><span class="line">0010</span><br><span class="line">0011</span><br><span class="line">0100</span><br><span class="line">0101</span><br><span class="line">0110</span><br><span class="line">0111</span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="number">1001</span></span><br><span class="line"><span class="number">1010</span></span><br><span class="line"><span class="number">1011</span></span><br><span class="line"><span class="number">1100</span></span><br><span class="line"><span class="number">1101</span></span><br><span class="line"><span class="number">1110</span></span><br><span class="line"><span class="number">1111</span></span><br></pre></td></tr></table></figure>

<h2 id="Combinations-and-combinations-with-replacement-itertools-combinations-and-itertools-combinations-with-replacement-列表组合和列表元素替代组合"><a href="#Combinations-and-combinations-with-replacement-itertools-combinations-and-itertools-combinations-with-replacement-列表组合和列表元素替代组合" class="headerlink" title="Combinations and combinations with replacement (itertools.combinations and itertools.combinations_with_replacement) / 列表组合和列表元素替代组合"></a>Combinations and combinations with replacement (itertools.combinations and itertools.combinations_with_replacement) / 列表组合和列表元素替代组合</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> itertools.combinations([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> c)</span><br><span class="line">...</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">124</span></span><br><span class="line"><span class="number">125</span></span><br><span class="line"><span class="number">134</span></span><br><span class="line"><span class="number">135</span></span><br><span class="line"><span class="number">145</span></span><br><span class="line"><span class="number">234</span></span><br><span class="line"><span class="number">235</span></span><br><span class="line"><span class="number">245</span></span><br><span class="line"><span class="number">345</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> itertools.combinations_with_replacement([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> c)</span><br><span class="line">...</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">33</span></span><br></pre></td></tr></table></figure>

<h2 id="Permutations-itertools-permutations-列表元素排列组合"><a href="#Permutations-itertools-permutations-列表元素排列组合" class="headerlink" title="Permutations (itertools.permutations) / 列表元素排列组合"></a>Permutations (itertools.permutations) / 列表元素排列组合</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> p <span class="keyword">in</span> itertools.permutations([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> p)</span><br><span class="line">...</span><br><span class="line"><span class="number">1234</span></span><br><span class="line"><span class="number">1243</span></span><br><span class="line"><span class="number">1324</span></span><br><span class="line"><span class="number">1342</span></span><br><span class="line"><span class="number">1423</span></span><br><span class="line"><span class="number">1432</span></span><br><span class="line"><span class="number">2134</span></span><br><span class="line"><span class="number">2143</span></span><br><span class="line"><span class="number">2314</span></span><br><span class="line"><span class="number">2341</span></span><br><span class="line"><span class="number">2413</span></span><br><span class="line"><span class="number">2431</span></span><br><span class="line"><span class="number">3124</span></span><br><span class="line"><span class="number">3142</span></span><br><span class="line"><span class="number">3214</span></span><br><span class="line"><span class="number">3241</span></span><br><span class="line"><span class="number">3412</span></span><br><span class="line"><span class="number">3421</span></span><br><span class="line"><span class="number">4123</span></span><br><span class="line"><span class="number">4132</span></span><br><span class="line"><span class="number">4213</span></span><br><span class="line"><span class="number">4231</span></span><br><span class="line"><span class="number">4312</span></span><br><span class="line"><span class="number">4321</span></span><br></pre></td></tr></table></figure>

<h2 id="Chaining-iterables-itertools-chain-可链接迭代器"><a href="#Chaining-iterables-itertools-chain-可链接迭代器" class="headerlink" title="Chaining iterables (itertools.chain) / 可链接迭代器"></a>Chaining iterables (itertools.chain) / 可链接迭代器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> p <span class="keyword">in</span> itertools.chain(itertools.combinations(a, <span class="number">2</span>), itertools.combinations(a, <span class="number">3</span>)):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> p</span><br><span class="line">...</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> subset <span class="keyword">in</span> itertools.chain.from_iterable(itertools.combinations(a, n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a) + <span class="number">1</span>))</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> subset</span><br><span class="line">...</span><br><span class="line">()</span><br><span class="line">(<span class="number">1</span>,)</span><br><span class="line">(<span class="number">2</span>,)</span><br><span class="line">(<span class="number">3</span>,)</span><br><span class="line">(<span class="number">4</span>,)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Grouping-rows-by-a-given-key-itertools-groupby-根据文件指定列类聚"><a href="#Grouping-rows-by-a-given-key-itertools-groupby-根据文件指定列类聚" class="headerlink" title="Grouping rows by a given key (itertools.groupby) / 根据文件指定列类聚"></a>Grouping rows by a given key (itertools.groupby) / 根据文件指定列类聚</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;contactlenses.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> infile:</span><br><span class="line"><span class="meta">... </span>    data = [line.strip().split(<span class="string">&#x27;,&#x27;</span>) <span class="keyword">for</span> line <span class="keyword">in</span> infile]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = data[<span class="number">1</span>:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_data</span>(<span class="params">rows</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&#x27;\n&#x27;</span>.join(<span class="string">&#x27;\t&#x27;</span>.join(<span class="string">&#x27;&#123;: &lt;16&#125;&#x27;</span>.<span class="built_in">format</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> row) <span class="keyword">for</span> row <span class="keyword">in</span> rows)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_data(data)</span><br><span class="line">young               myope                   no                      reduced                 none</span><br><span class="line">young               myope                   no                      normal                  soft</span><br><span class="line">young               myope                   yes                     reduced                 none</span><br><span class="line">young               myope                   yes                     normal                  hard</span><br><span class="line">young               hypermetrope            no                      reduced                 none</span><br><span class="line">young               hypermetrope            no                      normal                  soft</span><br><span class="line">young               hypermetrope            yes                     reduced                 none</span><br><span class="line">young               hypermetrope            yes                     normal                  hard</span><br><span class="line">pre-presbyopic      myope                   no                      reduced                 none</span><br><span class="line">pre-presbyopic      myope                   no                      normal                  soft</span><br><span class="line">pre-presbyopic      myope                   yes                     reduced                 none</span><br><span class="line">pre-presbyopic      myope                   yes                     normal                  hard</span><br><span class="line">pre-presbyopic      hypermetrope            no                      reduced                 none</span><br><span class="line">pre-presbyopic      hypermetrope            no                      normal                  soft</span><br><span class="line">pre-presbyopic      hypermetrope            yes                     reduced                 none</span><br><span class="line">pre-presbyopic      hypermetrope            yes                     normal                  none</span><br><span class="line">presbyopic          myope                   no                      reduced                 none</span><br><span class="line">presbyopic          myope                   no                      normal                  none</span><br><span class="line">presbyopic          myope                   yes                     reduced                 none</span><br><span class="line">presbyopic          myope                   yes                     normal                  hard</span><br><span class="line">presbyopic          hypermetrope            no                      reduced                 none</span><br><span class="line">presbyopic          hypermetrope            no                      normal                  soft</span><br><span class="line">presbyopic          hypermetrope            yes                     reduced                 none</span><br><span class="line">presbyopic          hypermetrope            yes                     normal                  none</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.sort(key=itemgetter(-<span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> value, group <span class="keyword">in</span> itertools.groupby(data, <span class="keyword">lambda</span> r: r[-<span class="number">1</span>]):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&#x27;-----------&#x27;</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&#x27;Group: &#x27;</span> + value</span><br><span class="line"><span class="meta">... </span>    print_data(group)</span><br><span class="line">...</span><br><span class="line">-----------</span><br><span class="line">Group: hard</span><br><span class="line">young               myope                   yes                     normal                  hard</span><br><span class="line">young               hypermetrope            yes                     normal                  hard</span><br><span class="line">pre-presbyopic      myope                   yes                     normal                  hard</span><br><span class="line">presbyopic          myope                   yes                     normal                  hard</span><br><span class="line">-----------</span><br><span class="line">Group: none</span><br><span class="line">young               myope                   no                      reduced                 none</span><br><span class="line">young               myope                   yes                     reduced                 none</span><br><span class="line">young               hypermetrope            no                      reduced                 none</span><br><span class="line">young               hypermetrope            yes                     reduced                 none</span><br><span class="line">pre-presbyopic      myope                   no                      reduced                 none</span><br><span class="line">pre-presbyopic      myope                   yes                     reduced                 none</span><br><span class="line">pre-presbyopic      hypermetrope            no                      reduced                 none</span><br><span class="line">pre-presbyopic      hypermetrope            yes                     reduced                 none</span><br><span class="line">pre-presbyopic      hypermetrope            yes                     normal                  none</span><br><span class="line">presbyopic          myope                   no                      reduced                 none</span><br><span class="line">presbyopic          myope                   no                      normal                  none</span><br><span class="line">presbyopic          myope                   yes                     reduced                 none</span><br><span class="line">presbyopic          hypermetrope            no                      reduced                 none</span><br><span class="line">presbyopic          hypermetrope            yes                     reduced                 none</span><br><span class="line">presbyopic          hypermetrope            yes                     normal                  none</span><br><span class="line">-----------</span><br><span class="line">Group: soft</span><br><span class="line">young               myope                   no                      normal                  soft</span><br><span class="line">young               hypermetrope            no                      normal                  soft</span><br><span class="line">pre-presbyopic      myope                   no                      normal                  soft</span><br><span class="line">pre-presbyopic      hypermetrope            no                      normal                  soft</span><br><span class="line">presbyopic          hypermetrope            no                      normal                  soft</span><br></pre></td></tr></table></figure>



<hr>
<p><em><strong>转载自 <a href="http://sahandsaba.com/thirty-python-language-features-and-tricks-you-may-not-know.html">30 Python Language Features and Tricks You May Not Know About</a></strong></em><br><em><strong>中文版 <a href="http://blog.jobbole.com/63320/">30个有关Python的小技巧</a></strong></em></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式linux环境搭建-jz2440开发板</title>
    <url>/2017/02/21/1707-jz2440-env/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/02/16/1705-linux-env/">嵌入式linux环境搭建-主机端</a></li>
<li><a href="https://draapho.github.io/2017/02/21/1707-jz2440-env/">嵌入式linux环境搭建-jz2440开发板</a></li>
<li><a href="https://draapho.github.io/2017/11/28/1738-dhcp-env/">基于DHCP建立嵌入式Linux开发环境</a></li>
</ul>
<h1 id="环境及结论"><a href="#环境及结论" class="headerlink" title="环境及结论"></a>环境及结论</h1><ul>
<li><p>大环境的搭建思路如下:</p>
<ul>
<li>gateway ip <code>10.0.0.138</code></li>
<li>PC windows: win10 64bit, ip <code>10.0.0.98</code></li>
<li>PC linux(最终版本): ubuntu desktop 16.04 32 bit, ip <code>10.0.0.100</code></li>
<li>Embedded Linux: jz2440v3 ip <code>10.0.0.111</code></li>
</ul>
</li>
<li><p>用 jLink 或 openJtag 烧录 uboot</p>
</li>
<li><p>基于nfs服务烧录kernal</p>
</li>
<li><p>使用nfs加载文件系统</p>
</li>
<li><p>编译一个驱动模块并运行</p>
</li>
<li><p>以上, 完成jz2440的环境搭建</p>
</li>
<li><p><strong>最新补充(2017-09-30). 根据实践, 建议的方式如下:</strong></p>
<ul>
<li>linux下使用samba实现文件共享, Ubuntu下配置支持Windows访问的samba共享</li>
<li>linux下安装NFS服务器, 便于让开发板linux通过网络加载文件系统. Ubuntu 16.04安装配置NFS</li>
<li>如果开发板联网不方便, 则建议使用 uboot+dnw(linux下) 的方式进行烧录, 也非常方便.</li>
</ul>
</li>
</ul>
<p><strong>PC linux 建议使用Ubuntu 32bit, 交叉编译工具必须使用 <code>arm-linux-gcc-3.4.5-glibc-2.3.6</code></strong></p>
<h1 id="设置静态ip"><a href="#设置静态ip" class="headerlink" title="设置静态ip"></a>设置静态ip</h1><h2 id="uboot-设置静态ip"><a href="#uboot-设置静态ip" class="headerlink" title="uboot 设置静态ip"></a>uboot 设置静态ip</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置ip地址, 在OpenJTAG&gt; 提示符下</span></span><br><span class="line"><span class="built_in">set</span> ipaddr 10.0.0.111           <span class="comment"># 设置开发板的ip地址</span></span><br><span class="line"><span class="built_in">set</span> serverip 10.0.0.138</span><br><span class="line">save                            <span class="comment"># 保存</span></span><br><span class="line">printenv                        <span class="comment"># 打印环境变量, 查看设置结果</span></span><br></pre></td></tr></table></figure>

<h2 id="嵌入式linux下设置静态ip"><a href="#嵌入式linux下设置静态ip" class="headerlink" title="嵌入式linux下设置静态ip"></a>嵌入式linux下设置静态ip</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 手工修改ip地址</span></span><br><span class="line">ifconfig eth0 10.0.0.111 netmask 255.255.255.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久修改IP地址</span></span><br><span class="line">vi /etc/init.d/rcS              <span class="comment"># 可以在windows下直接改</span></span><br><span class="line">    <span class="comment"># ===== 文件内容, 添加如下内容: =====</span></span><br><span class="line">    ifconfig eth0 10.0.0.111</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vi =====</span></span><br></pre></td></tr></table></figure>

<h1 id="uboot-的编译和烧录"><a href="#uboot-的编译和烧录" class="headerlink" title="uboot 的编译和烧录"></a>uboot 的编译和烧录</h1><h2 id="uboot-打补丁和编译"><a href="#uboot-打补丁和编译" class="headerlink" title="uboot 打补丁和编译"></a>uboot 打补丁和编译</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu shell</span></span><br><span class="line"></span><br><span class="line">tar xjvf u-boot-1.1.6.tar.bz2               <span class="comment"># 解压uboot源码</span></span><br><span class="line"><span class="built_in">cd</span> u-boot-1.1.6                             <span class="comment"># 进入uboot源码目录</span></span><br><span class="line">patch -p1 &lt; ../u-boot-1.1.6_jz2440.patch    <span class="comment"># 打补丁文件, p1表忽略patch文件内的1层目录</span></span><br><span class="line"><span class="comment"># tar cjvf u-boot-1.1.6-patched.tar.bz2 dir # 可选, 压缩备份一下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd = u-boot-1.1.6</span></span><br><span class="line">make clean</span><br><span class="line">make 100ask24x0_config                      <span class="comment"># uboot config文件</span></span><br><span class="line">make                                        <span class="comment"># uboot 编译, 得到u-boot.bin文件</span></span><br><span class="line"><span class="comment"># 不能用sudo make, 否则就是报错</span></span><br></pre></td></tr></table></figure>

<h2 id="uboot-的烧录和升级"><a href="#uboot-的烧录和升级" class="headerlink" title="uboot 的烧录和升级"></a>uboot 的烧录和升级</h2><p>一般而言, 开发板出厂时已经烧录好可用的uboot.<br>只要烧录好了uboot, 就不再需要 jLink 或 openJtag 这类烧录工具了!<br>若要烧录uboot, 可用 jLink 或 openJtag 烧录到norflash中, 略过不表.</p>
<p>基于dnw升级uboot:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开 jz2440 开发板串口终端, 启动时输入空格键, 进入如下菜单</span></span><br><span class="line"><span class="comment">##### 100ask Bootloader for OpenJTAG #####</span></span><br><span class="line">[n] Download u-boot to Nand Flash</span><br><span class="line">...</span><br><span class="line">Enter your selection: n                     <span class="comment"># 输入n, 烧录uboot</span></span><br><span class="line">USB host is connected. Waiting a download.  <span class="comment"># 提示连接成功</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 Ubuntu 终端, 输入</span></span><br><span class="line"><span class="comment"># pwd = ./u-boot-1.1.6                      # 确保在 uboot 源码路径下</span></span><br><span class="line">sudo dnw u-boot.bin                         <span class="comment"># 使用dnw烧录uboot</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要烧录其它如 kernel, filesystem 整个流程和 dnw 指令都是一样的. 譬如:</span></span><br><span class="line">sudo dnw ./arch/arm/boot/uImage             <span class="comment"># 先输入k, 烧录kernel</span></span><br><span class="line">sudo dnw fs_qtopia_ts.yaffs2                <span class="comment"># 先输入y, 烧录文件系统</span></span><br><span class="line">sudo dnw leds_0x31000000.bin 0x31000000     <span class="comment"># 先输入d, 烧录代码到SDRAM并运行</span></span><br></pre></td></tr></table></figure>

<p>或者基于nfs服务升级uboot, 指令较为复杂(dnw方式只是自动化运行这些指令了.):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"><span class="comment"># 要使用nfs功能, 必须正确设置uboot的ip地址</span></span><br><span class="line"><span class="comment"># 将 .../u-boot-1.1.6/u-boot.bin 拷贝到 /jz2440/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># uboot烧录: 用 jLink 烧录成功到nor flash后, 就可以用nfs进行升级或再烧录到nand flash中.</span></span><br><span class="line"><span class="comment"># uboot升级: 在OpenJTAG&gt; 提示符下</span></span><br><span class="line">nfs 30000000 10.0.0.98:/jz2440/u-boot.bin   <span class="comment"># nfs 加载 uboot 固件到ram中 (0x30000000是sdram的地址)</span></span><br><span class="line">nand erase bootloader                       <span class="comment"># 擦除 falsh 的 bootloader 区</span></span><br><span class="line">nand write.jffs2 30000000 bootloader        <span class="comment"># 烧录 uboot (ram-&gt;flash)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># uboot 运行时, 已经被加载到ram中, 因此可以用uboot的nfs功能来擦除和升级flash中的uboot</span></span><br><span class="line"><span class="comment"># 看上去实在自己运行自己, 本质上是ram中的uboot读写flash内容.</span></span><br></pre></td></tr></table></figure>


<h1 id="kernel-的编译和烧录"><a href="#kernel-的编译和烧录" class="headerlink" title="kernel 的编译和烧录"></a>kernel 的编译和烧录</h1><h2 id="kernel-打补丁和编译"><a href="#kernel-打补丁和编译" class="headerlink" title="kernel 打补丁和编译"></a>kernel 打补丁和编译</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu shell</span></span><br><span class="line"></span><br><span class="line">tar xjvf linux-2.6.22.6.tar.bz2             <span class="comment"># 解压kernel源码</span></span><br><span class="line"><span class="built_in">cd</span> linux-2.6.22.6                           <span class="comment"># 进入kernel源码目录</span></span><br><span class="line">patch -p1 &lt; ../linux-2.6.22.6_jz2440.patch  <span class="comment"># 打补丁文件, p1表忽略patch文件内的1层目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd = linux-2.6.22.6</span></span><br><span class="line">cp ../4.3寸LCD_mach-smdk2440.c arch/arm/mach-s3c2440/mach-smdk2440.c    <span class="comment"># 替换为4.3寸屏源码</span></span><br><span class="line">make clean                                  <span class="comment"># 清空 (先清空再在SI内查看)</span></span><br><span class="line">cp config_ok .config                        <span class="comment"># 设置config文件</span></span><br><span class="line">make uImage                                 <span class="comment"># 编译获得内核image</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可能在make时, 提示如下错误信息. 原因是新版的make对老的Makefile规则不兼容</span></span><br><span class="line">Makefile:1449: *** mixed implicit and normal rules.  Stop.</span><br><span class="line"></span><br><span class="line">vim Makefile</span><br><span class="line">    <span class="comment"># 416行      config %config: scripts_basic outputmakefile FORCE</span></span><br><span class="line">    <span class="comment">#   改为 -&gt;  %config: scripts_basic outputmakefile FORCE</span></span><br><span class="line">    <span class="comment"># 1449行     / %/: prepare scripts FORCE</span></span><br><span class="line">    <span class="comment">#   改为 -&gt;  %/: prepare scripts FORCE</span></span><br><span class="line">    <span class="comment"># 保存后重新编译即可.</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-dnw-烧录-kernel"><a href="#使用-dnw-烧录-kernel" class="headerlink" title="使用 dnw 烧录 kernel"></a>使用 dnw 烧录 kernel</h2><p>网路配置比较繁琐和复杂, windows的dnw需要安装驱动, 而且会有问题!<br>因此最便捷的方式就是基于uboot, 使用 linux 的 dnw.<br><strong>确保链接了开发板的串口和usb口, 并把usb口关联到Ubuntu上.</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开 jz2440 开发板串口终端, 启动时输入空格键, 进入如下菜单</span></span><br><span class="line"><span class="comment">##### 100ask Bootloader for OpenJTAG #####</span></span><br><span class="line">[n] Download u-boot to Nand Flash</span><br><span class="line">[o] Download u-boot to Nor Flash            <span class="comment"># 如果是Nand Flash启动的话，这个菜单项没有</span></span><br><span class="line">[k] Download Linux kernel uImage</span><br><span class="line">[j] Download root_jffs2 image</span><br><span class="line">[y] Download root_yaffs image</span><br><span class="line">[d] Download to SDRAM &amp; Run</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Enter your selection: k                     <span class="comment"># 输入k, 烧录 kernel</span></span><br><span class="line">USB host is connected. Waiting a download.  <span class="comment"># 提示连接成功</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 Ubuntu 终端, 输入</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6                    # 确保在 kernel 源码路径下</span></span><br><span class="line">sudo dnw ./arch/arm/boot/uImage             <span class="comment"># 输入dnw指令, 指明烧录文件</span></span><br><span class="line"><span class="comment"># DNW usb device found!                     # 开始烧录</span></span><br><span class="line"><span class="comment"># 这样就成功把 kernel 烧录到 jz2440 开发板中了.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要烧录其它如 uboot, filesystem, 整个流程和 dnw 指令都是一样的. 譬如:</span></span><br><span class="line">sudo dnw u-boot.bin                         <span class="comment"># 先输入n, 烧录uboot</span></span><br><span class="line">sudo dnw fs_qtopia_ts.yaffs2                <span class="comment"># 先输入y, 烧录文件系统</span></span><br><span class="line">sudo dnw leds_0x31000000.bin 0x31000000     <span class="comment"># 先输入d, 烧录代码到SDRAM并运行</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-nfs-烧录-kernel"><a href="#使用-nfs-烧录-kernel" class="headerlink" title="使用 nfs 烧录 kernel"></a>使用 nfs 烧录 kernel</h2><p>如果配置好网路, 建议使用 nfs 进行烧录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"><span class="comment"># 要使用nfs功能, 必须正确设置uboot的ip地址</span></span><br><span class="line"><span class="comment"># 将 .../linux-2.6.22.6/arch/arm/boot/uImage 拷贝到 /jz2440/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kernel: 在OpenJTAG&gt; 提示符下</span></span><br><span class="line">nfs 30000000 10.0.0.98:/jz2440/uImage       <span class="comment"># nfs 加载 kernel 固件到ram中 (0x30000000是sdram的地址)</span></span><br><span class="line">nand erase kernel                           <span class="comment"># 擦除 falsh 的 kernel 区</span></span><br><span class="line">nand write.jffs2 30000000 kernel            <span class="comment"># 烧录 kernel (ram-&gt;flash)</span></span><br></pre></td></tr></table></figure>


<h1 id="加载-filesystem"><a href="#加载-filesystem" class="headerlink" title="加载 filesystem"></a>加载 filesystem</h1><p>提供了如下几个文件系统</p>
<ol>
<li>fs_mini.tar.bz2      是最小的根文件系统. 不推荐, 需要手工建立设备节点</li>
<li>fs_mini_mdev.tar.bz2 是最小的根文件系统. 推荐, 启动后使用mdev自动建立设备节点</li>
<li>fs_qtopia.tar.bz2    是JZ2440使用的支持触摸屏的根文件系统</li>
<li>fs_xwindow.tar.bz2   是基于X的根文件系统</li>
</ol>
<p>这里以 fs_mini_mdev.tar.bz2 为例进行开发. 无UI, shell操作.</p>
<h2 id="制作-filesystem"><a href="#制作-filesystem" class="headerlink" title="制作 filesystem"></a>制作 filesystem</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu shell</span></span><br><span class="line"></span><br><span class="line">sudo tar xjf fs_mini_mdev.tar.bz2             <span class="comment"># 解压缩, 必须加sudo</span></span><br><span class="line">mkyaffs2image fs_mini_mdev fs_mini_mdev.yaffs <span class="comment"># 生成文件系统 fs_mini_mdev.yaffs</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-dnw-烧录-filesystem"><a href="#使用-dnw-烧录-filesystem" class="headerlink" title="使用 dnw 烧录 filesystem"></a>使用 dnw 烧录 filesystem</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开 jz2440 开发板串口终端, 启动时输入空格键, 进入如下菜单</span></span><br><span class="line"><span class="comment">##### 100ask Bootloader for OpenJTAG #####</span></span><br><span class="line">[n] Download u-boot to Nand Flash</span><br><span class="line">[o] Download u-boot to Nor Flash            <span class="comment"># 如果是Nand Flash启动的话，这个菜单项没有</span></span><br><span class="line">[k] Download Linux kernel uImage</span><br><span class="line">[j] Download root_jffs2 image</span><br><span class="line">[y] Download root_yaffs image</span><br><span class="line">[d] Download to SDRAM &amp; Run</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Enter your selection: y                     <span class="comment"># 输入k, 烧录 root_yaffs</span></span><br><span class="line">USB host is connected. Waiting a download.  <span class="comment"># 提示连接成功</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 Ubuntu 终端, 输入</span></span><br><span class="line">sudo dnw fs_mini_mdev.yaffs2                <span class="comment"># 输入dnw指令, 指明烧录文件</span></span><br><span class="line"><span class="comment"># DNW usb device found!                     # 开始烧录</span></span><br><span class="line"><span class="comment"># 这样就成功把文件系统烧录到 jz2440 开发板中了.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要烧录其它如 uboot, kernel, 整个流程和 dnw 指令都是一样的. 譬如:</span></span><br><span class="line">sudo dnw u-boot.bin                         <span class="comment"># 先输入n, 烧录uboot</span></span><br><span class="line">sudo dnw ./arch/arm/boot/uImage             <span class="comment"># 先输入k, 烧录kernel</span></span><br><span class="line">sudo dnw leds_0x31000000.bin 0x31000000     <span class="comment"># 先输入d, 烧录代码到SDRAM并运行</span></span><br></pre></td></tr></table></figure>


<h2 id="使用-nfs-烧录-filesystem"><a href="#使用-nfs-烧录-filesystem" class="headerlink" title="使用 nfs 烧录 filesystem"></a><del>使用 nfs 烧录 filesystem</del></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"><span class="comment"># 要使用nfs功能, 必须正确设置uboot的ip地址</span></span><br><span class="line"><span class="comment"># 将 .../fs_mini_mdev.yaffs 拷贝到 /jz2440/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fs: 在OpenJTAG&gt; 提示符下 (实际不用, 用nfs加载fs)</span></span><br><span class="line">nfs 30000000 10.0.0.98:/jz2440/fs_mini_mdev.yaffs2</span><br><span class="line">nand erase root</span><br><span class="line">nand write.yaffs 30000000 260000 ‭88AC40‬       <span class="comment"># 要算文件大小, 很麻烦.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置为从flash启动 file system. 在OpenJTAG&gt; 提示符下</span></span><br><span class="line"><span class="built_in">set</span> bootargs noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0</span><br><span class="line">save</span><br><span class="line">reset</span><br></pre></td></tr></table></figure>

<h2 id="直接加载-nfs-文件系统"><a href="#直接加载-nfs-文件系统" class="headerlink" title="直接加载 nfs 文件系统"></a>直接加载 nfs 文件系统</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"><span class="comment"># 要使用nfs功能, 必须正确设置uboot的ip地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># uboot, 从NFS加载文件系统. 在OpenJTAG&gt; 提示符下</span></span><br><span class="line"><span class="built_in">set</span> bootargs noinitrd root=/dev/nfs nfsroot=10.0.0.98:/fs ip=10.0.0.111:10.0.0.98:10.0.0.138:255.255.255.0::eth0:off init=/linuxrc console=ttySAC0</span><br><span class="line"><span class="comment"># (简化ip: &#x27;set bootargs noinitrd root=/dev/nfs nfsroot=10.0.0.98:/fs ip=10.0.0.111 init=/linuxrc console=ttySAC0&#x27; 也可以工作)</span></span><br><span class="line">save        <span class="comment"># 保存修改</span></span><br><span class="line">reset       <span class="comment"># 重启. (稍后再重启, 先修改好 filesystem 内的初始化文件)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数简要说明:</span></span><br><span class="line"><span class="comment"># &#x27;root=/dev/nfs&#x27; 加载nfs文件系统</span></span><br><span class="line"><span class="comment"># &#x27;nfsroot=10.0.0.98:/fs&#x27; nfs文件系统的来源, 此处是由win10当nfs服务器, 共享出/fs文件夹</span></span><br><span class="line"><span class="comment"># &#x27;ip=10.0.0.111:10.0.0.98:10.0.0.138:255.255.255.0::eth0:off&#x27; 分别表示:</span></span><br><span class="line"><span class="comment">#  ip= 开发板ip : nfs服务器ip: 网关ip : 子网掩码 :: 开发板网口 : off</span></span><br></pre></td></tr></table></figure>

<h2 id="加载其它nfs文件"><a href="#加载其它nfs文件" class="headerlink" title="加载其它nfs文件"></a>加载其它nfs文件</h2><p>为了方便开发调试, 可以加载其它nfs文件到开发板linux中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板手动加载nfs文件</span></span><br><span class="line">mkdir /mnt/jz2440</span><br><span class="line">mount -t nfs -o nolock,vers=2 10.0.0.98:/jz2440 /mnt/jz2440</span><br><span class="line"></span><br><span class="line">// 开机自动加载nfs文件</span><br><span class="line">mkdir /mnt/jz2440</span><br><span class="line">vi /etc/init.d/rcS                          <span class="comment"># 可以在windows下直接改</span></span><br><span class="line">    <span class="comment"># ===== 文件内容, 末尾加入如下语句: =====</span></span><br><span class="line">    <span class="comment"># mkdir /mnt/jz2440     # 建议手动创建, 需要容错的话, 可加上这句</span></span><br><span class="line">    mount -t nfs -o nolock,vers=2 10.0.0.98:/jz2440 /mnt/jz2440</span><br><span class="line">    ln -s /mnt/jz2440 /jz2440</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vi =====</span></span><br></pre></td></tr></table></figure>

<h2 id="基于-fs-mini-mdev-制作-qt"><a href="#基于-fs-mini-mdev-制作-qt" class="headerlink" title="基于 fs_mini_mdev 制作 qt"></a><del>基于 fs_mini_mdev 制作 qt</del></h2><p><strong>这部分没有自己验证过</strong>, 步骤繁琐, 不确定是否有问题.<br>因为本质上和使用最小系统是一样的, 只是加上了图形界面, 这个要到应用层开发UI才会用到!</p>
<h3 id="编译qt依赖的库文件"><a href="#编译qt依赖的库文件" class="headerlink" title="编译qt依赖的库文件"></a><del>编译qt依赖的库文件</del></h3><p>注意修改<code>--prefix=/work/tools/gcc-3.4.5-glibc-2.3.6/arm-linux</code> 为实际的gcc-3.4.5-glibc-2.3.6绝对路径.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu shell</span></span><br><span class="line"><span class="comment"># 编译qt依赖的库文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 编译jpeg库</span></span><br><span class="line"><span class="comment"># 源码位于 &#x27;.../qtopia/deps/jpegsrc.v6b.tar.gz&#x27;</span></span><br><span class="line">tar xzf jpegsrc.v6b.tar.gz                  <span class="comment"># 解压得到jpeg-6b目录</span></span><br><span class="line"><span class="built_in">cd</span> jpeg-6b                                  <span class="comment"># 进入源码目录进行配置</span></span><br><span class="line">./configure --enable-shared --enable-static --prefix=/work/tools/gcc-3.4.5-glibc-2.3.6/arm-linux --build=i386 --host=arm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会生成 Makefile 文件, 修改编译工具(需要改为arm-linux-xxx, 交叉编译):</span></span><br><span class="line">vim Makefile                                <span class="comment"># 可以在windows下直接改</span></span><br><span class="line">    <span class="comment"># ===== 文件内容, 修改如下内容: =====</span></span><br><span class="line">    CC= arm-linux-gcc       <span class="comment"># CC= gcc</span></span><br><span class="line">    AR= arm-linux-ar rc     <span class="comment"># AR= ar rc</span></span><br><span class="line">    AR2= arm-linux-ranlib   <span class="comment"># AR2= ranlib</span></span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line">make</span><br><span class="line">make install-lib</span><br><span class="line"><span class="comment"># .../gcc-3.4.5-glibc-2.3.6/arm-linux/lib 中生成jpeg库文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 编译uuid库</span></span><br><span class="line"><span class="comment"># 源码位于 &#x27;.../qtopia/deps/e2fsprogs-1.40.2.tar.gz&#x27;</span></span><br><span class="line">tar xzf e2fsprogs-1.40.2.tar.gz             <span class="comment"># 解压</span></span><br><span class="line"><span class="built_in">cd</span> e2fsprogs-1.40.2                         <span class="comment"># 进入源码目录进行配置</span></span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"><span class="comment"># 指定编译工具, 配置编译环境</span></span><br><span class="line">../configure --with-cc=arm-linux-gcc --with-linker=arm-linux-ld --enable-elf-shlibs--host=arm-prefix=/work/tools/gcc-3.4.5-glibc-2.3.6/arm-linux</span><br><span class="line">make</span><br><span class="line">make install-lib</span><br><span class="line"><span class="comment"># .../gcc-3.4.5-glibc-2.3.6/arm-linux/lib 中生成 libuuid.so</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 编译zlib库</span></span><br><span class="line"><span class="comment"># 源码位于 &#x27;.../qtopia/deps/zlib-1.2.3.tar.gz&#x27;</span></span><br><span class="line">tar xzf zlib-1.2.3.tar.gz                   <span class="comment"># 解压</span></span><br><span class="line"><span class="built_in">cd</span> zlib-1.2.3                               <span class="comment"># 进入源码目录进行配置</span></span><br><span class="line">./configure --shared --prefix=/work/tools/gcc-3.4.5-glibc-2.3.6/arm-linux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会生成 Makefile 文件, 修改编译工具(需要改为arm-linux-xxx, 交叉编译):</span></span><br><span class="line">vim Makefile                                <span class="comment"># 可以在windows下直接改</span></span><br><span class="line">    <span class="comment"># ===== 文件内容, 修改如下内容: =====</span></span><br><span class="line">    CC=arm-linux-gcc            <span class="comment"># CC=gcc</span></span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">    <span class="comment">#LDSHARED=gcc -shared -Wl,-soname,libz.so.1</span></span><br><span class="line">    LDSHARED=arm-linux-gcc -shared -Wl,-soname,libz.so.1</span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">    CPP=arm-linux-gcc -E        <span class="comment"># CPP=gcc -E</span></span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">    AR=arm-linux-ar rc          <span class="comment"># AR=ar rc</span></span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">    RANLIB=arm-linux-ranlib     <span class="comment"># RANLIB=ranlib</span></span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"><span class="comment"># .../gcc-3.4.5-glibc-2.3.6/arm-linux/lib 中生成zlib库文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 编译png库</span></span><br><span class="line"><span class="comment"># 源码位于 &#x27;.../qtopia/deps/libpng-1.2.23.tar.bz2&#x27;</span></span><br><span class="line">tar xjf libpng-1.2.23.tar.bz2               <span class="comment"># 解压</span></span><br><span class="line"><span class="built_in">cd</span> libpng-1.2.23                            <span class="comment"># 进入源码目录进行配置</span></span><br><span class="line">cp scripts/makefile.linux ./Makefile        <span class="comment"># 复制makefile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开 Makefile 文件, 修改编译工具(需要改为arm-linux-xxx, 交叉编译):</span></span><br><span class="line">vim Makefile                                <span class="comment"># 可以在windows下直接改</span></span><br><span class="line">    <span class="comment"># ===== 文件内容, 修改如下内容: =====</span></span><br><span class="line">    AR_RC=arm-linux-ar rc       <span class="comment"># AR_RC=ar rc</span></span><br><span class="line">    CC=arm-linux-gcc            <span class="comment"># CC=gcc</span></span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">    RANLIB=arm-linux-ranlib     <span class="comment"># RANLIB=ranlib</span></span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">    prefix=/work/tools/gcc-3.4.5-glibc-2.3.6/arm-linux</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line">make</span><br><span class="line">make install-lib</span><br><span class="line"><span class="comment"># .../gcc-3.4.5-glibc-2.3.6/arm-linux/lib 中生成png库文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 编译ts库</span></span><br><span class="line"><span class="comment"># 源码位于 &#x27;.../qtopia/deps/tslib-1.3.tar.bz2&#x27;</span></span><br><span class="line">tar xjf tslib-1.3.tar.bz2                   <span class="comment"># 解压</span></span><br><span class="line"><span class="built_in">cd</span> tslib-1.3                                <span class="comment"># 进入源码目录进行配置</span></span><br><span class="line">./autogen.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ac_cv_func_malloc_0_nonnull=yes&quot;</span> &gt;arm-linux.cache</span><br><span class="line">./configure --host=arm-linux --cache-file=arm-linux.cache --enable-inputapi=no --prefix=/work/tools/gcc-3.4.5-glibc-2.3.6/arm-linux</span><br><span class="line"></span><br><span class="line">vim ./src/ts_read_raw.c                     <span class="comment"># 修改触摸芯片型号</span></span><br><span class="line">    <span class="comment"># ===== 文件内容, 修改如下内容: =====</span></span><br><span class="line">    <span class="comment">#char *defaulttseventtype=&quot;UCB1x00&quot;;    # 此句修改为:</span></span><br><span class="line">    char *defaulttseventtype=<span class="string">&quot;H3600&quot;</span>;</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 防止出现 &quot;libtool:link: only absolute run-paths are allowed&quot; 的错误</span></span><br><span class="line">vim ./plugins/Makefile                      <span class="comment"># 修改为绝对路径</span></span><br><span class="line">    <span class="comment"># ===== 文件内容, 修改如下内容: =====</span></span><br><span class="line">    <span class="comment">#LDFLAGS :=$(LDFLAGS) -rpath $(PLUGIN_DIR)</span></span><br><span class="line">    LDFLAGS :=$(LDFLAGS) -rpath `<span class="built_in">cd</span> $(PLUGIN_DIR) &amp;&amp; <span class="built_in">pwd</span>`</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"><span class="comment"># .../gcc-3.4.5-glibc-2.3.6/arm-linux/lib 中生成ts库文件</span></span><br></pre></td></tr></table></figure>

<h3 id="制作QT文件系统"><a href="#制作QT文件系统" class="headerlink" title="制作QT文件系统"></a><del>制作QT文件系统</del></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu shell</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 创建qt文件夹</span></span><br><span class="line"><span class="comment"># tar要加上sudo. 因为解压出来的dev目录下有一些设备节点要用到root权限</span></span><br><span class="line">sudo tar xjf fs_mini_mdev.tar.bz2           <span class="comment"># 解压 fs_mini_mdev 最小fs</span></span><br><span class="line">sudo cp -rf fs_mini_mdev fs_qtopia          <span class="comment"># 重命名为 fs_qtopia</span></span><br><span class="line"><span class="comment"># sudo chown -R root:root fs_qtopis         # 更改用户和组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 复制Qtopia 依赖的库文件</span></span><br><span class="line"><span class="built_in">cd</span> .../gcc-3.4.5-glibc-2.3.6/arm-linux/lib/</span><br><span class="line">cp libpng.so* .../fs_qtopia/lib/ -d</span><br><span class="line">cp libjpeg.so* .../fs_qtopia/lib/ -d</span><br><span class="line">cp libuuid.so* .../fs_qtopia/lib/ -d</span><br><span class="line">cp libz.so* .../fs_qtopia/lib/ -d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 安装触摸屏所需的文件</span></span><br><span class="line"><span class="built_in">cd</span> .../tslib-1.3                            <span class="comment"># 编译ts库时, 解压出来的文件目录</span></span><br><span class="line">make prefix=.../fs_qtopia/usr/ install      <span class="comment"># 修改为绝对路径!</span></span><br><span class="line"><span class="built_in">cd</span> .../fs_qtopia</span><br><span class="line">cp ./usr/etc/ts.conf ./etc/                 <span class="comment"># 复制 ts.conf 文件</span></span><br><span class="line">vim ./etc/ts.conf                           <span class="comment"># 可以在windows下直接改</span></span><br><span class="line">    <span class="comment"># ===== 文件内容, 修改如下内容: =====</span></span><br><span class="line">    <span class="comment"># module mousebuts</span></span><br><span class="line">    module variance xlimit=50 ylimit=50 pthreshold=3</span><br><span class="line">    <span class="comment"># module dejitter xdelta=1 ydelta=1 pthreshold=3    # 注释掉了这一行!</span></span><br><span class="line">    module linear</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 复制字库和opt文件夹到开发板根目录</span></span><br><span class="line"><span class="built_in">cd</span> .../qtopia/qtopia-free-2.2.0/</span><br><span class="line">cp -rf qt2/lib/fonts qtopia/image/opt/Qtopia/lib/</span><br><span class="line">cp -rf qtopia/image/opt/ .../fs_qtopia</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 创建时区文件, 直接使用ubuntu中的时区文件</span></span><br><span class="line"><span class="built_in">cd</span> .../fs_qtopia</span><br><span class="line">mkdir -p usr/share/zoneinfo/</span><br><span class="line">cp -rf /usr/share/zoneinfo/America usr/share/zoneinfo/</span><br><span class="line">cp /usr/share/zoneinfo/zone.tab usr/share/zoneinfo/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 建立脚本, 用来校验触摸屏</span></span><br><span class="line"><span class="comment"># QT自带的触摸屏程序不好用. 想再次较验时, 把 /etc/pointercal 删掉后重启就可以了</span></span><br><span class="line"><span class="built_in">cd</span> .../fs_qtopia</span><br><span class="line">vim bin/ts_cal.sh                   <span class="comment"># 建立script文件</span></span><br><span class="line">    <span class="comment"># ===== 文件内容如下: =====</span></span><br><span class="line">    <span class="comment">#!/bin/sh</span></span><br><span class="line">    <span class="built_in">export</span> HOME=/root</span><br><span class="line">    <span class="built_in">export</span> QTDIR=/opt/Qtopia</span><br><span class="line">    <span class="built_in">export</span> QPEDIR=/opt/Qtopia</span><br><span class="line">    <span class="built_in">export</span> QWS_DISPLAY=LinuxFb:/dev/fb0</span><br><span class="line">    <span class="built_in">export</span> QWS_KEYBOARD=<span class="string">&quot;TTY:/dev/tty1&quot;</span></span><br><span class="line">    <span class="comment">#export QWS_MOUSE_PROTO=&quot;USB:/dev/mouse0&quot;</span></span><br><span class="line">    <span class="built_in">export</span> QWS_MOUSE_PROTO=<span class="string">&quot;TPanel:/dev/ts0&quot;</span></span><br><span class="line">    <span class="built_in">export</span> PATH=<span class="variable">$QPEDIR</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">    <span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$QPEDIR</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line">    <span class="built_in">export</span> TSLIB_TSDEVICE=/dev/ts0</span><br><span class="line">    <span class="built_in">export</span> TSLIB_CONSOLEDEVICE=none</span><br><span class="line">    <span class="built_in">export</span> TSLIB_FBDEVICE=/dev/fb0</span><br><span class="line">    <span class="built_in">export</span> TSLIB_CONFFILE=/etc/ts.conf</span><br><span class="line">    <span class="built_in">export</span> TSLIB_PLUGINDIR=/usr/share/ts/plugins</span><br><span class="line">    <span class="built_in">export</span> TSLIB_TSEVENTTYPE=<span class="string">&quot;H3600&quot;</span></span><br><span class="line">    /usr/bin/ts_calibrate</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line"></span><br><span class="line">chmod +x bin/ts_cal.sh     <span class="comment"># 修改为可执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 建立脚本, 用来运行qtopia</span></span><br><span class="line"><span class="built_in">cd</span> .../fs_qtopia</span><br><span class="line">mkdir -p root                       <span class="comment"># 给 export HOME=/root 使用</span></span><br><span class="line">vim bin/qpe.sh                      <span class="comment"># 建立script文件</span></span><br><span class="line">    <span class="comment"># ===== 文件内容如下: =====</span></span><br><span class="line">    <span class="comment">#!/bin/sh</span></span><br><span class="line">    <span class="built_in">export</span> HOME=/root</span><br><span class="line">    <span class="built_in">export</span> QTDIR=/opt/Qtopia</span><br><span class="line">    <span class="built_in">export</span> QPEDIR=/opt/Qtopia</span><br><span class="line">    <span class="built_in">export</span> QWS_DISPLAY=LinuxFb:/dev/fb0</span><br><span class="line">    <span class="built_in">export</span> QWS_KEYBOARD=<span class="string">&quot;TTY:/dev/tty1&quot;</span></span><br><span class="line">    <span class="comment">#export QWS_MOUSE_PROTO=&quot;USB:/dev/mouse0&quot;</span></span><br><span class="line">    <span class="built_in">export</span> QWS_MOUSE_PROTO=<span class="string">&quot;TPanel:/dev/ts0&quot;</span></span><br><span class="line">    <span class="built_in">export</span> PATH=<span class="variable">$QPEDIR</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">    <span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$QPEDIR</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line">    <span class="built_in">export</span> TSLIB_TSDEVICE=/dev/ts0</span><br><span class="line">    <span class="built_in">export</span> TSLIB_CONSOLEDEVICE=none</span><br><span class="line">    <span class="built_in">export</span> TSLIB_FBDEVICE=/dev/fb0</span><br><span class="line">    <span class="built_in">export</span> TSLIB_CONFFILE=/etc/ts.conf</span><br><span class="line">    <span class="built_in">export</span> TSLIB_PLUGINDIR=/usr/share/ts/plugins</span><br><span class="line">    <span class="built_in">export</span> TSLIB_TSEVENTTYPE=<span class="string">&quot;H3600&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ ! -e /etc/pointercal ] <span class="keyword">then</span>                <span class="comment"># 若不存在ts校验文件</span></span><br><span class="line">        /bin/ts_cal.sh                              <span class="comment"># 执行校验脚本 (步骤6的文件)</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$QPEDIR</span>/bin/qpe &amp;</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line"></span><br><span class="line">chmod +x bin/qpe.sh         <span class="comment"># 修改为可执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 修改根文件系统的启动脚本</span></span><br><span class="line"><span class="comment"># 需要用到临时目录/tmp，为减少对Flash的擦写，在/tmp目录上挂接tmpfs文件系统</span></span><br><span class="line"><span class="built_in">cd</span> .../fs_qtopia</span><br><span class="line">mkdir -p tmp                        <span class="comment"># 建立/tmp目录</span></span><br><span class="line">vim etc/fstab                       <span class="comment"># 挂载 tmpfs</span></span><br><span class="line">    <span class="comment"># ===== 文件内容, 加入如下语句: =====</span></span><br><span class="line">    tmpfs   /tmp    tmpfs   defaults    0   0</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vi =====</span></span><br><span class="line">vim etc/init.d/rcS                  <span class="comment"># 开机自动执行 qpe.sh 脚本</span></span><br><span class="line">    <span class="comment"># ===== 文件内容, 末尾加入如下语句: =====</span></span><br><span class="line">    /bin/qpe.sh &amp;</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vi =====</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">9. 至此, fs_qtopia已经是一个完整的, 可支持QT的根文件系统了.</span><br><span class="line">mkyaffs2image fs_qtopia fs_qtopia.yaffs2    <span class="comment"># 制作映像文件</span></span><br></pre></td></tr></table></figure>



<h1 id="编译驱动程序"><a href="#编译驱动程序" class="headerlink" title="编译驱动程序"></a>编译驱动程序</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu shell</span></span><br><span class="line"><span class="comment"># 源码位于 &#x27;.../drivers_and_test/first_drv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd = 驱动程序目录下</span></span><br><span class="line">vim Makefile                             <span class="comment"># 修改Makefile</span></span><br><span class="line">    <span class="comment"># ===== 文件内容, 找到 &#x27;KERN_DIR&#x27;, 配置内核位置: =====</span></span><br><span class="line">    KERN_DIR = /mnt/nfs/study/jz2440/kernel/linux-2.6.22.6</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line">make                                    <span class="comment"># 获得 first_drv.ko</span></span><br><span class="line">arm-linux-gcc -o firstdrvtest firstdrvtest.c      <span class="comment"># 交叉编译测试程序,</span></span><br><span class="line"><span class="comment"># -o 表示目标文件, 所以 &#x27;arm-linux-gcc firstdrvtest.c -o firstdrvtest&#x27; 也可以</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 开发板 shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设使用nfs加载的系统, 上述编译好后, 直接能在开发板上看到更改</span></span><br><span class="line"><span class="comment"># pwd = 驱动程序目录下</span></span><br><span class="line">insmod first_drv.ko                     <span class="comment"># 加载驱动模块</span></span><br><span class="line">./firstdrvtest on                       <span class="comment"># 执行测试</span></span><br><span class="line">./firstdrvtest off                      <span class="comment"># 执行测试</span></span><br></pre></td></tr></table></figure>



<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>environment</tag>
        <tag>jz2440</tag>
      </tags>
  </entry>
  <entry>
    <title>我的终极思考</title>
    <url>/2017/10/09/1728-ultimatethink/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
<li><a href="https://draapho.github.io/2021/03/05/2107-tuibeitu1/">万年歌, 马前课, 梅花诗, 推背图 (上)</a></li>
<li><a href="https://draapho.github.io/2021/03/18/2108-tuibeitu2/">万年歌, 马前课, 梅花诗, 推背图 (下)</a></li>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/26/2123-caseofsatori/">见性者体验收集</a></li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>终极思考, 题目取的很大. 加上”我的”二字后, 就可大可小, 也不用纠结于论证是不是合理, 境界够不够深远之类的问题了.<br>此文基本能体现人生至此的三观了. 算是个人思想的一份总结, 此文以后, 不会再去纠结这类哲学问题.</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>简单介绍一下自己的经历和心路.</p>
<h2 id="看山是山，看水是水"><a href="#看山是山，看水是水" class="headerlink" title="看山是山，看水是水"></a>看山是山，看水是水</h2><p>农村长大, 喜欢蓝天白云, 看着云朵总能想出像什么. 读书后, 玩模型, 玩编程, 研究宇宙.<br>直到初中, 除了英语让父母多操了点心外, 一切都很顺利, 自己也很开心.</p>
<h2 id="看山不是山，看水不是是水"><a href="#看山不是山，看水不是是水" class="headerlink" title="看山不是山，看水不是是水"></a>看山不是山，看水不是是水</h2><p>到了高中, 开始着迷于思考生命的意义, 人类的终极命运这类命题. 高考一度想报考并不擅长的历史, 以期探索甚至解决这个问题.<br>大学里选了历史系的选修课, 和历史系教授提了下困惑, 推荐一些国内的杂志和论语之类的古籍, 没什么帮助.<br>工作以后, 想着好好做, 定了个5年内年薪20W目标, 读了个交大的硕士. 但也慢慢地越来越没干劲.<br>这个阶段, 自己始终对自己不满意, 读书时对学不好英语不满意, 工作后, 对工作没有进一步的发展空间不满意.</p>
<p>整个人的状态大致就是:</p>
<ul>
<li>心情好时, 觉得自己还一切皆有可能, 如果努力坚持, 一定会成功到留名青史.</li>
<li>YY不超过一天, 又会跌入到深深的自责中, 感觉自己什么也做不好, 在虚度光阴. 人生无意义也无乐趣…</li>
<li>于是乎, 精神状态基本处于女孩子来大姨妈一般的周期中.</li>
</ul>
<p>至于原因, 现在看来很简单. 人总是希望被认同的, 或被自己的内心认同, 或被周围的人的认同.<br>而我本质上是一个内在驱动型的人, 但却又渴望着被他人赏识和认同(这涉及到儿时的亲子关系, 就不多言了).<br>我的内心最关注的始终是人类/宇宙之类的哲学问题, 而周遭的人对你的认同就是–成家立业赚大钱.<br>一边放不下内心的关注点, 一边又想让自己成为他人眼中的”成功人士”.<br>对我而言, 就成了不可调和的矛盾. 心不定则心生不满, 两边都做不好!</p>
<h2 id="看山还是山，看水还是水"><a href="#看山还是山，看水还是水" class="headerlink" title="看山还是山，看水还是水"></a>看山还是山，看水还是水</h2><p>2014年尝试技术移民, 英语学到脑袋神经痛, 8场雅思之后勉强6炸.<br>2015年股灾, 本金亏的只剩20%.<br>2016年移民, 没有工作, 没有稳定的落脚点, 一家三口拿着5W澳元到了人生地不熟, 连语言也不怎么通的澳洲.<br>三个月后, 有幸找了本职工作. 此时, 只剩5K澳元.</p>
<p>这些经历是催化剂, 促使我去尝试让焦虑不堪的心平静下来, 去解决心中种种的矛盾和困惑.<br>于是乎, 去筛选灵修类的书. 去思考唯物主义和唯心主义的孰是孰非. 去接触和比较宗教.<br>于是乎, 一改以前的颓废. 建立了这个博客, 重新开始自学, 并重新体会到了专注的快乐.<br>于是乎, 知道了自己想要什么, 无所谓什么. 懂得了路飞为何在罗格镇的行刑台上能笑着说:”大家, 对不起, 我要死了”.</p>
<h1 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h1><ul>
<li>世界或许是唯物的, 个人一定是唯心的.</li>
<li>物由心转, 要改变世界, 先改变自己.</li>
<li>大脑的核心机制是比较, 为了达到目的它可以虚构故事.</li>
<li>过去和未来皆是虚无, 真正重要的只有当下.</li>
</ul>
<p>现在的我, 无所谓他人怎么评价, 我需要的只是自我认同.<br>出门也不再带单反拍拍拍, 在当下, 亲自感受美好就好.<br>发呆时, 也不会自责虚度光阴. 或许当下该做的就是发呆.</p>
<p>** 推荐艾克哈特·托勒的《当下的力量》. **<br>至于其《新世界:灵性的觉醒》, 更像是作者的美好愿望.</p>
<p>灵修类的书有一个特点, 信的人很相信, 不信的人怎么都不会去相信.<br>这边书也一样, 相信的人将其捧上神坛, 不相信的人嗤之以鼻.</p>
<p>我是这样评价《当下的力量》这边书的, 书很真实, 是作者的亲身体验和实践.<br>作者倾注了全部心血来尝试理解他自己的开悟, 并将其有效的实践一一记录下来.<br>但作者在试图解释和证明这种开悟时, 非常的主观而没有说服力.</p>
<p>瑕不掩瑜, 在可实践性方面, 《当下的力量》确实是灵修类不可多得的好书.<br>他剥开了宗教繁复的外壳, 将其最核心的东西通俗易懂的展现在人们面前.<br>他指明了看到圣光, 顿悟之类的体验和宗教无关. 无信仰的人也有能体会到.<br>他没有创造和也没有强调任何概念. 唯一的核心就是轻视思维, 重视感受.</p>
<p>开悟的月亮就在那里. 如果不记得经常抬头看看, 纵然有观月台, 望远镜, 我们都无法看到心中的月亮.<br>目前案边常备的是《当下的力量2》, 精简到极致的一本书, 为了能提醒自己要常抬头看看心中之月.</p>
<p>几大宗教里面, 最倾向的还是《佛教》. 只是他过于博大精深, 大多数人难以接触其核心内容.<br>如果真的万物相连, 人与宇宙能通过冥想之类的进行信息交流, 那佛教是有可能早于科学接触到世界本质的.</p>
<p><strong>补充与2017-11-22</strong><br>现在在看《佛教入门丛书》, 先初步了解一下. 可以看出《新世界:灵性的觉醒》一书借鉴了不少佛教的概念.<br>开始借由打坐冥想替代《当下的力量2》一书, 能更好的控制和减少负面情绪.<br><strong>补充结束</strong></p>
<h1 id="人类"><a href="#人类" class="headerlink" title="人类"></a>人类</h1><ul>
<li>社会的基石来自于虚构的故事.</li>
<li>人类与个人的关系: 就是人与体内生命体的关系.</li>
<li>人类还在进化吗? 是的, 是在社会层面的进化, 而非个体上的进化.</li>
<li>人类的未来: 不知道, 关键是全方位的保持多样性, 保持进化的能力.</li>
</ul>
<p>谈及对人类的思考, <strong>推荐尤瓦尔·赫拉利的《人类简史》</strong>.<br>对于其另外一本《未来简史》, 是可能性之一.<br>我很欣赏作者表现出的人文主义关怀.</p>
<h2 id="认知革命"><a href="#认知革命" class="headerlink" title="认知革命"></a>认知革命</h2><p>人类之所以为人类, 在于相互合作的个体能突破150人(邓巴数/150定律)并保持目标的灵活性.<br>有些动物, 譬如迁徙的野牛, 似乎也是在大规模的相互合作, 但这是刻到基因里的, 无法灵活改变目标.<br>这来自于脑袋里的认知革命, 远比会使用工具, 大拇指的进化重要的多!</p>
<p>所以, 认知革命是解放思想. 而后的农业革命提供了人口膨胀的物质基础,<br>近代的工业革命+资本主义使得人类的发展由线性增长变为指数增长.</p>
<p>这种把相互不认识, 甚至互不信任的人组织到一起的能力, 使得人类相对于其他物种取得了量的优势, 并最终席卷全球!<br>这个能力的关键, 就是要人们共同相信一套虚构的故事. (会吹牛还能让别人相信的人, 是能成大事的人!)<br>让我们来看一看自古以来的这些故事:</p>
<ul>
<li>原始部落: 图腾(立信仰)+巫术(定规矩)</li>
<li>古代帝国: 宗教(立信仰)+律法(定规矩)</li>
<li>现代国家: 国家认同感(立信仰)+法律(定规矩)</li>
<li>现代企业: 企业文化(立信仰)+员工手册(定规矩)</li>
</ul>
<p>古代的图腾和现代的国旗没什么区别, 都用来帮助树立大众的信仰, 便于让人们愿意为部落或国家奉献一切.<br>巫术和法律的作用也是大同小异, 告诉大众什么能做或什么不能做, 越界了就会有惩罚.</p>
<h2 id="胜出的故事"><a href="#胜出的故事" class="headerlink" title="胜出的故事"></a>胜出的故事</h2><p>量变以后, 人类这个物种就取得了进化上的优势–保持物种繁衍延续, 并全方位探索各种虚构故事进化上的可能性!<br>造成人类社会进化差异的介绍, <strong>推荐贾雷德·戴蒙德的《枪炮、病菌与钢铁》</strong>, 其论证之精彩之严密, 至今无出其右.</p>
<p>虚构的故事千般万种, 回看真正能在人类社会流行开来的虚构故事:</p>
<ul>
<li>三大宗教, 都是宣扬平等的. 只是层次上有所差别: 教内平等vs众生平等.</li>
<li>中国集权制度: 王子犯法与庶民同罪.</li>
<li>马克思主义: 弱势群体一定会要求平等的理论.</li>
<li>西方民主制度: 平等与自由.</li>
</ul>
<p>可以发现, 虚构的故事经过一番优胜劣汰后, 能广为流传的必然会有平等的内容(有神不要紧, 但在神之下, 我们是平等的).<br>也唯有这种文化内涵, 才能聚拢人心, 保持人口规模, 避免庞大的组织从内部坍塌.<br>对统治者而言, 至少也要让人们看到或者相信这个世界还是平等的, 如果他们也相信自己能一直骗下去的话.</p>
<p>其实平等这个词很虚, 教育平等? 机会平等? 财富平等? 权利平等?<br>不同的理解就会有不同的社会模式, 事实上这几样没一样是平等的.<br>不过能广为流传的故事总得让人容易添油加醋, 去加上自己的理解么.</p>
<h2 id="众生平等"><a href="#众生平等" class="headerlink" title="众生平等"></a>众生平等</h2><p>目前, 人类社会以指数级别飞快变化着, 让越来越多的人感觉难以适应, 力不从心.<br>自从 AlphaGo 战胜所有人类棋手后, 无用阶层之论调也甚嚣尘上.<br>人类目前在雄心勃勃的进行着造脑活动, 那来看看个体之大脑对个人做了些什么.</p>
<ul>
<li>消耗20%的能量</li>
<li>养着在比较中存活的虚幻之像, 永不满足</li>
<li>偶尔的快感, 更多的失落感</li>
<li>为了目标, 可以让身体忍受痛苦, 不择手段</li>
<li>身体垮了, 才后悔道: 我应该更注重健康的</li>
</ul>
<p>事实上, 如果能让大脑放松下来, 去仔细感受一遍全身细胞的生命感和热度, 整个人就会有一种幸福感.<br>我第一次体会到这种全身暖流的幸福感是恋爱初期. 第二次就是看了《当下的力量》并认真实践之后.<br>人是一个整体, 体内每个细胞的重要性确有主次, 但他们都是活物, 也都渴望被关注, 被关注后就会回以积极的响应.</p>
<p>人类社会中的每个人, 有如每个细胞一般, 能力和贡献确有主次, 但人人渴望被平等对待.<br>也只有相对平等的社会, 包容性才更强, 才更有活力, 才会允许一定概率的思想变异. 而变异乃进化的关键因素之一!<br>这里说一下中国, 中国几个思想盛世都处于乱世之中. 在中国, 盛世只需要一言堂. 在乱世, 各种思想才有机会发扬光大.</p>
<p>更深层次的说, 不光是对人类自己. 人类也应该对所有事物保持一定的平等之心, 为我所用可以, 不要赶尽杀绝!<br>澳洲土著以及美洲土著为何没有可供驯化的大型哺乳动物? 很大可能就是被他们自己的祖先给杀光了!<br>这个影响万年以后直接导致了澳洲和美洲土著无法抵抗欧洲人的小规模入侵(《枪炮、病菌与钢铁》)</p>
<p>因此, 有幸成为人类大脑的人或物, 如果真觉得唯我独尊, 众生无用.<br>那众生既然能支撑起这个大脑活动所需的能量, 也能一起毁灭掉.</p>
<p>小孩的行为深受父母影响, 超人类的人造物其思想必起源于人类.<br>我们无法预测未来, 但我们可以善待当下, 做一个合格的父母, 树一个慈悲的榜样.</p>
<h1 id="进化"><a href="#进化" class="headerlink" title="进化"></a>进化</h1><p>这里的进化不是指达尔文的生物进化, 是指事物自行发展的过程.<br>论述进化之力量的, <strong>推荐凯文·凯利的《失控》</strong>.<br>对于人类目前主流的科学与工程学方法, 这本书就是飘在远处的一朵乌云.</p>
<h2 id="从细胞到星球生命"><a href="#从细胞到星球生命" class="headerlink" title="从细胞到星球生命"></a>从细胞到星球生命</h2><p>人类个体早就没有什么进化的压力了, 但人类这个整体始终保持着进化的特性. 做个简单类比, 帮助理解.</p>
<table>
<thead>
<tr>
<th>人的进化</th>
<th>人类的进化</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>细胞</td>
<td>人</td>
<td>低层次的基本单位</td>
</tr>
<tr>
<td>细菌</td>
<td>原始部落</td>
<td>自给自足</td>
</tr>
<tr>
<td>植物</td>
<td>原始帝国</td>
<td>职能分层</td>
</tr>
<tr>
<td>动物</td>
<td>现代社会</td>
<td>高度特质化</td>
</tr>
<tr>
<td>人</td>
<td>星球生命</td>
<td>高层次的基本单位</td>
</tr>
</tbody></table>
<ul>
<li>…(细胞怎么来的?)</li>
<li>在人体内, 充满了各种特质化的细胞, 细菌群落, 让人生存着, 发展着.</li>
<li>在人类社会, 充满了各种专职化的个人, 让人类社会生存着, 发展着.</li>
<li>在银河系内, 充满了各种专职化的星球, 让银河生命生存着, 发展着.</li>
<li>…(宇宙之外又是什么?)</li>
</ul>
<p>注: 所谓星球生命指在更高的视角上, 这个星球就是一个生命体. 然后星球生命作为基本单位进行的进化.<br>无论是人类,超人或者人造机器人,以目前的趋势,宇宙殖民是高概率的事情.</p>
<p>举例: 在 <a href="https://www.bilibili.com/video/av54169659/">《生命循环：奇异的腐烂科学》</a> 这部纪录片里，科学家用食物模拟了东京附近的城市布局。结果粘菌生长出的菌丝与东京的铁路网非常的相似，有兴趣可以从63分45秒看起，过程基本如下</p>
<p><img src="https://draapho.github.io/images/1728/mould.jpeg" alt="mould.jpeg"></p>
<h2 id="进化的几个特点"><a href="#进化的几个特点" class="headerlink" title="进化的几个特点"></a>进化的几个特点</h2><ul>
<li>低层次的事物成为高层次事物稳定的基本结构.</li>
<li>低层次的事物无法了解高层次事物的运行方式.<ul>
<li>在人体内的细菌和细胞不可能理解人类的想法和行为</li>
<li>对低层次事物而言, 高层次事物有如背景一般存在.</li>
</ul>
</li>
<li>高层次的事物无需了解, 一般也无法了解低层次事物的运行方式.</li>
<li>决定性的进化不是渐变的, 连续的. 而是突然的, 断续的.<ul>
<li>寒武纪物种大爆发</li>
<li>奥陶纪物种大爆发</li>
<li>人类的轴心时代</li>
</ul>
</li>
<li>进化以量取胜, 并用时间去尝试尽可能多的可能性.</li>
<li>进化最终会到达一个动态稳定状态, 需要外力破坏后才会重新进化.<ul>
<li>五次生物大灭绝, 才让人类有机会站在生物界之巅.</li>
<li>野火烧不尽, 春风吹又生. 没有野火的话, 有些植物是没有机会的.</li>
<li>没有死亡, 新生是没有机会的. 死亡孕育着新生</li>
</ul>
</li>
<li>成为基本单位后, 意味着种群不容易被毁灭.<ul>
<li>就是人类核武自我毁灭, 细胞和细菌依旧存在于地球.</li>
<li>只要地球环境依旧稳定, 再多次的毁灭, 生命也会重新发展起来.</li>
<li>如果以星球生命去看的话, 成规模星球生命的毁灭会导致更高层次事物的死亡.</li>
<li>但人类只要在一个星球上还活着, 就会去重新点燃这些星球生命.</li>
<li>说到底, 还是靠着时空上的数量, 以及自我繁殖达到这一点的.</li>
</ul>
</li>
</ul>
<p>进化并无明确的目的, 也不是越进化就越先进越复杂.<br>进化只是根据周遭变或不变的环境, 选择一部分, 淘汰一部分.<br>在生命的进化中, 生命并不以”生存”为目的, 生命们只是尝试着所有的可能性.<br>不难理解, 随着时间的推移, 唯有能生存和繁衍的生命才会延续至今, 推向未来.<br>很有可能的, 历史上也有试图长生不老的生命体, 但最终死于剧烈的外部环境变化.</p>
<h2 id="造物九律"><a href="#造物九律" class="headerlink" title="造物九律"></a>造物九律</h2><p>KK在文末总结了一下造物九律:</p>
<blockquote>
<p>我总结了操纵无中生有的造物九律:<br>分布式状态 (蜂窝意识, 经济体行为, 超级电脑的思维)<br>自下而上的控制 (全体能够引导自己, 复杂控制依赖于简单性的底层)<br>培养递增收益 (让技能/知识进行正反馈或滚雪球, 这样, 拥有的越多就得到的越多)<br>模块化生长 (创造有效的复杂系统的唯一途径就是先从一个简单有效的简单系统开始)<br>边缘最大化 (事物需要经历地震般的变革来适应世界, 这种变革蕴藏在事物的边缘地区)<br>礼待错误 (容忍错误, 进化可以被看作是对系统错误的管理)<br>不求目标最优, 但求目标众多 (系统能自适应和稳定运行, 就棒极了. 自适应意味着多指向的目标)<br>谋求持久的不均衡 (恒久不变和无情的变化都无益于创造, 谋求一种连续冲浪的状态)<br>变自生变 (变化是可架构的. 我的理解是, 进化有一套内在逻辑)</p>
</blockquote>
<h1 id="宇宙"><a href="#宇宙" class="headerlink" title="宇宙"></a>宇宙</h1><p>可以看看 <strong>史蒂芬·霍金的《时间简史》</strong></p>
<h2 id="已知的世界"><a href="#已知的世界" class="headerlink" title="已知的世界"></a>已知的世界</h2><p>目前的共识是大爆炸理论</p>
<ul>
<li>宇宙年龄: 138亿年</li>
<li>人类可观测到的宇宙范围: 910亿光年</li>
<li>宇宙的命运: 决定于总物质的多少. 或”大坍缩(big crunch)”, 或”大撕裂(big rip)”<ul>
<li>人们期望能给宇宙的未来一个”稳定”的未来, 或坍缩重生, 或一片死寂</li>
<li>然后测试各种参数后, 却又发现各个参数又是那么的精巧, 总是临界大坍缩和大撕裂之间</li>
</ul>
</li>
<li>人类依旧非常无知, 有些知其然而不知其所以然<ul>
<li>暗能量, 暗物质</li>
<li>反物质</li>
<li>量子纠缠</li>
</ul>
</li>
</ul>
<h2 id="未来不可预测"><a href="#未来不可预测" class="headerlink" title="未来不可预测"></a>未来不可预测</h2><p>物理是我学生时代的兴趣之一, 但对唯物观和科学的坚信不疑, 让我一度非常沮丧.<br>知道了宇宙的结局, 也就知道了人类的命运.<br>在结合一下对万事万物的主观感受, 容易得到这么一个结论:<br><strong>死神永生</strong></p>
<p>在这个前提下, 再去考虑人类为何而活, 就非常悲观了:</p>
<ul>
<li>为生存而活吗? 再努力也没用, 宇宙的定律在那里.</li>
<li>为幸福而活吗? 那超AI机器人只要把人类养在营养液里, 调节调节各种化学物质就行了.<br>  或许大部分人愿意, 但一定有一部分人不愿意! (因为没有了自由, 没法探索人生的其它可能性了)</li>
<li>追求的是一个公平的社会吗? 这需要解决一个更复杂的问题: 何为公平… 至于现实社会, 那就不提了.</li>
<li>想了一圈, 悲从心中来. 结局和过程看来都不好. 我沦为悲观主义者.</li>
</ul>
<p>幸运的是, 现在的我走出了这种命中注定的想法.</p>
<ul>
<li>我们可以精确预测生命的未来吗? 不能!</li>
<li>生命会改造物理环境吗? 会!</li>
</ul>
<p>以上两点就够了, 物理学无法去预测一个包含生命的系统.<br><strong>宇宙中包含生命, 所以宇宙的未来不可预测.</strong><br>更何况, 目前的物理学还无法调和量子力学和广义相对论.<br>就算有了大统一论, 也不意味着科学的终点.</p>
<h2 id="我们是孤独的吗"><a href="#我们是孤独的吗" class="headerlink" title="我们是孤独的吗"></a>我们是孤独的吗</h2><p>我们不可能是孤独的. 宇宙如此宽广, 我们如此无知.<br>在很多地方, 一定还存在着我们可以理解或无法理解的生命形式存在.</p>
<p>宇宙存在了138亿年, 地球生命存在了40亿年.<br>初步看来, 别处存在过生命或会产生生命是一定的, 但就如之前所说, 进化是无目的的.<br>因此不存在生命进化必然越来越智能化, 必然要征服宇宙之类的使命.<br>人类是幸运儿之一, 但也不用妄自菲薄, 我们是生命体中的一个偶然而非必然.<br>如果没有清醒的认识, 人类灭亡也是再正常不过的事情而已, 进化会去寻求别的可能性.</p>
<p>就目前观测的宇宙而言, 还没有发展成星球生命甚至星系生命的物种产生.<br>而与我们同等级的生命形式, 我们没有能力观测到.</p>
<p>如果说, 当下人类是否有最重要的事情的话, 我认同伊隆·马斯克的观点:<br><strong>尽快星际殖民, 不要把已知的生命放在地球这一个篮子里面.</strong><br>相对而言, 其它的事情譬如自我进化, 成为造物者没那么急迫.<br>原因如下:</p>
<ul>
<li>我们不确定自己会不会把地球玩残. (核战争, 环境问题)</li>
<li>随着交流越来越充分和频繁, 人类文化的多样性必然会显著下降, 这不利于进化</li>
<li>因此需要通过星际殖民, 来实现人口基数的增长以及保持文化多样性</li>
<li>唯有建立起一定数量的星球生命后, 才会有机会产生更高层次的事物并使其进化.</li>
</ul>
<p>当然, 伊隆·马斯克那小小的呐喊和亲力亲为似乎已被AI狂潮淹没.<br>但我也并不十分悲观, 一切随缘.</p>
<ul>
<li>我们不知道强AI何时才会实现, 何况强AI并不是唯一的威胁</li>
<li>人类的性格和潜力决定了, 当大众都能感知到地球有威胁时, 星际移民项目就迎来了春天.</li>
<li>讲不定, 这一波的AI发展成了支撑星际移民的关键技术之一.</li>
<li>讲不定, 星际移民导致人类过早接触其他星际文明, 然后被灭.</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>个人或人类, 生命或种群, 都是来了, 演出一番, 走了.<br>路飞之所以在罗格镇的行刑台上笑着说:”大家, 对不起, 我要死了”,<br>是知道了自己从哪来(诞生), 会到哪里去(死亡), 对来去的认同.<br>所谓人生, 即在舞台上随性表演. 但不必贪恋于舞台.</p>
<p>每个人都没自己想的那么重要, 人类也没自己想的那么独特.<br>生命没什么终极目的, 即不是生存繁衍, 也不是快乐至上.<br>生命的本质就是什么都尝试尝试, 生生死死.</p>
<p>时空都是相对的, 取决于个体的主观感受.<br>人和人类需要放下对时空的执念, 时空是舞台, 她不属于任何生命.<br>空间上不去贪恋物欲横流, 天下王土.<br>时间上不去追求长生不老, 生生世世.<br>但在舞台上怎么表演, 可以自己决定一部分.</p>
<p><strong>一花一世界, 一木一浮生. 随缘就好.</strong></p>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之字符设备-框架</title>
    <url>/2017/11/22/1733-drv-chr1/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/11/22/1733-drv-chr1/">驱动之字符设备-框架</a></li>
<li><a href="https://draapho.github.io/2017/11/30/1740-drv-chr2/">驱动之基于LinK+设计按键驱动</a></li>
<li><a href="https://draapho.github.io/2017/12/07/1741-drv-chr3/">驱动之基于中断设计按键驱动</a></li>
<li><a href="https://draapho.github.io/2017/12/11/1742-drv-chr4/">驱动之poll机制</a></li>
<li><a href="https://draapho.github.io/2017/12/12/1743-drv-chr5/">驱动之异步通知</a></li>
<li><a href="https://draapho.github.io/2017/12/13/1744-drv-chr6/">驱动之同步互斥阻塞</a></li>
<li><a href="https://draapho.github.io/2018/01/04/1801-drv-chr7/">驱动之定时器按键防抖</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="linux-架构概念"><a href="#linux-架构概念" class="headerlink" title="linux 架构概念"></a>linux 架构概念</h1><p><img src="https://draapho.github.io/images/1733/Linux_kernel_System_Call_Interface_and_glibc.png" alt="Linux_kernel_System_Call_Interface_and_glibc.png"></p>
<p><img src="https://draapho.github.io/images/1733/Linux_kernel_Layer.JPG" alt="Linux_kernel_Layer.JPG"></p>
<ul>
<li>一个操作系统需要软硬件分离. 应用端无需关注底层硬件的实现.</li>
<li>Linux采用的接口就是 GNU C Library 标准, 下面简称C库.<ul>
<li>譬如 <code>open</code> <code>read</code> <code>write</code></li>
</ul>
</li>
<li>应用程序和C库运行在芯片的用户空间 (权限受限, 保证安全).</li>
<li>当应用程序调用C库, C库会使用 <code>SWI</code> 汇编指令触发异常, 切换到内核空间.</li>
<li>内核空间的对外接口是 <strong>System Call Interface</strong>, 下面简称系统调用<ul>
<li>譬如 <code>sys_open</code> <code>sys_read</code> <code>sys_write</code></li>
</ul>
</li>
<li>触发系统调用后, Linux内核会根据框架结构自动去调用对应的驱动.</li>
<li>编写驱动时, 需要了解的是Linux各个驱动的实现框架.<ul>
<li>譬如 <code>led_open</code> <code>led_read</code> <code>led_write</code></li>
</ul>
</li>
<li>最后一点, <strong>Linux下一切皆文件, 文件即节点(inode)</strong>. 所以驱动也是一个个文件节点.</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://draapho.github.io/2017/01/23/1704-linux-source/">Linux 0.11 源码阅读笔记-总览</a></li>
<li><a href="https://draapho.github.io/2017/02/01/1704-linux-source4/">Linux 0.11 源码阅读笔记-设备驱动程序</a></li>
<li><a href="https://www.gnu.org/software/libc/documentation.html">The GNU C Library (glibc) Documentation</a></li>
</ul>
<p><strong>重点推荐</strong></p>
<ul>
<li><a href="https://www.kernel.org/doc/man-pages/">The Linux man-pages project</a> Library部分就是GNUC库的函数说明</li>
<li><a href="https://www.fsl.cs.sunysb.edu/kernel-api/">Linux Kernel API</a> Linux内核API函数说明</li>
</ul>
<h1 id="字符设备的驱动框架"><a href="#字符设备的驱动框架" class="headerlink" title="字符设备的驱动框架"></a>字符设备的驱动框架</h1><ul>
<li>实现 <code>led_open</code> <code>led_write</code> <code>led_read</code> 等函数</li>
<li>定义一个 <code>file_operations</code> 结构体, 设置好对应的函数指针<ul>
<li><code>/include/linux/fs.h</code> 下包含了此结构</li>
</ul>
</li>
<li>实现一个初始化函数, 并调用 <code>register_chrdev</code> 注册定义好的 <code>file_operations</code><ul>
<li><code>/include/linux/fs.h</code> 下包含了此函数</li>
<li>源码位于 <code>/fs/chr_dev.c</code>, 使用 <code>EXPORT_SYMBOL</code> 让内核函数可以调用它.</li>
</ul>
</li>
<li>使用 <code>module_init</code> 指定好初始化函数.</li>
<li>内核在加载驱动时, 会先自动调用初始化函数. 初始化函数做相关的注册工作</li>
<li>这样, 系统调用就能找到最终要执行的函数了.</li>
</ul>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul>
<li>主设备号. 可以人工指定, 也可以由系统动态分配. 理解为设备类型的id即可.</li>
<li>子设备号. 譬如一个led灯的驱动设备, 可以实现多个led的控制. 子设备号可以提供针对特定的led进行控制<ul>
<li>譬如: 0表示控制所有led, 1表示led1, 2表示led2…</li>
</ul>
</li>
<li>mdev. 根据动态驱动模块的信息自动创建设备节点.</li>
<li>地址映射. 这是与单片机的区别. 单片机操作寄存器可以直接使用物理地址. 但linux下使用的是虚拟地址!<ul>
<li>地址转换使用 <code>ioremap</code> <code>iounmap</code> 函数.</li>
<li>一般的芯片商也会提供操作寄存器的函数, 譬如 <code>s3c2410_gpio_setpin</code></li>
</ul>
</li>
<li>用户空间和内核空间. 两个空间的资源不能直接相互访问.<ul>
<li>驱动程序内经常要用 <code>copy_to_user</code> 以及 <code>copy_from_user</code></li>
</ul>
</li>
</ul>
<h1 id="人工绑定设备号"><a href="#人工绑定设备号" class="headerlink" title="人工绑定设备号"></a>人工绑定设备号</h1><h2 id="驱动代码-drv-leds-c"><a href="#驱动代码-drv-leds-c" class="headerlink" title="驱动代码 drv_leds.c"></a>驱动代码 drv_leds.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ~/jz2440/driver/drv_leds/drv_leds.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NAME <span class="meta-string">&quot;drv_leds&quot;</span>      <span class="comment">// 设备类型名称, cat /proc/devices 可以看到</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED_MAJOR   111             <span class="comment">// 主设备号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_LEN    5               <span class="comment">// 缓存大小. 这里定小一点便于测试</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 驱动的硬件实现部分, 和单片机类似 =====</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drv_leds_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;drv_leds_open\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">drv_leds_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *data, <span class="keyword">size_t</span> len, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buff[BUFF_LEN];</span><br><span class="line">    <span class="keyword">int</span> i, l;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;drv_leds_write: &quot;</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        l = len&lt;BUFF_LEN? len:BUFF_LEN;</span><br><span class="line">        copy_from_user(buff, data, l);                      <span class="comment">// 一点点拷贝, 避免溢出</span></span><br><span class="line">        data += l;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;l; i++)</span><br><span class="line">            printk(<span class="string">&quot;%c&quot;</span>, buff[i]);</span><br><span class="line">        len -= l;</span><br><span class="line">    &#125; <span class="keyword">while</span> (len&gt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此结构体指定了C库的文件操作函数需要调用的底层驱动的函数名.</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">drv_leds_fops</span> =</span> &#123;</span><br><span class="line">    .owner  =   THIS_MODULE,        <span class="comment">// 这是一个宏，指向编译模块时自动创建的__this_module变量. 和平台相关</span></span><br><span class="line">    .open   =   drv_leds_open,</span><br><span class="line">    .write  =   drv_leds_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 加载和卸载内核时, 指定要调用的函数 =====</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drv_leds_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    register_chrdev(LED_MAJOR, DEVICE_NAME, &amp;drv_leds_fops);<span class="comment">// 注册驱动, 包含了函数指针</span></span><br><span class="line">    printk(DEVICE_NAME <span class="string">&quot; initialized\n&quot;</span>);                   <span class="comment">// 调试用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drv_leds_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unregister_chrdev(LED_MAJOR, DEVICE_NAME);</span><br><span class="line">    printk(DEVICE_NAME <span class="string">&quot; deinitialized\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(drv_leds_init);</span><br><span class="line">module_exit(drv_leds_exit);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 描述驱动程序的一些信息，不是必须的 =====</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;draapho&quot;</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">&quot;0.1.0&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;First Driver for LED&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ~/jz2440/driver/drv_leds/Makefile</span></span><br><span class="line"></span><br><span class="line">KERN_DIR = ~/jz2440/kernel/linux-2.6.22.6</span><br><span class="line"><span class="comment"># 这是交叉编译, 需要指定嵌入式linux内核地址</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules</span><br><span class="line"><span class="comment"># pwd 表示当前目录, 即驱动代码所在的目录</span></span><br><span class="line"><span class="comment"># 驱动目录并不需要放在内核目录下面.</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules clean</span><br><span class="line">    rm -rf modules.order</span><br><span class="line"></span><br><span class="line">obj-m   += drv_leds.o</span><br></pre></td></tr></table></figure>


<h2 id="测试代码-drv-leds-test-c"><a href="#测试代码-drv-leds-test-c" class="headerlink" title="测试代码, drv_leds_test.c"></a>测试代码, drv_leds_test.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ~/jz2440/driver/drv_leds/drv_leds_test.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/xxx&quot;</span>, O_RDWR);      <span class="comment">// 这里设备名字并不重要, 设备和驱动的关联方式是主设备号!</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc &gt;=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;argc; i++)</span><br><span class="line">        write(fd, argv[i], <span class="built_in">strlen</span>(argv[i]));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./drv_led_test &lt;str1&gt; [str2]\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译加载并测试"><a href="#编译加载并测试" class="headerlink" title="编译加载并测试"></a>编译加载并测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ===== Ubuntu主机端, 编译驱动 =====</span></span><br><span class="line"><span class="comment"># pwd = drv_leds.c所在的目录.</span></span><br><span class="line">$ make clean</span><br><span class="line">$ make                                  <span class="comment"># 编译驱动</span></span><br><span class="line"><span class="comment"># 成功后, 生成 drv_leds.ko 动态库</span></span><br><span class="line"></span><br><span class="line">$ cp drv_leds.ko ~/jz2440/fs_first/     <span class="comment"># 先直接放到文件系统根目录下了.</span></span><br><span class="line"><span class="comment"># 嵌入式端最好用网络的方式加载文件系统, 这样就不用重新烧录文件系统了, 便于调试!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ===== 嵌入式Linux端, 加载驱动 =====</span></span><br><span class="line"><span class="comment"># pwd = /</span></span><br><span class="line">$ insmod drv_leds.ko                    <span class="comment"># 加载模块</span></span><br><span class="line">drv_leds initialized                    <span class="comment"># 打印的调试信息</span></span><br><span class="line">$ cat /proc/devices                     <span class="comment"># 查看设备信息</span></span><br><span class="line">Character devices:</span><br><span class="line">111 drv_leds                            <span class="comment"># 应该能找到这一项</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ===== Ubuntu主机端, 编译测试源码 =====</span></span><br><span class="line"><span class="comment"># pwd = drv_leds_test.c所在的目录.</span></span><br><span class="line">$ arm-linux-gcc -o drv_leds_test drv_leds_test.c    <span class="comment"># 编译应用程序</span></span><br><span class="line">$ cp drv_leds_test ~/jz2440/fs_first/               <span class="comment"># 先直接放到文件系统根目录下了.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果此时直接在嵌入式端运行 ./drv_leds_test</span></span><br><span class="line"><span class="comment"># 会显示 can&#x27;t open! 因为不存在文件 /dev/xxx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ===== Ubuntu主机端, 创建文件节点 ======</span></span><br><span class="line">$ mknod /dev/xxx c 111 0</span><br><span class="line"><span class="comment"># 创建设备xxx文件, c-字符设备, 111-主设备号(关联到了drv_les驱动设备), 0-子设备号(先随便写)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ===== 嵌入式Linux端, 测试驱动 =====</span></span><br><span class="line">$ ./drv_leds_test 123</span><br><span class="line">drv_leds_open</span><br><span class="line">drv_leds_write: 123</span><br></pre></td></tr></table></figure>


<h1 id="自动化实现"><a href="#自动化实现" class="headerlink" title="自动化实现"></a>自动化实现</h1><h2 id="驱动代码-drv-leds-c-1"><a href="#驱动代码-drv-leds-c-1" class="headerlink" title="驱动代码 drv_leds.c"></a>驱动代码 drv_leds.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ~/jz2440/driver/drv_leds/drv_leds.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/hardware.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NAME <span class="meta-string">&quot;drv_leds&quot;</span>                      <span class="comment">// 设备类型名称, cat /proc/devices 可以看到</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> major;                                   <span class="comment">// 存储自动分配的主设备号</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">leds_class</span>;</span>                    <span class="comment">// 类, 供mdev用, ls /sys/class/ 可以看到</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">class_device</span>  *<span class="title">leds_class_devs</span>[4];</span>    <span class="comment">// 类下设备, ls /sys/class/class_name 可以看到</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> gpio_base;                     <span class="comment">// gpio 寄存器基础地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_OFFSET(addr) ((addr) - 0x56000000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPFCON  (*(volatile unsigned long *)(gpio_base + GPIO_OFFSET(0x56000050)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPFDAT  (*(volatile unsigned long *)(gpio_base + GPIO_OFFSET(0x56000054)))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 驱动的硬件实现部分, 和单片机类似 =====</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_leds_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minor = MINOR(inode-&gt;i_rdev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化对应的LED</span></span><br><span class="line">    <span class="keyword">if</span> ((minor == <span class="number">1</span>) || (minor == <span class="number">0</span>)) &#123;             <span class="comment">// led1 或 leds</span></span><br><span class="line">        GPFCON &amp;= ~(<span class="number">0x3</span>&lt;&lt;(<span class="number">4</span>*<span class="number">2</span>));                    <span class="comment">// GPF4 配置为输出</span></span><br><span class="line">        GPFCON |= (<span class="number">1</span>&lt;&lt;(<span class="number">4</span>*<span class="number">2</span>));</span><br><span class="line">        GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);                           <span class="comment">// 关灯</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((minor == <span class="number">2</span>) || (minor == <span class="number">0</span>)) &#123;             <span class="comment">// led2 或 leds</span></span><br><span class="line">        GPFCON &amp;= ~(<span class="number">0x3</span>&lt;&lt;(<span class="number">5</span>*<span class="number">2</span>));                    <span class="comment">// GPF5 配置为输出</span></span><br><span class="line">        GPFCON |= (<span class="number">1</span>&lt;&lt;(<span class="number">5</span>*<span class="number">2</span>));</span><br><span class="line">        GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((minor == <span class="number">3</span>) || (minor == <span class="number">0</span>)) &#123;             <span class="comment">// led3 或 leds</span></span><br><span class="line">        <span class="comment">// GPFCON &amp;= ~(0x3&lt;&lt;(6*2));                    // GPF6 配置为输出</span></span><br><span class="line">        <span class="comment">// GPFCON |= (1&lt;&lt;(6*2));</span></span><br><span class="line">        <span class="comment">// GPFDAT |= (1&lt;&lt;6);</span></span><br><span class="line">        s3c2410_gpio_cfgpin(S3C2410_GPF6, S3C2410_GPF6_OUTP);</span><br><span class="line">        s3c2410_gpio_setpin(S3C2410_GPF6, <span class="number">1</span>);       <span class="comment">// 另外一种方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;drv_leds_open\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">drv_leds_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *data, <span class="keyword">size_t</span> len, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minor = MINOR(file-&gt;f_dentry-&gt;d_inode-&gt;i_rdev);</span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line"></span><br><span class="line">    copy_from_user(&amp;val, data, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作对应的LED</span></span><br><span class="line">    <span class="keyword">if</span> ((minor == <span class="number">1</span>) || (minor == <span class="number">0</span>)) &#123;             <span class="comment">// led1 或 leds</span></span><br><span class="line">        <span class="keyword">if</span> (val)</span><br><span class="line">            GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);                      <span class="comment">// 开灯</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);                       <span class="comment">// 关灯</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((minor == <span class="number">2</span>) || (minor == <span class="number">0</span>)) &#123;             <span class="comment">// led2 或 leds</span></span><br><span class="line">        <span class="keyword">if</span> (val)</span><br><span class="line">            GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((minor == <span class="number">3</span>) || (minor == <span class="number">0</span>)) &#123;             <span class="comment">// led3 或 leds</span></span><br><span class="line">        <span class="comment">// if (val)</span></span><br><span class="line">            <span class="comment">// GPFDAT &amp;= ~(1&lt;&lt;6);</span></span><br><span class="line">        <span class="comment">// else</span></span><br><span class="line">            <span class="comment">// GPFDAT |= (1&lt;&lt;6);</span></span><br><span class="line">        s3c2410_gpio_setpin(S3C2410_GPF6, !val);     <span class="comment">// 另外一种方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;drv_leds_write, led%d=%d\n&quot;</span>, minor, val);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此结构体指定了C库的文件操作函数需要调用的底层驱动的函数名.</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">drv_leds_fops</span> =</span> &#123;</span><br><span class="line">    .owner  =   THIS_MODULE,        <span class="comment">// 这是一个宏，指向编译模块时自动创建的__this_module变量. 和平台相关</span></span><br><span class="line">    .open   =   drv_leds_open,</span><br><span class="line">    .write  =   drv_leds_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 加载和卸载内核时, 指定要调用的函数 =====</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_leds_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取寄存器起始地址的虚拟地址值. 其它寄存器基于此值再用偏移量.</span></span><br><span class="line">    gpio_base = ioremap(<span class="number">0x56000000</span>, <span class="number">0xD0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!gpio_base) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册驱动, 指定主设备号</span></span><br><span class="line"><span class="comment">//    minor = register_chrdev(LED_MAJOR, DEVICE_NAME, &amp;s3c24xx_leds_fops);</span></span><br><span class="line"><span class="comment">//    if (minor &lt; 0) &#123;</span></span><br><span class="line"><span class="comment">//        printk(DEVICE_NAME &quot; can&#x27;t register major number\n&quot;);</span></span><br><span class="line"><span class="comment">//        return minor;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册驱动, 0表示动态分配主设备号</span></span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, DEVICE_NAME, &amp;drv_leds_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成系统设备信息, 供mdev自动创建设备节点使用</span></span><br><span class="line">    leds_class = class_create(THIS_MODULE, <span class="string">&quot;leds&quot;</span>);             <span class="comment">// 创建 leds 类</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(leds_class))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(leds_class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 leds 类下面的设备. 0表示所有led, 名称为 leds</span></span><br><span class="line">    leds_class_devs[<span class="number">0</span>] = class_device_create(leds_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;leds&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1-3 表示3个独立的led, 名称为 led1, led2, led3</span></span><br><span class="line">    <span class="keyword">for</span> (minor = <span class="number">1</span>; minor &lt; <span class="number">4</span>; minor++) &#123;</span><br><span class="line">        leds_class_devs[minor] = class_device_create(leds_class, <span class="literal">NULL</span>, MKDEV(major, minor), <span class="literal">NULL</span>, <span class="string">&quot;led%d&quot;</span>, minor);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(IS_ERR(leds_class_devs[minor])))</span><br><span class="line">            <span class="keyword">return</span> PTR_ERR(leds_class_devs[minor]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(DEVICE_NAME <span class="string">&quot; initialized\n&quot;</span>);                       <span class="comment">// 调试用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drv_leds_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (minor = <span class="number">0</span>; minor &lt; <span class="number">4</span>; minor++) &#123;</span><br><span class="line">        class_device_unregister(leds_class_devs[minor]);        <span class="comment">// 删除设备节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    class_destroy(leds_class);                                  <span class="comment">// 删除设备类</span></span><br><span class="line"></span><br><span class="line">    unregister_chrdev(major, DEVICE_NAME);                      <span class="comment">// 卸载驱动</span></span><br><span class="line">    iounmap(gpio_base);</span><br><span class="line">    printk(DEVICE_NAME <span class="string">&quot; deinitialized\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(drv_leds_init);</span><br><span class="line">module_exit(drv_leds_exit);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 描述驱动程序的一些信息，不是必须的 =====</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;draapho&quot;</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">&quot;0.1.1&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;First Driver for LED&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Makefile-1"><a href="#Makefile-1" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ~/jz2440/driver/drv_leds/Makefile</span></span><br><span class="line"></span><br><span class="line">KERN_DIR = ~/jz2440/kernel/linux-2.6.22.6</span><br><span class="line"><span class="comment"># 这是交叉编译, 需要指定嵌入式linux内核地址</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules</span><br><span class="line"><span class="comment"># pwd 表示当前目录, 即驱动代码所在的目录</span></span><br><span class="line"><span class="comment"># 驱动目录并不需要放在内核目录下面.</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules clean</span><br><span class="line">    rm -rf modules.order</span><br><span class="line"></span><br><span class="line">obj-m   += drv_leds.o</span><br></pre></td></tr></table></figure>


<h2 id="测试代码-drv-leds-test-c-1"><a href="#测试代码-drv-leds-test-c-1" class="headerlink" title="测试代码, drv_leds_test.c"></a>测试代码, drv_leds_test.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ~/jz2440/driver/drv_leds/drv_leds_test.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  ledtest &lt;dev&gt; &lt;on|off&gt;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_usage</span><span class="params">(<span class="keyword">char</span> *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s &lt;dev&gt; &lt;on|off&gt;\n&quot;</span>,file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;eg. \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s /dev/leds on\n&quot;</span>, file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s /dev/leds off\n&quot;</span>, file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s /dev/led1 on\n&quot;</span>, file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s /dev/led1 off\n&quot;</span>, file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span>* filename;</span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;                        <span class="comment">// 输入错误, 打印帮助信息</span></span><br><span class="line">        print_usage(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    filename = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    fd = open(filename, O_RDWR);            <span class="comment">// 打开设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error, can&#x27;t open %s\n&quot;</span>, filename);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;on&quot;</span>, argv[<span class="number">2</span>])) &#123;    <span class="comment">// 亮灯</span></span><br><span class="line">        val = <span class="number">1</span>;</span><br><span class="line">        write(fd, &amp;val, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;off&quot;</span>, argv[<span class="number">2</span>])) &#123;   <span class="comment">// 灭灯</span></span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">        write(fd, &amp;val, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        print_usage(argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译加载并测试-1"><a href="#编译加载并测试-1" class="headerlink" title="编译加载并测试"></a>编译加载并测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ===== Ubuntu主机端, 编译驱动 =====</span></span><br><span class="line"><span class="comment"># pwd = drv_leds.c所在的目录.</span></span><br><span class="line">$ make clean</span><br><span class="line">$ make                                  <span class="comment"># 编译驱动</span></span><br><span class="line"><span class="comment"># 成功后, 生成 drv_leds.ko 动态库</span></span><br><span class="line"></span><br><span class="line">$ cp drv_leds.ko ~/jz2440/fs_first/     <span class="comment"># 先直接放到文件系统根目录下了.</span></span><br><span class="line"><span class="comment"># 嵌入式端最好用网络的方式加载文件系统, 这样就不用重新烧录文件系统了, 便于调试!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ===== 嵌入式Linux端, 加载驱动 =====</span></span><br><span class="line"><span class="comment"># pwd = /</span></span><br><span class="line">$ insmod drv_leds.ko                    <span class="comment"># 加载模块</span></span><br><span class="line">drv_leds initialized                    <span class="comment"># 打印的调试信息</span></span><br><span class="line">$ cat /proc/devices                     <span class="comment"># 查看设备信息</span></span><br><span class="line">Character devices:</span><br><span class="line">252 drv_leds                            <span class="comment"># 应该能找到这一项, 自动分配的主设备号252</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要配置好 mdev. 才支持insmod后自动生成设备节点.</span></span><br><span class="line">$ ls -l /dev/led1                       <span class="comment"># 查看自动加载的设备节点 led1. 其它3个同理查看</span></span><br><span class="line">crw-rw----  1 0     0       252, 1  时间信息    /dev/led1</span><br><span class="line">$ <span class="built_in">cd</span> /sys/class/                        <span class="comment"># 查看设备的类</span></span><br><span class="line">$ ls</span><br><span class="line">leds                                    <span class="comment"># 可以找到这一项</span></span><br><span class="line">$ ls leds/                              <span class="comment"># 查看类下面的设备</span></span><br><span class="line">led1 led2 led3 leds</span><br><span class="line">$ cat leds/led1/dev                     <span class="comment"># 查看设备信息</span></span><br><span class="line">252:1                                   <span class="comment"># 主设备号252(自动分配的), 次设备号为1</span></span><br><span class="line">$ rmmod drv_leds.ko                     <span class="comment"># 移除驱动</span></span><br><span class="line">drv_leds deinitialized                  <span class="comment"># 打印的调试信息</span></span><br><span class="line">$ ls /dev/led1                          <span class="comment"># 会告知文件或目录不存在</span></span><br><span class="line">$ ls /sys/class                         <span class="comment"># leds 已经不见了! 说明mdev把这个设备节点自动卸载掉了.</span></span><br><span class="line">$ insmod drv_leds.ko                    <span class="comment"># 加载一下, 为测试做准备</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ===== Ubuntu主机端, 编译测试源码 =====</span></span><br><span class="line"><span class="comment"># pwd = drv_leds_test.c所在的目录.</span></span><br><span class="line">$ arm-linux-gcc -o drv_leds_test drv_leds_test.c    <span class="comment"># 编译应用程序</span></span><br><span class="line">$ cp drv_leds_test ~/jz2440/fs_first/               <span class="comment"># 先直接放到文件系统根目录下了.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ===== 嵌入式Linux端, 测试驱动 =====</span></span><br><span class="line">$ ./drv_leds_test                       <span class="comment"># 显示使用方法</span></span><br><span class="line">$ ./drv_leds_test /dev/leds on          <span class="comment"># LED全开</span></span><br><span class="line">$ ./drv_leds_test /dev/led2 off         <span class="comment"># 关LED2</span></span><br></pre></td></tr></table></figure>




<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之定时器按键防抖</title>
    <url>/2018/01/04/1801-drv-chr7/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/11/22/1733-drv-chr1/">驱动之字符设备-框架</a></li>
<li><a href="https://draapho.github.io/2017/11/30/1740-drv-chr2/">驱动之基于LinK+设计按键驱动</a></li>
<li><a href="https://draapho.github.io/2017/12/07/1741-drv-chr3/">驱动之基于中断设计按键驱动</a></li>
<li><a href="https://draapho.github.io/2017/12/11/1742-drv-chr4/">驱动之poll机制</a></li>
<li><a href="https://draapho.github.io/2017/12/12/1743-drv-chr5/">驱动之异步通知</a></li>
<li><a href="https://draapho.github.io/2017/12/13/1744-drv-chr6/">驱动之同步互斥阻塞</a></li>
<li><a href="https://draapho.github.io/2017/12/13/1744-drv-chr6/">驱动之同步互斥阻塞</a></li>
<li><a href="https://draapho.github.io/2018/01/04/1801-drv-chr7/">驱动之定时器按键防抖</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.<br>硬件具备唯一性, 因此某一时刻应该只有一个应用程序能对驱动进行操作.</p>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>定时器的用法一般分为如下步骤:</p>
<ol>
<li>声明一个 timer<ul>
<li><code>struct timer_list newTimer</code></li>
</ul>
</li>
<li>声明并初始化 timer<ul>
<li>方法一: <code>DEFINE_TIMER(newTimer, timer_function, expires, data);</code></li>
<li>方法二: <code>setup_timer(&amp;newTimer, timer_function, data)</code></li>
<li>方法三: <code>init_timer(&amp;newTimer)</code></li>
<li>timer_function 就是定时器的中断服务函数</li>
</ul>
</li>
<li>完善定时中断服务函数<ul>
<li>要周期性调用定时器, 使用 <code>mod_timer(&amp;newTimer, jiffies+interval)</code> 重新注册</li>
<li>此部分代码特别注意锁的问题!</li>
</ul>
</li>
<li>注册 timer 到定时器链表<ul>
<li>相当于启动定时器, 可用 <code>add_timer(&amp;newTimer)</code></li>
<li>实际上 <code>add_timer</code> 并非必须调用, 直接使用<code>mod_timer</code>也没问题.</li>
<li><code>mod_timer</code> 等效于 <code>del_timer(); set expires; add_timer();</code></li>
</ul>
</li>
<li>重新注册 timer<ul>
<li>定时器配在置好后只运行一次，执行完中断服务函数后定时器就会自动销毁!</li>
<li>想要实现周期性定时中断就必须在中断服务程序的结尾重新给定时器写入超时值</li>
<li>使用 <code>mod_timer(&amp;newTimer, jiffies+interval)</code> 重新注册</li>
</ul>
</li>
<li>提前停止定时器 timer （非必需步骤）<ul>
<li>定时器计时结束后, 系统会自动销毁相关定时器.</li>
<li><code>del_timer(&amp;newTimer)</code></li>
<li><code>del_timer_sync(&amp;newTimer)</code>, 用于多核CPU. 单核的话等同于 <code>del_timer</code></li>
</ul>
</li>
<li>其它相关概念<ul>
<li><code>jiffies</code> 是linux系统启动后芯片时钟的节拍总数</li>
<li><code>HZ</code> 每秒经过的jiffies数. 其值就是系统时钟的频率</li>
<li><code>jiffies/HZ</code> 就是当前系统运行了多少秒</li>
<li>64位系统中, jiffies 只访问到低32位值, 需要使用 <code>get_jiffies_64()</code> 才能获取完整的64位数值.</li>
</ul>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://blog.csdn.net/armeasy/article/details/6027709">内核sem、wait_queue_head_t、timer和kernel_thread使用驱动范例</a> 内核线程和定时器的用法</li>
<li><a href="http://blog.csdn.net/qidi_huang/article/details/51318157">Linux内核 定时器 用法</a></li>
<li><a href="http://www.cnblogs.com/chen-farsight/p/6226562.html">Linux设备驱动——内核定时器</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-timers-list/index.html">Linux内核中的计时器和列表</a></li>
</ul>
<h1 id="驱动源码"><a href="#驱动源码" class="headerlink" title="驱动源码"></a>驱动源码</h1><p>此驱动源码是韦东山教程里按键的最终版本. 驱动有如下特性:</p>
<ul>
<li>按键使用了中断</li>
<li>多线程/进程安全, 硬件使用了互斥量.</li>
<li>支持应用层阻塞或者非阻塞访问</li>
<li>支持poll机制. 应用层可以使用poll</li>
<li>支持异步机制. 应用层可以用信号中断来处理按键事件</li>
</ul>
<p>但对我个人而言, 这一版本的按键依旧不够好, 有机会自己写一版按键驱动</p>
<ul>
<li>按键状态反馈过于简单, 没有提供诸如短按, 长按, 连发, 释放的按键信息.</li>
<li>经典的按键范例是状态机模型, 用定时器定时扫描按键状态, 可以不用硬件中断.</li>
<li>没有实现对单个按键的open/closse操作.</li>
</ul>
<h2 id="drv-keys-c"><a href="#drv-keys-c" class="headerlink" title="drv_keys.c"></a>drv_keys.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">===============================================================================</span><br><span class="line">Driver Name     :       drv_keys</span><br><span class="line">Author          :       DRAAPHO</span><br><span class="line">License         :       GPL</span><br><span class="line">Description     :       LINUX DEVICE DRIVER PROJECT</span><br><span class="line">===============================================================================</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;drv_keys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEYS_N_MINORS 1                 <span class="comment">// 子设备号, 可用于区别按键.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEYS_FIRST_MINOR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEYS_NODE_NAME <span class="meta-string">&quot;key&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEYS_BUFF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> drv_keys_major=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">dev_t</span> drv_keys_device_num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">drv_keys_class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">keys_async</span>;</span>            <span class="comment">// 新增, kill_fasync使用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_MUTEX</span><span class="params">(keys_lock)</span></span>;             <span class="comment">// 定义互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">privatedata</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nMinor;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">drv_keys_device</span>;</span></span><br><span class="line">&#125; drv_keys_private;</span><br><span class="line"></span><br><span class="line">drv_keys_private devices[DRV_KEYS_N_MINORS];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 中断和定时器增加的代码 =====</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(key_waitq)</span></span>;  <span class="comment">// 作用类似于信号量, 这里是向系统加入一个等待列表.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> ev_press = <span class="number">0</span>;           <span class="comment">// 中断事件标记, 手动值1或者清0</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> keys_val;              <span class="comment">// 记录按键值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pin_desc</span> * <span class="title">pindesc</span>;</span>                  <span class="comment">// 用于保存中断内的数据指针, 给超时函数使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">keys_timer</span>;</span>               <span class="comment">// 定时器</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pin_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pin;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> key_val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pin_desc</span> <span class="title">pins_desc</span>[3] =</span> &#123;            <span class="comment">// 设置好按键的引脚和对应的值</span></span><br><span class="line">    &#123;S3C2410_GPF0, <span class="number">0x01</span>&#125;,</span><br><span class="line">    &#123;S3C2410_GPF2, <span class="number">0x02</span>&#125;,</span><br><span class="line">    &#123;S3C2410_GPG3, <span class="number">0x04</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">keys_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PINFO(<span class="string">&quot;keys_irq, irq=%d\n&quot;</span>, irq);</span><br><span class="line">    pindesc = (struct pin_desc *)dev_id;    <span class="comment">// 获取自用的数据指针</span></span><br><span class="line">    mod_timer(&amp;keys_timer, jiffies+HZ/<span class="number">100</span>); <span class="comment">// 每次产生中断, 都等待10ms, 避开按键抖动</span></span><br><span class="line">    <span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keys_wait_10ms</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span> </span>&#123;            <span class="comment">// 中断发生10ms后, 在读取电平值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pinval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pindesc)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    pinval = s3c2410_gpio_getpin(pindesc-&gt;pin);             <span class="comment">// 读取按键电平</span></span><br><span class="line">    <span class="keyword">if</span> (pinval) &#123;                                           <span class="comment">// 松开</span></span><br><span class="line">        keys_val &amp;= ~pindesc-&gt;key_val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                <span class="comment">// 按下</span></span><br><span class="line">        keys_val |= pindesc-&gt;key_val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ev_press = <span class="number">1</span>;                                           <span class="comment">// 表示中断发生</span></span><br><span class="line">    wake_up_interruptible(&amp;key_waitq);                      <span class="comment">// 唤醒休眠的进程</span></span><br><span class="line">    kill_fasync(&amp;keys_async, SIGIO, POLL_IN);               <span class="comment">// 发送SIGIO信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 部分修改模板代码 =====</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_keys_open</span><span class="params">(struct inode *inode,struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;               <span class="comment">// 非阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (down_trylock(&amp;keys_lock))               <span class="comment">// 尝试获取信号量</span></span><br><span class="line">            <span class="keyword">return</span> -EBUSY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        down(&amp;keys_lock);                           <span class="comment">// 获取信号量, 阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    drv_keys_private *priv = container_of(inode-&gt;i_cdev ,</span><br><span class="line">            drv_keys_private ,cdev);</span><br><span class="line">    filp-&gt;private_data = priv;</span><br><span class="line">    PINFO(<span class="string">&quot;drv_keys_open\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册中断号, 设置中断类型, 设置中断名称(和设备名称无关), 传入自用的数据指针</span></span><br><span class="line">    ret  = request_irq(IRQ_EINT0, keys_irq, IRQT_BOTHEDGE, <span class="string">&quot;S2&quot;</span>, &amp;pins_desc[<span class="number">0</span>]);</span><br><span class="line">    ret |= request_irq(IRQ_EINT2, keys_irq, IRQT_BOTHEDGE, <span class="string">&quot;S3&quot;</span>, &amp;pins_desc[<span class="number">1</span>]);</span><br><span class="line">    ret |= request_irq(IRQ_EINT11, keys_irq, IRQT_BOTHEDGE, <span class="string">&quot;S4&quot;</span>, &amp;pins_desc[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器初始化.</span></span><br><span class="line">    setup_timer(&amp;keys_timer, keys_wait_10ms, <span class="number">0</span>);</span><br><span class="line">    add_timer(&amp;keys_timer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_keys_release</span><span class="params">(struct inode *inode,struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    drv_keys_private *priv;</span><br><span class="line">    priv=filp-&gt;private_data;</span><br><span class="line">    PINFO(<span class="string">&quot;drv_keys_release\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    del_timer_sync(&amp;keys_timer);                    <span class="comment">// 删除定时器</span></span><br><span class="line">    free_irq(IRQ_EINT11, &amp;pins_desc[<span class="number">2</span>]);            <span class="comment">// 注销中断</span></span><br><span class="line">    free_irq(IRQ_EINT2, &amp;pins_desc[<span class="number">1</span>]);</span><br><span class="line">    free_irq(IRQ_EINT0, &amp;pins_desc[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    up(&amp;keys_lock);                                 <span class="comment">// 释放信号量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">drv_keys_read</span><span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span> __user *ubuff,<span class="keyword">size_t</span> count,<span class="keyword">loff_t</span> *offp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    drv_keys_private *priv;</span><br><span class="line">    priv = filp-&gt;private_data;</span><br><span class="line">    PINFO(<span class="string">&quot;drv_keys_read()\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;               <span class="comment">// 非阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (!ev_press)                              <span class="comment">// 无按键, 立刻返回</span></span><br><span class="line">            <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ev_press, 用于判断是否可以让当前进程睡眠(让出CPU, 进程切换)</span></span><br><span class="line">        wait_event_interruptible(key_waitq, ev_press);      <span class="comment">// 阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ev_press = <span class="number">0</span>;                                           <span class="comment">// 运行后, 立刻清零</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ubuff, &amp;keys_val, <span class="number">1</span>)) &#123;                <span class="comment">// 传回按键值</span></span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="title">drv_keys_poll</span><span class="params">(struct file *file, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">    poll_wait(file, &amp;key_waitq, wait);      <span class="comment">// 这里不会休眠. 进程不阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ev_press)</span><br><span class="line">        mask |= POLLIN | POLLRDNORM;        <span class="comment">// 关键是返回值, 返回值为0, 进程可能休眠.</span></span><br><span class="line">        <span class="comment">// POLLIN, 是标准的事件值, 测试程序就基于此判断.</span></span><br><span class="line">        <span class="comment">// POLLRDNORM, Normal data may be read without blocking. 作用应该是告知应用程序类型和后续动作.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_keys_fasync</span> <span class="params">(<span class="keyword">int</span> fd, struct file *filp, <span class="keyword">int</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PINFO(<span class="string">&quot;drv_key_fasync\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> fasync_helper (fd, filp, on, &amp;keys_async);       <span class="comment">// 初始化keys_async</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 模板代码, 没有修改 =====</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">drv_keys_fops</span>=</span> &#123;</span><br><span class="line">    .owner              = THIS_MODULE,</span><br><span class="line">    .open               = drv_keys_open,</span><br><span class="line">    .release            = drv_keys_release,</span><br><span class="line">    .read               = drv_keys_read,</span><br><span class="line">    .poll               = drv_keys_poll,</span><br><span class="line">    .fasync             = drv_keys_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">drv_keys_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    res = alloc_chrdev_region(&amp;drv_keys_device_num,DRV_KEYS_FIRST_MINOR,DRV_KEYS_N_MINORS ,DRIVER_NAME);</span><br><span class="line">    <span class="keyword">if</span>(res) &#123;</span><br><span class="line">        PERR(<span class="string">&quot;register device no failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    drv_keys_major = MAJOR(drv_keys_device_num);</span><br><span class="line"></span><br><span class="line">    drv_keys_class = class_create(THIS_MODULE , DRIVER_NAME);</span><br><span class="line">    <span class="keyword">if</span>(!drv_keys_class) &#123;</span><br><span class="line">        PERR(<span class="string">&quot;class creation failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;DRV_KEYS_N_MINORS;i++) &#123;</span><br><span class="line">        drv_keys_device_num= MKDEV(drv_keys_major ,DRV_KEYS_FIRST_MINOR+i);</span><br><span class="line">        cdev_init(&amp;devices[i].cdev , &amp;drv_keys_fops);</span><br><span class="line">        cdev_add(&amp;devices[i].cdev,drv_keys_device_num,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        devices[i].drv_keys_device  =</span><br><span class="line">                device_create(drv_keys_class , <span class="literal">NULL</span> ,drv_keys_device_num ,</span><br><span class="line">                            <span class="comment">// NULL ,DRV_KEYS_NODE_NAME&quot;%d&quot;,DRV_KEYS_FIRST_MINOR+i);    // for higher kernel version</span></span><br><span class="line">                            DRV_KEYS_NODE_NAME<span class="string">&quot;%d&quot;</span>,DRV_KEYS_FIRST_MINOR+i);             <span class="comment">// for 2.6 kernel version</span></span><br><span class="line">        <span class="keyword">if</span>(!devices[i].drv_keys_device) &#123;</span><br><span class="line">            class_destroy(drv_keys_class);</span><br><span class="line">            PERR(<span class="string">&quot;device creation failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        devices[i].nMinor = DRV_KEYS_FIRST_MINOR+i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;INIT\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">drv_keys_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;EXIT\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;DRV_KEYS_N_MINORS;i++) &#123;</span><br><span class="line">        drv_keys_device_num= MKDEV(drv_keys_major ,DRV_KEYS_FIRST_MINOR+i);</span><br><span class="line"></span><br><span class="line">        cdev_del(&amp;devices[i].cdev);</span><br><span class="line"></span><br><span class="line">        device_destroy(drv_keys_class ,drv_keys_device_num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class_destroy(drv_keys_class);</span><br><span class="line"></span><br><span class="line">    unregister_chrdev_region(drv_keys_device_num ,DRV_KEYS_N_MINORS);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(drv_keys_init);</span><br><span class="line">module_exit(drv_keys_exit);</span><br></pre></td></tr></table></figure>


<h2 id="drv-keys-h"><a href="#drv-keys-h" class="headerlink" title="drv_keys.h"></a>drv_keys.h</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_NAME <span class="meta-string">&quot;drv_keys&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDEBUG(fmt,args...) printk(KERN_DEBUG<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERR(fmt,args...) printk(KERN_ERR<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME,##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINFO(fmt,args...) printk(KERN_INFO<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch-s3c2410/irqs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/hardware.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>这里我修改了一下, 把测试文件的编译也放进了这个文件.<br>用 <code>make test</code> 就能编译测试文件.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TEST_FILE   := drv_keys_test</span><br><span class="line"></span><br><span class="line">obj-m       := drv_keys.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br><span class="line">    rm -f <span class="variable">$(TEST_FILE)</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">    arm-linux-gcc <span class="variable">$(TEST_FILE)</span>.c -o <span class="variable">$(TEST_FILE)</span></span><br></pre></td></tr></table></figure>


<h2 id="drv-keys-test-c"><a href="#drv-keys-test-c" class="headerlink" title="drv_keys_test.c"></a>drv_keys_test.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void keys_signal_handler(int signum)         // 信号中断处理函数</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">// unsigned char key_val = 0;</span></span><br><span class="line">    <span class="comment">// read(fd,&amp;key_val,1);</span></span><br><span class="line">    <span class="comment">// printf(&quot;key_val: 0x%x\n&quot;,key_val);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> oflags;                                 <span class="comment">// 用于异步通知的设置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span>                       <span class="comment">// poll 关联的文件, 可多个文件</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> key_val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/key0&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">// fd = open(&quot;/dev/key0&quot;, O_RDWR | O_NONBLOCK); // 非阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===== 使用异步通知 =====</span></span><br><span class="line">    <span class="comment">// signal(SIGIO, keys_signal_handler);      // 注册信号中断处理函数</span></span><br><span class="line">    <span class="comment">// fcntl(fd,F_SETOWN,getpid());             // 告诉内核，发给本进程</span></span><br><span class="line">    <span class="comment">// oflags = fcntl(fd,F_GETFL);</span></span><br><span class="line">    <span class="comment">// fcntl(fd, F_SETFL, oflags | FASYNC);     // 改变fasync标记, 内核会调用驱动fasync, 完成初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===== POLL轮询 =====</span></span><br><span class="line">    <span class="comment">// fds[0].fd     = fd;                      // 关联的驱动文件</span></span><br><span class="line">    <span class="comment">// fds[0].events = POLLIN;                  // 事件类型</span></span><br><span class="line">    <span class="comment">// while (1) &#123;</span></span><br><span class="line">        <span class="comment">// ret = poll(fds, 1, 5000);            // 执行poll. 最多阻塞5s (有按键事件会立刻返回)</span></span><br><span class="line">        <span class="comment">// if (ret == 0) &#123;</span></span><br><span class="line">        <span class="comment">//     printf(&quot;time out\n&quot;);            // 5s后超时</span></span><br><span class="line">        <span class="comment">// &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//     read(fd, &amp;keys_val, 1);          // 有按键, 读取按键值</span></span><br><span class="line">        <span class="comment">//     printf(&quot;keys_val = 0x%x\n&quot;, keys_val);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===== 阻塞查询 =====</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;                                  <span class="comment">// 开始主任务</span></span><br><span class="line">        ret = read(fd,&amp;key_val,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;key_val: 0x%x, ret = %d\n&quot;</span>, key_val, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="编译和测试"><a href="#编译和测试" class="headerlink" title="编译和测试"></a>编译和测试</h1><h2 id="Ubuntu主机端"><a href="#Ubuntu主机端" class="headerlink" title="Ubuntu主机端"></a>Ubuntu主机端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主机端, 编译源码</span></span><br><span class="line"><span class="comment"># pwd = /home/draapho/share/drv/drv_key_poll/KERN_SRC   # 驱动源码路径, share是nfs共享文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译驱动</span></span><br><span class="line">$ make clean</span><br><span class="line">$ make modules                  <span class="comment"># 编译驱动</span></span><br><span class="line">$ make <span class="built_in">test</span>                     <span class="comment"># 编译测试代码</span></span><br></pre></td></tr></table></figure>

<h2 id="开发板端"><a href="#开发板端" class="headerlink" title="开发板端"></a>开发板端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板端, 测试驱动功能</span></span><br><span class="line"><span class="comment"># pwd = /home/draapho/share/drv/drv_key_poll/KERN_SRC   # 驱动源码路径, share是nfs共享文件夹</span></span><br><span class="line"></span><br><span class="line">$ insmod drv_keys.ko            <span class="comment"># 加载模块</span></span><br><span class="line">$ ./drv_keys_test               <span class="comment"># 检测按键中断</span></span><br><span class="line"><span class="comment"># 按键测试...</span></span><br><span class="line"><span class="comment"># 按ctrl+c 终止进程</span></span><br><span class="line"></span><br><span class="line">$ ./drv_keys_test &amp;             <span class="comment"># 后台运行, 会运行</span></span><br><span class="line">$ ./drv_keys_test &amp;             <span class="comment"># 后台运行, 进程被挂起, 因为资源被锁.</span></span><br><span class="line">$ top                           <span class="comment"># 查看进程情况</span></span><br><span class="line">$ <span class="built_in">kill</span> 789                      <span class="comment"># 杀死第一个进程</span></span><br><span class="line"><span class="comment"># 第二个进程就能获得资源, 开始运行</span></span><br><span class="line">$ <span class="built_in">kill</span> 790                      <span class="comment"># 杀死第二个进程</span></span><br><span class="line">$ rmmod drv_keys.ko             <span class="comment"># 卸载模块</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>linuxembedded linux</tag>
        <tag>drv</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之input子系统</title>
    <url>/2018/01/05/1802-drv-input/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a></li>
<li><a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a></li>
<li><a href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">驱动之RTC分析</a></li>
<li><a href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">驱动之LCD驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/11/1806-drv-ts/">驱动之触摸屏驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">驱动之USB基础概念和框架</a></li>
<li><a href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">驱动之USB设备驱动程序</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="输入子系统"><a href="#输入子系统" class="headerlink" title="输入子系统"></a>输入子系统</h1><p>输入子系统是Linux对硬件设备进一步的抽象.<br>将输入系统的逻辑概念统一写好, 我们称之为软件抽象层.<br>而硬件部分的底层工作需要由开发人员具体实现, 我们称之为硬件设备层.<br>中间还有个连接层, 用于实现软件抽象层和硬件设备层的多对多关联.</p>
<p>按键, 鼠标, 键盘, 触摸屏等设备都可以归属为输入子系统.<br>这些设备的硬件驱动和输入子系统对接, 输入子系统再统一将输入事件传递给应用层.<br>这样, 应用层的设备就无需考虑底层硬件的区别.<br>而我们之前写的按键驱动, LED驱动, 一般只是给公司内部调用的, 不具有通用性!</p>
<p>整个输入子系统完成的工作其实和自己写的驱动是一样的.<br>只是部分可以软件抽象的功能被输入子系统打包掉了.<br>其核心代码在 <code>/drivers/input/input.c</code><br>整体框架如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ===== 输入子系统, 核心层 =====</span></span><br><span class="line">文件 /drivers/input/input.c 内, 关键函数</span><br><span class="line">    input_init              <span class="comment">// 初始化</span></span><br><span class="line">    class_register          <span class="comment">// 注册类</span></span><br><span class="line">    register_chrdev         <span class="comment">// 注册设备(主设备号13)</span></span><br><span class="line"></span><br><span class="line">    input_register_device   <span class="comment">// 注册硬件设备 input_dev</span></span><br><span class="line">    input_register_handler  <span class="comment">// 注册软件抽象 input_handler</span></span><br><span class="line">    input_register_handle   <span class="comment">// 注册连接     input_handle</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 软件抽象层, 系统已实现 =====</span></span><br><span class="line"><span class="number">1.</span> <span class="keyword">static</span> 初始化一个 input_handler 全局变量</span><br><span class="line"><span class="number">2.</span> 注册此变量, input_register_handler</span><br><span class="line"><span class="number">3.</span> 实现 event connect 等函数</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> &#123;</span></span><br><span class="line">    event,connect, disconnect, start        <span class="comment">// 函数具体实现的指针</span></span><br><span class="line">    <span class="keyword">int</span> minor;                              <span class="comment">// 次设备号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;                       <span class="comment">// 显示在proc/bus/input/handlers</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id_table</span>;</span> <span class="comment">// 驱动支持的id表(用于匹配input_dev)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">blacklist</span>;</span><span class="comment">// id表黑名单</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_list</span>;</span>             <span class="comment">// 存放input_handle(没有r)的链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">node</span>;</span>               <span class="comment">// 存放input_handler自身的链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 连接层, 系统已实现 =====</span></span><br><span class="line">多个文件 /drivers/input<span class="comment">/*dev.c 内*/</span></span><br><span class="line"><span class="number">1.</span> *dev_connect里分配 input_handle(没有r)变量</span><br><span class="line"><span class="number">2.</span> 设置/初始化此变量</span><br><span class="line"><span class="number">3.</span> 注册, input_register_handle(没有r)</span><br><span class="line"></span><br><span class="line"><span class="function">struct <span class="title">input_handle</span><span class="params">(没有r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;                          <span class="comment">// 私有数据, 指向了父指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span>                  <span class="comment">// 指向input_dev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span>          <span class="comment">// 指向 input_handler</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">d_node</span>;</span>             <span class="comment">// 存放input_dev-&gt;h_list的链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_node</span>;</span>             <span class="comment">// 存放input_handler-&gt;h_list的链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 硬件设备层, 自己写 =====</span></span><br><span class="line"><span class="number">1.</span> 分配一个input_dev变量</span><br><span class="line"><span class="number">2.</span> 设置/初始化此变量</span><br><span class="line"><span class="number">3.</span> 注册, input_register_device</span><br><span class="line"><span class="number">4.</span> 硬件相关代码, open, close, event, sync等等.</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;                       <span class="comment">// 设备描述</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *phys;                       <span class="comment">// 设备路径?</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span>                     <span class="comment">// 总线类型. 供应商/产品/版本信息. 用于匹配 input_handler</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> evbit[NBITS(EV_MAX)];     <span class="comment">// 记录支持的事件类型位图</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> keybit[NBITS(KEY_MAX)];   <span class="comment">// 记录支持的按键值位图</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> relbit[NBITS(REL_MAX)];   <span class="comment">// 记录支持的相对坐标位图, 如滚轮</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> absbit[NBITS(ABS_MAX)];   <span class="comment">// 记录支持的绝对坐标位图, 如触摸屏</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_list</span>;</span>             <span class="comment">// 存放input_handle(没有r)的链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">node</span>;</span>               <span class="comment">// 存放input_dev自身的链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如图, 较为直观的说明了三者的指针关系, 以及 <code>input_handler</code> 和 <code>input_dev</code> 通过 <code>input_handle(没有r)</code> 的建立的多对多关系</p>
<p><img src="https://draapho.github.io/images/1802/input_struct_relation.png" alt="input_struct_relation"></p>
<h2 id="input核心层"><a href="#input核心层" class="headerlink" title="input核心层"></a>input核心层</h2><p>整个input初始化流程大致如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/input/input.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">input_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">class_register</span><span class="params">(&amp;input_class)</span></span>;       <span class="comment">// 注册input类. 对应于自己写的驱动的 class_create, 也会class_register</span></span><br><span class="line">    input_proc_init();                  <span class="comment">// 初始化一些交互文件</span></span><br><span class="line">    register_chrdev(INPUT_MAJOR, <span class="string">&quot;input&quot;</span>, &amp;input_fops); <span class="comment">// 对应于自己写的驱动的 register_chrdev, 注册设备</span></span><br><span class="line">        <span class="comment">// input的主设备号固定为13, 子设备号后面会自动分配. 核心是 input_fops 这么一个结构.</span></span><br><span class="line">        <span class="comment">// 查看 input_fops 变量, 只有一个 .open 函数, 指向 input_open_file</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_open_file</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function">            struct input_handler *handler </span>= input_table[iminor(inode) &gt;&gt; <span class="number">5</span>];    <span class="comment">// 取出子设备号高3位, 低5位用于自动分配</span></span><br><span class="line">            new_fops = fops_get(handler-&gt;fops)  <span class="comment">// 打开handler指向的fop, 譬如 &amp;evdev_fops (后面会讲到)</span></span><br><span class="line">            file-&gt;f_op = new_fops;</span><br><span class="line">            new_fops-&gt;open(inode, file);        <span class="comment">// 打开真正可操作的文件, 里面会有 read, write</span></span><br><span class="line">            <span class="comment">// 这样 app:read &gt; ... &gt; file-&gt;f_op-&gt;read</span></span><br><span class="line">    <span class="comment">// 另外一个 class_device_create 是在 input_handler.connect 的函数里实现的.</span></span><br></pre></td></tr></table></figure>

<p>上述代码, 关键点在于从 input_table 取出 input_handler的指针.<br>那么 input_table 由谁构造呢? 搜索可知是: <code>input_register_handler</code>. 继续往下看.</p>
<h2 id="软件抽象层"><a href="#软件抽象层" class="headerlink" title="软件抽象层"></a>软件抽象层</h2><p>注册 input_handler 的过程:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// input_open_file 函数里, 有个关键数组为 input_table, 存储了input_handler的指针!</span></span><br><span class="line"><span class="comment">// 函数 input_register_handler 会设置 input_table. 它被如下代码调用:</span></span><br><span class="line"><span class="comment">// drivers/char/keyboard.c  // 按键抽象</span></span><br><span class="line"><span class="comment">// drivers/input/evbug.c    // 调试用, 所用的事件存到 syslog文件中</span></span><br><span class="line"><span class="comment">// drivers/input/evdev.c    // input_table[2], 子设备号0x40-0x5F, 设备事件抽象</span></span><br><span class="line"><span class="comment">// drivers/input/joydev.c   // input_table[0], 子设备号0x00-0x0F, 游戏杆抽象</span></span><br><span class="line"><span class="comment">// drivers/input/mousedev.c // input_table[1], 子设备号0x20-0x3F, 鼠标抽象</span></span><br><span class="line"><span class="comment">// drivers/input/tsdev.c    // input_table[4], 子设备号0x80-0x9F, 触摸屏抽象</span></span><br><span class="line"><span class="comment">// 上述几个文件真正定义了 input_handler 的变量如 evdev_handler, 并对其初始化, 包括 id_table</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_handler</span><span class="params">(struct input_handler *handler)</span></span></span><br><span class="line">    input_table[handler-&gt;minor &gt;&gt; 5] = handler;         // 将input_handler指针放入数组</span><br><span class="line">    list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list); <span class="comment">// 放入链表</span></span><br><span class="line">    list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);             <span class="comment">// 对于每个input_dev, 调用input_attach_handler</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_attach_handler</span><span class="params">(struct input_dev *dev, struct input_handler *handler)</span></span></span><br><span class="line"><span class="function">    id </span>= input_match_device(handler-&gt;id_table, dev);    <span class="comment">// 根据input_handler的id_table判断能否支持这个input_dev</span></span><br><span class="line">    error = handler-&gt;connect(handler, dev, id);         <span class="comment">// 匹配的话, 就自动建立连接, 连接函数由软件抽象层实现</span></span><br></pre></td></tr></table></figure>


<h2 id="硬件设备层"><a href="#硬件设备层" class="headerlink" title="硬件设备层"></a>硬件设备层</h2><p>注册 input_dev 的过程:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数 input_register_device 用于注册硬件设备, 由开发人员写的驱动代码调用.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_device</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function">    <span class="title">list_add_tail</span><span class="params">(&amp;dev-&gt;node, &amp;input_dev_list)</span></span>;         <span class="comment">// 放入链表</span></span><br><span class="line">    list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);             <span class="comment">// 对于每一个input_handler，调用 input_attach_handler</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_attach_handler</span><span class="params">(struct input_dev *dev, struct input_handler *handler)</span></span></span><br><span class="line"><span class="function">    id </span>= input_match_device(handler-&gt;id_table, dev);    <span class="comment">// 根据input_handler的id_table判断能否支持这个input_dev</span></span><br><span class="line">    error = handler-&gt;connect(handler, dev, id);         <span class="comment">// 匹配的话, 就自动建立连接, 连接函数由软件抽象层实现</span></span><br></pre></td></tr></table></figure>

<h2 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h2><p>有上述分析可知, 软件抽象层和硬件设备层建立连接的关键是 <code>handler-&gt;connect</code> 指向的函数.<br>建立连接的基本步骤如下:</p>
<ol>
<li>分配一个 <code>input_handle(没有r)</code> 结构体</li>
<li>设置/初始化 <code>input_handle(没有r)</code><ul>
<li><code>input_handle.dev = input_dev;</code> 保存硬件设备, input_dev</li>
<li><code>input_handle.handler = input_handler;</code> 保存软件抽象, input_handler</li>
</ul>
</li>
<li>软件层和硬件层分别注册 <code>input_handle(没有r)</code>, 将其指针保存到各自结构体的<code>h_list</code>项中<ul>
<li><code>input_handler-&gt;h_list = &amp;input_handle;</code></li>
<li><code>inpu_dev-&gt;h_list = &amp;input_handle;</code></li>
</ul>
</li>
</ol>
<p>硬件设备层的代码最终是要自己写的, 因此我们会比较熟悉.<br>下面以软件抽象层的 <code>drivers/input/evdev.c</code> 为例, 分析一下整个匹配过程.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前已经分析到, 调用 input_register_handler 和 input_register_device 时, 都会进行匹配</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_attach_handler</span><span class="params">(struct input_dev *dev, struct input_handler *handler)</span></span></span><br><span class="line"><span class="function">    id </span>= input_match_device(handler-&gt;id_table, dev);    <span class="comment">// 根据input_handler的id_table判断能否支持这个input_dev</span></span><br><span class="line">    error = handler-&gt;connect(handler, dev, id);         <span class="comment">// 匹配的话, 就自动建立连接, 连接函数由软件抽象层实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里说明一下, handler-&gt;id_table 和 handler-&gt;connect 的初始值都是由软件抽象层几个文件完成的. 具体就是下面几个:</span></span><br><span class="line"><span class="comment">// drivers/char/keyboard.c  // 按键抽象</span></span><br><span class="line"><span class="comment">// drivers/input/evbug.c    // 调试用, 所用的事件存到 syslog文件中</span></span><br><span class="line"><span class="comment">// drivers/input/evdev.c    // input_table[2], 子设备号0x40-0x5F, 设备事件抽象</span></span><br><span class="line"><span class="comment">// drivers/input/joydev.c   // input_table[0], 子设备号0x00-0x0F, 游戏杆抽象</span></span><br><span class="line"><span class="comment">// drivers/input/mousedev.c // input_table[1], 子设备号0x20-0x3F, 鼠标抽象</span></span><br><span class="line"><span class="comment">// drivers/input/tsdev.c    // input_table[4], 子设备号0x80-0x9F, 触摸屏抽象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们以 evdev.c 为例深入分析一下. 其定义的 input_handler 变量名为 evdev_handler. connect会调用evdev_connect</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evdev_connect</span><span class="params">(struct input_handler *handler, struct input_dev *dev, <span class="keyword">const</span> struct input_device_id *id)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 1. 分配一个evdev, 里面包含了input_handle(没有r)</span></span></span><br><span class="line"><span class="function">    evdev </span>= kzalloc(<span class="keyword">sizeof</span>(struct evdev), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置/初始化</span></span><br><span class="line">    evdev-&gt;handle.dev = dev;            <span class="comment">// 保存硬件设备的input_dev指针</span></span><br><span class="line">    evdev-&gt;handle.name = evdev-&gt;name;</span><br><span class="line">    evdev-&gt;handle.handler = handler;    <span class="comment">// 保存软件抽象的input_handler指针</span></span><br><span class="line">    evdev-&gt;handle.<span class="keyword">private</span> = evdev;      <span class="comment">// 保存 evdev 这个指针. 让handle知道归属.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里对应于自己写的驱动的 class_device_create, 注册input类下面的设备.</span></span><br><span class="line">    <span class="comment">// 另外两个, 注册驱动和注册类都是在 input_init() 里完成的</span></span><br><span class="line">    class_device_create(&amp;input_class, &amp;dev-&gt;cdev, devt,dev-&gt;cdev.dev, evdev-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 注册</span></span><br><span class="line">    error = input_register_handle(&amp;evdev-&gt;handle);              <span class="comment">// 注意没有r, 不是 input_register_handler</span></span><br><span class="line">        list_add_tail(&amp;handle-&gt;d_node, &amp;handle-&gt;dev-&gt;h_list);   <span class="comment">// 将 handle 加入 dev-&gt;h_list 链表中</span></span><br><span class="line">        list_add_tail(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);       <span class="comment">// 将 handle 加入 handler-&gt;h_list 链表中</span></span><br><span class="line">        <span class="comment">// 这里可以分析出, 软件抽象层和硬件设备层的对应关系是可以多对多的, 两者都维护着一个handle列表(h_list).</span></span><br></pre></td></tr></table></figure>

<h2 id="APP层相关函数"><a href="#APP层相关函数" class="headerlink" title="APP层相关函数"></a>APP层相关函数</h2><p>最后, 从APP层读取输入子系统进行分析. 以按键为例, 用到 <code>drivers/input/evdev.c</code> 和 <code>drivers/char/keyboard.c</code><br>在书写按键的硬件模块时, input子系统会自动匹配关联到上述两个软件抽象层.<br>(猜测, keyboard的抽象层次比evdev更高. 因此keyboard没有input_table初始值)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app: read 试着读取按键值后:</span></span><br><span class="line"><span class="comment">// ....... 中间过程省略掉, 最后会调用:</span></span><br><span class="line">    evdev_read</span><br><span class="line">        <span class="comment">// 无数据(用的环形缓冲区)并且是非阻塞方式打开，则立刻返回</span></span><br><span class="line">        <span class="keyword">if</span> (client-&gt;head == client-&gt;tail &amp;&amp; evdev-&gt;exist &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">            <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">        <span class="comment">// 否则休眠</span></span><br><span class="line">        retval = wait_event_interruptible(evdev-&gt;wait, client-&gt;head != client-&gt;tail || !evdev-&gt;exist);</span><br><span class="line"></span><br><span class="line">    evdev_event     <span class="comment">// 休眠后, 由evdev_event来唤醒, 此时间和硬件相关, 由硬件设备层实现</span></span><br><span class="line">        wake_up_interruptible(&amp;evdev-&gt;wait);</span><br></pre></td></tr></table></figure>



<h1 id="硬件设备端源码"><a href="#硬件设备端源码" class="headerlink" title="硬件设备端源码"></a>硬件设备端源码</h1><p>由于input子系统的实际上是帮我们完成了相当一部分的注册工作, 并实现了通用的逻辑功能.<br>因此实际写硬件设备驱动时, 反而变得更简单了. 核心步骤如下:</p>
<ol>
<li>分配一个input_dev结构体. <code>input_allocate_device</code></li>
<li>设置事件, 设置事件支持的操作类型</li>
<li>注册 <code>input_register_device</code></li>
<li>硬件初始化和逻辑判断<ul>
<li>上报事件: <code>input_event</code> <code>input_sync</code></li>
</ul>
</li>
</ol>
<p>依旧通过 LinK+ 软件来写驱动. LinK+设置步骤可参考 <a href="https://draapho.github.io/2017/11/30/1740-drv-chr2/">驱动之基于LinK+设计按键驱动</a></p>
<p>与input有关的设置页面如下:<br><img src="https://draapho.github.io/images/1802/link+input.JPG" alt="link+input"></p>
<h2 id="input-keys-c"><a href="#input-keys-c" class="headerlink" title="input_keys.c"></a>input_keys.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">Driver Name     :       input_keys</span></span><br><span class="line"><span class="comment">Author          :       DRAAPHO</span></span><br><span class="line"><span class="comment">License         :       GPL</span></span><br><span class="line"><span class="comment">Description     :       LINUX DEVICE DRIVER PROJECT</span></span><br><span class="line"><span class="comment">                :       参考drivers\input\keyboard\gpio_keys.c</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;input_keys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keys_desc</span>&#123;</span>                                       <span class="comment">// 硬件相关参数</span></span><br><span class="line">    <span class="keyword">int</span> irq;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pin;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> key_val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keys_desc</span> <span class="title">keys_desc_public</span>[4] =</span> &#123;                <span class="comment">// 硬件参数初始化</span></span><br><span class="line">    &#123;IRQ_EINT0,  <span class="string">&quot;S2&quot;</span>, S3C2410_GPF0,  KEY_L&#125;,</span><br><span class="line">    &#123;IRQ_EINT2,  <span class="string">&quot;S3&quot;</span>, S3C2410_GPF2,  KEY_S&#125;,</span><br><span class="line">    &#123;IRQ_EINT11, <span class="string">&quot;S4&quot;</span>, S3C2410_GPG3,  KEY_ENTER&#125;,</span><br><span class="line">    &#123;IRQ_EINT19, <span class="string">&quot;S5&quot;</span>, S3C2410_GPG11, KEY_LEFTSHIFT&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_keys_private</span> &#123;</span>                             <span class="comment">// 私有变量结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">keys_desc</span> *<span class="title">keysdesc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">keys_timer</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_keys_private</span> *<span class="title">input_keys_priv</span>;</span>             <span class="comment">// 私有变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">keys_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span>      <span class="comment">// 按键中断函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!input_keys_priv)</span><br><span class="line">        <span class="keyword">return</span> IRQ_NONE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10ms后启动定时器, 用于按键防抖动</span></span><br><span class="line">    input_keys_priv-&gt;keysdesc = (struct keys_desc *)dev_id;</span><br><span class="line">    mod_timer(&amp;input_keys_priv-&gt;keys_timer, jiffies+HZ/<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keys_timer_function</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span>     <span class="comment">// 定时器超时中断函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">keydev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">keys_desc</span> *<span class="title">keydesc</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pinval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!input_keys_priv)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    keydesc= input_keys_priv-&gt;keysdesc;</span><br><span class="line">    keydev = input_keys_priv-&gt;dev;</span><br><span class="line">    pinval = s3c2410_gpio_getpin(keydesc-&gt;pin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pinval) &#123;</span><br><span class="line">        <span class="comment">/* 松开 : 最后一个参数: 0-松开, 1-按下 */</span></span><br><span class="line">        input_event(keydev, EV_KEY, keydesc-&gt;key_val, <span class="number">0</span>);   <span class="comment">// 触发按键事件</span></span><br><span class="line">        input_sync(keydev);                                 <span class="comment">// 事件结束, 同步到用户空间</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 按下 */</span></span><br><span class="line">        input_event(keydev, EV_KEY, keydesc-&gt;key_val, <span class="number">1</span>);   <span class="comment">// 触发按键事件</span></span><br><span class="line">        input_sync(keydev);                                 <span class="comment">// 事件结束, 同步到用户空间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_keys_open</span><span class="params">(struct input_dev *dev)</span>           <span class="comment">// 观察用, 初始化代码建议全部放在init函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PINFO(<span class="string">&quot;input_keys_open \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_keys_close</span><span class="params">(struct input_dev *dev)</span>         <span class="comment">// 观察用, 退出代码建议全部放在exit函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PINFO(<span class="string">&quot;input_keys_close \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">input_keys_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, res;</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;input_keys_init\n&quot;</span>);</span><br><span class="line">    input_keys_priv = kzalloc(<span class="keyword">sizeof</span>(struct input_keys_private),GFP_KERNEL);</span><br><span class="line">    <span class="comment">/*===== 1. 分配一个input_dev结构体, 并初始化 =====*/</span></span><br><span class="line">    input_keys_priv-&gt;dev = input_allocate_device();</span><br><span class="line">    <span class="comment">// 1.1 初始化后dev的一些内容</span></span><br><span class="line">    input_keys_priv-&gt;dev-&gt;name = DRIVER_NAME;</span><br><span class="line">    input_keys_priv-&gt;dev-&gt;open = input_keys_open;           <span class="comment">// 可以注释掉</span></span><br><span class="line">    input_keys_priv-&gt;dev-&gt;close = input_keys_close;         <span class="comment">// 可以注释掉</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*===== 2. 设置事件. =====*/</span></span><br><span class="line">    <span class="comment">// 2.1 设置event事件</span></span><br><span class="line">    set_bit(EV_KEY,input_keys_priv-&gt;dev-&gt;evbit);            <span class="comment">// 支持按键事件</span></span><br><span class="line">    set_bit(EV_REP,input_keys_priv-&gt;dev-&gt;evbit);            <span class="comment">// 支持按键连发功能</span></span><br><span class="line">    <span class="comment">// 2.2 设置key事件支持的按键值</span></span><br><span class="line">    set_bit(KEY_L, input_keys_priv-&gt;dev-&gt;keybit);           <span class="comment">// 支持按键 l</span></span><br><span class="line">    set_bit(KEY_S, input_keys_priv-&gt;dev-&gt;keybit);           <span class="comment">// 支持按键 s</span></span><br><span class="line">    set_bit(KEY_ENTER, input_keys_priv-&gt;dev-&gt;keybit);       <span class="comment">// 支持按键 enter</span></span><br><span class="line">    set_bit(KEY_LEFTSHIFT, input_keys_priv-&gt;dev-&gt;keybit);   <span class="comment">// shift</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2 其它初始化, 然后赋值这个私有结构体给 dev-&gt;private</span></span><br><span class="line">    input_keys_priv-&gt;keysdesc = keys_desc_public;</span><br><span class="line">    input_keys_priv-&gt;keys_timer.function = keys_timer_function;</span><br><span class="line">    input_set_drvdata(input_keys_priv-&gt;dev , input_keys_priv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*===== 3. 注册 input_device, 此处会去调用 open 函数 =====*/</span></span><br><span class="line">    PINFO(<span class="string">&quot;input_keys_init_befor_register\n&quot;</span>);</span><br><span class="line">    res = input_register_device(input_keys_priv-&gt;dev);</span><br><span class="line">    <span class="keyword">if</span>(res&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        PERR(<span class="string">&quot;input registration failed. error_id=%d\n&quot;</span>, res);</span><br><span class="line">        <span class="keyword">goto</span> fail1;</span><br><span class="line">    &#125;</span><br><span class="line">    PINFO(<span class="string">&quot;input_keys_init_after_register\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*===== 4. 硬件相关的操作, 这部分也可以放在open函数中 =====*/</span></span><br><span class="line">    <span class="comment">// 4.1 注册中断号, 设置中断类型, 设置中断名称(和设备名称无关), 传入自用的数据指针</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        res = request_irq(keys_desc_public[i].irq, keys_irq, IRQT_BOTHEDGE, keys_desc_public[i].name, &amp;keys_desc_public[i]);</span><br><span class="line">        <span class="keyword">if</span> (res&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            PERR(<span class="string">&quot;request_irq(%d), error_id=%d\n&quot;</span>, i, res);</span><br><span class="line">            <span class="keyword">goto</span> fail2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.2 初始化timer, 用于按键延时防抖.</span></span><br><span class="line">    init_timer(&amp;input_keys_priv-&gt;keys_timer);</span><br><span class="line">    add_timer(&amp;input_keys_priv-&gt;keys_timer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误处理部分.</span></span><br><span class="line">fail2:</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        free_irq(keys_desc_public[i].irq, &amp;keys_desc_public[i]);</span><br><span class="line">    &#125;</span><br><span class="line">fail1:</span><br><span class="line">    input_unregister_device(input_keys_priv-&gt;dev);</span><br><span class="line">    input_free_device(input_keys_priv-&gt;dev);</span><br><span class="line">    kfree(input_keys_priv);</span><br><span class="line">    <span class="keyword">return</span> -EBUSY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">input_keys_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exit 是 init 的反操作, 严格按照init的倒序执行!</span></span><br><span class="line">    del_timer(&amp;input_keys_priv-&gt;keys_timer);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        free_irq(keys_desc_public[i].irq, &amp;keys_desc_public[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;input_keys_exit_before_unregister\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 此处会调用 close 函数, 因此之前的内容也可以放到close函数中.</span></span><br><span class="line">    input_unregister_device(input_keys_priv-&gt;dev);</span><br><span class="line">    PINFO(<span class="string">&quot;input_keys_exit_after_unregister\n&quot;</span>);</span><br><span class="line">    input_free_device(input_keys_priv-&gt;dev);</span><br><span class="line">    kfree(input_keys_priv);</span><br><span class="line">    PINFO(<span class="string">&quot;input_keys_exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(input_keys_init);</span><br><span class="line">module_exit(input_keys_exit);</span><br></pre></td></tr></table></figure>

<h2 id="input-keys-h"><a href="#input-keys-h" class="headerlink" title="input_keys.h"></a>input_keys.h</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_NAME <span class="meta-string">&quot;input_keys&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDEBUG(fmt,args...) printk(KERN_DEBUG<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERR(fmt,args...) printk(KERN_ERR<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME,##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINFO(fmt,args...) printk(KERN_INFO<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-gpio.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m       := input_keys.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">install:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules_install</span><br><span class="line">    depmod -a</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ insmod input_keys.ko</span><br><span class="line">input_keys:input_keys_init</span><br><span class="line">input_keys:input_keys_init_befor_register</span><br><span class="line">input: input_keys as /class/input/input1</span><br><span class="line">input_keys:input_keys_open</span><br><span class="line">input_keys:input_keys_init_after_register</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一 (没有LCD):</span></span><br><span class="line">$ cat /dev/tty1             <span class="comment"># keyboard.c 里面和tty有关联, 不去深究了.</span></span><br><span class="line"><span class="comment"># 依次按下 s2,s3 相当于输入了ls. 此处没有回显! 输入s4, 终端仅显示ls.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二 (没有LCD):</span></span><br><span class="line">$ <span class="built_in">exec</span> 0&lt;/dev/tty1          <span class="comment"># 将标准输入改为 /dey/tty1. (没有改标准输出, 因此还是会回显$)</span></span><br><span class="line">$ ls                        <span class="comment"># 依次按下 s2,s3,s4, 相当于输入了ls enter</span></span><br><span class="line"><span class="comment"># 显示文件夹内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明, 由于改了标准输入, 只能重启后键盘才会有效</span></span><br><span class="line"><span class="comment"># ls -l /proc/pid/fd 查看进程的文件描述符. pid值可以由top指令获得.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三 (有LCD, 没有QT)</span></span><br><span class="line">$ vi /etc/inittab</span><br><span class="line">    <span class="comment"># ===== 设置为如下内容 =====</span></span><br><span class="line">    ::sysinit:/etc/init.d/rcS</span><br><span class="line">    s3c2410_serial0::askfirst:-/bin/sh</span><br><span class="line">    <span class="comment"># 增加了下面一行, 用于屏幕打开终端</span></span><br><span class="line">    tty1::askfirst:-/bin/sh</span><br><span class="line">    ::ctrlaltdel:/sbin/reboot</span><br><span class="line">    ::shutdown:/bin/umount -a -r</span><br><span class="line">    <span class="comment"># ===== wq保存, 退出 =====</span></span><br><span class="line">$ reboot                    <span class="comment"># 重启终端</span></span><br><span class="line"><span class="comment"># 这样点击按键就直接能在LCD上查看输入和输出了.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三 (有QT)</span></span><br><span class="line"><span class="comment"># 打开开发板上的记事本或终端, 依次按下 s2,s3,s4, 会看到输入了.</span></span><br><span class="line"></span><br><span class="line">$ rmmod input_keys.ko</span><br><span class="line">input_keys:input_keys_exit_before_unregister</span><br><span class="line">input_keys:input_keys_close</span><br><span class="line">input_keys:input_keys_exit_after_unregister</span><br><span class="line">input_keys:input_keys_exit</span><br></pre></td></tr></table></figure>

<p>额外说一下 <code>hexdump</code> 的测试方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ insmod input_keys.ko                             <span class="comment"># 加载模块后, 会自动生成 /dev/event1</span></span><br><span class="line">$ hexdump /dev/event1                              <span class="comment"># 16进制显示event1设备在用户空间获得的数据</span></span><br><span class="line"><span class="comment"># 字节数|   秒    |  微秒   | 类  |code|  value      # 小端模式, 低位在前!</span></span><br><span class="line">0000000 0bb2 0000 0e48 000c 0001 0026 0001 0000    <span class="comment"># input_event(keydev, EV_KEY, key_val, 1)</span></span><br><span class="line">0000010 0bb2 0000 0e54 000c 0000 0000 0000 0000    <span class="comment"># input_sync(keydev);</span></span><br><span class="line">0000020 0bb2 0000 5815 000e 0001 0026 0000 0000    <span class="comment"># input_event(keydev, EV_KEY, key_val, 0)</span></span><br><span class="line">0000030 0bb2 0000 581f 000e 0000 0000 0000 0000    <span class="comment"># input_sync(keydev);</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析这些数值含义的方法:</span></span><br><span class="line"><span class="comment"># 就是从硬件驱动调用了 input_event 开始逐步深入看, 发现会调用 input_handler-&gt;event.</span></span><br><span class="line"><span class="comment"># 于是找到 evdev.c 下的 evdev_event. 看到 client的赋值 和 kill_fasync给用户空间发送异步信号, 可知hexdump显示就是这些数据</span></span><br><span class="line"><span class="comment"># 然后, 查看 struct input_event, 将数据类型一一对应起来就可以了.</span></span><br></pre></td></tr></table></figure>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://www.cnblogs.com/ITmelody/archive/2012/05/22/2513028.html">arm 驱动进阶：输入子系统概念及架构</a> 图和流程说明很好</li>
<li><a href="http://blog.chinaunix.net/uid-29151914-id-3887032.html">Linux Input子系统之第一篇（input_dev/input_handle/input_handler</a></li>
<li><a href="http://blog.csdn.net/Golf_research/article/details/53293601">输入子系统（1）：数据结构总结</a></li>
<li><a href="http://www.bijishequ.com/detail/482153">linux内核input子系统分析</a></li>
<li><a href="http://www.360doc.com/content/12/0606/21/7775902_216485127.shtml">input_dev结构体分析</a> 对结构体的注释比较完整</li>
</ul>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>linuxembedded linux</tag>
        <tag>drv</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之LCD驱动框架和实现</title>
    <url>/2018/01/09/1804-drv-lcd/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a></li>
<li><a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a></li>
<li><a href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">驱动之RTC分析</a></li>
<li><a href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">驱动之LCD驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/11/1806-drv-ts/">驱动之触摸屏驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">驱动之USB基础概念和框架</a></li>
<li><a href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">驱动之USB设备驱动程序</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="LCD驱动框架分析"><a href="#LCD驱动框架分析" class="headerlink" title="LCD驱动框架分析"></a>LCD驱动框架分析</h1><h2 id="字符驱动基本步骤"><a href="#字符驱动基本步骤" class="headerlink" title="字符驱动基本步骤"></a>字符驱动基本步骤</h2><p>根据之前写的驱动, 已经对linux驱动基本步骤比较熟悉了.</p>
<ul>
<li>所有的驱动都会调用 <code>module_init</code> 和 <code>module_exit</code>, 从 <code>module_init</code> 开始看比较好.</li>
<li>定义并设置 <code>file_operations</code> 结构体, 然后实现里面的函数, 如open等.</li>
<li>获取<code>主设备号</code>, 可以手动分配, 也可以由系统自动分配</li>
<li>用 <code>register_chrdev</code> 注册字符设备. 核心过程如下:<ul>
<li><code>__register_chrdev_region</code> 注册/申请主设备号, 并申请子设备号范围.</li>
<li><code>cdev_init</code> 用 <code>file_operations</code> 结构体初始化一个字符设备</li>
<li><code>cdev_add</code> 用设备号向系统添加字符设备.</li>
</ul>
</li>
<li>如果要用mdev自动加载驱动, 还需要在init里实现如下函数<ul>
<li><code>class_create</code>, 创建一个设备类. 可以在 <code>/sys/class/</code> 看到设备类名称</li>
<li><code>device_create</code>, 创建和注册设备. 可以在 <code>/dev/</code> 看到设备名称</li>
<li><code>class_device_create</code> 是低版本Linux的函数. 本质就是 <code>device_create</code></li>
</ul>
</li>
</ul>
<h2 id="LCD驱动框架分析-1"><a href="#LCD驱动框架分析-1" class="headerlink" title="LCD驱动框架分析"></a>LCD驱动框架分析</h2><p>Linux的LCD驱动用了分层分离的思想, 用到了platform框架.</p>
<ul>
<li><code>/drivers/video/fbmem.c</code> frame buffer memory, 显存操作相关<ul>
<li><code>subsys_initcall(fbmem_init);</code> fbmem的初始化.<ul>
<li><code>register_chrdev(FB_MAJOR,&quot;fb&quot;,&amp;fb_fops)</code> 注册字符设备,</li>
<li><code>fb_class = class_create(THIS_MODULE, &quot;graphics&quot;);</code> 注册 graphics 设备类</li>
<li>可以去<code>/sys/class/graphics</code> 看看, 下面有 fb0 和 fbcon 两个文件.</li>
<li><strong>这里没有注册设备, 因为视频控制器和具体硬件相关</strong></li>
</ul>
</li>
<li><code>registered_fb</code> 是具体设备给fbmem.c提供信息的关键!<ul>
<li><code>fb_read</code> <code>fb_write</code> 里都可以看到 <code>struct fb_info *info = registered_fb[fbidx];</code></li>
<li>然后, 函数根据 info 信息, 决定是进一步调用具体设备的 read write等函数, 还是使用默认代码.</li>
</ul>
</li>
<li><code>register_framebuffer(struct fb_info *fb_info)</code> 供LCD设备调用, 提交<code>registered_fb</code>信息并注册设备.<ul>
<li><code>device_create(fb_class, fb_info-&gt;device, MKDEV(FB_MAJOR, i), &quot;fb%d&quot;, i)</code></li>
<li>真正注册一个LCD设备, 名字是fb0, fb1这样递加上去. 可以在 <code>/dev/</code> 里找到.</li>
</ul>
</li>
</ul>
</li>
<li><code>/drviers/video/s3c2410fb.c</code> 具体硬件的LCD驱动.<ul>
<li>这里用到了platform框架. <code>s3c2410fb.c</code> 是硬件相关的通用操作, 属于 <code>platform_driver</code></li>
<li><code>module_init</code> 里, 直接就是 <code>platform_driver_register</code>.</li>
<li>我们知道platform框架里, <code>probe</code>函数是很关键的, 在drive和device匹配时, 就会调用它.</li>
<li><code>probe</code>函数里, 初始化后, 可看到 <code>register_framebuffer(fbinfo);</code> 将LCD设备信息提交给fbmem.c, 并注册设备.</li>
</ul>
</li>
<li><code>/arch/arm/mach-s3c2440/mach-smdk2440.c</code> 配置硬件参数的地方.<ul>
<li>这里是platform框架的 <code>platform_device</code>.</li>
<li><code>smdk2440_machine_init</code> 初始化里<ul>
<li><code>s3c24xx_fb_set_platdata(&amp;smdk2440_lcd_cfg);</code> 将LCD配置信息拷贝到 <code>s3c_device_lcd</code></li>
<li><code>platform_add_devices(smdk2440_devices, ARRAY_SIZE(smdk2440_devices));</code> 注册 platform_device 设备.</li>
<li><code>smdk2440_devices</code> 里就包含了 <code>s3c_device_lcd</code></li>
</ul>
</li>
<li>如果硬件平台不变, 只是换屏的话, 只需要修改 <code>mach-smdk2440.c</code> 即可. 这就是分层分离概念的意义所在.</li>
</ul>
</li>
</ul>
<p>补充说明 <code>fbmem.c</code> 的上层:</p>
<ul>
<li><code>/drivers/video/console/fbcon.c</code> 在lcd上显示终端, 此文件和tty1关联.<ul>
<li><code>class_device_create(fb_class, NULL, MKDEV(0, 0), NULL, &quot;fbcon&quot;);</code> 注册 <code>fbcon</code> 设备</li>
<li><code>fbcon_start</code>  和 fb设备对接, 开始显示.</li>
</ul>
</li>
<li>app层调用 <code>open(&quot;/dev/fb0&quot;, ...)</code>, 主设备号为29, 次设备号为0<ul>
<li>会对应到kernel层 <code>fbmem.c</code> 的 <code>fb_open</code>函数:</li>
<li><code>int fbidx = iminor(inode);</code></li>
<li><code>struct fb_info *info = = registered_fb[0];</code></li>
</ul>
</li>
<li>app层调用 <code>read()</code><ul>
<li>会对应到kernel层 <code>fbmem.c</code> 的 <code>fb_read</code>函数:</li>
<li><code>registered_fb</code> 由 <code>register_framebuffer</code> 设置.</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fb_read(struct file *file, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos) &#123;</span><br><span class="line">    <span class="keyword">int</span> fbidx = iminor(inode);                              <span class="comment">// 子设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">info</span> =</span> registered_fb[fbidx];            <span class="comment">// LCD硬件信息.</span></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;fbops-&gt;fb_read)                               <span class="comment">// 如果硬件由自己的read函数</span></span><br><span class="line">        <span class="keyword">return</span> info-&gt;fbops-&gt;fb_read(info, buf, count, ppos);<span class="comment">// 调用后, 直接返回</span></span><br><span class="line"></span><br><span class="line">    src = (u32 __iomem *) (info-&gt;screen_base + p);          <span class="comment">// 获取显存地址</span></span><br><span class="line">    dst = buffer;</span><br><span class="line">    *dst++ = fb_readl(src++);</span><br><span class="line">    copy_to_user(buf, buffer, c)                            <span class="comment">// 将值返回给应用层. 获取显存内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="LCD驱动源码"><a href="#LCD驱动源码" class="headerlink" title="LCD驱动源码"></a>LCD驱动源码</h1><p>现在尝试忽略 <code>/drviers/video/s3c2410fb.c</code> 使用的platform框架.<br>直接自己写一个 LCD 驱动, 和 <code>/drivers/video/fbmem.c</code> 进行对接.<br><strong>此处只是为了练习, 实际项目不建议这样使用</strong></p>
<p>驱动的核心步骤如下:</p>
<ol>
<li>分配一个fb_info: <code>s3c_lcd = framebuffer_alloc(0, NULL);</code></li>
<li>设置fb_info<br> 2.1 设置固定的参数, <code>struct fb_fix_screeninfo</code><br> 2.2 设置可变的参数, <code>struct fb_var_screeninfo</code><br> 2.3 设置操作函数, <code>fbops</code><br> 2.4 其他的设置</li>
<li>硬件相关的操作<br> 3.1 配置GPIO用于LCD<br> 3.2 根据LCD手册设置LCD控制器, 比如VCLK的频率等<br> 3.3 分配显存(framebuffer), 并把地址告诉LCD控制器</li>
<li>注册 <code>register_framebuffer(s3c_lcd);</code></li>
</ol>
<h2 id="测试-原系统"><a href="#测试-原系统" class="headerlink" title="测试, 原系统"></a>测试, 原系统</h2><p>在使用自己写的LCD驱动源码之前, 先用系统提供的LCD框架驱动测试一下显示屏</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板端</span></span><br><span class="line">$ vi /etc/inittab</span><br><span class="line">    <span class="comment"># ===== 设置为如下内容 =====</span></span><br><span class="line">    ::sysinit:/etc/init.d/rcS</span><br><span class="line">    s3c2410_serial0::askfirst:-/bin/sh</span><br><span class="line">    <span class="comment"># 增加了下面一行, 用于屏幕打开终端</span></span><br><span class="line">    tty1::askfirst:-/bin/sh</span><br><span class="line">    ::ctrlaltdel:/sbin/reboot</span><br><span class="line">    ::shutdown:/bin/umount -a -r</span><br><span class="line">    <span class="comment"># ===== wq保存, 退出 =====</span></span><br><span class="line">$ reboot</span><br><span class="line"><span class="comment"># 重启终端</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启后, 屏幕就会显示终端信息了. 提示输入Enter键来触发终端.</span></span><br><span class="line"><span class="comment"># 加载 &quot;驱动之input子系统&quot; 里的驱动</span></span><br><span class="line">$ insmod input_keys.ko</span><br><span class="line"><span class="comment"># 按下S4按键, 相当于输入了 Enter</span></span><br><span class="line"><span class="comment"># 依次按下 S2, S3, S4, 就是输入了ls指令, 屏幕上会列出文件列表.</span></span><br></pre></td></tr></table></figure>

<h2 id="lcd-c"><a href="#lcd-c" class="headerlink" title="lcd.c"></a>lcd.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/dma-mapping.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/clk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/div64.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-lcd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/fb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c_lcdfb_setcolreg</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> regno, <span class="keyword">unsigned</span> <span class="keyword">int</span> red,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> green, <span class="keyword">unsigned</span> <span class="keyword">int</span> blue,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> transp, struct fb_info *info)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcd_regs</span> &#123;</span>                                   <span class="comment">// LCD相关寄存器, 方便操作</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdcon1;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdcon2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdcon3;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdcon4;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdcon5;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdsaddr1;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdsaddr2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdsaddr3;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   redlut;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   greenlut;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   bluelut;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   reserved[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   dithmode;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   tpal;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdintpnd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdsrcpnd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdintmsk;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lpcsel;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> <span class="title">s3c_lcdfb_ops</span> =</span> &#123;</span><br><span class="line">    .owner          = THIS_MODULE,</span><br><span class="line">    .fb_setcolreg   = s3c_lcdfb_setcolreg,          <span class="comment">// 设置调色板, 用于色域转换(RGB-&gt;RGB565)</span></span><br><span class="line">    <span class="comment">/* 下面三个函数, 需要用 make modules 获得ko文件. 路径 &quot;/drivers/video/cfb*.ko&quot; */</span></span><br><span class="line">    .fb_fillrect    = cfb_fillrect,                 <span class="comment">// 理解为画矩形</span></span><br><span class="line">    .fb_copyarea    = cfb_copyarea,                 <span class="comment">// 理解为拷贝区域</span></span><br><span class="line">    .fb_imageblit   = cfb_imageblit,                <span class="comment">// 理解为画图</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">s3c_lcd</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *gpbcon;              <span class="comment">// GPIO口的操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *gpbdat;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *gpccon;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *gpdcon;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *gpgcon;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">lcd_regs</span>* <span class="title">lcd_regs</span>;</span></span><br><span class="line"><span class="keyword">static</span> u32 pseudo_palette[<span class="number">16</span>];                      <span class="comment">// 假调色板</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* from pxafb.c */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">chan_to_field</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> chan, struct fb_bitfield *bf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    chan &amp;= <span class="number">0xffff</span>;</span><br><span class="line">    chan &gt;&gt;= <span class="number">16</span> - bf-&gt;length;</span><br><span class="line">    <span class="keyword">return</span> chan &lt;&lt; bf-&gt;offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置调色板, 用于色域转换(RGB-&gt;RGB565)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c_lcdfb_setcolreg</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> regno, <span class="keyword">unsigned</span> <span class="keyword">int</span> red,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> green, <span class="keyword">unsigned</span> <span class="keyword">int</span> blue,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> transp, struct fb_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (regno &gt; <span class="number">16</span>)                                 <span class="comment">// 一个调色板里, 最多有16个小碟子</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用red,green,blue三原色构造出val */</span>             <span class="comment">// 这里是压缩作用, 将红绿蓝压缩成16位真彩色.</span></span><br><span class="line">    val  = chan_to_field(red,   &amp;info-&gt;var.red);</span><br><span class="line">    val |= chan_to_field(green, &amp;info-&gt;var.green);</span><br><span class="line">    val |= chan_to_field(blue,  &amp;info-&gt;var.blue);</span><br><span class="line"></span><br><span class="line">    pseudo_palette[regno] = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lcd_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 1. 分配一个fb_info */</span></span><br><span class="line">    s3c_lcd = framebuffer_alloc(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 设置 */</span></span><br><span class="line">    <span class="comment">/* 2.1 设置固定的参数, struct fb_fix_screeninfo */</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s3c_lcd-&gt;fix.id, <span class="string">&quot;mylcd&quot;</span>);</span><br><span class="line">    s3c_lcd-&gt;fix.smem_len = <span class="number">480</span>*<span class="number">272</span>*<span class="number">16</span>/<span class="number">8</span>;           <span class="comment">// 显存大小(字节), 长*宽*位宽/8 (这里用的RGB565, 2字节)</span></span><br><span class="line">    s3c_lcd-&gt;fix.type     = FB_TYPE_PACKED_PIXELS;  <span class="comment">// 压缩格式. 另外有 逐行/隔行/VGA等等</span></span><br><span class="line">    s3c_lcd-&gt;fix.visual   = FB_VISUAL_TRUECOLOR;    <span class="comment">// 真彩, 即65536色.</span></span><br><span class="line">    s3c_lcd-&gt;fix.line_length = <span class="number">480</span>*<span class="number">2</span>;               <span class="comment">// 一行占用的字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2.2 设置可变的参数, struct fb_var_screeninfo */</span></span><br><span class="line">    s3c_lcd-&gt;var.xres           = <span class="number">480</span>;              <span class="comment">// 实际的屏幕分辨率(像素点)</span></span><br><span class="line">    s3c_lcd-&gt;var.yres           = <span class="number">272</span>;</span><br><span class="line">    s3c_lcd-&gt;var.xres_virtual   = <span class="number">480</span>;              <span class="comment">// 虚拟分辨率</span></span><br><span class="line">    s3c_lcd-&gt;var.yres_virtual   = <span class="number">272</span>;</span><br><span class="line">    s3c_lcd-&gt;var.bits_per_pixel = <span class="number">16</span>;               <span class="comment">// 每个像素点的位宽</span></span><br><span class="line">    s3c_lcd-&gt;var.red.offset     = <span class="number">11</span>;               <span class="comment">// RGB565的位和位偏移</span></span><br><span class="line">    s3c_lcd-&gt;var.red.length     = <span class="number">5</span>;</span><br><span class="line">    s3c_lcd-&gt;var.green.offset   = <span class="number">5</span>;</span><br><span class="line">    s3c_lcd-&gt;var.green.length   = <span class="number">6</span>;</span><br><span class="line">    s3c_lcd-&gt;var.blue.offset    = <span class="number">0</span>;</span><br><span class="line">    s3c_lcd-&gt;var.blue.length    = <span class="number">5</span>;</span><br><span class="line">    s3c_lcd-&gt;var.activate       = FB_ACTIVATE_NOW;  <span class="comment">// 实时显示</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2.3 设置操作函数, fbops */</span></span><br><span class="line">    s3c_lcd-&gt;fbops              = &amp;s3c_lcdfb_ops;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2.4 其他的设置 */</span></span><br><span class="line">    <span class="comment">/* 调色板, 可以理解为色域转换用, 譬如输入是8位, 输出是16位的颜色, 就需要用到调色板 */</span></span><br><span class="line">    s3c_lcd-&gt;pseudo_palette = pseudo_palette;       <span class="comment">// 真彩屏需要使用假调色板, 用于色域转换</span></span><br><span class="line">    <span class="comment">//s3c_lcd-&gt;screen_base  = ;                     // 3.3处会设置, 显存的虚拟地址</span></span><br><span class="line">    s3c_lcd-&gt;screen_size   = <span class="number">480</span>*<span class="number">272</span>*<span class="number">16</span>/<span class="number">8</span>;          <span class="comment">// Amount of ioremapped VRAM or 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 硬件相关的操作 */</span></span><br><span class="line">    <span class="comment">/* 3.1 配置GPIO用于LCD */</span>                        <span class="comment">// 看原理图和数据手册. 此处不详述了.</span></span><br><span class="line">    gpbcon = ioremap(<span class="number">0x56000010</span>, <span class="number">8</span>);</span><br><span class="line">    gpbdat = gpbcon+<span class="number">1</span>;</span><br><span class="line">    gpccon = ioremap(<span class="number">0x56000020</span>, <span class="number">4</span>);</span><br><span class="line">    gpdcon = ioremap(<span class="number">0x56000030</span>, <span class="number">4</span>);</span><br><span class="line">    gpgcon = ioremap(<span class="number">0x56000060</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    *gpccon  = <span class="number">0xaaaaaaaa</span>;                          <span class="comment">/* GPIO管脚用于VD[7:0],LCDVF[2:0],VM,VFRAME,VLINE,VCLK,LEND */</span></span><br><span class="line">    *gpdcon  = <span class="number">0xaaaaaaaa</span>;                          <span class="comment">/* GPIO管脚用于VD[23:8] */</span></span><br><span class="line">    *gpbcon &amp;= ~(<span class="number">3</span>);                                <span class="comment">/* GPB0设置为输出引脚 */</span></span><br><span class="line">    *gpbcon |= <span class="number">1</span>;</span><br><span class="line">    *gpbdat &amp;= ~<span class="number">1</span>;                                  <span class="comment">/* 输出低电平 */</span></span><br><span class="line">    *gpgcon |= (<span class="number">3</span>&lt;&lt;<span class="number">8</span>);                              <span class="comment">/* GPG4用作LCD_PWREN */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3.2 根据LCD手册设置LCD控制器, 比如VCLK的频率等 */</span></span><br><span class="line">    lcd_regs = ioremap(<span class="number">0x4D000000</span>, <span class="keyword">sizeof</span>(struct lcd_regs));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bit[17:8]: VCLK = HCLK / [(CLKVAL+1) x 2], LCD手册P14</span></span><br><span class="line"><span class="comment">     *            10MHz(100ns) = 100MHz / [(CLKVAL+1) x 2]</span></span><br><span class="line"><span class="comment">     *            CLKVAL = 4</span></span><br><span class="line"><span class="comment">     * bit[6:5]: 0b11, TFT LCD</span></span><br><span class="line"><span class="comment">     * bit[4:1]: 0b1100, 16 bpp for TFT</span></span><br><span class="line"><span class="comment">     * bit[0]  : 0 = Disable the video output and the LCD control signal.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lcd_regs-&gt;lcdcon1  = (<span class="number">4</span>&lt;&lt;<span class="number">8</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">0x0c</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line">    <span class="comment">/* 垂直方向的时间参数</span></span><br><span class="line"><span class="comment">     * bit[31:24]: VBPD, VSYNC之后再过多长时间才能发出第1行数据</span></span><br><span class="line"><span class="comment">     *             LCD手册 T0-T2-T1=4</span></span><br><span class="line"><span class="comment">     *             VBPD=3</span></span><br><span class="line"><span class="comment">     * bit[23:14]: 多少行, 320, 所以LINEVAL=320-1=319</span></span><br><span class="line"><span class="comment">     * bit[13:6] : VFPD, 发出最后一行数据之后，再过多长时间才发出VSYNC</span></span><br><span class="line"><span class="comment">     *             LCD手册T2-T5=322-320=2, 所以VFPD=2-1=1</span></span><br><span class="line"><span class="comment">     * bit[5:0]  : VSPW, VSYNC信号的脉冲宽度, LCD手册T1=1, 所以VSPW=1-1=0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lcd_regs-&gt;lcdcon2  = (<span class="number">1</span>&lt;&lt;<span class="number">24</span>) | (<span class="number">271</span>&lt;&lt;<span class="number">14</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 水平方向的时间参数</span></span><br><span class="line"><span class="comment">     * bit[25:19]: HBPD, VSYNC之后再过多长时间才能发出第1行数据</span></span><br><span class="line"><span class="comment">     *             LCD手册 T6-T7-T8=17</span></span><br><span class="line"><span class="comment">     *             HBPD=16</span></span><br><span class="line"><span class="comment">     * bit[18:8]: 多少列, 240, 所以HOZVAL=240-1=239</span></span><br><span class="line"><span class="comment">     * bit[7:0] : HFPD, 发出最后一行里最后一个象素数据之后，再过多长时间才发出HSYNC</span></span><br><span class="line"><span class="comment">     *             LCD手册T8-T11=251-240=11, 所以HFPD=11-1=10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lcd_regs-&gt;lcdcon3 = (<span class="number">1</span>&lt;&lt;<span class="number">19</span>) | (<span class="number">479</span>&lt;&lt;<span class="number">8</span>) | (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 水平方向的同步信号</span></span><br><span class="line"><span class="comment">     * bit[7:0] : HSPW, HSYNC信号的脉冲宽度, LCD手册T7=5, 所以HSPW=5-1=4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lcd_regs-&gt;lcdcon4 = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    lcd_regs-&gt;lcdcon2 = S3C2410_LCDCON2_VBPD(<span class="number">5</span>) | \</span><br><span class="line">        S3C2410_LCDCON2_LINEVAL(<span class="number">319</span>) | \</span><br><span class="line">        S3C2410_LCDCON2_VFPD(<span class="number">3</span>) | \</span><br><span class="line">        S3C2410_LCDCON2_VSPW(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    lcd_regs-&gt;lcdcon3 = S3C2410_LCDCON3_HBPD(<span class="number">10</span>) | \</span><br><span class="line">        S3C2410_LCDCON3_HOZVAL(<span class="number">239</span>) | \</span><br><span class="line">        S3C2410_LCDCON3_HFPD(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    lcd_regs-&gt;lcdcon4 = S3C2410_LCDCON4_MVAL(<span class="number">13</span>) | \</span><br><span class="line">        S3C2410_LCDCON4_HSPW(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 信号的极性</span></span><br><span class="line"><span class="comment">     * bit[11]: 1=565 format</span></span><br><span class="line"><span class="comment">     * bit[10]: 0 = The video data is fetched at VCLK falling edge</span></span><br><span class="line"><span class="comment">     * bit[9] : 1 = HSYNC信号要反转,即低电平有效</span></span><br><span class="line"><span class="comment">     * bit[8] : 1 = VSYNC信号要反转,即低电平有效</span></span><br><span class="line"><span class="comment">     * bit[6] : 0 = VDEN不用反转</span></span><br><span class="line"><span class="comment">     * bit[3] : 0 = PWREN输出0</span></span><br><span class="line"><span class="comment">     * bit[1] : 0 = BSWP</span></span><br><span class="line"><span class="comment">     * bit[0] : 1 = HWSWP 2440手册P413</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lcd_regs-&gt;lcdcon5 = (<span class="number">1</span>&lt;&lt;<span class="number">11</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">10</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">9</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">8</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3.3 分配显存(framebuffer), 并把地址告诉LCD控制器 */</span></span><br><span class="line">    <span class="comment">/* dma_alloc_writecombine 会分配一段连续的内存地址给内核, 返回的是虚拟地址, 因此此处直接赋值给 s3c_lcd-&gt;screen_base</span></span><br><span class="line"><span class="comment">     * s3c_lcd-&gt;fix.smem_start, 表示显存的物理起始地址, 同样由函数 dma_alloc_writecombine 设置.</span></span><br><span class="line"><span class="comment">     * 关于分配函数的比较, 可以参考 http://blog.sina.com.cn/s/blog_4770ef020101oy2e.html 看最后一张图</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s3c_lcd-&gt;screen_base = dma_alloc_writecombine(<span class="literal">NULL</span>, s3c_lcd-&gt;fix.smem_len, &amp;s3c_lcd-&gt;fix.smem_start, GFP_KERNEL);</span><br><span class="line">    lcd_regs-&gt;lcdsaddr1  = (s3c_lcd-&gt;fix.smem_start &gt;&gt; <span class="number">1</span>) &amp; ~(<span class="number">3</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">    lcd_regs-&gt;lcdsaddr2  = ((s3c_lcd-&gt;fix.smem_start + s3c_lcd-&gt;fix.smem_len) &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x1fffff</span>;</span><br><span class="line">    lcd_regs-&gt;lcdsaddr3  = (<span class="number">480</span>*<span class="number">16</span>/<span class="number">16</span>);                 <span class="comment">/* 一行的长度(单位: 2字节) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 启动LCD */</span></span><br><span class="line">    lcd_regs-&gt;lcdcon1 |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);                        <span class="comment">/* 使能LCD控制器 */</span></span><br><span class="line">    lcd_regs-&gt;lcdcon5 |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);                        <span class="comment">/* 使能LCD本身 */</span></span><br><span class="line">    *gpbdat |= <span class="number">1</span>;                                       <span class="comment">/* 输出高电平, 使能背光 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. 注册 */</span></span><br><span class="line">    register_framebuffer(s3c_lcd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lcd_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unregister_framebuffer(s3c_lcd);</span><br><span class="line">    lcd_regs-&gt;lcdcon1 &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);                       <span class="comment">/* 关闭LCD本身 */</span></span><br><span class="line">    *gpbdat &amp;= ~<span class="number">1</span>;                                      <span class="comment">/* 关闭背光 */</span></span><br><span class="line">    dma_free_writecombine(<span class="literal">NULL</span>, s3c_lcd-&gt;fix.smem_len, s3c_lcd-&gt;screen_base, s3c_lcd-&gt;fix.smem_start);</span><br><span class="line">    iounmap(lcd_regs);</span><br><span class="line">    iounmap(gpbcon);</span><br><span class="line">    iounmap(gpccon);</span><br><span class="line">    iounmap(gpdcon);</span><br><span class="line">    iounmap(gpgcon);</span><br><span class="line">    framebuffer_release(s3c_lcd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(lcd_init);</span><br><span class="line">module_exit(lcd_exit);</span><br></pre></td></tr></table></figure>


<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m       := lcd.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>这个测试比较复杂, 需要去掉自带的LCD驱动, 重新编译和烧录内核.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6_no_lcd  复制一个新的内核源码目录</span></span><br><span class="line"></span><br><span class="line">$ make clean</span><br><span class="line">$ make menuconfig                       <span class="comment"># 去掉原来的S3C2410驱动程序</span></span><br><span class="line"><span class="comment"># -&gt; Device Drivers</span></span><br><span class="line"><span class="comment"># -&gt; Graphics support</span></span><br><span class="line"><span class="comment"># &lt;M&gt; S3C2410 LCD framebuffer support</span></span><br><span class="line"><span class="comment"># 改为 M, 因为我们需要编译出里面的 &quot;/drivers/video/cfb*.ko&quot; 三个文件</span></span><br><span class="line"></span><br><span class="line">$ make uImage</span><br><span class="line">$ make modules</span><br><span class="line">$ cp ./drivers/video/cfb*.ko ~/share/jz2440/drivers/lcd/    <span class="comment"># 拷贝到lcd驱动目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 烧录新的uImage</span></span><br><span class="line"><span class="comment"># 重启开发板进入uboot烧录界面, 按k准备烧录内核. 略过不表</span></span><br><span class="line">$ sudo dnw ./arch/arm/boot/uImage</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/lcd/     # lcd驱动目录</span></span><br><span class="line">$ make modules                          <span class="comment"># 生成lcd.ko</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端</span></span><br><span class="line"><span class="comment"># pwd = ./share/jz2440/drivers/lcd/    # lcd驱动源码目录, nfs文件</span></span><br><span class="line">$ insmod cfbcopyarea.ko</span><br><span class="line">$ insmod cfbfillrect.ko</span><br><span class="line">$ insmod cfbimgblt.ko</span><br><span class="line">$ insmod lcd.ko</span><br><span class="line"><span class="comment"># 如果 /etc/inittab 已经增加过 tty1::askfirst:-/bin/sh 这么一行, 屏幕就会显示终端信息了.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd = ./share/jz2440/drivers/input_keys/KERN_SRC  # input_keys源码路径, nfs文件</span></span><br><span class="line">$ insmod input_keys.ko</span><br><span class="line"><span class="comment"># 按下 S4 输入Enter, 使能屏幕终端(即tty1),</span></span><br><span class="line"><span class="comment"># 依次按下 S2, S3, S4, 就是输入了ls指令, 屏幕上会列出文件列表.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 其它测试方法</span></span><br><span class="line"><span class="built_in">echo</span> hello &gt; /dev/tty1  // 可以在LCD上看见hello, tty1会用到 fbcon.c文件</span><br><span class="line">cat lcd.ko &gt; /dev/fb0   // 花屏</span><br></pre></td></tr></table></figure>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://daydreamer.idv.tw/rewrite.php/read-42.html">Framebuffer兩三事-Test On QT2410</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_4770ef020101oy2e.html">常见的Linux内核中内存分配函数</a> 看最后一张图</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>面试之常规问题</title>
    <url>/2018/01/10/1805-interview-general/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/05/04/1714-expression/">逻辑|这样表达，事半功倍</a></li>
<li><a href="https://draapho.github.io/2018/01/10/1805-interview-general/">面试之常规问题</a></li>
<li><a href="https://draapho.github.io/2018/05/07/1816-interview-c/">面试之嵌入式C语言</a></li>
<li><a href="https://draapho.github.io/2017/05/17/1715-c/">C语言知识巩固</a></li>
<li><a href="https://draapho.github.io/2018/05/08/1817-interview-linux/">面试之嵌入式Linux</a></li>
</ul>
<p>我个人面试经验极少, 但这种能力都是需要培养的.<br>此系列总结一下面试中常见的技能要点. 侧重于技术面的准备.</p>
<h1 id="中介面试"><a href="#中介面试" class="headerlink" title="中介面试"></a>中介面试</h1><p>中介面试, 更多的是对个人整体的一个考量. 特别是对你是否适合某雇主的评估.<br>一般而言, 中介是不懂技术的, 所以不用担心他问技术问题; 中介是八面玲珑的, 要小心自己的嘴巴<br>(<strong>有些中介是专门做技术人才的, 所以会问非常专业的问题</strong>, 这里只是说一般情况)<br>如果是电话面试 正常的语速, 有条理的回答, 适当的反问.<br>总之, 个人的看法是要从整体上让对方觉得你是一个思路清晰, 反应敏捷的专业人士.</p>
<p>在澳洲, 工作多集中在几个大城市, 跨地区申请很正常.<br>个人的经验是不跨地区申请 contract 的工作. 跨地区申请时一定要有充足的理由.</p>
<h1 id="雇主面试"><a href="#雇主面试" class="headerlink" title="雇主面试"></a>雇主面试</h1><p>一般来说, 能拿到雇主面试, 机会就比较大了. 分为技术面试和情商面试.</p>
<h2 id="技术面试"><a href="#技术面试" class="headerlink" title="技术面试"></a>技术面试</h2><p>紧扣中介给你的职位说明做准备, 那就是考试大纲!<br>联系自己提交的个人简历, 那就是应试宝典!<br>做过的项目, 时间, 地点, 流程, 型号, 配置, 记忆要具体到最微小的细节.</p>
<p>如果被问到不懂的地方, 直接坦白, 大家都是出来混的. 然后退一步:<br><code>But I do have some experience in XXX, for example XXX</code>, 把话题引到相关的自己熟悉的领域.</p>
<p>如果被问到半懂不懂的地方, 就说 <code>I am major in XXX, so not a XXX guru. But I like learning new staff</code>.<br>然后坦白的谈你对 XXX 的理解.</p>
<p>如果被问到细节自己又想不起来, 就告诉对方暂时记不起来了. 但在自己每天做的工作笔记中有(闪光点), 而且我现在可以把解决该问题的流程(闪光点)讲给你听.<br>总之, 一说实话, 二反应要快.</p>
<p>此处需要注意, 学会换位思考, 见人说人话, 见鬼说鬼话 (国内的技术人员普遍缺乏此种能力).</p>
<ul>
<li>Team Leader 希望你是一个技术专才.</li>
<li>CEO 或 Manager 则希望你的面要广一些.</li>
</ul>
<h2 id="情商面试"><a href="#情商面试" class="headerlink" title="情商面试"></a>情商面试</h2><p>其实这是最不好过的关, 因为主观性实在太强, 加之用非母语表达, 很容易因为紧张而影响反应和思维.<br>在这里只是与大家分享一下个人觉得不错的问题.</p>
<h3 id="你的弱点是什么"><a href="#你的弱点是什么" class="headerlink" title="你的弱点是什么"></a>你的弱点是什么</h3><p>第一种回答. 因为英语毕竟不是我的母语, 所以有时候语言上还会碰到问题, 但我一直在努力.<br>第二个回答. 是工作文化的差异. 因为在中国 Hard working 被认为是一种美德, 所以有时候自己在工作中表现的有些 Aggressive, 但会注意和同事的配合; 面试官的回答是 No Problem. 这个也是以退为进.</p>
<p>语言和文化, 是新一名的两座大山, 我们勇于承认问题, 面对问题, 解决问题, 保持自信. 这样的人才, 能不招人爱么!</p>
<h3 id="你的优点是什么"><a href="#你的优点是什么" class="headerlink" title="你的优点是什么"></a>你的优点是什么</h3><p>Like challenge, Hard working, 还有谁能比我们这些移民有资格这样说. Full of enthusiasm.</p>
<p>When you briefly explain to an employer what you have achived since you arrived in this new country, their reaction would be one of admiration. This says many things about you that make you an attractive candidate for a job - your technical skills and experience are just one of many things that you can offer.</p>
<h3 id="当你和上级意见不统一时怎么办"><a href="#当你和上级意见不统一时怎么办" class="headerlink" title="当你和上级意见不统一时怎么办"></a>当你和上级意见不统一时怎么办</h3><p>Firstly, have a full communication with him/her, demostrate/make clear my opinions and reasons.<br>But I know that generally speaking, the director’s scale of view is large and deep than me, and the finally decision is made by him/her.</p>
<h3 id="你更注重公司的氛围还是所在的团队氛围"><a href="#你更注重公司的氛围还是所在的团队氛围" class="headerlink" title="你更注重公司的氛围还是所在的团队氛围"></a>你更注重公司的氛围还是所在的团队氛围</h3><p>The atmosphere is deeply influenced by the company’s founder. In small company, I think it would be decided by the company atmosphere and in large company, I will pay more attention to the group atmosphere.</p>
<h3 id="你在X年内的职业发展规划"><a href="#你在X年内的职业发展规划" class="headerlink" title="你在X年内的职业发展规划"></a>你在X年内的职业发展规划</h3><p>事先注意收集对方公司的资料, 使自己的发展规划与对方公司的情况以及对你的期望契合.</p>
<h3 id="举一个你职业生涯中失败的例子"><a href="#举一个你职业生涯中失败的例子" class="headerlink" title="举一个你职业生涯中失败的例子"></a>举一个你职业生涯中失败的例子</h3><p>我想每个人都有自己的故事. 单但重要的不是失败, 而是But, 是你在随后的描述, 退一步进二步的策略. (ITT70)</p>
<h3 id="举一个你为过去公司带来实际效益的例子"><a href="#举一个你为过去公司带来实际效益的例子" class="headerlink" title="举一个你为过去公司带来实际效益的例子"></a>举一个你为过去公司带来实际效益的例子</h3><p>这个事情要先想清楚, 不然容易晕. 我举个两个例子:<br>一, 给xx公司做了一个调优, 使其不必升级系统而用现有资源满足了需求.<br>二, 建议xx公司取消了xx选购计划, 因为再过x个月下一代产品就上市了. 目前可以通过别的手段暂时满足需求. 面试官接着就追问我为什么会知道. 就可以说因为我定期看技术网站, 技术期刊(Technical magazine), 参加研讨会(seminar).</p>
<h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h2 id="Tell-me-about-yourself"><a href="#Tell-me-about-yourself" class="headerlink" title="Tell me about yourself"></a>Tell me about yourself</h2><p>Work out what the THREE most important qualities are for the job.<br>Say where you last worked and pick one or two things you achieved at that job<br>Say why you want to work for the particular company you are applying for.<br>Show specific knowledge about the industry and the company that you are applying for.<br>Show enthusiasm about the company.</p>
<h2 id="Work-experience-and-how-to-solve-problems-工作经验-工作遇到什么问题-怎么解决的"><a href="#Work-experience-and-how-to-solve-problems-工作经验-工作遇到什么问题-怎么解决的" class="headerlink" title="Work experience and how to solve problems (工作经验, 工作遇到什么问题, 怎么解决的)"></a>Work experience and how to solve problems (工作经验, 工作遇到什么问题, 怎么解决的)</h2><p>Initiative, Positive, can-do, innovative, work hard<br>先概括一下自己的工作经验. 然后对具体项目展开说.<br>譬如, 改善开发流程，加入敏捷开发思路在嵌入式系统，提升开发效率。</p>
<h2 id="Overtime，Take-home-work-with-you-对于加班的看法。"><a href="#Overtime，Take-home-work-with-you-对于加班的看法。" class="headerlink" title="Overtime，Take home work with you  对于加班的看法。"></a>Overtime，Take home work with you  对于加班的看法。</h2><p>To be honest, I hope to get a good balance between life and work. However, sometimes, overtime work is inevitable with some positions or projects in some emergency, like a problem from client desperately asking, I can understand that well and would solve these problem as quick as possible. I can prioritize well.<br>Furthermore, I am interesting in learning new knowledge and technique, this is a part of my life.<br>业余时间也会自己充电学习.</p>
<h2 id="Over-qualification-应聘的职位过低，容易被问-（隐去管理经验即可）"><a href="#Over-qualification-应聘的职位过低，容易被问-（隐去管理经验即可）" class="headerlink" title="Over qualification, 应聘的职位过低，容易被问 （隐去管理经验即可）"></a>Over qualification, 应聘的职位过低，容易被问 （隐去管理经验即可）</h2><p>I would say , I am well-qualified for the job. My qualification will help me do the job better and bring valuable contribution to your organization. For me, This job is a good chance to rebuild my career in Australia.</p>
<h2 id="did-you-find-this-place-easily？（热身题）"><a href="#did-you-find-this-place-easily？（热身题）" class="headerlink" title="did you find this place easily？（热身题）"></a>did you find this place easily？（热身题）</h2><p>I drive here and it is easy for me to find here. I just paid some time to park my car. Traffic is never a problem to me. I am used to study route in advance and leave enough time for a place I never visited.</p>
<h2 id="Do-you-have-some-questions？（面试结束时）"><a href="#Do-you-have-some-questions？（面试结束时）" class="headerlink" title="Do you have some questions？（面试结束时）"></a>Do you have some questions？（面试结束时）</h2><p>一般我是看人的。</p>
<ul>
<li>如果对方是engineer，将来的team mate，就问些日常需要用到的东西， 比如development process，用git还是svn，怎么test，之类的。或者team相关的。比较有共同语言。</li>
<li>有时候会问些跟工作不太相关的问题，比如为啥不用某某技术等等，不过这些容易引起讨论，最好自己要有点知识，或者有办法漂亮地收尾打住。</li>
<li>如果对方是manager，那当然就是大家据说的那些，比如career path，culture，大方面的projects等等。</li>
<li>如果对方是HR，就问些公司的大概情况，发展等等。</li>
<li>如果对方是再高层甚至CEO，那就灵活变通了。这个可能就以挣印象分为主。事先的功课非常重要。</li>
<li>问公司发展方向。或问些人家以前做过的东西，不管对方说啥一概是点头称是，yeah, right, yes, absolutely, ahha I didn’t know that等等。</li>
</ul>
<p>常见提问如下:</p>
<ul>
<li>what’s your expectation of the position holder in the first 3 months？</li>
<li>部门里有几个员工? structure如何? 一共有几个员工? 这些问题很重要,特别是公司的组织. 所在TEAM的人数和分工,有助于你进一步分析这个职位的前景和吸引度.</li>
<li>What characteristic would you define a great employee in this role?</li>
<li>How will success be measured in this role?</li>
<li>How would I report to you in this role, what is your management style?</li>
<li>What are some of the objectives you would like to see completed in the next 3 to 6 months?</li>
<li>What are some of the longer term objectives you would like to see completed?</li>
<li>How would you describe the culture of the organization?</li>
<li>Are there any advancement opportunities available for me in this role</li>
<li>What are the goals of the organisation during the next 3 years?</li>
<li>What new technologies or systems are you looking to adopt in the near future?</li>
</ul>
<h2 id="What-are-your-greatest-weaknesses-（弱点）"><a href="#What-are-your-greatest-weaknesses-（弱点）" class="headerlink" title="What are your greatest weaknesses?（弱点）"></a>What are your greatest weaknesses?（弱点）</h2><p>secondary language<br>cultural barrier</p>
<h2 id="What-can-you-contribuet-to-this-role-our-company-和what’s-your-stength"><a href="#What-can-you-contribuet-to-this-role-our-company-和what’s-your-stength" class="headerlink" title="What can you contribuet to this role (our company)? 和what’s your stength?"></a>What can you contribuet to this role (our company)? 和what’s your stength?</h2><ul>
<li>What is one of your greatest achievements to date?</li>
<li>Why do you want to work for our company?</li>
<li>Why should we employ you to work at our company? Why should we hire you?</li>
</ul>
<p>面试的基本准则是show your match。 就是要让对方信服你是最合适的人选。所以在回答问题的时候一定要注意不断突出这点。如果你说了半天你自己的特长都不是人家appreciate的，那就没有用了。</p>
<ul>
<li>问题一让你说说你过去的功绩。注意说的时候要挑选match此职位要求的地方说。</li>
<li>问题二主要是考你对公司的了解，为什么要应聘此公司，此公司为什么吸引你。这不是吹公司的优点。而是要突出吸引你的地方。也就是match你的职业发展的地方。</li>
<li>问题三出发点是你的特长，所以要说明你的什么特长对该公司有用。</li>
</ul>
<h2 id="如果你加入了我们公司，你觉得你面临的最大的挑战是什么"><a href="#如果你加入了我们公司，你觉得你面临的最大的挑战是什么" class="headerlink" title="如果你加入了我们公司，你觉得你面临的最大的挑战是什么?"></a>如果你加入了我们公司，你觉得你面临的最大的挑战是什么?</h2><p>说基本要求以外的缺点。技术上没有任何问题，主要还是culture-barrier</p>
<h2 id="did-you-fell-pressure-in-your-previous-job-How-did-you-release-those-pressure-（压力）"><a href="#did-you-fell-pressure-in-your-previous-job-How-did-you-release-those-pressure-（压力）" class="headerlink" title="did you fell pressure in your previous job? How did you release those pressure?（压力）"></a>did you fell pressure in your previous job? How did you release those pressure?（压力）</h2><p>有时, 我确实在会感到压力，但我认为适当的压力是正常的也是有益的(benefit, advantage), improve us to achieve self-break. 首先我会分析我说感到的压力，为什么我会感到压力。压力来自于何方(deadline, new knowledge)。这样有助于我了解自己的思维和正视问题。 在分析了压力以后，我会去想有什么解决产生这样压力根本问题的途径，而不是仅仅去想如何对付压力。<br>Too much pressure will become anxious, we should relief ourselves by psychological analysis<br>心理上，我会努力分析worst case的可能，如果把worst case都分析清楚了，就没有什么可以恐怖的了。 在解决问题的过程中，我会努力注重解决的过程，而不是可能的结果，这样有助于减轻我感到的压力。<br>只要我尽力去做了。所谓的压力，只是怕失败而已。 另外，我很喜欢冥想(meditation)，运动(rope skipping, biking)也是我缓解压力的一种日常手段。</p>
<h2 id="work-to-a-deadline"><a href="#work-to-a-deadline" class="headerlink" title="work to a deadline"></a>work to a deadline</h2><ul>
<li>process control: Monitor progress and communicate with all stakeholder Set milestones</li>
<li>team communication Encourage and push team member</li>
<li>Risk control identify and avoid potenial risk set contigency plan</li>
<li>be careful to make simple example to explain the above points.</li>
</ul>
<h2 id="你过去工作中遇到的最大的挑战是什么？"><a href="#你过去工作中遇到的最大的挑战是什么？" class="headerlink" title="你过去工作中遇到的最大的挑战是什么？"></a>你过去工作中遇到的最大的挑战是什么？</h2><p>我面试人的时候也喜欢问这个问题，</p>
<ul>
<li>一来可以进一步了解工作背景和经验，</li>
<li>二来可以考察面试者对业务的全面掌握程度，</li>
<li>三来考察处理问题的能力。</li>
</ul>
<p>做产品和项目, 最重要的目标就是 fulfill the goal.<br>最大的挑战就是风险控制。。。The Devil’s in the Details，魔鬼藏在细节中。</p>
<p>I’m a very focused person.<br>I divide whole task into smaller tasks then achieve and test them step by step.<br>Then I set time line for those tasks and start working as soon as possible.<br>I’m a kind of can-do person.  (work style)</p>
<h2 id="你如何不小心犯技术错误导致重大故障并且如何recovery"><a href="#你如何不小心犯技术错误导致重大故障并且如何recovery" class="headerlink" title="你如何不小心犯技术错误导致重大故障并且如何recovery?"></a>你如何不小心犯技术错误导致重大故障并且如何recovery?</h2><p>自己很严谨，开发软硬件都会模块化的自我测试，不会允许这种严重错误发生在项目中后期。<br>再强调一下process，然后才是沟通和技术上的细节处理</p>
<h2 id="how-do-you-avoid-mistake"><a href="#how-do-you-avoid-mistake" class="headerlink" title="how do you avoid mistake?"></a>how do you avoid mistake?</h2><ul>
<li>(事前) Before the event Good planning-list critical point Risk analysis Decide procedure Communication</li>
<li>(事中) During the event Keep tracking, double check in every step by using different method or different thinking style, ask third party to check Communication</li>
<li>(事后) After the events Learn the lessons, Improve the procedure</li>
</ul>
<h2 id="为什么跳槽。"><a href="#为什么跳槽。" class="headerlink" title="为什么跳槽。"></a>为什么跳槽。</h2><p>也有些人会问, 你现在工作中最不喜欢的事情是什么，（其实就是在问你什么要跳槽）</p>
<p>可以说因为公司内部要RESTRUCTURE,<br>目前公司没有发展的空间了  （应聘更高职位才说）<br>如果在一个公司工作很长时间了, 可以说, TIME FOR A CHANGE TO EXPERIENCE DIFFERENT STYLE AND HAVING EXPOSURES TO VARIETY<br>结合长期职业发展来阐述，从自己长期职业规划来说明自己需要什么样的机会，<br>同时贵公司（这个职位）有什么吸引我的地方，如何符合我的长期职业规划。<br>同时要表现出原公司也是不错的地方，只是不符合你长期的职业道路规划，<br>这样就更有说服力了。</p>
<h2 id="你是如何处理和老板间的矛盾冲突的"><a href="#你是如何处理和老板间的矛盾冲突的" class="headerlink" title="你是如何处理和老板间的矛盾冲突的"></a>你是如何处理和老板间的矛盾冲突的</h2><p>我的回答是这样的，和老板的冲突，大部分应该是对具体某件事情的不同看法，而不会是大原则性的问题，<br>而有不同的看法是很正常的，也是你在这个公司存在的价值的体现，<br>continuously communication很重要，从出现不同的看法，到如何解决这个差异，必须要懂得倾听，也要懂得适时和恰当的表达，<br>老板站在他决策层面上考虑问题，肯定和你在某些实际操作层面上考虑问题有些不同的，但大家都应是为了达到相同的目标。<br>作为team member，我们更应该服从老板在strategy上的思路，respect大家team共同的目标，<br>但在具体的执行层面提出自己的见解，这些见解可能更具有实际操作性和价值。</p>
<h2 id="说说你工作中不喜欢的同事"><a href="#说说你工作中不喜欢的同事" class="headerlink" title="说说你工作中不喜欢的同事"></a>说说你工作中不喜欢的同事</h2><p>当你的同事很难相处时,你是如何处理的?<br>If you want others respect you and kind to you,you must respect to others and kind to others.<br>Thus we can  easy to get  along with each other.<br>自己举个例子吧。设计师不理解程序员，程序员不理解设计师。事实上，大多是因为缺乏理解，多沟通保持尊重。</p>
<h2 id="如果你和collegue意见不一致时你怎样处理"><a href="#如果你和collegue意见不一致时你怎样处理" class="headerlink" title="如果你和collegue意见不一致时你怎样处理"></a>如果你和collegue意见不一致时你怎样处理</h2><p>先分析自己的观点是否正确，是否和团队目标一致。<br>如果我认为自己的观点正确，则和同事交流，尽量达成一致。<br>如果和同事不能达成一致，而且对团队目标影响较大时，主管交流，征求主管意见</p>
<h2 id="你喜欢亲自lead一个项目，还是喜欢将它break-down给不同的人？"><a href="#你喜欢亲自lead一个项目，还是喜欢将它break-down给不同的人？" class="headerlink" title="你喜欢亲自lead一个项目，还是喜欢将它break down给不同的人？"></a>你喜欢亲自lead一个项目，还是喜欢将它break down给不同的人？</h2><p>不在于我是否喜欢，而取决于TEAM的工作模式。<br>我一直是搞网络的，擅长网络设计，而网络往往是任何项目的核心部分.<br>在我以前公司，作为solution design的重要成员，我会把项目break down给不同的人，让各人发挥他们的专长(服务器、EMAIL、DC…..)，<br>而我作为项目的owner，负责整体协调和集成，包括技术审核、整体proposal，几乎充当了PM的角色，<br>所以，我不但有很强的技术背景，而且有丰富的项目组织协调能力。<br>若我能加入这个新的TEAM，我会follow这里的working model和文化，按照team leade规定的方式很好的完成我的职责。</p>
<h2 id="如果你加入了我们公司，你一年之内的计划是什么"><a href="#如果你加入了我们公司，你一年之内的计划是什么" class="headerlink" title="如果你加入了我们公司，你一年之内的计划是什么"></a>如果你加入了我们公司，你一年之内的计划是什么</h2><p>1年内的计划无疑是问你如何准备适应这个环境。<br>除非对方明确说明短期内的机会，否则绝大多数职位一年内应该没有promotion或job transfer的机会的。<br>所以在回答这个问题的时候，要着重阐述自己如何在此职位上发挥自己的能力，独档一面。<br>建议分入公司3个月，半年，1年三点来回答。着重于link职位的job responsibility阐述自己准备如何做好。</p>
<ul>
<li>Team member</li>
<li>try to merge yourself into the team</li>
<li>understanding of all corp processes involved</li>
<li>take over job and achieve required KPI</li>
</ul>
<h2 id="五年计划"><a href="#五年计划" class="headerlink" title="五年计划"></a>五年计划</h2><p>5年计划其实就是在问你长期职业规划。<br>这道题目的回答也可以注重soft 方面，而不是基于职位来回答。<br>比如你说5年后你要成为某个技术方面的专家，并在组织中起技术权威的作用，作为team leader引导组员等等。<br>这样既显示了自己的理想，又回避了具体的职位。</p>
<p>举个例子:<br>我笑笑说：我没有特别的计划，如果有，就是希望在今后的几年里有机会去塔斯马尼亚，珀斯，布里斯班旅游，最好能周游澳洲。<br>到了我这个年龄，已经不相信什么雄心壮志了，我只知道，工作自己会一一回报我的。或许回报我职位，或许回报我要的生活。 当时，我们大家都笑了。这的确是我当时真实的想法。面试者还说，对啊，工作就是为了生活。</p>
<h2 id="manage-internal-expectations（老板期望）-vs-external-expectations（客户期望）"><a href="#manage-internal-expectations（老板期望）-vs-external-expectations（客户期望）" class="headerlink" title="manage internal expectations（老板期望） vs. external expectations（客户期望）"></a>manage internal expectations（老板期望） vs. external expectations（客户期望）</h2><p>you boss probablay expect you to be cost efficent，improve bottom line， promote corp brand or image，custome relations<br>your client probably expect cheapest price with the best quality of service (usually is the case) ，time efficient ，instantaneous response （俗称随传随到）</p>
<h2 id="你喜欢工作在team里还是独立工作"><a href="#你喜欢工作在team里还是独立工作" class="headerlink" title="你喜欢工作在team里还是独立工作"></a>你喜欢工作在team里还是独立工作</h2><p>应该说，I can handle  both of them. 但是呢，应该偏向Team Work一点。<br>好象是说，我自己可以独立解决问题，比如说，Urgent Production Issue。<br>不过，Team Work那种Brain Storm的气氛也很不错，可以让问题被解决得更全面，而且本身的能力业务能更快提高。<br>当我们做大型项目的时候，Team Work绝对是必须的。</p>
<h2 id="你喜欢自己工作还是按照policy工作"><a href="#你喜欢自己工作还是按照policy工作" class="headerlink" title="你喜欢自己工作还是按照policy工作"></a>你喜欢自己工作还是按照policy工作</h2><p>Policy重要！ Policy不科学，那就改进它！Policy不灵活，那就使它灵活！ Policy是人制定的，为我们服务的，不是用来限制和框住大家的。</p>
<h2 id="你期望薪水是多少"><a href="#你期望薪水是多少" class="headerlink" title="你期望薪水是多少?"></a>你期望薪水是多少?</h2><p>Money is never a priority over knowledge and the role you would offer me.<br>Give me around the average rate in the market.<br>As the only earner member of my family , my purpose is XXX</p>
<h2 id="How-do-you-evaluate-Success"><a href="#How-do-you-evaluate-Success" class="headerlink" title="How do you evaluate Success?"></a>How do you evaluate Success?</h2><ul>
<li>When do some hard work, pay more attention to the process instead of the result and enjoy the process, and usually I will get a good result. This is success in work method.</li>
<li>Balance between work and life, pay attention to spiritual satisfaction instead of material requirement. This is success in life.</li>
<li>Be able to contribute back to society and improve the world better, This is the biggest success and one of my dream.</li>
</ul>
<h2 id="Are-you-willing-to-relocate-or-travel"><a href="#Are-you-willing-to-relocate-or-travel" class="headerlink" title="Are you willing to relocate or travel ?"></a>Are you willing to relocate or travel ?</h2><ul>
<li>Sure, I am willing to relocate as well as travel as required by my role. I am practical enough to understand the requirements of business.</li>
</ul>
<h2 id="Why-don’t-you-start-your-own-business"><a href="#Why-don’t-you-start-your-own-business" class="headerlink" title="Why don’t you start your own business?"></a>Why don’t you start your own business?</h2><p>Currently my family condition does not allow me to even think about taking higher risk and start my own business.<br>I also feel that if one is committed to the work, it always feel like you’re doing business.</p>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之触摸屏驱动框架和实现</title>
    <url>/2018/01/11/1806-drv-ts/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a></li>
<li><a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a></li>
<li><a href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">驱动之RTC分析</a></li>
<li><a href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">驱动之LCD驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/11/1806-drv-ts/">驱动之触摸屏驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">驱动之USB基础概念和框架</a></li>
<li><a href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">驱动之USB设备驱动程序</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="触摸屏驱动框架分析"><a href="#触摸屏驱动框架分析" class="headerlink" title="触摸屏驱动框架分析"></a>触摸屏驱动框架分析</h1><h2 id="回顾input子系统"><a href="#回顾input子系统" class="headerlink" title="回顾input子系统"></a>回顾input子系统</h2><p>在 <a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a> 一文里, 已经介绍了input子系统的框架.<br>触摸驱动作为输入设备, 很自然的需要用到input子系统.<br>input子系统, 核心点如下:</p>
<ul>
<li>软件抽象层, <code>/drivers/input/input.c</code> <code>/drviers/input/*dev.c</code><ul>
<li>初始化 <code>input_handler</code> 结构体变量, 负责软件抽象.</li>
<li>提供 <code>input_register_handler</code> 函数</li>
<li>提供 <code>input_register_handle(没有r)</code> 函数</li>
<li>提供 <code>input_register_device</code> 函数</li>
</ul>
</li>
<li>连接层, <code>/drviers/input/*dev.c</code><ul>
<li>初始化 <code>input_handle(没有r)</code> 结构体变量, 负责input系统的软硬层对接</li>
<li>注册此变量 <code>input_register_handle(没有r)</code></li>
<li>当注册handler或者device时, 会自动调用 <code>handler-&gt;connect</code>, 匹配并关联软件抽象层和硬件设备层.</li>
</ul>
</li>
<li>硬件设备层, 需要自己来实现<ul>
<li>负责具体的硬件功能实现.</li>
<li>初始化 <code>input_dev</code> 结构体变量</li>
<li>注册此变量 <code>input_register_device</code></li>
<li>实现硬件相关代码. 上报事件 <code>input_event</code></li>
</ul>
</li>
</ul>
<h2 id="s3c2410的触摸屏框架"><a href="#s3c2410的触摸屏框架" class="headerlink" title="s3c2410的触摸屏框架"></a>s3c2410的触摸屏框架</h2><p>s3c2410的触摸屏框架使用了input层. 硬件设备层又使用了platform框架来进一步隔离硬件上的通用代码和专用参数设置.<br>platform总线系统的详情可查看 <a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a><br>整个框架层次如下图:</p>
<p><img src="https://draapho.github.io/images/1806/ts.png" alt="ts"></p>
<p>platform 总线框架具体分析如下:</p>
<ul>
<li>platform_driver <code>/drivers/input/touchscreen/s3c2410_ts.c</code><ul>
<li>调用 <code>platform_driver_register(&amp;s3c2410ts_driver);</code></li>
<li>匹配时, 执行 <code>s3c2410ts_probe</code><ul>
<li>和想的不一样, 用的 <code>evbit</code> 而不是 <code>absbit</code></li>
<li><code>ts.dev-&gt;evbit[0] = BIT(EV_SYN) | BIT(EV_KEY) | BIT(EV_ABS);</code></li>
<li><code>ts.dev-&gt;keybit[LONG(BTN_TOUCH)] = BIT(BTN_TOUCH);</code></li>
<li>然后向input系统注册device <code>input_register_device(ts.dev);</code></li>
</ul>
</li>
<li>timer超时函数 <code>touch_timer_fire</code>, 检测和发送触摸事件<ul>
<li><code>input_report_abs</code></li>
<li><code>input_report_key</code></li>
</ul>
</li>
</ul>
</li>
<li>platform_device <code>/arch/arm/plat-s3c24xx/common-smdk.c</code><ul>
<li>调用 <code>platform_add_devices(smdk_devs, ARRAY_SIZE(smdk_devs));</code></li>
<li><code>smdk_devs</code> 里面包含了 <code>s3c_device_ts</code></li>
<li>通过 <code>set_s3c2410ts_info</code> 函数来设置 <code>s3c_device_ts</code></li>
</ul>
</li>
</ul>
<h1 id="测试触摸屏驱动"><a href="#测试触摸屏驱动" class="headerlink" title="测试触摸屏驱动"></a>测试触摸屏驱动</h1><p>这里用的开发板自带的触摸屏驱动, 先测试一下.</p>
<h2 id="方法一-hexdump"><a href="#方法一-hexdump" class="headerlink" title="方法一 hexdump"></a>方法一 hexdump</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板端</span></span><br><span class="line">$ ls /dev/event*</span><br><span class="line"><span class="comment"># 系统自带的一般是 event0, 对应触摸屏事件</span></span><br><span class="line">$ hexdump /dev/event0</span><br><span class="line"><span class="comment"># 字节数|   秒    |   微秒   |type|code|  value       # 小端模式, 低位在前!</span></span><br><span class="line">0000000 04aa 0000 8555 000b 0003 0000 0138 0000     <span class="comment"># input_report_abs(ts.dev, ABS_X, ts.xp);</span></span><br><span class="line">0000010 04aa 0000 8569 000b 0003 0001 020e 0000     <span class="comment"># input_report_abs(ts.dev, ABS_Y, ts.yp);</span></span><br><span class="line">0000020 04aa 0000 856e 000b 0001 014a 0001 0000     <span class="comment"># input_report_key(ts.dev, BTN_TOUCH, 1);</span></span><br><span class="line">0000030 04aa 0000 8570 000b 0003 0018 0001 0000     <span class="comment"># input_report_abs(ts.dev, ABS_PRESSURE, 1);</span></span><br><span class="line">0000040 04aa 0000 8573 000b 0000 0000 0000 0000     <span class="comment"># input_sync(ts.dev);</span></span><br></pre></td></tr></table></figure>

<h2 id="方法二-tslib"><a href="#方法二-tslib" class="headerlink" title="方法二 tslib"></a>方法二 tslib</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端, 需要先编译 tslib</span></span><br><span class="line"><span class="comment"># pwd = ./drivers/ts</span></span><br><span class="line">$ tar xzf tslib-1.4.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> tslib</span><br><span class="line">$ ./autogen.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错: ./autogen.sh: 4: autoreconf: not found</span></span><br><span class="line"><span class="comment"># 报错: configure.ac:25: error: possibly undefined macro: AC_DISABLE_STATIC</span></span><br><span class="line"><span class="comment"># sudo apt-get install autoconf automake libtool # 安装相关软件即可</span></span><br><span class="line"></span><br><span class="line">$ mkdir tmp</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;ac_cv_func_malloc_0_nonnull=yes&quot;</span> &gt;arm-linux.cache</span><br><span class="line">$ ./configure --host=arm-linux --cache-file=arm-linux.cache --prefix=$(<span class="built_in">pwd</span>)/tmp</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br><span class="line">$ ll tmp/bin                                <span class="comment"># 查看一下编译结果.</span></span><br><span class="line">$ vi tmp/etc/ts.conf</span><br><span class="line"><span class="comment"># ===== 修改第二行 =====</span></span><br><span class="line">    <span class="comment"># module_raw input</span></span><br><span class="line">    <span class="comment"># 取消注释, 改为:</span></span><br><span class="line">    module_raw input</span><br><span class="line"><span class="comment"># ===== wq 保存退出 =====</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端</span></span><br><span class="line"><span class="comment"># pwd = ./drivers/ts/tslib/tmp              # 挂载的nfs文件系统</span></span><br><span class="line">$ cp * -rf /                                <span class="comment"># 拷贝到根目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line">$ <span class="built_in">export</span> TSLIB_TSDEVICE=/dev/event0         <span class="comment"># 必须对应ts的event</span></span><br><span class="line">$ <span class="built_in">export</span> TSLIB_CALIBFILE=/etc/pointercal</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_CONFFILE=/etc/ts.conf</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_PLUGINDIR=/lib/ts</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_CONSOLEDEVICE=none</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_FBDEVICE=/dev/fb0            <span class="comment"># 对应屏幕的framebuffer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始测试</span></span><br><span class="line">$ ts_calibrate                              <span class="comment"># 五点校验</span></span><br><span class="line">xres = 480, yres = 272</span><br><span class="line">Top left :</span><br><span class="line">Top right :</span><br><span class="line">Bot right :</span><br><span class="line">Bot left :</span><br><span class="line">Center :</span><br><span class="line">$ ts_test                                   <span class="comment"># 开始测试</span></span><br><span class="line">时间: X坐标 Y坐标 是否按下</span><br><span class="line">$ ts_print_raw                              <span class="comment"># 打印原始数据</span></span><br><span class="line">时间: X电压值 Y电压值 是否按下</span><br></pre></td></tr></table></figure>

<h1 id="源码-第一版"><a href="#源码-第一版" class="headerlink" title="源码, 第一版"></a>源码, 第一版</h1><p>第一版源码, 让触摸屏工作起来即可</p>
<h2 id="ts-c"><a href="#ts-c" class="headerlink" title="ts.c"></a>ts.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/serio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/clk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/plat-s3c24xx/ts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-adc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s3c_ts_regs</span> &#123;</span>                                <span class="comment">// 触摸屏寄存器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> adccon;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> adctsc;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> adcdly;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> adcdat0;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> adcdat1;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> adcupdn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">s3c_ts_dev</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">s3c_ts_regs</span> *<span class="title">s3c_ts_regs</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 几个模式的设置</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enter_wait_pen_down_mode</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s3c_ts_regs-&gt;adctsc = <span class="number">0xd3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enter_wait_pen_up_mode</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s3c_ts_regs-&gt;adctsc = <span class="number">0x1d3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enter_measure_xy_mode</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s3c_ts_regs-&gt;adctsc = (<span class="number">1</span>&lt;&lt;<span class="number">3</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start_adc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s3c_ts_regs-&gt;adccon |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触摸事件中断, 按下或松开触摸屏</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">pen_down_up_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s3c_ts_regs-&gt;adcdat0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;pen up\n&quot;</span>);</span><br><span class="line">        enter_wait_pen_down_mode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printk(&quot;pen down\n&quot;);</span></span><br><span class="line">        <span class="comment">//enter_wait_pen_up_mode();</span></span><br><span class="line">        enter_measure_xy_mode();                    <span class="comment">// 按下了, 准备开始测量</span></span><br><span class="line">        start_adc();                                <span class="comment">// 测量adc</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ADC完成中断</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">adc_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    printk(<span class="string">&quot;adc_irq cnt = %d, x = %d, y = %d\n&quot;</span>, ++cnt,</span><br><span class="line">        s3c_ts_regs-&gt;adcdat0 &amp; <span class="number">0x3ff</span>, s3c_ts_regs-&gt;adcdat1 &amp; <span class="number">0x3ff</span>);</span><br><span class="line">                                                    <span class="comment">// 打印测量结果</span></span><br><span class="line">    enter_wait_pen_up_mode();</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c_ts_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span>* <span class="title">clk</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 分配一个input_dev结构体 */</span></span><br><span class="line">    s3c_ts_dev = input_allocate_device();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 设置 */</span></span><br><span class="line">    <span class="comment">/* 2.1 能产生哪类事件 */</span></span><br><span class="line">    set_bit(EV_KEY, s3c_ts_dev-&gt;evbit);             <span class="comment">// 按键事件</span></span><br><span class="line">    set_bit(EV_ABS, s3c_ts_dev-&gt;evbit);             <span class="comment">// 绝对坐标事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2.2 能产生按键事件里的哪些值 */</span></span><br><span class="line">    set_bit(BTN_TOUCH, s3c_ts_dev-&gt;keybit);         <span class="comment">// 键盘的虚拟按键</span></span><br><span class="line"></span><br><span class="line">    input_set_abs_params(s3c_ts_dev, ABS_X, <span class="number">0</span>, <span class="number">0x3FF</span>, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">// 绝对坐标范围设置</span></span><br><span class="line">    input_set_abs_params(s3c_ts_dev, ABS_Y, <span class="number">0</span>, <span class="number">0x3FF</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    input_set_abs_params(s3c_ts_dev, ABS_PRESSURE, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 是否按压, 理解为Z轴即可.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 注册 */</span></span><br><span class="line">    input_register_device(s3c_ts_dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. 硬件相关的操作 */</span></span><br><span class="line">    <span class="comment">/* 4.1 使能时钟(CLKCON[15]) */</span></span><br><span class="line">    clk = clk_get(<span class="literal">NULL</span>, <span class="string">&quot;adc&quot;</span>);</span><br><span class="line">    clk_enable(clk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4.2 设置S3C2440的ADC/TS寄存器 */</span></span><br><span class="line">    s3c_ts_regs = ioremap(<span class="number">0x58000000</span>, <span class="keyword">sizeof</span>(struct s3c_ts_regs));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bit[14]  : 1-A/D converter prescaler enable</span></span><br><span class="line"><span class="comment">     * bit[13:6]: A/D converter prescaler value,</span></span><br><span class="line"><span class="comment">     *            49, ADCCLK=PCLK/(49+1)=50MHz/(49+1)=1MHz</span></span><br><span class="line"><span class="comment">     * bit[0]: A/D conversion starts by enable. 先设为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s3c_ts_regs-&gt;adccon = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>)|(<span class="number">49</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使能两个中断</span></span><br><span class="line">    request_irq(IRQ_TC, pen_down_up_irq, IRQF_SAMPLE_RANDOM, <span class="string">&quot;ts_pen&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    request_irq(IRQ_ADC, adc_irq, IRQF_SAMPLE_RANDOM, <span class="string">&quot;adc&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    enter_wait_pen_down_mode();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c_ts_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    free_irq(IRQ_TC, <span class="literal">NULL</span>);</span><br><span class="line">    iounmap(s3c_ts_regs);</span><br><span class="line">    input_unregister_device(s3c_ts_dev);</span><br><span class="line">    input_free_device(s3c_ts_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(s3c_ts_init);</span><br><span class="line">module_exit(s3c_ts_exit);</span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-m       := ts.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux<span class="number">-2.6</span><span class="number">.22</span><span class="number">.6</span>/</span><br><span class="line">PWD         := $(shell pwd)</span><br><span class="line"></span><br><span class="line">modules:</span><br><span class="line">    make -C $(KERN_SRC) M=$(PWD) modules</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    make -C $(KERN_SRC) M=$(PWD) clean</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>由于内核自带了驱动程序, 因此需要重新编译内核, 去掉触摸驱动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Ubuntu 主机端</span><br><span class="line"># pwd &#x3D; .&#x2F;linux-2.6.22.6_custom  复制一个新的内核源码目录</span><br><span class="line"></span><br><span class="line">$ make clean</span><br><span class="line">$ make menuconfig                               # 去掉自带的触摸屏驱动程序</span><br><span class="line"># -&gt; Device Drivers</span><br><span class="line">#   -&gt; Input device support</span><br><span class="line">#     -&gt; Touchscreens</span><br><span class="line">#       &lt; &gt; S3C2410&#x2F;S3C2440 touchscreens        # 取消触摸屏驱动</span><br><span class="line"></span><br><span class="line">$ make uImage</span><br><span class="line"># 烧录新的uImage</span><br><span class="line"># 重启开发板进入uboot烧录界面, 按k准备烧录内核. 略过不表</span><br><span class="line">$ sudo dnw .&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;uImage</span><br><span class="line"></span><br><span class="line"># pwd &#x3D; ~&#x2F;share&#x2F;jz2440&#x2F;drivers&#x2F;ts&#x2F;              # 触摸屏驱动目录</span><br><span class="line">$ make modules                                  # 生成ts.ko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 开发板端</span><br><span class="line"># pwd &#x3D; ~&#x2F;share&#x2F;jz2440&#x2F;drivers&#x2F;ts&#x2F;              # 触摸屏驱动目录, nfs</span><br><span class="line">$ insmod ts.ko                                  # 加载驱动, 开始测试</span><br><span class="line">input: Unspecified device as &#x2F;class&#x2F;input&#x2F;input0</span><br><span class="line">adc_irq cnt &#x3D; 1, x &#x3D; 17, y &#x3D; 991</span><br><span class="line">pen up</span><br><span class="line"># 点击触摸屏, 就会打印出坐标, 释放时, 就会显示 pen up</span><br><span class="line"># 至此, 说明触摸屏的硬件设置没有问题!</span><br></pre></td></tr></table></figure>

<h1 id="源码-第二版"><a href="#源码-第二版" class="headerlink" title="源码, 第二版"></a>源码, 第二版</h1><p>第一版的源码用于检测触摸屏的硬件设置是否正确, 触摸屏是否能正常工作.<br>但在实际情况下, 对触摸屏的ADC值还需要进行软件滤波等工作, 以提高可用性.<br>另外我们去掉了printk的打印信息, 改为 <code>input_report_abs</code> <code>input_report_key</code></p>
<h2 id="ts-c-1"><a href="#ts-c-1" class="headerlink" title="ts.c"></a>ts.c</h2><p>为方便理解, 减少代码量, 和源码第一版相同的部分删掉了.<br>譬如头文件, 小函数等.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">ts_timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 软件过滤用, 如果4次ADC值的差值过大, 直接丢弃</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c_filter_ts</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ERR_LIMIT 10                                    <span class="comment">// 这是个经验值</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> avr_x, avr_y;</span><br><span class="line">    <span class="keyword">int</span> det_x, det_y;</span><br><span class="line"></span><br><span class="line">    avr_x = (x[<span class="number">0</span>] + x[<span class="number">1</span>])/<span class="number">2</span>;                                <span class="comment">// 获得数据0,1的平均值</span></span><br><span class="line">    avr_y = (y[<span class="number">0</span>] + y[<span class="number">1</span>])/<span class="number">2</span>;</span><br><span class="line">    det_x = (x[<span class="number">2</span>] &gt; avr_x) ? (x[<span class="number">2</span>] - avr_x) : (avr_x - x[<span class="number">2</span>]);<span class="comment">// 求数据2的差值</span></span><br><span class="line">    det_y = (y[<span class="number">2</span>] &gt; avr_y) ? (y[<span class="number">2</span>] - avr_y) : (avr_y - y[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((det_x &gt; ERR_LIMIT) || (det_y &gt; ERR_LIMIT))         <span class="comment">// 差值太大, 丢弃整组数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    avr_x = (x[<span class="number">1</span>] + x[<span class="number">2</span>])/<span class="number">2</span>;                                <span class="comment">// 获得数据1,2的平均值</span></span><br><span class="line">    avr_y = (y[<span class="number">1</span>] + y[<span class="number">2</span>])/<span class="number">2</span>;</span><br><span class="line">    det_x = (x[<span class="number">3</span>] &gt; avr_x) ? (x[<span class="number">3</span>] - avr_x) : (avr_x - x[<span class="number">3</span>]);<span class="comment">// 求数据3的差值</span></span><br><span class="line">    det_y = (y[<span class="number">3</span>] &gt; avr_y) ? (y[<span class="number">3</span>] - avr_y) : (avr_y - y[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((det_x &gt; ERR_LIMIT) || (det_y &gt; ERR_LIMIT))         <span class="comment">// 差值太大, 丢弃整组数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器, 用去测量触摸屏长按和移动. 在adc中断函数里触发</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c_ts_timer_function</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s3c_ts_regs-&gt;adcdat0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 已经松开 */</span>                                       <span class="comment">// 向input层报告事件</span></span><br><span class="line">        input_report_abs(s3c_ts_dev, ABS_PRESSURE, <span class="number">0</span>);</span><br><span class="line">        input_report_key(s3c_ts_dev, BTN_TOUCH, <span class="number">0</span>);</span><br><span class="line">        input_sync(s3c_ts_dev);</span><br><span class="line">        enter_wait_pen_down_mode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 测量X/Y坐标 */</span></span><br><span class="line">        enter_measure_xy_mode();                            <span class="comment">// 没有松开, 周期性测量</span></span><br><span class="line">        start_adc();                                        <span class="comment">// 触发adc, adc完成后又会触发定时器, 形成周期测量.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触摸事件中断, 按下或松开触摸屏</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">pen_down_up_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s3c_ts_regs-&gt;adcdat0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printk(&quot;pen up\n&quot;);                               // 松开, 向input层报告事件</span></span><br><span class="line">        input_report_abs(s3c_ts_dev, ABS_PRESSURE, <span class="number">0</span>);</span><br><span class="line">        input_report_key(s3c_ts_dev, BTN_TOUCH, <span class="number">0</span>);</span><br><span class="line">        input_sync(s3c_ts_dev);</span><br><span class="line">        enter_wait_pen_down_mode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printk(&quot;pen down\n&quot;);</span></span><br><span class="line">        <span class="comment">//enter_wait_pen_up_mode();</span></span><br><span class="line">        enter_measure_xy_mode();                            <span class="comment">// 刚按下, 开始测量</span></span><br><span class="line">        start_adc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ADC完成中断</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">adc_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x[<span class="number">4</span>], y[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> adcdat0, adcdat1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 优化措施2: 如果ADC完成时, 发现触摸笔已经松开, 则丢弃此次结果 */</span></span><br><span class="line">    adcdat0 = s3c_ts_regs-&gt;adcdat0;</span><br><span class="line">    adcdat1 = s3c_ts_regs-&gt;adcdat1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s3c_ts_regs-&gt;adcdat0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 已经松开 */</span></span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        input_report_abs(s3c_ts_dev, ABS_PRESSURE, <span class="number">0</span>);</span><br><span class="line">        input_report_key(s3c_ts_dev, BTN_TOUCH, <span class="number">0</span>);</span><br><span class="line">        input_sync(s3c_ts_dev);</span><br><span class="line">        enter_wait_pen_down_mode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;adc_irq cnt = %d, x = %d, y = %d\n&quot;, ++cnt, adcdat0 &amp; 0x3ff, adcdat1 &amp; 0x3ff);</span></span><br><span class="line">        <span class="comment">/* 优化措施3: 多次测量求平均值 */</span></span><br><span class="line">        x[cnt] = adcdat0 &amp; <span class="number">0x3ff</span>;</span><br><span class="line">        y[cnt] = adcdat1 &amp; <span class="number">0x3ff</span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 优化措施4: 软件过滤 */</span></span><br><span class="line">            <span class="keyword">if</span> (s3c_filter_ts(x, y))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//printk(&quot;x = %d, y = %d\n&quot;, (x[0]+x[1]+x[2]+x[3])/4, (y[0]+y[1]+y[2]+y[3])/4);</span></span><br><span class="line">                input_report_abs(s3c_ts_dev, ABS_X, (x[<span class="number">0</span>]+x[<span class="number">1</span>]+x[<span class="number">2</span>]+x[<span class="number">3</span>])/<span class="number">4</span>);</span><br><span class="line">                input_report_abs(s3c_ts_dev, ABS_Y, (y[<span class="number">0</span>]+y[<span class="number">1</span>]+y[<span class="number">2</span>]+y[<span class="number">3</span>])/<span class="number">4</span>);</span><br><span class="line">                input_report_abs(s3c_ts_dev, ABS_PRESSURE, <span class="number">1</span>);</span><br><span class="line">                input_report_key(s3c_ts_dev, BTN_TOUCH, <span class="number">1</span>);</span><br><span class="line">                input_sync(s3c_ts_dev);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            enter_wait_pen_up_mode();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 启动定时器处理长按/滑动的情况 */</span></span><br><span class="line">            mod_timer(&amp;ts_timer, jiffies + HZ/<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            enter_measure_xy_mode();</span><br><span class="line">            start_adc();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c_ts_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......                          <span class="comment">// 硬件配置都一样, 略过</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使能两个中断</span></span><br><span class="line">    request_irq(IRQ_TC, pen_down_up_irq, IRQF_SAMPLE_RANDOM, <span class="string">&quot;ts_pen&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    request_irq(IRQ_ADC, adc_irq, IRQF_SAMPLE_RANDOM, <span class="string">&quot;adc&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 优化措施1:</span></span><br><span class="line"><span class="comment">     * 设置ADCDLY为最大值, 这使得电压稳定后再发出IRQ_TC中断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s3c_ts_regs-&gt;adcdly = <span class="number">0xffff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 优化措施5: 使用定时器处理长按,滑动的情况 */</span></span><br><span class="line">    init_timer(&amp;ts_timer);</span><br><span class="line">    ts_timer.function = s3c_ts_timer_function;</span><br><span class="line">    add_timer(&amp;ts_timer);</span><br><span class="line"></span><br><span class="line">    enter_wait_pen_down_mode();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c_ts_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    free_irq(IRQ_TC, <span class="literal">NULL</span>);</span><br><span class="line">    free_irq(IRQ_ADC, <span class="literal">NULL</span>);</span><br><span class="line">    iounmap(s3c_ts_regs);</span><br><span class="line">    input_unregister_device(s3c_ts_dev);</span><br><span class="line">    input_free_device(s3c_ts_dev);</span><br><span class="line">    del_timer(&amp;ts_timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先按照此文之前的测试步骤设置好tslib, 烧录无触摸屏驱动的内核文件.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端</span></span><br><span class="line"><span class="comment"># pwd = ./drivers/ts/                               # 挂载的nfs文件系统</span></span><br><span class="line">$ rmmod ts                                          <span class="comment"># 卸载源码第一版加载的触摸屏驱动</span></span><br><span class="line">$ ls /dev/event*</span><br><span class="line">$ insmod ts.ko                                      <span class="comment"># 加载驱动</span></span><br><span class="line">$ ls /dev/event*</span><br><span class="line"><span class="comment"># 多出的一个event, 就是触摸屏的event, 譬如event0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一, 用hexdump测试</span></span><br><span class="line"></span><br><span class="line">$ hexdump /dev/event0</span><br><span class="line"><span class="comment"># 字节数|   秒    |   微秒   |type|code|  value       # 小端模式, 低位在前!</span></span><br><span class="line">0000000 04aa 0000 8555 000b 0003 0000 0138 0000     <span class="comment"># input_report_abs(ts.dev, ABS_X, ts.xp);</span></span><br><span class="line">0000010 04aa 0000 8569 000b 0003 0001 020e 0000     <span class="comment"># input_report_abs(ts.dev, ABS_Y, ts.yp);</span></span><br><span class="line">0000030 04aa 0000 8570 000b 0003 0018 0001 0000     <span class="comment"># input_report_abs(ts.dev, ABS_PRESSURE, 1);</span></span><br><span class="line">0000020 04aa 0000 856e 000b 0001 014a 0001 0000     <span class="comment"># input_report_key(ts.dev, BTN_TOUCH, 1);</span></span><br><span class="line">0000040 04aa 0000 8573 000b 0000 0000 0000 0000     <span class="comment"># input_sync(ts.dev);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二, 用tslib测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line">$ <span class="built_in">export</span> TSLIB_TSDEVICE=/dev/event0         <span class="comment"># 必须对应ts的event</span></span><br><span class="line">$ <span class="built_in">export</span> TSLIB_CALIBFILE=/etc/pointercal</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_CONFFILE=/etc/ts.conf</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_PLUGINDIR=/lib/ts</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_CONSOLEDEVICE=none</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_FBDEVICE=/dev/fb0            <span class="comment"># 对应屏幕的framebuffer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始测试</span></span><br><span class="line">$ ts_calibrate                              <span class="comment"># 五点校验</span></span><br><span class="line">xres = 480, yres = 272</span><br><span class="line">Top left :</span><br><span class="line">Top right :</span><br><span class="line">Bot right :</span><br><span class="line">Bot left :</span><br><span class="line">Center :</span><br><span class="line">$ ts_test                                   <span class="comment"># 开始测试</span></span><br><span class="line">时间: X坐标 Y坐标 是否按下</span><br><span class="line">$ ts_print_raw                              <span class="comment"># 打印原始数据</span></span><br><span class="line">时间: X电压值 Y电压值 是否按下</span><br></pre></td></tr></table></figure>

<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之USB设备驱动程序</title>
    <url>/2018/01/19/1808-drv-usb2/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a></li>
<li><a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a></li>
<li><a href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">驱动之RTC分析</a></li>
<li><a href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">驱动之LCD驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/11/1806-drv-ts/">驱动之触摸屏驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">驱动之USB基础概念和框架</a></li>
<li><a href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">驱动之USB设备驱动程序</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="查看USB设备信息"><a href="#查看USB设备信息" class="headerlink" title="查看USB设备信息"></a>查看USB设备信息</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /proc/bus/usb/devices           <span class="comment"># 查看USB设备信息, 但是jz2440里没有devices目录</span></span><br><span class="line">$ cat /proc/bus/input/devices         <span class="comment"># 接入的是USB鼠标, 是输入设备, 这里可以看到USB鼠标的信息</span></span><br><span class="line">I: Bus=0003 Vendor=046d Product=c52b Version=0111</span><br><span class="line">N: Name=<span class="string">&quot;Logitech USB Receiver&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接入USB鼠标后, 会显示如下信息, 可知被分配到input10.</span></span><br><span class="line">usb 1-1: new full speed USB device using s3c2410-ohci and address 8</span><br><span class="line">usb 1-1: configuration <span class="comment">#1 chosen from 1 choice</span></span><br><span class="line">input: Logitech USB Receiver as /class/input/input10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后用如下指令, 可以查处VID, PID</span></span><br><span class="line">$ cat sys/class/input/input10/id/product</span><br><span class="line">c52b</span><br><span class="line">$ cat sys/class/input/input10/id/vendor</span><br><span class="line">046d</span><br><span class="line">$ cat sys/class/input/input10/id/version</span><br><span class="line">0111</span><br></pre></td></tr></table></figure>


<h1 id="源码-第一版"><a href="#源码-第一版" class="headerlink" title="源码, 第一版"></a>源码, 第一版</h1><p>第一版, 先实现USB框架.<br>使用 <code>LinK+ Device Driver Development</code> 生成并部分修改而来.</p>
<p><img src="https://draapho.github.io/images/1808/drv_usb.jpg" alt="drv_usb.jpg"></p>
<p>基本步骤如下:</p>
<ol>
<li>分配/设置 <code>struct usb_driver</code> 结构体<ul>
<li><code>.id_table</code></li>
<li><code>.probe</code></li>
<li><code>.disconnect</code></li>
</ul>
</li>
<li>注册 <code>usb_register</code></li>
</ol>
<h2 id="mousekey-c"><a href="#mousekey-c" class="headerlink" title="mousekey.c"></a>mousekey.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">Driver Name     :       mousekey</span></span><br><span class="line"><span class="comment">Author          :       DRAAPHO</span></span><br><span class="line"><span class="comment">License         :       GPL</span></span><br><span class="line"><span class="comment">Description     :       LINUX DEVICE DRIVER PROJECT</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;mousekey.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO Fill the USB device table */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> <span class="title">mousekey_usb_ids</span>[] =</span> &#123;</span><br><span class="line"><span class="comment">// 可以选择 USB设备类型, 或者 VID/PID 匹配驱动</span></span><br><span class="line">    &#123; USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID, USB_INTERFACE_SUBCLASS_BOOT, USB_INTERFACE_PROTOCOL_MOUSE) &#125;,</span><br><span class="line"><span class="comment">//    &#123; USB_DEVICE(0x046d,0xc52b) &#125;,  // idVendor(VID), idProduct(PID)</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//struct usb_private &#123;</span></span><br><span class="line"><span class="comment">//  struct urb *urb;</span></span><br><span class="line"><span class="comment">//  struct usb_device *udev;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">mousekey_usb_driver</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mousekey_probe</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    struct usb_interface *iface, <span class="keyword">const</span> struct usb_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    struct usb_private *priv;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// struct usb_device_id *id 只记录用于匹配的信息.</span></span><br><span class="line">    <span class="comment">// 因此这里需要通过 iface 获取 usb_device 的信息.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">dev</span> =</span> interface_to_usbdev(iface);</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;found USB mousekey! ==========&gt;\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;USB address=%d\n&quot;</span></span><br><span class="line">           <span class="string">&quot;manufacturer=%s, product=%s, serial=%s\n&quot;</span></span><br><span class="line">           <span class="string">&quot;idVendor=0x%x, idProduct=0x%x\n&quot;</span></span><br><span class="line">           <span class="string">&quot;Device Class=%d, SubClass=%d, Protocol=%d\n&quot;</span>,</span><br><span class="line">           dev-&gt;devnum,</span><br><span class="line">           dev-&gt;manufacturer, dev-&gt;product, dev-&gt;serial,</span><br><span class="line">           dev-&gt;descriptor.idVendor, dev-&gt;descriptor.idProduct,</span><br><span class="line">           dev-&gt;descriptor.bDeviceClass,</span><br><span class="line">           dev-&gt;descriptor.bDeviceSubClass,</span><br><span class="line">           dev-&gt;descriptor.bDeviceProtocol);</span><br><span class="line">    printk(<span class="string">&quot;InterfaceNumber=%d, NumberOfEndpoints=%d\n&quot;</span></span><br><span class="line">           <span class="string">&quot;Interface Class=%d, SubClass=%d, Protocol=%d\n&quot;</span>,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bNumEndpoints,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceClass,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceSubClass,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceProtocol);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span></span><br><span class="line"><span class="comment">//    if (!priv) &#123;</span></span><br><span class="line"><span class="comment">//        PERR(&quot;Failed to allocate the device&#x27;s private data\n&quot;);</span></span><br><span class="line"><span class="comment">//        return -ENOMEM;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    usb_set_intfdata(iface, priv);</span></span><br><span class="line"><span class="comment">//    priv-&gt;udev = interface_to_usbdev(iface);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mousekey_disconnect</span><span class="params">(struct usb_interface *iface)</span>    </span>&#123;</span><br><span class="line"><span class="comment">//    struct usb_private *priv = usb_get_intfdata(iface);</span></span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;disconnect USB mousekey\n&quot;</span>);</span><br><span class="line"><span class="comment">//    kfree(priv);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 分配/设置 struct usb_driver */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">mousekey_usb_driver</span> =</span> &#123;</span><br><span class="line">    .name           = DRIVER_NAME,</span><br><span class="line">    .id_table       = mousekey_usb_ids,</span><br><span class="line">    .probe          = mousekey_probe,</span><br><span class="line">    .disconnect     = mousekey_disconnect,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">mousekey_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 注册 */</span></span><br><span class="line">    res = usb_register(&amp;mousekey_usb_driver);</span><br><span class="line">    <span class="keyword">if</span>( res ) &#123;</span><br><span class="line">        PERR(<span class="string">&quot;Error registering the USB Driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;INIT\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">mousekey_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line">    PINFO(<span class="string">&quot;EXIT\n&quot;</span>);</span><br><span class="line">    usb_deregister(&amp;mousekey_usb_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mousekey_init);</span><br><span class="line">module_exit(mousekey_exit);</span><br></pre></td></tr></table></figure>


<h2 id="mousekey-h"><a href="#mousekey-h" class="headerlink" title="mousekey.h"></a>mousekey.h</h2><figure class="highlight h"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_NAME <span class="meta-string">&quot;mousekey&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDEBUG(fmt,args...) printk(KERN_DEBUG<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERR(fmt,args...) printk(KERN_ERR<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME,##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINFO(fmt,args...) printk(KERN_INFO<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/usb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/hid.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m       := mousekey.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">install:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules_install</span><br><span class="line">    depmod -a</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>由于内核自带了USB鼠标驱动程序, 因此需要重新编译内核, 去掉内核的HID的USB功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6_custom  复制一个新的内核源码目录</span></span><br><span class="line"></span><br><span class="line">$ make clean</span><br><span class="line">$ make menuconfig                               <span class="comment"># 去掉自带的HID USB驱动程序</span></span><br><span class="line"><span class="comment"># -&gt; Device Drivers</span></span><br><span class="line"><span class="comment">#   -&gt; HID Devices</span></span><br><span class="line"><span class="comment">#     &lt; &gt; USB Human Interface Device (full HID) support     # 取消HID的USB支持</span></span><br><span class="line"></span><br><span class="line">$ make uImage</span><br><span class="line"><span class="comment"># 烧录新的uImage</span></span><br><span class="line"><span class="comment"># 重启开发板进入uboot烧录界面, 按k准备烧录内核. 略过不表</span></span><br><span class="line">$ sudo dnw ./arch/arm/boot/uImage</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/mousekey/        # USB鼠标驱动目录</span></span><br><span class="line">$ make modules                                  <span class="comment"># 生成mousekey.ko</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/mousekey/        # USB鼠标驱动目录, nfs</span></span><br><span class="line">$ insmod mousekey.ko                            <span class="comment"># 加载驱动, 开始测试</span></span><br><span class="line">usbcore: registered new interface driver mousekey</span><br><span class="line">mousekey:INIT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板上接入USB鼠标, 会打印如下信息:</span></span><br><span class="line">usb 1-1: new full speed USB device using s3c2410-ohci and address 7</span><br><span class="line">usb 1-1: configuration <span class="comment">#1 chosen from 1 choice</span></span><br><span class="line">mousekey:found USB mousekey! ==========&gt;</span><br><span class="line">......                                          <span class="comment"># 打印具体信息. 可以看出Device不重要, Interface才重要.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板上拔出USB鼠标, 会打印如下信息:</span></span><br><span class="line">usb 1-1: USB disconnect, address 7</span><br><span class="line">mousekey:disconnect USB mousekey</span><br><span class="line"></span><br><span class="line"><span class="comment"># rmmod mousekey</span></span><br><span class="line">mousekey:EXIT</span><br><span class="line">usbcore: deregistering interface driver mousekey</span><br></pre></td></tr></table></figure>

<h1 id="源码-第二版"><a href="#源码-第二版" class="headerlink" title="源码, 第二版"></a>源码, 第二版</h1><p>实现USB设备驱动, 将USB鼠标识别成按键.<br>左键输入<code>l</code>, 右键输入<code>s</code>, 中键输入<code>enter</code></p>
<ul>
<li><code>mousekey.h</code> 和 <code>Makefile</code> 参考 <code>源码, 第一版</code></li>
<li>这里因为是用的input子系统, 所以注册设备用了 <code>input_register_device</code>, 而不是 <code>usb_register_dev</code><ul>
<li>用 <code>input_register_device</code> 注册的话, 会在 <code>/dev/</code> 下面新增一个 <code>event*</code></li>
<li>用 <code>usb_register_dev</code> 注册的话, 会在 <code>/sys/class/usb/</code> 下面看到节点名称.</li>
</ul>
</li>
<li><code>input 子系统</code> 参考 <a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a><ol>
<li>分配一个input_dev变量</li>
<li>设置/初始化此变量</li>
<li>注册, input_register_device</li>
<li>硬件相关代码, open, close, event, sync等等.</li>
</ol>
</li>
<li><code>URB</code>, 即 <code>usb request block</code>. 基本用法:<ol>
<li>分配 URB. <code>usb_alloc_urb</code></li>
<li>初始化 URB 结构体 <code>struct urb</code></li>
<li>提交URB (开始通讯). <code>usb_submit_urb</code></li>
</ol>
</li>
<li>可参考 Linux 内核里的 <code>/drivers/hid/usbhid/usbmouse.c</code></li>
</ul>
<h2 id="mousekey-c-1"><a href="#mousekey-c-1" class="headerlink" title="mousekey.c"></a>mousekey.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">Driver Name     :       mousekey</span></span><br><span class="line"><span class="comment">Author          :       DRAAPHO</span></span><br><span class="line"><span class="comment">License         :       GPL</span></span><br><span class="line"><span class="comment">Description     :       LINUX DEVICE DRIVER PROJECT</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;mousekey.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO Fill the USB device table */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> <span class="title">mousekey_usb_ids</span>[] =</span> &#123;</span><br><span class="line"><span class="comment">// 可以选择 USB设备类型, 或者 VID/PID 匹配驱动</span></span><br><span class="line">    &#123; USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID, USB_INTERFACE_SUBCLASS_BOOT, USB_INTERFACE_PROTOCOL_MOUSE) &#125;,</span><br><span class="line"><span class="comment">//    &#123; USB_DEVICE(0x046d,0xc52b) &#125;,  // idVendor(VID), idProduct(PID)</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">mousekey_usb_driver</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">urb</span> *<span class="title">urb</span>;</span>                <span class="comment">// usb请求块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">udev</span>;</span>        <span class="comment">// usb 设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">idev</span>;</span>         <span class="comment">// input 设备</span></span><br><span class="line">    <span class="keyword">char</span> *buf;                      <span class="comment">// urb 用的缓冲</span></span><br><span class="line">    <span class="keyword">dma_addr_t</span> buf_phys;            <span class="comment">// 缓冲物理地址, dma要用</span></span><br><span class="line">    <span class="keyword">int</span> len;                        <span class="comment">// 缓冲区大小</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mousekey_irq</span><span class="params">(struct urb *urb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_private</span> *<span class="title">priv</span> =</span> urb-&gt;context;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">// 先打印查看usb鼠标发来的数据, 不同的鼠标数据格式略有不同!</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; priv-&gt;len; i++) &#123;</span><br><span class="line">        printk(<span class="string">&quot;%02x &quot;</span>, priv-&gt;buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    usb_submit_urb(priv-&gt;urb, GFP_KERNEL);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (urb-&gt;status) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:             <span class="comment">/* success */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> -ECONNRESET:   <span class="comment">/* unlink */</span></span><br><span class="line">    <span class="keyword">case</span> -ENOENT:</span><br><span class="line">    <span class="keyword">case</span> -ESHUTDOWN:</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* -EPIPE:  should clear the halt */</span></span><br><span class="line">    <span class="keyword">default</span>:            <span class="comment">/* error */</span></span><br><span class="line">        <span class="keyword">goto</span> resubmit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USB鼠标数据含义</span></span><br><span class="line"><span class="comment">     * data[0]: bit0-左键, 1-按下, 0-松开</span></span><br><span class="line"><span class="comment">     *          bit1-右键, 1-按下, 0-松开</span></span><br><span class="line"><span class="comment">     *          bit2-中键, 1-按下, 0-松开</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    input_report_key(priv-&gt;idev, KEY_L,     priv-&gt;buf[<span class="number">0</span>] &amp; <span class="number">0x01</span>);</span><br><span class="line">    input_report_key(priv-&gt;idev, KEY_S,     priv-&gt;buf[<span class="number">0</span>] &amp; <span class="number">0x02</span>);</span><br><span class="line">    input_report_key(priv-&gt;idev, KEY_ENTER, priv-&gt;buf[<span class="number">0</span>] &amp; <span class="number">0x04</span>);</span><br><span class="line">    input_sync(priv-&gt;idev);</span><br><span class="line"></span><br><span class="line">resubmit:</span><br><span class="line">    <span class="comment">/* 重新提交urb */</span></span><br><span class="line">    usb_submit_urb (urb, GFP_ATOMIC);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mousekey_probe</span><span class="params">(struct usb_interface *iface,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> struct usb_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_private</span> *<span class="title">priv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_endpoint_descriptor</span> *<span class="title">endpoint</span>;</span></span><br><span class="line">    PINFO(<span class="string">&quot;found USB mousekey! ==========&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    priv = kzalloc(<span class="keyword">sizeof</span>(*priv), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!priv) &#123;</span><br><span class="line">        PERR(<span class="string">&quot;Failed to allocate the device&#x27;s private data\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    usb_set_intfdata(iface, priv);</span><br><span class="line">    priv-&gt;udev = interface_to_usbdev(iface);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;USB address=%d\n&quot;</span></span><br><span class="line">           <span class="string">&quot;manufacturer=%s, product=%s, serial=%s\n&quot;</span></span><br><span class="line">           <span class="string">&quot;idVendor=0x%x, idProduct=0x%x\n&quot;</span></span><br><span class="line">           <span class="string">&quot;Device Class=%d, SubClass=%d, Protocol=%d\n&quot;</span>,</span><br><span class="line">           priv-&gt;udev-&gt;devnum,</span><br><span class="line">           priv-&gt;udev-&gt;manufacturer, priv-&gt;udev-&gt;product, priv-&gt;udev-&gt;serial,</span><br><span class="line">           priv-&gt;udev-&gt;descriptor.idVendor, priv-&gt;udev-&gt;descriptor.idProduct,</span><br><span class="line">           priv-&gt;udev-&gt;descriptor.bDeviceClass,</span><br><span class="line">           priv-&gt;udev-&gt;descriptor.bDeviceSubClass,</span><br><span class="line">           priv-&gt;udev-&gt;descriptor.bDeviceProtocol);</span><br><span class="line">    printk(<span class="string">&quot;InterfaceNumber=%d, NumberOfEndpoints=%d\n&quot;</span></span><br><span class="line">           <span class="string">&quot;Interface Class=%d, SubClass=%d, Protocol=%d\n&quot;</span>,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bNumEndpoints,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceClass,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceSubClass,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceProtocol);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iface-&gt;cur_altsetting-&gt;desc.bNumEndpoints != <span class="number">1</span>)     <span class="comment">// endpoint 不为1, 认为不是USB鼠标</span></span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    endpoint = &amp;iface-&gt;cur_altsetting-&gt;endpoint[<span class="number">0</span>].desc;</span><br><span class="line">    <span class="keyword">if</span> (!usb_endpoint_is_int_in(endpoint))                  <span class="comment">// endpoint 传输属性必须是中断输入</span></span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* a. 分配一个input_dev */</span></span><br><span class="line">    priv-&gt;idev = input_allocate_device();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* b. 设置 */</span></span><br><span class="line">    <span class="comment">/* b.1 能产生哪类事件 */</span></span><br><span class="line">    set_bit(EV_KEY, priv-&gt;idev-&gt;evbit);</span><br><span class="line">    set_bit(EV_REP, priv-&gt;idev-&gt;evbit);</span><br><span class="line">    <span class="comment">/* b.2 能产生哪些事件 */</span></span><br><span class="line">    set_bit(KEY_L, priv-&gt;idev-&gt;keybit);                     <span class="comment">// 鼠标按键模拟键盘 L S ENTER</span></span><br><span class="line">    set_bit(KEY_S, priv-&gt;idev-&gt;keybit);</span><br><span class="line">    set_bit(KEY_ENTER, priv-&gt;idev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* c. 注册 */</span></span><br><span class="line">    input_register_device(priv-&gt;idev);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* d. 硬件相关操作, 这里就是使用urb进行USB通讯 */</span></span><br><span class="line">    <span class="comment">/* 1. 分配 URB. */</span></span><br><span class="line">    priv-&gt;urb = usb_alloc_urb(<span class="number">0</span>, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 初始化 URB 结构体 */</span></span><br><span class="line">    pipe = usb_rcvintpipe(priv-&gt;udev, endpoint-&gt;bEndpointAddress);  <span class="comment">// 指定USB通讯类型和endpoint</span></span><br><span class="line">    priv-&gt;len = endpoint-&gt;wMaxPacketSize;                           <span class="comment">// buf大小</span></span><br><span class="line">    priv-&gt;buf = usb_buffer_alloc(priv-&gt;udev, priv-&gt;len, GFP_ATOMIC, &amp;priv-&gt;buf_phys);</span><br><span class="line">    <span class="comment">// 分配buf, usb会使用dma进行数据传输, buf_phys用于记录buf的物理地址.</span></span><br><span class="line"></span><br><span class="line">    usb_fill_int_urb(priv-&gt;urb, priv-&gt;udev, pipe, priv-&gt;buf, priv-&gt;len, mousekey_irq, priv, endpoint-&gt;bInterval);</span><br><span class="line">    <span class="comment">// mousekey_irq, usb中断发生时的回调函数. priv, 回调函数用的私有参数, 可以是NULL. bInterval, USB HUB的轮询间隔时间.</span></span><br><span class="line">    priv-&gt;urb-&gt;transfer_dma = priv-&gt;buf_phys;                       <span class="comment">// dma传输需要物理地址</span></span><br><span class="line">    priv-&gt;urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 提交URB (开始通讯) */</span></span><br><span class="line">    usb_submit_urb(priv-&gt;urb, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mousekey_disconnect</span><span class="params">(struct usb_interface *iface)</span>    </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_private</span> *<span class="title">priv</span> =</span> usb_get_intfdata(iface);</span><br><span class="line">    PINFO(<span class="string">&quot;disconnect USB mousekey\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    usb_kill_urb(priv-&gt;urb);</span><br><span class="line">    usb_free_urb(priv-&gt;urb);</span><br><span class="line">    usb_buffer_free(priv-&gt;udev, priv-&gt;len, priv-&gt;buf, priv-&gt;buf_phys);</span><br><span class="line">    input_unregister_device(priv-&gt;idev);</span><br><span class="line">    input_free_device(priv-&gt;idev);</span><br><span class="line">    kfree(priv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 分配/设置 struct usb_driver */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">mousekey_usb_driver</span> =</span> &#123;</span><br><span class="line">    .name           = DRIVER_NAME,</span><br><span class="line">    .id_table       = mousekey_usb_ids,</span><br><span class="line">    .probe          = mousekey_probe,</span><br><span class="line">    .disconnect     = mousekey_disconnect,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">mousekey_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 注册 */</span></span><br><span class="line">    res = usb_register(&amp;mousekey_usb_driver);</span><br><span class="line">    <span class="keyword">if</span>( res ) &#123;</span><br><span class="line">        PERR(<span class="string">&quot;Error registering the USB Driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;INIT\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">mousekey_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line">    PINFO(<span class="string">&quot;EXIT\n&quot;</span>);</span><br><span class="line">    usb_deregister(&amp;mousekey_usb_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mousekey_init);</span><br><span class="line">module_exit(mousekey_exit);</span><br></pre></td></tr></table></figure>

<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先按照此文之前的测试步骤烧录好无HID USB驱动的内核文件.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/mousekey/        # USB鼠标驱动目录, nfs</span></span><br><span class="line">$ insmod mousekey.ko                            <span class="comment"># 加载驱动, 开始测试</span></span><br><span class="line">usbcore: registered new interface driver mousekey</span><br><span class="line">mousekey:INIT</span><br><span class="line"></span><br><span class="line">$ ls /dev/event*                                <span class="comment"># 查看已有的event号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板上接入USB鼠标, 会打印如下信息:</span></span><br><span class="line">usb 1-1: new full speed USB device using s3c2410-ohci and address 7</span><br><span class="line">usb 1-1: configuration <span class="comment">#1 chosen from 1 choice</span></span><br><span class="line">mousekey:found USB mousekey! ==========&gt;</span><br><span class="line">......                                          <span class="comment"># 打印具体信息. 可以看出Device不重要, Interface才重要.</span></span><br><span class="line"></span><br><span class="line">$ ls /dev/event*                                <span class="comment"># 查看新增的event号, 就是此驱动的event</span></span><br><span class="line">/dev/event1                                     <span class="comment"># 譬如, 新增了event1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一 (没有LCD):</span></span><br><span class="line">$ cat /dev/tty1</span><br><span class="line"><span class="comment"># 点击鼠标, 终端会显示输入, 但没有输出反馈.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二 (没有LCD):</span></span><br><span class="line">$ hexdump /dev/event1</span><br><span class="line"><span class="comment"># 字节数|   秒    |  微秒   | 类  |code|  value      # 小端模式, 低位在前!</span></span><br><span class="line">0000000 0bb2 0000 0e48 000c 0001 0026 0001 0000    <span class="comment"># input_event(keydev, EV_KEY, key_val, 1)</span></span><br><span class="line">0000010 0bb2 0000 0e54 000c 0000 0000 0000 0000    <span class="comment"># input_sync(keydev);</span></span><br><span class="line">0000020 0bb2 0000 5815 000e 0001 0026 0000 0000    <span class="comment"># input_event(keydev, EV_KEY, key_val, 0)</span></span><br><span class="line">0000030 0bb2 0000 581f 000e 0000 0000 0000 0000    <span class="comment"># input_sync(keydev);</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三 (有LCD, 没有QT)</span></span><br><span class="line">$ vi /etc/inittab</span><br><span class="line">    <span class="comment"># ===== 设置为如下内容 =====</span></span><br><span class="line">    ::sysinit:/etc/init.d/rcS</span><br><span class="line">    s3c2410_serial0::askfirst:-/bin/sh</span><br><span class="line">    <span class="comment"># 增加了下面一行, 用于屏幕打开终端</span></span><br><span class="line">    tty1::askfirst:-/bin/sh</span><br><span class="line">    ::ctrlaltdel:/sbin/reboot</span><br><span class="line">    ::shutdown:/bin/umount -a -r</span><br><span class="line">    <span class="comment"># ===== wq保存, 退出 =====</span></span><br><span class="line">$ reboot                                        <span class="comment"># 重启终端</span></span><br><span class="line"><span class="comment"># 这样点击鼠标就直接能在LCD上查看输入和输出了.</span></span><br></pre></td></tr></table></figure>

<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之I2C驱动</title>
    <url>/2018/02/09/1815-drv-i2c/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/02/09/1815-drv-i2c/">驱动之I2C驱动</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 由于jz2440开发板没有板载I2C设备, 因此源码部分无法实际测试.</p>
<h1 id="I2C驱动框架分析"><a href="#I2C驱动框架分析" class="headerlink" title="I2C驱动框架分析"></a>I2C驱动框架分析</h1><p>I2C协议本身不是太复杂, 但Linux内核为了通用化, 搞了一套复杂的总线系统.</p>
<p><img src="https://draapho.github.io/images/1815/layer.png" alt="layer.png"></p>
<p><strong>最要理解i2c框架, 尝试理解 <code>i2c_add_adapter</code> 和 <code>i2c_add_driver</code> 就行了.</strong></p>
<ul>
<li><code>i2c_adapter</code> 对i2c主机的抽象概念, 与 <code>i2c_add_adapter</code> 相关<ul>
<li>这部分的架构都是已经搭好的, 由CPU厂商完成.</li>
<li>针对特定的开发板, 一般情况只会有一个 <code>i2c_adapter</code>. 会在<code>/drivers/i2c/busses</code>下选取一个</li>
<li>但特殊情况, 如果需要用不同的数据预处理方式, 如 <code>i2c-algo-bit</code>, 那么也可以抽象出多个 <code>i2c_adapter</code></li>
</ul>
</li>
<li><code>i2c_driver</code>  对i2c从机的抽象概念, 与 <code>i2c_add_driver</code> 相关<ul>
<li>Linux内核给了很多i2c芯片的驱动范例. 我们所说的开发i2c驱动, 是位于这一端的.</li>
<li>一个真实的i2c从机设备并非对应唯一的 <code>i2c_driver</code>.</li>
<li>譬如i2c芯片24cXX. 可以对APP端抽象出多种概念:<ul>
<li>linux内核为了让APP端能直接操作i2c, 通过 <code>i2c-dev.c</code> 实现了一个 <code>i2c_driver</code></li>
<li>系统里的<code>eeprom.c</code>, 帮我们实现了通用eeprom的操作. 就是另一个 <code>i2c_driver</code></li>
<li>我们自己也可以写一个驱动, 将24cXX认为是一块加密芯片. 就是第三个 <code>i2c_driver</code></li>
<li>这样, i2c从机端的底层都是一样的, 但上层的抽象概念是不同的. 或许, 这也是将主机端取名为 <code>i2c_adapter</code> 的原因, 它只是一个通讯适配器. 将APP层的不同抽象概念适配到一个个具体的i2c芯片上.</li>
</ul>
</li>
</ul>
</li>
<li><code>i2c_adapter</code> 和 <code>i2c_driver</code> 的关联方式<ul>
<li>就是 platform 总线架构, 两个链表有新加内容后, 循环查找匹配.</li>
<li>是否匹配有两个要点:<ul>
<li>一是 <code>i2c_adapter.nr</code> 和 <code>i2c_client_address_data</code> 里的设置是否一样</li>
<li>这里基本都不用这个值去匹配的. 总线驱动也没去设置 <code>i2c_adapter.nr</code>. 设备端驱动直接设置为 <code>ANY_I2C_BUS</code> 即可.</li>
<li>二是 i2c 的物理地址, 根据物理地址实际通讯一下, 来进行匹配.</li>
<li>如果用了 <code>i2c_client_address_data.force</code>, 那么物理地址的检测过程也将被忽略.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ul>
<li><code>./drivers/i2c/i2c-core.c</code> 这个文件实现了I2C核心的功能以及/proc/bus/i2c*接口。<ul>
<li>此文件就是 <code>i2c核心层</code> 作用是承上启下:</li>
<li>对上, 提供统一的调用接口, 屏蔽硬件差异. 如提供 <code>read</code> <code>write</code> 函数.</li>
<li>对下, 抽象出i2c操作通用的部分, 简化i2c的硬件驱动开发.</li>
</ul>
</li>
<li>　<code>./drivers/i2c/busses</code> 包含了各个芯片厂商的I2C总线的驱动<ul>
<li>如 <code>i2c-s3c2410.c</code> 针对S3C系列处理器的I2C控制器驱动.</li>
</ul>
</li>
<li><code>./drivers/i2c/i2c-dev.c</code> 实现了I2C适配器设备文件的功能，每一个I2C适配器都被分配一个设备.<ul>
<li>把这个文件理解为系统提供的一个i2c设备驱动程序即可. 需要手动加载.</li>
<li>此文件会调用 <code>i2c_add_driver</code>, 系统默认注册的一个i2c设备, 可供app端直接调用.</li>
<li>i2c芯片另外需要自己的驱动程序, 去调用 <code>i2c_add_driver</code>, 并注册设备.</li>
</ul>
</li>
<li><del><code>./drivers/i2c/algos</code>　文件夹实现了一些I2C总线适配器的algorithm.</del><ul>
<li>algorithm 这个词让人容易误解. 我的理解是数据预处理方式的不同.</li>
<li><code>i2c-algo-pca.c</code>. 可参考 <a href="https://www.nxp.com/docs/en/data-sheet/PCF8584.pdf">PCF8584 I2C-bus controller</a></li>
<li><code>i2c-algo-pcf.c</code>. 可参考 <a href="https://www.nxp.com/docs/en/data-sheet/PCA9564.pdf">PCA9564 Parallel bus to I2C-bus controller</a></li>
<li><code>i2c-algo-sgi.c</code>. 应该针对给2款早已过时的PC机用的.</li>
<li><code>I2C_ALGO_XXX</code> 的宏定义可以在 <code>./include/linux/i2c-id.h</code> 下找到</li>
</ul>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li><code>struct i2c_driver</code> 提供 <code>probe</code> <code>remove</code> 等函数接口. i2c从机设备驱动使用<ul>
<li><code>i2c_add_driver</code> 函数使用. 与 <code>i2c_adapter</code> 对应, 两者需要匹配.</li>
</ul>
</li>
<li><code>struct i2c_adapter</code> 适配器. 就是将多种多样的底层I2C硬件需求(不同地址, 不同通讯方法)给一个统一的方法接入到I2C核心层.<ul>
<li>指定通讯方式(i2c_algorithm)</li>
<li>指定i2c设备(i2c_client)</li>
<li><code>i2c_add_adapter</code> 函数使用. 与 <code>i2c_driver</code> 对应, 两者需要匹配.</li>
</ul>
</li>
<li><code>struct i2c_client</code> 描述了真实设备的所有必要信息, 如 i2c addr, 设备名称, 中断号等等.<ul>
<li>除了提供给 <code>i2c_adapter</code> 外, 还直接和 <code>i2c_driver</code> 想关联.</li>
<li>原因应该是内核层和应用层都需要方便的读取真实i2c设备的必要信息</li>
</ul>
</li>
<li><code>struct i2c_algorithm</code> 通讯方法. 其中两个函数指针是由底层硬件实现的. 相当于 i2c核心层和底层的接口<ul>
<li>algorithm 这个词让人容易误解. 我的理解是数据预处理方式的不同.</li>
<li>只和 <code>i2c_adapter</code> 相关, 给i2c主机提供收发功能</li>
<li><code>.master_xfer</code> 发送函数, 需要底层实现.</li>
<li><code>struct i2c_msg</code> 用于存放通讯时的地址, 数据buf, 长度等信息</li>
<li><code>.functionality</code> 驱动支持的功能, 需要底层明确.</li>
<li>底层没有接收函数. 因为i2c通讯必须由主机发起并提供时钟, 发送的同时就会接收数据.</li>
</ul>
</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><img src="https://draapho.github.io/images/1815/function.png" alt="function.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// =========== 从 i2c_add_driver 看 ==========</span></span><br><span class="line">i2c_add_driver                                              <span class="comment">// I2C 设备驱动会调用, 如自己写的驱动</span></span><br><span class="line">    i2c_register_driver</span><br><span class="line">        driver-&gt;driver.bus = &amp;i2c_bus_type;</span><br><span class="line">        driver_register(&amp;driver-&gt;driver);</span><br><span class="line">        list_add_tail(&amp;driver-&gt;<span class="built_in">list</span>,&amp;drivers);              <span class="comment">// 将 i2c_driver 放到链表尾部</span></span><br><span class="line"></span><br><span class="line">        list_for_each_entry(adapter, &amp;adapters, <span class="built_in">list</span>) &#123;</span><br><span class="line">            driver-&gt;attach_adapter(adapter);                <span class="comment">// 尝试匹配 i2c_adapter</span></span><br><span class="line">            <span class="comment">// driver-&gt;attach_adapter 就会去调用驱动里指定的 attach_adapter 函数.</span></span><br><span class="line">            <span class="comment">// 一般的, 就是直接调用 i2c_probe. &quot;i2c-dev.c&quot; 除外, 它关联所有的 &quot;i2c_adapter&quot;.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i2c_probe(adapter, &amp;addr_data, eeprom_detect);              <span class="comment">// adapter 是系统传过来的</span></span><br><span class="line">    adap_id = i2c_adapter_id(adapter)                       <span class="comment">// i2c_adapter.nr 作为判断.</span></span><br><span class="line">    <span class="comment">// 判断 address_data 里是否有 forces.类型匹配即可. 强制类型不会检查I2C从设备是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (address_data-&gt;forces) &#123;</span><br><span class="line">        <span class="comment">// force里的类型与 i2c_adapter.nr 一致, 或者是 ANY_I2C_BUS</span></span><br><span class="line">        <span class="keyword">if</span> (forces[kind][i] == adap_id || forces[kind][i] == ANY_I2C_BUS) &#123;</span><br><span class="line">            i2c_probe_address();                            <span class="comment">// 调用 i2c_probe_address</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// address_data.probe 里的地址和类型不受ignore影响.</span></span><br><span class="line">    <span class="comment">// probe 的数据格式也必须是 &#123;I2C_BUS_ID, ADDR, I2C_BUS_ID, ADDR, I2C_CLIENT_END&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (address_data-&gt;probe[i] == adap_id || address_data-&gt;probe[i] == ANY_I2C_BUS) &#123;</span><br><span class="line">            i2c_probe_address();                            <span class="comment">// 调用 i2c_probe_address</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// address_data.normal_i2c, 就是排除 .ignore 后, 进行 i2c_probe_address</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i2c_probe_address                                           <span class="comment">// 发出S信号,发出设备地址(来自addr_data)</span></span><br><span class="line">    i2c_smbus_xfer</span><br><span class="line">        i2c_smbus_xfer_emulated</span><br><span class="line">            i2c_transfer</span><br><span class="line">                adap-&gt;algo-&gt;master_xfer                     <span class="comment">// 就是调用 s3c24xx_i2c_xfer</span></span><br><span class="line">    found_proc(adapter, addr, kind);</span><br><span class="line">    <span class="comment">// 回调用户设置的的 detection 函数, 告知匹配成功. 可以做一些收发数据的初始化准备.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// =========== 从 i2c_add_adapter 看 ==========</span></span><br><span class="line">i2c_add_adapter                                             <span class="comment">// I2C 总线驱动会调用, 如 &quot;i2c-s3c2410.c&quot;</span></span><br><span class="line">    i2c_register_adapter</span><br><span class="line">        device_register(&amp;adap-&gt;dev);                        <span class="comment">// 在 i2c-adapter 下注册 i2c-X</span></span><br><span class="line">        list_for_each(item,&amp;drivers) &#123;</span><br><span class="line">            driver = list_entry(item, struct i2c_driver, <span class="built_in">list</span>);</span><br><span class="line">            driver-&gt;attach_adapter(adap);                   <span class="comment">// 尝试匹配 i2c_adapter</span></span><br><span class="line">            <span class="comment">// driver-&gt;attach_adapter 就会去调用i2c设备驱动里指定的 attach_adapter 函数.</span></span><br><span class="line">            <span class="comment">// 后续过程和后面的 i2c_add_driver 一样, 略过不表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于 i2c_adapter.nr 应该是由这里的驱动在设定, 作为对接的依据之一.</span></span><br><span class="line"><span class="comment">// 但实际上, 大多数CPU厂商都没有用这个 i2c_adapter.nr 去作为 I2C_BUS 的ID. 默认值应该是0</span></span><br><span class="line"><span class="comment">// 所以最终是否能匹配就变成了根据 I2C 的地址, 实际检测一下设备是否存在...</span></span><br></pre></td></tr></table></figure>


<h1 id="编写I2C设备驱动"><a href="#编写I2C设备驱动" class="headerlink" title="编写I2C设备驱动"></a>编写I2C设备驱动</h1><p>一般的, I2C总线驱动也由芯片公司完成了.<br>因此, 当外接了某个i2c设备时, 只需要编写一下设备驱动就可以了.<br>linux内核还包含了常用的 i2c 设备如eeprom. 可以在 <code>./drivers/i2c/chips</code> 下看看.</p>
<p>核心步骤如下:</p>
<ul>
<li>分配一个i2c_driver结构体</li>
<li>设置:<pre><code>- `attach_adapter`, 它直接调用 i2c_probe (adap, 设备地址, 发现这个设备后要调用的函数)
- `detach_client`,  卸载这个驱动后,如果之前发现能够支持的设备,则调用它来清理
</code></pre>
</li>
<li>注册： <code>i2c_add_driver</code></li>
<li>注册为<code>字符设备</code>或其它. 如 <code>input系统</code> <code>块设备</code>, 并实现对应的操作函数.</li>
</ul>
<h2 id="at24cxx-c"><a href="#at24cxx-c" class="headerlink" title="at24cxx.c"></a>at24cxx.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/jiffies.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> ignore[]      = &#123; I2C_CLIENT_END &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> normal_addr[] = &#123; <span class="number">0x50</span>, I2C_CLIENT_END &#125;;     <span class="comment">// 地址值是7位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ignore 数组范例</span></span><br><span class="line"><span class="comment">// static unsigned short ignore[]      = &#123; ANY_I2C_BUS, 0x60, I2C_CLIENT_END &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// probe 数组范例</span></span><br><span class="line"><span class="comment">// static unsigned short probe[]       = &#123; ANY_I2C_BUS, 0x60, I2C_CLIENT_END &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// force 数组范例</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> force_addr[] = &#123;ANY_I2C_BUS, <span class="number">0x60</span>, I2C_CLIENT_END&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> *forces[] = &#123;force_addr, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client_address_data</span> <span class="title">addr_data</span> =</span> &#123;</span><br><span class="line">    .normal_i2c = normal_addr,              <span class="comment">// 要发出S信号和设备地址并得到ACK信号, 才确认设备存在</span></span><br><span class="line">    .probe      = ignore,</span><br><span class="line">    .ignore     = ignore,</span><br><span class="line">    <span class="comment">// 一般不用 .forces 的. 由于jz2440没有i2c从设备, 因此这里用一下.</span></span><br><span class="line">    .forces     = forces,                   <span class="comment">// 强制认为存在这个设备</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> major;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">cls</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">at24cxx_driver</span>;</span>    <span class="comment">// i2c_driver 结构体, 初始化在后面</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">at24cxx_client</span>;</span>          <span class="comment">// i2c_client 结构体</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">at24cxx_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> * offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> address;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span>                  <span class="comment">// i2c_msg 结构体</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">1</span>)                          <span class="comment">// 只接受1个参数, 表地址.</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    copy_from_user(&amp;address, buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读AT24CXX时,要先把要读的存储空间的地址发给它</span></span><br><span class="line">    msg[<span class="number">0</span>].addr  = at24cxx_client-&gt;addr;    <span class="comment">// 目的</span></span><br><span class="line">    msg[<span class="number">0</span>].buf   = &amp;address;                <span class="comment">// 源</span></span><br><span class="line">    msg[<span class="number">0</span>].len   = <span class="number">1</span>;                       <span class="comment">// 地址=1 byte</span></span><br><span class="line">    msg[<span class="number">0</span>].flags = <span class="number">0</span>;                       <span class="comment">// 表示写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后启动读操作</span></span><br><span class="line">    msg[<span class="number">1</span>].addr  = at24cxx_client-&gt;addr;    <span class="comment">// 源</span></span><br><span class="line">    msg[<span class="number">1</span>].buf   = &amp;data;                   <span class="comment">// 目的</span></span><br><span class="line">    msg[<span class="number">1</span>].len   = <span class="number">1</span>;                       <span class="comment">// 数据=1 byte</span></span><br><span class="line">    msg[<span class="number">1</span>].flags = I2C_M_RD;                <span class="comment">// 表示读</span></span><br><span class="line"></span><br><span class="line">    ret = i2c_transfer(at24cxx_client-&gt;adapter, msg, <span class="number">2</span>);    <span class="comment">// 发送+接受</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">2</span>) &#123;</span><br><span class="line">        copy_to_user(buf, &amp;data, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">at24cxx_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> val[<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[1];</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">2</span>)                          <span class="comment">// 只接受2个参数, 表地址和数据.</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    copy_from_user(val, buf, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    msg[<span class="number">0</span>].addr  = at24cxx_client-&gt;addr;    <span class="comment">// 目的</span></span><br><span class="line">    msg[<span class="number">0</span>].buf   = val;                     <span class="comment">// 源</span></span><br><span class="line">    msg[<span class="number">0</span>].len   = <span class="number">2</span>;                       <span class="comment">// 地址+数据=2 byte</span></span><br><span class="line">    msg[<span class="number">0</span>].flags = <span class="number">0</span>;                       <span class="comment">// 表示写</span></span><br><span class="line"></span><br><span class="line">    ret = i2c_transfer(at24cxx_client-&gt;adapter, msg, <span class="number">1</span>);    <span class="comment">// 发送</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">at24cxx_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .read  = at24cxx_read,</span><br><span class="line">    .write = at24cxx_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">at24cxx_detect</span><span class="params">(struct i2c_adapter *adapter, <span class="keyword">int</span> address, <span class="keyword">int</span> kind)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;at24cxx_detect\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个i2c_client结构体: 收发数据时会用到它</span></span><br><span class="line">    at24cxx_client = kzalloc(<span class="keyword">sizeof</span>(struct i2c_client), GFP_KERNEL);</span><br><span class="line">    at24cxx_client-&gt;addr    = address;</span><br><span class="line">    at24cxx_client-&gt;adapter = adapter;</span><br><span class="line">    at24cxx_client-&gt;driver  = &amp;at24cxx_driver;</span><br><span class="line">    <span class="built_in">strcpy</span>(at24cxx_client-&gt;name, <span class="string">&quot;at24cxx&quot;</span>);</span><br><span class="line">    i2c_attach_client(at24cxx_client);      <span class="comment">// 关联到 i2c_driver 和 i2c_adapter</span></span><br><span class="line"></span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;at24cxx&quot;</span>, &amp;at24cxx_fops);</span><br><span class="line"></span><br><span class="line">    cls = class_create(THIS_MODULE, <span class="string">&quot;at24cxx&quot;</span>);</span><br><span class="line">    class_device_create(cls, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;at24cxx&quot;</span>);           <span class="comment">// /dev/at24cxx</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">at24cxx_attach</span><span class="params">(struct i2c_adapter *adapter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 主动调用 probe 函数, 符合要求后, 会调用 at24cxx_detect</span></span><br><span class="line">    <span class="keyword">return</span> i2c_probe(adapter, &amp;addr_data, at24cxx_detect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">at24cxx_detach</span><span class="params">(struct i2c_client *client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;at24cxx_detach\n&quot;</span>);</span><br><span class="line">    class_device_destroy(cls, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">    class_destroy(cls);</span><br><span class="line">    unregister_chrdev(major, <span class="string">&quot;at24cxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    i2c_detach_client(client);</span><br><span class="line">    kfree(i2c_get_clientdata(client));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">at24cxx_driver</span> =</span> &#123; <span class="comment">// i2c_driver 结构体</span></span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;at24cxx&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .attach_adapter = at24cxx_attach,</span><br><span class="line">    .detach_client  = at24cxx_detach,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">at24cxx_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i2c_add_driver(&amp;at24cxx_driver);        <span class="comment">// i2c_add_driver, 会自动去匹配 i2c_add_adapter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">at24cxx_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i2c_del_driver(&amp;at24cxx_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(at24cxx_init);</span><br><span class="line">module_exit(at24cxx_exit);</span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TEST_FILE   := i2c_test</span><br><span class="line"></span><br><span class="line">obj-m       := at24cxx.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br><span class="line">    rm -f <span class="variable">$(TEST_FILE)</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">    arm-linux-gcc <span class="variable">$(TEST_FILE)</span>.c -o <span class="variable">$(TEST_FILE)</span></span><br></pre></td></tr></table></figure>


<h2 id="i2c-test-c"><a href="#i2c-test-c" class="headerlink" title="i2c_test.c"></a>i2c_test.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* i2c_test r addr</span></span><br><span class="line"><span class="comment"> * i2c_test w addr val</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_usage</span><span class="params">(<span class="keyword">char</span> *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s r addr\n&quot;</span>, file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s w addr val\n&quot;</span>, file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((argc != <span class="number">3</span>) &amp;&amp; (argc != <span class="number">4</span>)) &#123;</span><br><span class="line">        print_usage(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/at24cxx&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open /dev/at24cxx\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        buf[<span class="number">0</span>] = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        read(fd, buf, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;data: %c, %d, 0x%2x\n&quot;</span>, buf[<span class="number">0</span>], buf[<span class="number">0</span>], buf[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;w&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        buf[<span class="number">0</span>] = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        buf[<span class="number">1</span>] = strtoul(argv[<span class="number">3</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        write(fd, buf, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        print_usage(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/i2c/             # i2c驱动目录</span></span><br><span class="line">$ make modules</span><br><span class="line">$ make <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line">$ cat /proc/devices                             <span class="comment"># 注册的驱动, 如调用 &quot;register_chrdev&quot;</span></span><br><span class="line">$ ls /sys/class/                                <span class="comment"># 注册的类, 如调用 &quot;class_create&quot;</span></span><br><span class="line">i2c-adapter                                     <span class="comment"># 由 i2c-core.c 生成</span></span><br><span class="line"><span class="comment"># 里面有个 i2c-0 设备, 是i2c主机端概念,</span></span><br><span class="line"><span class="comment"># 由 i2c_add_adapter 生成. 就是 s3c2440-i2c.</span></span><br><span class="line"></span><br><span class="line">$ ls /sys/class/class_name                      <span class="comment"># 注册的设备, 如调用 &quot;device_create&quot;</span></span><br><span class="line">$ ls /dev/                                      <span class="comment"># mdev根据注册的设备, 使用mknod生成的设备节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440//kernel/linux-2.6.22.6/drivers/i2c   # i2c驱动目录, nfs</span></span><br><span class="line">$ insmod i2c-dev.ko                             <span class="comment"># 加载系统自带的i2c</span></span><br><span class="line"><span class="comment"># 源码里会调用 i2c_add_driver 表示一个从机设备, 供APP端直接操作此i2c设备</span></span><br><span class="line"></span><br><span class="line">$ cat /proc/devices</span><br><span class="line"> 89 i2c                                         <span class="comment"># 固定的主设备号89, i2c 从设备</span></span><br><span class="line">$ ls /sys/class/</span><br><span class="line">i2c-dev                                         <span class="comment"># 找到了 i2c-dev 类</span></span><br><span class="line">$ ls /sys/class/i2c-dev</span><br><span class="line">i2c-0                                           <span class="comment"># 这个i2c0是从机端概念, 由 i2c_add_driver 生成</span></span><br><span class="line"><span class="comment"># ls /dev/i2c*</span></span><br><span class="line">/dev/i2c-0                                      <span class="comment"># 是 i2c-dev 的 i2c-0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续做实验</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/i2c/             # i2c驱动目录, nfs</span></span><br><span class="line">$ insmod at24cxx.ko                             <span class="comment"># 加载驱动</span></span><br><span class="line">at24cxx_detect                                  <span class="comment"># 使用的强制加载, 因此没有外设也说检测到了</span></span><br><span class="line"></span><br><span class="line">$ cat /proc/devices</span><br><span class="line"> 89 i2c                                         <span class="comment"># APP可以通过这里操作i2c底层</span></span><br><span class="line">252 at24cxx                                     <span class="comment"># APP可以通过这里认为只是在读写eeprom, 虽然底层实现是i2c通讯</span></span><br><span class="line">$ ls /sys/class/</span><br><span class="line">at24cxx                                         <span class="comment"># 由自己的i2c驱动代码生成, 与 i2c_add_driver 相关</span></span><br><span class="line">i2c-adapter                                     <span class="comment"># 由 i2c-core 生成, 与 i2c_add_adapter 相关</span></span><br><span class="line">i2c-dev                                         <span class="comment"># 由 i2c-dev 生成, 与 i2c_add_driver 相关</span></span><br><span class="line">$ ls /dev/at* /dev/i2c*</span><br><span class="line">/dev/at24cxx  /dev/i2c-0                        <span class="comment"># 两个设备节点.</span></span><br><span class="line"><span class="comment"># i2c-adapter 是不会出现在这里的. 因为只会对i2c从机进行读写操作, 是不会对i2c主机做什么操作的.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># at24c芯片操作.</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/i2c/             # i2c驱动目录, nfs</span></span><br><span class="line">$ ./i2c_test r 0</span><br><span class="line">$ ./i2c_test w 0 0x59</span><br><span class="line">$ ./i2c_test r 0                                <span class="comment"># 回读应该也是 0x59 才对.</span></span><br><span class="line"><span class="comment"># 断电后再读也应该是0x59. eeprom是非易失性存储器</span></span><br><span class="line"><span class="comment"># 对jz2440肯定是失败的, 因为没有这个外设.</span></span><br></pre></td></tr></table></figure>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://www.cnblogs.com/lcw/p/3297889.html">【驱动】linux下I2C驱动架构全面分析</a></li>
<li><a href="http://blog.csdn.net/hanmengaidudu/article/details/10159787">用户空间使用i2c-dev.c</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>面试之嵌入式C语言</title>
    <url>/2018/05/07/1816-interview-c/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/05/04/1714-expression/">逻辑|这样表达，事半功倍</a></li>
<li><a href="https://draapho.github.io/2018/01/10/1805-interview-general/">面试之常规问题</a></li>
<li><a href="https://draapho.github.io/2018/05/07/1816-interview-c/">面试之嵌入式C语言</a></li>
<li><a href="https://draapho.github.io/2017/05/17/1715-c/">C语言知识巩固</a></li>
<li><a href="https://draapho.github.io/2018/05/08/1817-interview-linux/">面试之嵌入式Linux</a></li>
</ul>
<p>我个人面试经验极少, 但这种能力都是需要培养的.<br>此系列总结一下面试中常见的技能要点. 侧重于技术面的准备.</p>
<h1 id="Q1-define"><a href="#Q1-define" class="headerlink" title="Q1: #define"></a>Q1: #define</h1><p>Using the #define statement, how would you declare a manifest constant that returns the number of seconds in a year? Disregard leap years in your answer.</p>
<p>A1:<br><code>#define SECONDS_PER_YEAR (60UL * 60UL * 24UL * 365UL)</code></p>
<p>I’m looking for several things here:</p>
<ul>
<li>Basic knowledge of the #define syntax (i.e. no semi-colon at the end, the need to parenthesize etc.).</li>
<li>A good choice of name, with capitalization and underscores.</li>
<li>An understanding that the pre-processor will evaluate constant expressions for you. Thus, it is clearer, and penalty free to spell out how you are calculating the number of seconds in a year, rather than actually doing the calculation yourself.</li>
<li>A realization that the expression will oveflow an integer argument on a 16 bit machine hence the need for the L, telling the compiler to treat the expression as a Long.</li>
<li>As a bonus, if you modified the expression with a UL (indicating unsigned long), then you are off to a great start because you are showing that you are mindful of the perils of signed and unsigned types and remember, first impressions count!</li>
</ul>
<h1 id="Q2-define"><a href="#Q2-define" class="headerlink" title="Q2: #define"></a>Q2: #define</h1><p>Write the “standard” MIN macro. That is, a macro that takes two arguments and returns the smaller of the two arguments.</p>
<p>A2:<br><code>#define MIN(A,B) ( (A) &lt;= (B) ? (A) : (B) )</code></p>
<p>The purpose of this question is to test the following:</p>
<ul>
<li>Basic knowledge of the #define directive as used in macros. This is important, because until the inline operator becomes part of standard C, macros are the only portable way of generating inline code. Inline code is often necessary in embedded systems in order to achieve the required performance level.</li>
<li>Knowledge of the ternary conditional operator. This exists in C because it allows the compiler to potentially produce more optimal code than an ifthen-else sequence. Given that performance is normally an issue in embedded systems, knowledge and use of this construct is important.</li>
<li>Understanding of the need to very carefully parenthesize arguments to macros.</li>
<li>I also use this question to start a discussion on the side effects of macros, e.g. what happens when you write code such as : <code>least = MIN(*p++, b);</code></li>
</ul>
<h1 id="Q3-error"><a href="#Q3-error" class="headerlink" title="Q3: #error"></a>Q3: #error</h1><p>What is the purpose of the preprocessor directive #error?</p>
<p>A3:<br>Either you know the answer to this, or you don’t. If you don’t, then see reference.<br>This question is very useful for dierentiating between normal folks and the nerds. It’s only the nerds that actually read the appendices of C textbooks that find out about such things. Of course, if you aren’t looking for a nerd, the candidate better hope she doesn’t know the answer.</p>
<h1 id="Q4-Infinite-loops"><a href="#Q4-Infinite-loops" class="headerlink" title="Q4: Infinite loops"></a>Q4: Infinite loops</h1><p>Infinite loops often arise in embedded systems. How does one code an infinite loop in C?</p>
<p>A4:<br>There are several solutions to this question. My preferred solution is:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Another common construct is:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Personally, I dislike this construct because the syntax doesn’t exactly spell out what is going on. Thus, if a candidate gives this as a solution, I’ll use it as an opportunity to explore their rationale for doing so. If their answer is basically “I was taught to do it this way and I have never thought about it since” then it tells me something (bad) about them. Conversely, if they state that it’s the K&amp;R preferred method and the only way to get an infinite loop passed Lint, then they score bonus points.</p>
<p>A third solution is to use a goto:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Loop :</span><br><span class="line">. . .</span><br><span class="line"><span class="keyword">goto</span> Loop ;</span><br></pre></td></tr></table></figure>
<p>Candidates that propose this are either assembly language programmers (which is probably good), or else they are closet BASIC / FORTRAN programmers looking to get into a new field.</p>
<h1 id="Q5-Data-declarations"><a href="#Q5-Data-declarations" class="headerlink" title="Q5: Data declarations"></a>Q5: Data declarations</h1><p>Using the variable a, write down definitions for the following:<br>a) An integer<br>b) A pointer to an integer<br>c) A pointer to a pointer to an integer<br>d) An array of ten integers<br>e) An array of ten pointers to integers<br>f) A pointer to an array of ten integers<br>g) A pointer to a function that takes an integer as an argument and returns an integer<br>h) An array of ten pointers to functions that take an integer argument and return an integer</p>
<p>A5:<br>The answers are:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;          <span class="comment">// An integer</span></span><br><span class="line"><span class="keyword">int</span> *a;         <span class="comment">// A pointer to an integer</span></span><br><span class="line"><span class="keyword">int</span> **a;        <span class="comment">// A pointer to a pointer to an integer</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];      <span class="comment">// An array of ten integers</span></span><br><span class="line"><span class="keyword">int</span> *a[<span class="number">10</span>];     <span class="comment">// An array of ten pointers to integers</span></span><br><span class="line"><span class="keyword">int</span> (*a)[<span class="number">10</span>];   <span class="comment">// A pointer to an array of ten integers</span></span><br><span class="line"><span class="keyword">int</span> (*a)(<span class="keyword">int</span>);  <span class="comment">// A pointer to a function that takes an integer as an argument and returns an integer</span></span><br><span class="line"><span class="keyword">int</span> (*a[<span class="number">10</span>])(<span class="keyword">int</span>); <span class="comment">// An array of ten pointers to functions that take an integer argument and return an integer</span></span><br></pre></td></tr></table></figure>
<p>People often claim that a couple of these are the sorts of thing that one looks up in textbooks and I agree. While writing this article, I consulted textbooks to ensure the syntax was correct. However, I expect to be asked this question (or something close to it) when in an interview situation. Consequently, I make sure I know the answers at least for the few hours of the interview. Candidates that don’t know the answers (or at least most of them) are simply unprepared for the interview. If they can’t be prepared for the interview, what will they be prepared for?</p>
<h1 id="Q6-Static"><a href="#Q6-Static" class="headerlink" title="Q6: Static"></a>Q6: Static</h1><p>What are the uses of the keyword static?</p>
<p>A6:<br>This simple question is rarely answered completely. Static has three distinct uses in C:</p>
<ul>
<li>A variable declared static within the body of a function maintains its value between function invocations.</li>
<li>A variable declared static within a module1, (but outside the body of a function) is accessible by all functions within that module. It is not accessible by functions within any other module. That is, it is a localized global.</li>
<li>Functions declared static within a module may only be called by otherfunctions within that module. That is, the scope of the function is localized to the module within which it is declared.</li>
</ul>
<p>Most candidates get the first part correct. A reasonable number get the second part correct, while a pitiful number understand the third answer. This is a serious weakness in a candidate, since they obviously do not understand the importance and benefits of localizing the scope of both data and code.</p>
<h1 id="Q7-Const"><a href="#Q7-Const" class="headerlink" title="Q7: Const"></a>Q7: Const</h1><p>What does the keyword const mean?</p>
<p>A7:<br>As soon as the interviewee says “const means constant”, I know I’m dealing with an amateur. Dan Saks has exhaustively covered const in the last year, such that every reader of ESP should be extremely familiar with what const can and cannot do for you. If you haven’t been reading that column, suffice it to say that const means “read-only”. Although this answer doesn’t really do the subject justice, I’d accept it as a correct answer. (If you want the detailed answer, then read Saks’ columns carefully!).</p>
<p>If the candidate gets the answer correct, then I’ll ask him these supplemental questions:</p>
<h1 id="Q7-1-Const"><a href="#Q7-1-Const" class="headerlink" title="Q7.1: Const"></a>Q7.1: Const</h1><p>What do the following incomplete declarations mean?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int a ;</span><br><span class="line">int const a ;</span><br><span class="line">const int *a ;</span><br><span class="line">int * const a ;</span><br><span class="line">int const *a const ;</span><br></pre></td></tr></table></figure>

<p>A7.1:<br>The first two mean the same thing, namely a is a const (read-only) integer.<br>The third means a is a pointer to a const integer (i.e., the integer isn’t modifiable, but the pointer is).<br>The fourth declares a to be a const pointer to an integer (i.e., the integer pointed to by a is modifiable, but the pointer is not).<br>The final declaration declares a to be a const pointer to a const integer (i.e., neither the integer pointed to by a, nor the pointer itself may be modified).</p>
<p>If the candidate correctly answers these questions, I’ll be impressed. Incidentally, one might wonder why I put so much emphasis on const, since it is very easy to write a correctly functioning program without ever using it. There are several reasons:</p>
<ul>
<li>The use of const conveys some very useful information to someone reading your code. In effect, declaring a parameter const tells the user about its intended usage. If you spend a lot of time cleaning up the mess left by other people, then you’ll quickly learn to appreciate this extra piece of information. (Of course, programmers that use const, rarely leave a mess for others to clean up…)</li>
<li>const has the potential for generating tighter code by giving the optimizer some additional information.</li>
<li>Code that uses const liberally is inherently protected by the compiler against inadvertent coding constructs that result in parameters being changed that should not be. In short, they tend to have fewer bugs.</li>
</ul>
<h1 id="Q8-Volatile"><a href="#Q8-Volatile" class="headerlink" title="Q8: Volatile"></a>Q8: Volatile</h1><p>What does the keyword volatile mean? Give three different examples of its use.</p>
<p>A8:<br>A volatile variable is one that can change unexpectedly. Consequently, the compiler can make no assumptions about the value of the variable. In particular, the optimizer must be careful to reload the variable every time it is used instead of holding a copy in a register. Examples of volatile variables are:</p>
<ul>
<li>Hardware registers in peripherals (e.g., status registers)</li>
<li>Non-stack variables referenced within an interrupt service routine.</li>
<li>Variables shared by multiple tasks in a multi-threaded application.</li>
</ul>
<p>If a candidate does not know the answer to this question, they aren’t hired. I consider this the most fundamental question that distinguishes between a ‘C programmer’ and an ‘embedded systems programmer’. Embedded folks deal with hardware, interrupts, RTOSes, and the like. All of these require volatile variables. Failure to understand the concept of volatile will lead to disaster. On the (dubious) assumption that the interviewee gets this question correct, I like to probe a little deeper, to see if they really understand the full significance of volatile. In particular, I’ll ask them the following:</p>
<h1 id="Q8-1-Volatile"><a href="#Q8-1-Volatile" class="headerlink" title="Q8.1: Volatile"></a>Q8.1: Volatile</h1><ul>
<li>Can a parameter be both const and volatile? Explain your answer.</li>
<li>Can a pointer be volatile? Explain your answer.</li>
<li>What is wrong with the following function?:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span> <span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr * *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A8.1:<br>The answers are as follows:</p>
<ul>
<li>Yes. An example is a read only status register. It is volatile because it can change unexpectedly. It is const because the program should not attempt to modify it.</li>
<li>Yes. Although this is not very common. An example is when an interrupt service routine modifses a pointer to a buffer.</li>
<li>This one is wicked. The intent of the code is to return the square of the value pointed to by <code>*ptr</code>. However, since <code>*ptr</code>points to a volatile parameter, the compiler will generate code that looks something like this:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span> <span class="params">( <span class="keyword">volatile</span> <span class="keyword">int</span> *ptr )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    a = *ptr ;</span><br><span class="line">    b = *ptr ;</span><br><span class="line">    <span class="keyword">return</span> a * b ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Since it is possible for the value of <code>*ptr</code> to change unexpectedly, it is possible for a and b to be different. Consequently, this code could return a number that is not a square! The correct way to code this is:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">square</span> <span class="params">( <span class="keyword">volatile</span> <span class="keyword">int</span> *ptr )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a = *ptr;</span><br><span class="line">    <span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Q9-Bit-Manipulation"><a href="#Q9-Bit-Manipulation" class="headerlink" title="Q9: Bit Manipulation"></a>Q9: Bit Manipulation</h1><p>Embedded systems always require the user to manipulate bits in registers or variables. Given an integer variable a, write two code fragments. The first should set bit 3 of a. The second should clear bit 3 of a. In both cases, the remaining<br>bits should be unmodified.</p>
<p>A9:<br>These are the three basic responses to this question:</p>
<ul>
<li>No idea. The interviewee cannot have done any embedded systems work.</li>
<li>Use bit fields. Bit fields are right up there with trigraphs as the most braindead portion of C. Bit fields are inherently non-portable across compilers, and as such guarantee that your code is not reusable. I recently had the misfortune to look at a driver written by Infineon for one of their more complex communications chip. It used bit fields, and was completely useless because my compiler implemented the bit fields the other way around. The moral never let a non-embedded person anywhere near a real piece of hardware!</li>
<li>Use #defines and bit masks. This is a highly portable method, and is the one that should be used. My optimal solution to this problem would be:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT3 (0x1&lt;&lt;3)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_bit3</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    a |= BIT3 ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_bit3</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    a &amp;= ~BIT3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Some people prefer to define a mask, together with manifest constants for the set and clear values. This is also acceptable. The important elements that I’m looking for are the use of manifest constants, together with the <code>|=</code> and <code>&amp;=</code> constructs.</p>
<h1 id="Q10-Accessing-fixed-memory-locations"><a href="#Q10-Accessing-fixed-memory-locations" class="headerlink" title="Q10: Accessing fixed memory locations"></a>Q10: Accessing fixed memory locations</h1><p>Embedded systems are often characterized by requiring the programmer to access a specific memory location. On a certain project it is required to set an integer variable at the absolute address 0x67a9 to the value 0xaa55. The compiler is a pure ANSI compiler. Write code to accomplish this task.</p>
<p>A10:<br>This problem tests whether you know that it is legal to typecast an integer to a pointer in order to access an absolute location. The exact syntax varies depending upon one’s style. However, I would typically be looking</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for something like this:</span></span><br><span class="line"><span class="keyword">int</span> *ptr;</span><br><span class="line">ptr = (<span class="keyword">int</span> *)<span class="number">0x67a9</span> ;</span><br><span class="line">*ptr = <span class="number">0xaa55</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A more obfuscated approach is:</span></span><br><span class="line">*(<span class="keyword">int</span> * <span class="keyword">const</span>)(<span class="number">0x67a9</span>) = <span class="number">0xaa55</span>;</span><br></pre></td></tr></table></figure>
<p>Even if your taste runs more to the second solution, I suggest the first solution when you are in an interview situation.</p>
<h1 id="Q11-Interrupts"><a href="#Q11-Interrupts" class="headerlink" title="Q11: Interrupts"></a>Q11: Interrupts</h1><p>Interrupts are an important part of embedded systems. Consequently, many compiler vendors offer an extension to standard C to support interrupts. Typically, this new key word is <code>__interrupt</code>. The following code uses <code>__interrupt</code> to define an interrupt service routine. Comment on the code.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__interrupt <span class="keyword">double</span> <span class="title">compute_area</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ar ea = PI * radius * radius;</span><br><span class="line">    print (<span class="string">&quot;\nArea = %f&quot;</span>, area ) ;</span><br><span class="line">    <span class="keyword">return</span> area ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A11:<br>This function has so much wrong with it, it’s almost tough to know where to start.</p>
<ul>
<li>Interrupt service routines cannot return a value. If you don’t understand this, then you aren’t hired.</li>
<li>ISR’s cannot be passed parameters. See first item for your employment prospects if you missed this.</li>
<li>On many processors/compilers, floating point operations are not necessarily re-entrant. In some cases one needs to stack additional registers, in other cases, one simply cannot do floating point in an ISR. Furthermore, given that a general rule of thumb is that ISRs should be short and sweet, one wonders about the wisdom of doing floating point math here.</li>
<li>In a similar vein to third point, printf() often has problems with reentrancy and performance.<br>If you missed last two points then I wouldn’t be too hard on you. Needless to say, if you got these two points, then your employment prospects are looking better and better.</li>
</ul>
<h1 id="Q12-Code-Examples"><a href="#Q12-Code-Examples" class="headerlink" title="Q12: Code Examples"></a>Q12: Code Examples</h1><p>What does the following code output and why?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void foo (void) &#123;</span><br><span class="line">    unsigned int a &#x3D; 6;</span><br><span class="line">    int b &#x3D; -20;</span><br><span class="line">    (a+b &gt; 6) ? puts (&quot;&gt;6&quot;) : puts(&quot;&lt;&#x3D;6&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A12:<br>This question tests whether you understand the integer promotion rules in C an area that I find is very poorly understood by many developers. Anyway, the answer is that this outputs <code>&gt;6</code>. The reason for this is that expressions involving signed and unsigned types have all operands promoted to unsigned types. Thus <code>-20</code> becomes a very large positive integer and the expression evaluates to greater than 6. This is a very important point in embedded systems where unsigned data types should be used frequently. If you get this one wrong, then you are perilously close to not being hired.</p>
<h1 id="Q13-Code-Examples"><a href="#Q13-Code-Examples" class="headerlink" title="Q13: Code Examples"></a>Q13: Code Examples</h1><p>Comment on the following code fragment?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned int zero &#x3D; 0;</span><br><span class="line">unsigned int compzero &#x3D; 0xFFFF; &#x2F;* 1&#39;s complement of zero *&#x2F;</span><br></pre></td></tr></table></figure>

<p>A13:<br>On machines where an int is not 16 bits, this will be incorrect. It should be coded:<br><code>unsigned int compzero = ~0;</code></p>
<p>This question really gets to whether the candidate understands the importance of word length on a computer. In my experience, good embedded programmers are critically aware of the underlying hardware and its limitations, whereas computer programmers tend to dismiss the hardware as a necessary annoyance.</p>
<p>By this stage, candidates are either completely demoralized or they are on a roll and having a good time. If it is obvious that the candidate isn’t very good, then the test is terminated at this point. However, if the candidate is doing well, then I throw in these supplemental questions. These questions are hard, and I expect that only the very best candidates will do well on them. In posing these questions, I’m looking more at the way the candidate tackles the problems, rather than the answers. Anyway, have fun…</p>
<h1 id="Q14-Dynamic-memory-allocation"><a href="#Q14-Dynamic-memory-allocation" class="headerlink" title="Q14: Dynamic memory allocation"></a>Q14: Dynamic memory allocation</h1><p>Although not as common as in non-embedded computers, embedded systems still do dynamically allocate memory from the heap. What are the problems with dynamic memory allocation in embedded systems?</p>
<p>A14:<br>Here, I expect the user to mention memory fragmentation, problems with garbage collection, variable execution time, etc. This topic has been covered extensively in ESP, mainly by Plauger. His explanations are far more insightful than anything I could offer here, so go and read those back issues! Having lulled the candidate into a sense of false security, I then offer up this tidbit: What does the following code fragment output and why?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *ptr;</span><br><span class="line"><span class="keyword">if</span> (( ptr=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Got a null pointer&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Got a valid pointer&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is a fun question. I stumbled across this only recently, when a colleague of mine inadvertently passed a value of 0 to malloc, and got back a valid pointer! After doing some digging, I discovered that the result of malloc(0) is implementation defined, so that the correct answer is “it depends”. I use this to start a discussion on what the interviewee thinks is the correct thing for malloc to do. Getting the right answer here is nowhere near as important as the way you approach the problem and the rationale for your decision.</p>
<h1 id="Q15-Typedef"><a href="#Q15-Typedef" class="headerlink" title="Q15: Typedef"></a>Q15: Typedef</h1><p>Typedef is frequently used in C to declare synonyms for pre-existing data types.<br>It is also possible to use the preprocessor to do something similar. For instance,<br>consider the following code fragment:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dPS struct s *</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s</span> * <span class="title">tPS</span>;</span></span><br></pre></td></tr></table></figure>
<p>The intent in both cases is to define dPS and tPS to be pointers to structure s. Which method (if any) is preferred and why?</p>
<p>A15:<br>This is a very subtle question, and anyone that gets it right (for the right reason) is to be congratulated or condemned (“get a life” springs to mind). The answer is the typedef is preferred. Consider the declarations:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dPS p1, p2;</span><br><span class="line">tPS p3, p4;</span><br></pre></td></tr></table></figure>

<p>The first expands to <code>struct s *p1 , p2</code> which defines p1 to be a pointer to the structure and p2 to be an actual structure, which is probably not what you wanted. The second example correctly defines p3 and p4 to be pointers.</p>
<h1 id="Q16-Obfuscated-syntax"><a href="#Q16-Obfuscated-syntax" class="headerlink" title="Q16: Obfuscated syntax"></a>Q16: Obfuscated syntax</h1><p>C allows some appalling constructs. Is this construct legal, and if so what does this code do?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">5</span>, b=<span class="number">7</span>, c;</span><br><span class="line">c = a+++b ;</span><br></pre></td></tr></table></figure>

<p>A16:<br>This question is intended to be a lighthearted end to the quiz, as, believe it or not, this is perfectly legal syntax. The question is how does the compiler treat it? Those poor compiler writers actually debated this issue, and came up with the “maximum munch” rule, which stipulates that the compiler should bite off as big a (legal) chunk as it can. Hence, this code is treated as:<br>    <code>c = a++ + b;</code></p>
<p>Thus, after this code is executed, a = 6, b = 7 and c = 12; If you knew the answer, or guessed correctly then well done. If you didn’t know the answer then I would not consider this to be a problem. I find the biggest benefit of this question is that it is very good for stimulating questions on coding styles, the value of code reviews and the benefits of using lint.</p>
<p>Well folks, there you have it. That was my version of the C test. I hope you had as much fun doing it as I had writing it. If you think the test is a good test, then by all means use it in your recruitment. Who knows, I may get lucky in a year or two and end up being on the receiving end of my own work.</p>
<h1 id="Q-What-is-NULL-pointer-and-what-is-its-use"><a href="#Q-What-is-NULL-pointer-and-what-is-its-use" class="headerlink" title="Q: What is NULL pointer and what is its use?"></a>Q: What is NULL pointer and what is its use?</h1><p>The NULL is a macro de¡ned in C. Null pointer actually means a pointer that does not point to any valid location. We de¡ne a pointer to be null when we want to make sure that the pointer does not point to any valid location and not to use that pointer to change anything. If we don’t use null pointer, then we can’t verify whether this pointer points to any valid location or not.</p>
<h1 id="Q-What-is-void-pointer-and-what-is-its-use"><a href="#Q-What-is-void-pointer-and-what-is-its-use" class="headerlink" title="Q: What is void pointer and what is its use?"></a>Q: What is void pointer and what is its use?</h1><p>The void pointer means that it points to a variable that can be of any type. Other pointers points to a speci¡c type of variable while void pointer is a somewhat generic pointer and can be pointed to any data type, be it standard data type(int, char etc) or user de¡ne data type (structure, union etc.). We can pass any kind of pointer and reference it as a void pointer. But to dereference it, we have to type the void pointer to correct data type.</p>
<h1 id="Q-What-is-ISR"><a href="#Q-What-is-ISR" class="headerlink" title="Q: What is ISR?"></a>Q: What is ISR?</h1><p>An ISR(Interrupt Service Routine) is an interrupt handler, a callback subroutine which is called when a interrupt is encountered Interrupt latency is the time required for an ISR responds to an interrupt.</p>
<h1 id="Q-What-is-interrupt-latency-How-to-reduce-interrupt-latency"><a href="#Q-What-is-interrupt-latency-How-to-reduce-interrupt-latency" class="headerlink" title="Q: What is interrupt latency? How to reduce interrupt latency?"></a>Q: What is interrupt latency? How to reduce interrupt latency?</h1><p>Interrupt latency is the time required for an ISR responds to an interrupt.<br>Interrupt latency can be minimized by writing short ISR routine and by not delaying interrupts for more time.</p>
<ol start="20">
<li>What is Top half &amp; bottom half of a kernel?</li>
</ol>
<p>Sometimes to handle an interrupt, a substantial amount of work has to be done. But it conflicts with the speed need for an interrupt handler. To handle this situation, Linux splits the handler into two parts – Top half and Bottom half. The top half is the routine that actually responds to the interrupt. The bottom half on the other hand is a routine that is scheduled by the upper half to be executed later at a safer time.</p>
<p>All interrupts are enabled during execution of the bottom half. The top half saves the device data into the specific buffer, schedules bottom half and exits. The bottom half does the rest. This way the top half can service a new interrupt while the bottom half is working on the previous.</p>
<h1 id="Q-Can-static-variables-be-declared-in-a-header-file"><a href="#Q-Can-static-variables-be-declared-in-a-header-file" class="headerlink" title="Q: Can static variables be declared in a header file?"></a>Q: Can static variables be declared in a header file?</h1><p>A static variable cannot be declared without defining it. A static variable can be defined in the header file. But doing so, the result will be having a private copy of that variable in each source file which includes the header file. So it will be wise not to declare a static variable in header file, unless you are dealing with a different scenario.</p>
<h1 id="Q-Is-Count-Down-to-Zero-Loop-better-than-Count-Up-Loops"><a href="#Q-Is-Count-Down-to-Zero-Loop-better-than-Count-Up-Loops" class="headerlink" title="Q: Is Count Down_to_Zero Loop better than Count_Up_Loops?"></a>Q: Is Count Down_to_Zero Loop better than Count_Up_Loops?</h1><p>Count down to zero loops are better. Reason behind this is that at loop termination, comparison to zero can be optimized by the compiler. Most processors have instruction for comparing to zero. So they don’t need to load the loop variable and the maximum value, subtract them and then compare to zero. That is why count down to zero loop is better.</p>
<h1 id="Q-What-are-inline-functions-Advantages-and-disadvantages-of-using-macro-and-inline-functions"><a href="#Q-What-are-inline-functions-Advantages-and-disadvantages-of-using-macro-and-inline-functions" class="headerlink" title="Q: What are inline functions? Advantages and disadvantages of using macro and inline functions?"></a>Q: What are inline functions? Advantages and disadvantages of using macro and inline functions?</h1><p>The ARM compilers support inline functions with the keyword __inline. These functions have a small definition and the function body is substituted in each call to the inline function. The argument passing and stack maintenance is skipped and it results in faster code execution, but it increases code size, particularly if the inline function is large or one inline function is used often.</p>
<p>The advantage of the macro and inline function is that the overhead for argument passing and stuff is reduced as the function are in-lined. The advantage of macro function is that we can write type insensitive functions. It is also the disadvantage of macro function as macro functions can’t do validation check. The macro and inline function also increases the size of the executable.</p>
<h1 id="Q-What-happens-when-recursive-functions-are-declared-inline"><a href="#Q-What-happens-when-recursive-functions-are-declared-inline" class="headerlink" title="Q: What happens when recursive functions are declared inline?"></a>Q: What happens when recursive functions are declared inline?</h1><p>Inlining an recursive function reduces the overhead of saving context on stack. But, inline is merely a suggestion to the compiler and it does not guarantee that a function will be inlined. Obviously, the compiler won’t be able to inline a recursive function infinitely. It may not inline it at all or it may inline it, just a few levels deep.</p>
<h1 id="Q-Can-structures-be-passed-to-the-functions-by-value"><a href="#Q-Can-structures-be-passed-to-the-functions-by-value" class="headerlink" title="Q: Can structures be passed to the functions by value?"></a>Q: Can structures be passed to the functions by value?</h1><p>Passing structure by its value to a function is possible, but not a good programming practice. First of all, if we pass the structure by value and the function changes some of those values, then the value change is not reflected in caller function. Also, if the structure is big, then passing the structure by value means copying the whole structure to the function argument stack which can slow the program by a significant amount.</p>
<h1 id="Q-Why-cannot-arrays-be-passed-by-values-to-functions"><a href="#Q-Why-cannot-arrays-be-passed-by-values-to-functions" class="headerlink" title="Q: Why cannot arrays be passed by values to functions?"></a>Q: Why cannot arrays be passed by values to functions?</h1><p>In C, the array name itself represents the address of the first element. So, even if we pass the array name as argument, it will be passed as reference and not its address.</p>
<h1 id="Q-What-is-the-concatenation-operator"><a href="#Q-What-is-the-concatenation-operator" class="headerlink" title="Q: What is the concatenation operator?"></a>Q: What is the concatenation operator?</h1><p>The Concatenation operator (##) in macro is used to concatenate two arguments. Literally, we can say that the arguments are concatenated, but actually their value are not concatenated. Think it this way, if we pass A and B to a macro which uses ## to concatenate those two, then the result will be AB. Consider the example to clear the confusion-</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOME_MACRO(a, b) a##b</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> var = <span class="number">15</span>;</span><br><span class="line">  <span class="built_in">printf</span>(“%d”, SOME_MACRO(v, ar));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output of the above program will be 15.</p>
<h1 id="Q-define-cat-x-y-x-y-concatenates-x-to-y-But-cat-cat-1-2-3-does-not-expand-but-gives-preprocessor-warning-Why"><a href="#Q-define-cat-x-y-x-y-concatenates-x-to-y-But-cat-cat-1-2-3-does-not-expand-but-gives-preprocessor-warning-Why" class="headerlink" title="Q: #define cat(x,y) x##y concatenates x to y. But cat(cat(1,2),3) does not expand but gives preprocessor warning. Why?"></a>Q: <code>#define cat(x,y) x##y</code> concatenates x to y. But <code>cat(cat(1,2),3)</code> does not expand but gives preprocessor warning. Why?</h1><p>The cat(x, y) expands to x##y. It just pastes x and y. But in case of cat(cat(1,2),3), it expands to cat(1,2)##3 instead of 1##2##3. That is why it is giving preprocessor warning.</p>
<h1 id="Q-How-to-decide-whether-given-processor-is-using-little-endian-format-or-big-endian-format"><a href="#Q-How-to-decide-whether-given-processor-is-using-little-endian-format-or-big-endian-format" class="headerlink" title="Q: How to decide whether given processor is using little endian format or big endian format ?"></a>Q: How to decide whether given processor is using little endian format or big endian format ?</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_for_endianness</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> *c = (<span class="keyword">char</span>*) &amp;x;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)*c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Q-What-is-forward-reference-w-r-t-pointers-in-c"><a href="#Q-What-is-forward-reference-w-r-t-pointers-in-c" class="headerlink" title="Q: What is forward reference w.r.t. pointers in c?"></a>Q: What is forward reference w.r.t. pointers in c?</h1><p>Forward Referencing with respect to pointers is used when a pointer is declared and compiler reserves the memory for the pointer, but the variable or data type is not defined to which the pointer points to. For example</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="comment">// members</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Q-How-can-you-define-a-structure-with-bit-field-members"><a href="#Q-How-can-you-define-a-structure-with-bit-field-members" class="headerlink" title="Q: How can you define a structure with bit field members?"></a>Q: How can you define a structure with bit field members?</h1><p>Not command use bit field in embedded system! because bit fields are inherently non-portable across compilers, and as such guarantee that your code is not reusable.<br>Bit field members can be declared as shown below</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line"> char c1 : 3;</span><br><span class="line"> char c2 : 4;</span><br><span class="line"> char c3 : 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Here c1, c2 and c3 are members of a structure with width 3, 4, and 1 bit respectively. The ‘:’ indicates that they are bit fields and the following numbers indicates the width in bits.</p>
<h1 id="Q-How-do-you-write-a-function-which-takes-2-arguments-a-byte-and-a-field-in-the-byte-and-returns-the-value-of-the-field-in-that-byte"><a href="#Q-How-do-you-write-a-function-which-takes-2-arguments-a-byte-and-a-field-in-the-byte-and-returns-the-value-of-the-field-in-that-byte" class="headerlink" title="Q: How do you write a function which takes 2 arguments - a byte and a field in the byte and returns the value of the field in that byte?"></a>Q: How do you write a function which takes 2 arguments - a byte and a field in the byte and returns the value of the field in that byte?</h1><p>The function will look like this -</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFieldValue</span><span class="params">(<span class="keyword">int</span> byte, <span class="keyword">int</span> field )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (byte &gt;&gt; field) &amp; <span class="number">0x01</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The byte is right shifted exactly n times where n is same as the field value. That way, our intended value ends up in the 0th bit position. “Bitwise And” with 1 can get the intended value. The function then returns the intended value.</p>
<h1 id="Q-What-is-job-of-preprocessor-compiler-assembler-and-linker"><a href="#Q-What-is-job-of-preprocessor-compiler-assembler-and-linker" class="headerlink" title="Q: What is job of preprocessor, compiler, assembler and linker ?"></a>Q: What is job of preprocessor, compiler, assembler and linker ?</h1><p>The preprocessor commands are processed and expanded by the preprocessor before actual compilation. After preprocessing, the compiler takes the output of the preprocessor and the source code, and generates assembly code. Once compiler completes its work, the assembler takes the assembly code and produces an assembly listing with offsets and generate object files.</p>
<p>The linker combines object files or libraries and produces a single executable file. It also resolves references to external symbols, assigns final addresses to functions and variables, and revises code and data to reflect new addresses.</p>
<h1 id="Q-Significance-of-watchdog-timer-in-Embedded-Systems"><a href="#Q-Significance-of-watchdog-timer-in-Embedded-Systems" class="headerlink" title="Q: Significance of watchdog timer in Embedded Systems."></a>Q: Significance of watchdog timer in Embedded Systems.</h1><p>The watchdog timer is a timing device with a predefined time interval. During that interval, some event may occur or else the device generates a time out signal. It is used to reset to the original state whenever some inappropriate events take place which can result in system malfunction. It is usually operated by counter devices.</p>
<h1 id="Q-Why-n-executes-faster-than-n-1"><a href="#Q-Why-n-executes-faster-than-n-1" class="headerlink" title="Q: Why ++n executes faster than n+1?"></a>Q: Why ++n executes faster than n+1?</h1><p>The expression ++n requires a single machine instruction such as INR to carry out the increment operation. In case of n+1, apart from INR, other instructions are required to load the value of n. That is why ++n is faster.</p>
<h1 id="Q-What-is-wild-pointer"><a href="#Q-What-is-wild-pointer" class="headerlink" title="Q: What is wild pointer?"></a>Q: What is wild pointer?</h1><p>A pointer that is not initialized to any valid address or NULL is considered as wild pointer. Consider the following code fragment -</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">*p = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>Here p is not initialized to any valid address and still we are trying to access the address. The p will get any garbage location and the next statement will corrupt that memory location.</p>
<h1 id="Q-What-is-dangling-pointer"><a href="#Q-What-is-dangling-pointer" class="headerlink" title="Q: What is dangling pointer?"></a>Q: What is dangling pointer?</h1><p>迷途指针, 指向的buffer已经被释放了, 但是指向它的指针依旧<br>If the memory of a pointer is de-allocated or freed and the pointer is not assigned to NULL, then it may still contain that address and accessing the pointer means that we are trying to access that location and it will give an error. This type of pointer is called dangling pointer.</p>
<h1 id="Q-Write-down-the-equivalent-pointer-expression-for-referring-the-same-element-a-i-j-k-l"><a href="#Q-Write-down-the-equivalent-pointer-expression-for-referring-the-same-element-a-i-j-k-l" class="headerlink" title="Q: Write down the equivalent pointer expression for referring the same element a[i][j][k][l] ?"></a>Q: Write down the equivalent pointer expression for referring the same element <code>a[i][j][k][l]</code> ?</h1><p>We know that <code>a[i]</code> can be written as <code>*(a+i)</code>. Same way, the array elements can be written like pointer expression as follows -</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[i][j] == *(*(a+i)+j)</span><br><span class="line">a[i][j][k] == *(*(*(a+i)+j)+k)</span><br><span class="line">a[i][j][k][l] == *(*(*(*(a+i)+j)+k)+l)</span><br></pre></td></tr></table></figure>

<h1 id="Q-When-should-we-use-register-modifier"><a href="#Q-When-should-we-use-register-modifier" class="headerlink" title="Q: When should we use register modifier?"></a>Q: When should we use register modifier?</h1><p>The register modifier is used when a variable is expected to be heavily used and keeping it in the CPU’s registers will make the access faster.</p>
<h1 id="Q-Explain-what-are-the-different-storage-classes-in-C"><a href="#Q-Explain-what-are-the-different-storage-classes-in-C" class="headerlink" title="Q: Explain what are the different storage classes in C"></a>Q: Explain what are the different storage classes in C</h1><ul>
<li><code>auto</code> for local variables in RAM</li>
<li><code>register</code> for local variables in register</li>
<li><code>static</code> for local variable, keeping the value during the life-time of the program</li>
<li><code>static</code> for global variable only shared on its own file scope</li>
<li><code>extern</code> to give a reference of a global variable that is visible to ALL the program files</li>
</ul>
<hr>
<p><em><strong>转载自 <a href="http://www.emb-linux.narod.ru/interview/0x10_questions.pdf">The 0x10 Best Questions for Would-be Embedded Programmers</a></strong></em><br><em><strong>转载自 <a href="http://a4academics.com/interview-questions/57-c-plus-plus/722-embedded-c-interview-questions?showall=&limitstart=">Embedded C Interview Questions and Answers</a></strong></em></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>面试之嵌入式Linux</title>
    <url>/2018/05/08/1817-interview-linux/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/05/04/1714-expression/">逻辑|这样表达，事半功倍</a></li>
<li><a href="https://draapho.github.io/2018/01/10/1805-interview-general/">面试之常规问题</a></li>
<li><a href="https://draapho.github.io/2018/05/07/1816-interview-c/">面试之嵌入式C语言</a></li>
<li><a href="https://draapho.github.io/2017/05/17/1715-c/">C语言知识巩固</a></li>
<li><a href="https://draapho.github.io/2018/05/08/1817-interview-linux/">面试之嵌入式Linux</a></li>
</ul>
<p>我个人面试经验极少, 但这种能力都是需要培养的. 此系列总结一下面试中常见的技能要点. 侧重于技术面的准备.</p>
<h1 id="common"><a href="#common" class="headerlink" title="common"></a>common</h1><h2 id="Q-What-Is-The-Difference-Between-Microprocessor-And-Microcontroller"><a href="#Q-What-Is-The-Difference-Between-Microprocessor-And-Microcontroller" class="headerlink" title="Q: What Is The Difference Between Microprocessor And Microcontroller?"></a>Q: What Is The Difference Between Microprocessor And Microcontroller?</h2><p>Microcontroller is a self-contained system with peripherals, memory and a processor that can be used as embedded system.</p>
<p>Microprocessor is managers of the resources (I/O, memory) which lie outside of its architecture.</p>
<h2 id="Q-Difference-btwn-Process-and-Thread"><a href="#Q-Difference-btwn-Process-and-Thread" class="headerlink" title="Q: Difference btwn Process and Thread"></a>Q: Difference btwn Process and Thread</h2><p>the threads are a part of a process<br>Process has a self-contained execution environment, each process has its own memory space. just can use IPC to communication<br>Threads share resources, which helps in efficient communication between threads.</p>
<h2 id="Q-What-is-thread-safety-What-is-re-entrancy"><a href="#Q-What-is-thread-safety-What-is-re-entrancy" class="headerlink" title="Q: What is thread safety? What is re-entrancy?"></a>Q: What is thread safety? What is re-entrancy?</h2><p>线程安全的概念比较直观，一般来说，一个函数被称为线程安全的，当且仅当被多个并发线程反复调用时，它会一直产生正确的结果.<br>可重入函数一定是线程安全的. 但线程安全的函数不一定是可重入的.</p>
<p>对于可重入函数, 有如下要求:</p>
<ul>
<li>不使用全局变量或静态变量；</li>
<li>不使用用malloc或者new开辟出的空间；</li>
<li>不调用不可重入函数；</li>
</ul>
<h2 id="Q-Explain-Interrupt-Latency-And-How-Can-We-Decrease-It"><a href="#Q-Explain-Interrupt-Latency-And-How-Can-We-Decrease-It" class="headerlink" title="Q: Explain Interrupt Latency And How Can We Decrease It?"></a>Q: Explain Interrupt Latency And How Can We Decrease It?</h2><ul>
<li>Interrupt latency basically refers to the time span an interrupt is generated and it being serviced by an appropriate routine defined, usually the interrupt handler.</li>
<li>External signals, some condition in the program or by the occurrence of some event, these could be the reasons for generation of an interrupt.</li>
<li>Interrupts can also be masked so as to ignore them even if an event occurs for which a routine has to be executed.</li>
<li>Following steps could be followed to reduce the latency<ul>
<li>ISRs being simple and short.</li>
<li>Interrupts being serviced immediately</li>
<li>Avoiding those instructions that increase the latency period.</li>
<li>Also by prioritizing interrupts over threads.</li>
<li>Avoiding use of inappropriate APIs.</li>
</ul>
</li>
</ul>
<h2 id="Q-What-is-Top-half-amp-bottom-half-of-a-kernel"><a href="#Q-What-is-Top-half-amp-bottom-half-of-a-kernel" class="headerlink" title="Q: What is Top half &amp; bottom half of a kernel?"></a>Q: What is Top half &amp; bottom half of a kernel?</h2><p>Sometimes to handle an interrupt, a substantial amount of work has to be done. But it conflicts with the speed need for an interrupt handler.<br>To handle this situation, Linux splits the handler into two parts: Top half and Bottom half.</p>
<ul>
<li>The top half is the routine that actually responds to the interrupt.</li>
<li>The bottom half on the other hand is a routine that is scheduled by the upper half to be executed later at a safer time.</li>
</ul>
<p>All interrupts are enabled during execution of the bottom half. The top half saves the device data into the specific buffer, schedules bottom half and exits. The bottom half does the rest. This way the top half can service a new interrupt while the bottom half is working on the previous.</p>
<h2 id="Q-List-Out-Various-Uses-Of-Timers-In-Embedded-System"><a href="#Q-List-Out-Various-Uses-Of-Timers-In-Embedded-System" class="headerlink" title="Q: List Out Various Uses Of Timers In Embedded System?"></a>Q: List Out Various Uses Of Timers In Embedded System?</h2><ul>
<li>Real Time Clock (RTC) for the system</li>
<li>Initiating an event after a preset time delay</li>
<li>Initiating an event after a comparison of preset times</li>
<li>Capturing the count value in timer on an event</li>
<li>Between two events finding the time interval</li>
<li>Time slicing for various tasks</li>
<li>Time division multiplexing</li>
<li>Scheduling of various tasks in RTOS</li>
</ul>
<h2 id="Q-Significance-of-watchdog-timer-in-Embedded-Systems"><a href="#Q-Significance-of-watchdog-timer-in-Embedded-Systems" class="headerlink" title="Q: Significance of watchdog timer in Embedded Systems."></a>Q: Significance of watchdog timer in Embedded Systems.</h2><p>The watchdog timer is a timing device with a predefined time interval. During that interval, some event may occur or else the device generates a time out signal. It is used to reset to the original state whenever some inappropriate events take place which can result in system malfunction. It is usually operated by counter devices.</p>
<h2 id="Q-Difference-between-RISC-and-CISC-processor"><a href="#Q-Difference-between-RISC-and-CISC-processor" class="headerlink" title="Q: Difference between RISC and CISC processor."></a>Q: Difference between RISC and CISC processor.</h2><p>RISC (Reduced Instruction Set Computer) could carry out a few sets of simple instructions simultaneously. Fewer transistors are used to manufacture RISC, which makes RISC cheaper. RISC has uniform instruction set and those instructions are also fewer in number. Due to the less number of instructions as well as instructions being simple, the RISC computers are faster. RISC emphasise on software rather than hardware. RISC can execute instructions in one machine cycle.</p>
<p>CISC (Complex Instruction Set Computer) is capable of executing multiple operations through a single instruction. CISC have rich and complex instruction set and more number of addressing modes. CISC emphasise on hardware rather that software, making it costlier than RISC. It has a small code size, high cycles per second and it is slower compared to RISC.</p>
<h2 id="Q-What-is-RTOS-What-is-the-difference-between-hard-real-time-and-soft-real-time-OS"><a href="#Q-What-is-RTOS-What-is-the-difference-between-hard-real-time-and-soft-real-time-OS" class="headerlink" title="Q: What is RTOS? What is the difference between hard real-time and soft real-time OS?"></a>Q: What is RTOS? What is the difference between hard real-time and soft real-time OS?</h2><p>The scheduler in a Real Time Operating System (RTOS) is designed to provide a predictable execution pattern. In an embedded system, a certain event must be entertained in strictly defined time.<br>To meet real time requirements, the behaviour of the scheduler must be predictable. This type of OS which have a scheduler with predictable execution pattern is called Real Time OS(RTOS).</p>
<p>A Hard real-time system strictly adheres to the deadline associated with the task. If the system fails to meet the deadline, even once, the system is considered to have failed.<br>In case of a soft real-time system, missing a deadline is acceptable. In this type of system, a critical real-time task gets priority over other tasks and retains that priority until it completes.</p>
<h2 id="Q-What-type-of-scheduling-is-there-in-RTOS"><a href="#Q-What-type-of-scheduling-is-there-in-RTOS" class="headerlink" title="Q: What type of scheduling is there in RTOS?"></a>Q: What type of scheduling is there in RTOS?</h2><p>RTOS uses pre-emptive scheduling. In pre-emptive scheduling, the higher priority task can interrupt a running process and the interrupted process will be resumed later.</p>
<h2 id="Q-What-is-priority-inversion-What-is-priority-inheritance"><a href="#Q-What-is-priority-inversion-What-is-priority-inheritance" class="headerlink" title="Q: What is priority inversion? What is priority inheritance?"></a>Q: What is priority inversion? What is priority inheritance?</h2><p>If two tasks share a resource, the one with higher priority will run first. However, if the lower-priority task is using the shared resource when the higher-priority task becomes ready, then the higher-priority task must wait for the lower-priority task to finish. In this scenario, even though the task has higher priority it needs to wait for the completion of the lower-priority task with the shared resource. This is called priority inversion.</p>
<p>Priority inheritance is a solution to the priority inversion problem. The process waiting for any resource which has a resource lock will have the maximum priority. This is priority inheritance. When one or more high priority jobs are blocked by a job, the original priority assignment is ignored and execution of critical section will be assigned to the job with the highest priority in this elevated scenario. The job returns to the original priority level soon after executing the critical section.</p>
<h2 id="Q-What-is-job-of-preprocessor-compiler-assembler-and-linker"><a href="#Q-What-is-job-of-preprocessor-compiler-assembler-and-linker" class="headerlink" title="Q: What is job of preprocessor, compiler, assembler and linker?"></a>Q: What is job of preprocessor, compiler, assembler and linker?</h2><p>The preprocessor commands are processed and expanded by the preprocessor before actual compilation.</p>
<p>After preprocessing, the compiler takes the output of the preprocessor and the source code, and generates assembly code.</p>
<p>Once compiler completes its work, the assembler takes the assembly code and produces an assembly listing with offsets and generate object files.</p>
<p>The linker combines object files or libraries and produces a single executable file. It also resolves references to external symbols, assigns final addresses to functions and variables, and revises code and data to reflect new addresses.</p>
<h2 id="Q-How-you-will-debug-the-memory-issues"><a href="#Q-How-you-will-debug-the-memory-issues" class="headerlink" title="Q: How you will debug the memory issues?"></a>Q: How you will debug the memory issues?</h2><ul>
<li>First of all, double check the code source. Make sure already paired using <code>kmalloc</code> <code>kfree</code> and <code>vmalloc</code> <code>vfree</code></li>
<li><code>free -m</code> to monitor memory using status.</li>
<li><code>kmemleak</code> to log the possible problem</li>
<li>oom or panic information from kernel</li>
<li>Intercept all functions that allocate and deallocate memory.</li>
</ul>
<h2 id="Q-Debugging-techniques"><a href="#Q-Debugging-techniques" class="headerlink" title="Q: Debugging techniques"></a>Q: Debugging techniques</h2><p><code>GDB</code>, printk, led, <code>/var/log/</code></p>
<h1 id="hardware"><a href="#hardware" class="headerlink" title="hardware"></a>hardware</h1><h2 id="Q-What-Does-Dma-Address-Will-Deal-With"><a href="#Q-What-Does-Dma-Address-Will-Deal-With" class="headerlink" title="Q: What Does Dma Address Will Deal With?"></a>Q: What Does Dma Address Will Deal With?</h2><p>DMA address deals with physical addresses. It is a device which directly drives the data and address bus during data transfer. So, it is purely physical address.</p>
<h2 id="Q-What-is-virtual-memory"><a href="#Q-What-is-virtual-memory" class="headerlink" title="Q: What is virtual memory?"></a>Q: What is virtual memory?</h2><p>Virtual memory is a technique that allows processes to allocate memory in case of physical memory shortage using automatic storage allocation upon a request.<br>The advantage of the virtual memory is that the program can have a larger memory than the physical memory. It allows large virtual memory to be provided when only a smaller physical memory is available.</p>
<p>Virtual memory can be implemented using paging.<br>A paging system is quite similar to a paging system with swapping. When we want to execute a process, we swap it into memory. Here we use a lazy swapper called pager rather than swapping the entire process into memory. When a process is to be swapped in, the pager guesses which pages will be used based on some algorithm, before the process is swapped out again. Instead of swapping whole process, the pager brings only the necessary pages into memory. By that way, it avoids reading in unnecessary memory pages, decreasing the swap time and the amount of physical memory.</p>
<h2 id="Q-What-is-kernel-paging-What-is-page-frame"><a href="#Q-What-is-kernel-paging-What-is-page-frame" class="headerlink" title="Q: What is kernel paging? What is page frame?"></a>Q: What is kernel paging? What is page frame?</h2><p>Paging is a memory management scheme by which computers can store and retrieve data from the secondary memory storage when needed in to primary memory. In this scheme, the operating system retrieves data from secondary storage in same-size blocks called pages. The paging scheme allows the physical address space of a process to be non continuous. Paging allows OS to use secondary storage for data that does not fit entirely into physical memory.</p>
<p>A page frame is a block of RAM that is used for virtual memory. It has its page frame number. The size of a page frame may vary from system to system, and it is in the power of 2 in bytes. Also, it is the smallest length block of memory in which an operating system maps memory pages.</p>
<h2 id="Q-Virtual-Address-Linear-Address-Physical-Address"><a href="#Q-Virtual-Address-Linear-Address-Physical-Address" class="headerlink" title="Q: Virtual Address, Linear Address, Physical Address"></a>Q: Virtual Address, Linear Address, Physical Address</h2><p>32-bit CPU 3GB for user layer, 1GB for kernel layer<br><code>kmalloc</code> apply the physical address directly, so it is continuous but size limination<br><code>vmalloc</code> apply the virtual memory, in physical it is not continuous. need MMU to translate to physical memory.<br>Virtual Address – Segment(GDT LDT) – Linear Address – Paging (4 layer Page Directory, Page Table) – Physical Address</p>
<h2 id="Q-How-to-decide-whether-given-processor-is-using-little-endian-format-or-big-endian-format"><a href="#Q-How-to-decide-whether-given-processor-is-using-little-endian-format-or-big-endian-format" class="headerlink" title="Q:How to decide whether given processor is using little endian format or big endian format ?"></a>Q:How to decide whether given processor is using little endian format or big endian format ?</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_for_endianness</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> *c = (<span class="keyword">char</span>*) &amp;x;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)*c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Q-nand-vs-nor-flash"><a href="#Q-nand-vs-nor-flash" class="headerlink" title="Q: nand vs nor flash"></a>Q: nand vs nor flash</h2><ul>
<li>使用复杂 vs 使用简单(same as sram)</li>
<li>读取慢 vs 读取快</li>
<li>写入快 vs 写入慢</li>
<li>顺序读取快, 随机存取慢 vs 随机存取快</li>
<li>容量大 vs 容量小</li>
<li>擦写次数多 vs 擦写次数少</li>
<li>yaffs2 vs jffs2</li>
<li>存放引导程序, 参数区 vs 用户文件, 多媒体文件</li>
</ul>
<h2 id="Q-Definition-and-difference-between-Hardware-interrupt-Software-Interrupt-Exception-Trap-and-Signals"><a href="#Q-Definition-and-difference-between-Hardware-interrupt-Software-Interrupt-Exception-Trap-and-Signals" class="headerlink" title="Q: Definition and difference between Hardware interrupt, Software Interrupt, Exception, Trap and Signals?"></a>Q: Definition and difference between Hardware interrupt, Software Interrupt, Exception, Trap and Signals?</h2><ul>
<li>Hardware Interrupts: may arrive anytime, typically IO interrupts.</li>
<li>Exception: may only arrive after the execution of an instruction, for example when the cpu try to devide a number by 0 or a page fault</li>
<li>Trap is a kind of exceptions, whose main purpose is for debugging</li>
<li>Software Interrupt occurs at the request of the programmer. They are used to implement system calls, and handled by the CPU as trap.</li>
<li>Signals are part of the IPC, not belong to interrupts or exceptions.</li>
</ul>
<h2 id="Q-Explain-MMU-in-Linux"><a href="#Q-Explain-MMU-in-Linux" class="headerlink" title="Q: Explain MMU in Linux"></a>Q: Explain MMU in Linux</h2><p>Paged memory management unit. Translation of virtual memory addresses to physical addresses</p>
<h2 id="Q-What-are-high-memory-and-low-memory-on-Linux"><a href="#Q-What-are-high-memory-and-low-memory-on-Linux" class="headerlink" title="Q: What are high memory and low memory on Linux"></a>Q: What are high memory and low memory on Linux</h2><ul>
<li>The High Memory is the segment of memory that user-space programs can address. It cannot touch Low Memory.</li>
<li>Low Memory is the segment of memory that the Linux kernel can address directly.</li>
<li>If the kernel must access High Memory, it has to map it into its own address space first.</li>
<li><code>copy_from_user(&amp;val, data, 1);</code></li>
</ul>
<h2 id="Q-How-to-register-an-interrupt-handler"><a href="#Q-How-to-register-an-interrupt-handler" class="headerlink" title="Q: How to register an interrupt handler?"></a>Q: How to register an interrupt handler?</h2><ul>
<li><code>request_irq(IRQ_ID, handler_irq, ...);</code></li>
<li><code>irqreturn_t handler_irq(int irq, void *dev_id)</code> can get the IRQ_ID from <code>int irq</code></li>
</ul>
<h1 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h1><h2 id="Q-Linux驱动的一些基本概念"><a href="#Q-Linux驱动的一些基本概念" class="headerlink" title="Q: Linux驱动的一些基本概念"></a>Q: Linux驱动的一些基本概念</h2><ul>
<li>主设备号. 可以人工指定, 也可以由系统动态分配. 理解为设备类型的id即可.</li>
<li>子设备号. 譬如一个led灯的驱动设备, 可以实现多个led的控制. 子设备号可以提供针对特定的led进行控制</li>
<li>mdev. 根据动态驱动模块的信息自动创建设备节点.</li>
<li>地址映射. 这是与单片机的区别. 单片机操作寄存器可以直接使用物理地址. 但linux下使用的是虚拟地址!<ul>
<li>地址转换使用 <code>ioremap</code> <code>iounmap</code> 函数.</li>
<li>一般的芯片商也会提供操作寄存器的函数, 譬如 s3c2410_gpio_setpin</li>
</ul>
</li>
<li>用户空间和内核空间. 两个空间的资源不能直接相互访问.<ul>
<li>驱动程序内经常要用 <code>copy_to_user</code> 以及 <code>copy_from_user</code></li>
</ul>
</li>
</ul>
<h2 id="Q-Linux-调度机制"><a href="#Q-Linux-调度机制" class="headerlink" title="Q: Linux 调度机制"></a>Q: Linux 调度机制</h2><ul>
<li>轮转调度算法(Round Robin), 先来先服务(FIFC)策略, have a time slice</li>
<li>优先级调度算法(Priority): preemptive(抢占式), static priority, dynamic priority</li>
<li>Linux Sheduler:<ul>
<li>pick next, staircase scheduler.</li>
<li>using dynamic priority, and time slice</li>
<li>rt_proirity(实时任务): SCHED_FIFO (just priority), SCHED_RR (time_slice)</li>
</ul>
</li>
</ul>
<h2 id="Q-linux-android-启动流程"><a href="#Q-linux-android-启动流程" class="headerlink" title="Q: linux android 启动流程"></a>Q: linux android 启动流程</h2><ul>
<li>hardware bootloader, can load specific flash address to ram and run automatically</li>
<li>uboot stage1 (start.s): 底层硬件初始化(register), copy stage2 code to ram, init stack, data segment</li>
<li>uboot stage2 (main.c): 硬件初始化(flash, ui, net), load kernel image, copy parameter to specific address for linux</li>
<li>kernel: decompress image, read parameter from uboot, init hardware(register, MMU, paging table)</li>
<li>load filesystem, init environment(<code>etc/inittab</code>, <code>etc/init.d/rcS</code>, <code>bin/sh</code>)</li>
<li>load dymatical drivers, run user application</li>
<li>Then for android:<ul>
<li>zygote (由 Linux init 启动)</li>
<li>Dalvik VM</li>
<li>SyetemServers</li>
<li>Managers</li>
<li>Launcher</li>
</ul>
</li>
</ul>
<h2 id="Q-linux-file-system"><a href="#Q-linux-file-system" class="headerlink" title="Q: linux file system"></a>Q: linux file system</h2><ul>
<li>Linux下一切皆文件, 文件即inode.</li>
<li>索引过程为: 目录inode-&gt;目录名/文件名-&gt;对应inode-&gt;具体内容</li>
<li>BusyBox 是linux下的一个应用程序, 集成了最常用的Linux命令和工具.</li>
<li>最小文件系统 <code>dev/console</code> <code>dev/null</code> init进程<code>bin/busybox</code> <code>etc/inittab</code> C库 <code>lib/</code> 系统程序或脚本 <code>/etc/init.d/rcS</code> <code>bin/sh</code></li>
<li>mdev: 动态加载驱动时, 自动生成节点文件 <code>/dev</code></li>
<li>file format yaffs2 for nand, jffs2 for nor</li>
</ul>
<h2 id="Q-What-do-you-understand-about-Linux-Kernel-and-can-you-edit-it"><a href="#Q-What-do-you-understand-about-Linux-Kernel-and-can-you-edit-it" class="headerlink" title="Q: What do you understand about Linux Kernel and can you edit it?"></a>Q: What do you understand about Linux Kernel and can you edit it?</h2><p>Linux Kernel is the component that manages the hardware resources for the user and that provides essential services and interact with the user commands.<br>Linux Kernel is an open source software and free, and it is released under General Public License so we can edit it and it is legal.</p>
<h2 id="Q-What-are-the-different-types-of-Kernels-Explain"><a href="#Q-What-are-the-different-types-of-Kernels-Explain" class="headerlink" title="Q: What are the different types of Kernels? Explain"></a>Q: What are the different types of Kernels? Explain</h2><p>We can build kernels by many different types, but 3 of the types of kernels are most commonly used: monolithic, microkernel and hybrid.</p>
<ul>
<li><p>Microkernel: This type of kernel only manages CPU, memory, and IPC. This kind of kernel provides portability, small memory footprint and also security.</p>
</li>
<li><p>Monolithic Kernel: Linux is a monolithic kernel. So, this type of kernel provides file management, system server calls, also manages CPU, IPC as well as device drivers. It provides easier access to the process to communicate and as there is not any queue for processor time, so processes react faster.</p>
</li>
<li><p>Hybrid Kernel: In this type of kernels, programmers can select what they want to run in user mode and what in supervisor mode. So, this kernel provides more flexibility than any other kernel but it can have some latency problems.</p>
</li>
</ul>
<h2 id="Q-Linux-operating-system-components"><a href="#Q-Linux-operating-system-components" class="headerlink" title="Q: Linux operating system components"></a>Q: Linux operating system components</h2><ul>
<li>Kernel: Linux is a monolithic kernel</li>
<li>System Library: GNU C Library. Library plays a vital role because application programs access Kernels feature using system library.</li>
<li>System Utility: System Utility performs specific and individual level tasks.</li>
</ul>
<h2 id="Q-Where-is-password-file-located-in-Linux-and-how-can-you-improve-the-security-of-password-file"><a href="#Q-Where-is-password-file-located-in-Linux-and-how-can-you-improve-the-security-of-password-file" class="headerlink" title="Q: Where is password file located in Linux and how can you improve the security of password file?"></a>Q: Where is password file located in Linux and how can you improve the security of password file?</h2><p>This is an important question that is generally asked by the interviewers.<br>User information along with the passwords in Linux is stored in <code>/etc/passwd</code> that is a compatible format. But this file is used to get the user information by several tools. Here, security is at risk. So, we have to make it secured.</p>
<p>To improve the security of the password file, instead of using a compatible format we can use <strong>shadow password format</strong>.</p>
<p>So, in shadow password format, the password will be stored as single “x” character which is not <code>/etc/passwd</code>. This information is stored in another file instead with a file name <code>/etc/shadow</code>. So, to enhance the security, the file is made word readable and also, this file is readable only by the root user. Thus security risks are overcome to a great extent by using the shadow password format.</p>
<h2 id="Q-Explain-system-calls-used-for-process-management"><a href="#Q-Explain-system-calls-used-for-process-management" class="headerlink" title="Q: Explain system calls used for process management?"></a>Q: Explain system calls used for process management?</h2><p>There are some system calls used in Linux for process management.<br>These are as follows:</p>
<ul>
<li><code>Fork()</code>: It is used to create a new process</li>
<li><code>Exec()</code>: It is used to execute a new process</li>
<li><code>Wait()</code>: It is used to make the process to wait</li>
<li><code>Exit()</code>: It is used to exit or terminate the process</li>
<li><code>Getpid()</code>: It is used to find the unique process ID</li>
<li><code>Getppid()</code>: It is used to check the parent process ID</li>
<li><code>Nice()</code>: It is used to bias the currently running process property</li>
</ul>
<h2 id="Q-Guess-the-output"><a href="#Q-Guess-the-output" class="headerlink" title="Q:Guess the output"></a>Q:Guess the output</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">    fork();</span><br><span class="line">    fork();</span><br><span class="line">    fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It will print “hello world’ 8 times.<br>The main() will print one time and creates 3 children, let us say Child_1, Child_2, Child_3. All of them printed once.<br>The Child_3 will not create any child.<br>Child2 will create one child and that child will print once.<br>Child_1 will create two children, say Child_4 and Child_5 and each of them will print once.<br>Child_4 will again create another child and that child will print one time.<br>A total of eight times the printf statement will be executed.</p>
<h2 id="Q-What-is-the-difference-between-static-linking-and-dynamic-linking"><a href="#Q-What-is-the-difference-between-static-linking-and-dynamic-linking" class="headerlink" title="Q: What is the difference between static linking and dynamic linking ?"></a>Q: What is the difference between static linking and dynamic linking ?</h2><p>In static linking, all the library modules used in the program are placed in the final executable file making it larger in size. This is done by the linker. If the modules used in the program are modified after linking, then re-compilation is needed. The advantage of static linking is that the modules are present in an executable file. We don’t want to worry about compatibility issues.</p>
<p>In case of dynamic linking, only the names of the module used are present in the executable file and the actual linking is done at run time when the program and the library modules both are present in the memory. That is why, the executables are smaller in size. Modification of the library modules used does not force re-compilation. But dynamic linking may face compatibility issues with the library modules used.</p>
<h2 id="Q-How-a-user-mode-is-transferred-to-kernel-mode-Difference-between-kernerl-user-space"><a href="#Q-How-a-user-mode-is-transferred-to-kernel-mode-Difference-between-kernerl-user-space" class="headerlink" title="Q: How a user mode is transferred to kernel mode? Difference between kernerl/user space"></a>Q: How a user mode is transferred to kernel mode? Difference between kernerl/user space</h2><p>using System call<br>kernel mode: can do anything, cpu run in full function<br>user mode: safty purpose, cpu function is liminated.<br>kernel 访问用户层数据: <code>copy_to_user</code> <code>copy_from_user</code></p>
<h2 id="Q-Main-difference-between-Tasklets-and-workqs"><a href="#Q-Main-difference-between-Tasklets-and-workqs" class="headerlink" title="Q: Main difference between Tasklets and workqs?"></a>Q: Main difference between Tasklets and workqs?</h2><ul>
<li>Tasklets:<ul>
<li>are old (around 2.3 I believe)</li>
<li>have a straightforward, simple API</li>
<li>are designed for low latency</li>
<li>cannot sleep</li>
</ul>
</li>
<li>Work queues:<ul>
<li>are more recent (introduced in 2.5)</li>
<li>have a flexible API (more options/flags supported)</li>
<li>are designed for higher latency</li>
<li>can sleep</li>
</ul>
</li>
</ul>
<h2 id="Q-Do-you-know-panic-and-oops-errors-in-kernel-crash"><a href="#Q-Do-you-know-panic-and-oops-errors-in-kernel-crash" class="headerlink" title="Q: Do you know panic and oops errors in kernel crash?"></a>Q: Do you know panic and oops errors in kernel crash?</h2><p>Oops is a way to debug kernel code, and there are utilities for helping with that.<br>A kernel panic means the system cannot recover and must be restarted.<br>However, with an Oops, the system can usually continue. You can configure klogd and syslogd to log oops messages to files, rather than to std out.</p>
<h2 id="Q-What-is-the-name-and-path-of-the-main-system-log"><a href="#Q-What-is-the-name-and-path-of-the-main-system-log" class="headerlink" title="Q: What is the name and path of the main system log?"></a>Q: What is the name and path of the main system log?</h2><p>By default, the main system log is <code>/var/log/messages</code>.<br>This file contains all the messages and the script written by the user. By default, all scripts are saved in this file. This is the standard system log file, which contains messages from all system software, non-kernel boot issues, and messages that go to <code>dmesg</code>.<br><code>dmesg</code> is a system file that is written upon system boot.<br><code>dmesg | less</code> to review boot messages.</p>
<h2 id="Q-Explain-what-happens-when-an-insmod-is-done-an-module"><a href="#Q-Explain-what-happens-when-an-insmod-is-done-an-module" class="headerlink" title="Q: Explain what happens when an insmod is done an module"></a>Q: Explain what happens when an insmod is done an module</h2><p>insmod is a user space utility to load a module into Linux kernel. It calls init_module system call to do the work.<br>init_module loads the kernel module in ELF format into kernel address space. Each section of the ELF are read and mapped using vmalloc().<br>Use of vmalloc is because kernel modules can be big and kernel might not have contiguous physical memory to accommodate for module text and data.</p>
<p>Each .ko has a struct module section. This has relocatable address of init and exit routines (ones specified in module_init and module_exit). This goes as a separate section in ELF. Once all the relevant sections are loaded in memory, kernel calls init routine of the module.</p>
<h2 id="Q-How-will-you-insert-a-module-statically-in-to-linux-kernel"><a href="#Q-How-will-you-insert-a-module-statically-in-to-linux-kernel" class="headerlink" title="Q: How will you insert a module statically in to linux kernel."></a>Q: How will you insert a module statically in to linux kernel.</h2><p>Using makefile <code>obj-y</code>. By the way <code>obj-m</code> will generate <code>.ko</code> file.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-y += mymodule.o</span><br><span class="line">mymodule-objs := src.o other.o</span><br></pre></td></tr></table></figure>

<h2 id="Q-what-is-a-device-driver-and-write-a-simple-driver"><a href="#Q-what-is-a-device-driver-and-write-a-simple-driver" class="headerlink" title="Q: what is a device driver and write a simple driver"></a>Q: what is a device driver and write a simple driver</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/xxx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/xxx.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NAME <span class="meta-string">&quot;drv_leds&quot;</span>                      <span class="comment">// 设备类型名称, cat /proc/devices 可以看到</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> major;                                   <span class="comment">// 存储自动分配的主设备号</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">leds_class</span>;</span>                    <span class="comment">// 类, 供mdev用, ls /sys/class/ 可以看到</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">class_device</span>  *<span class="title">leds_class_devs</span>[4];</span>    <span class="comment">// 类下设备, ls /sys/class/class_name 可以看到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 驱动的硬件实现部分, 和单片机类似 =====</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_leds_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minor = MINOR(inode-&gt;i_rdev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化对应的LED</span></span><br><span class="line">    gpio_init(minor);</span><br><span class="line">    printk(<span class="string">&quot;drv_leds_open\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">drv_leds_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *data, <span class="keyword">size_t</span> len, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minor = MINOR(file-&gt;f_dentry-&gt;d_inode-&gt;i_rdev);</span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line">    copy_from_user(&amp;val, data, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作对应的LED</span></span><br><span class="line">    gpio_set(minor);</span><br><span class="line">    printk(<span class="string">&quot;drv_leds_write, led%d=%d\n&quot;</span>, minor, val);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此结构体指定了C库的文件操作函数需要调用的底层驱动的函数名.</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">drv_leds_fops</span> =</span> &#123;</span><br><span class="line">    .owner  =   THIS_MODULE,        <span class="comment">// 这是一个宏，指向编译模块时自动创建的__this_module变量. 和平台相关</span></span><br><span class="line">    .open   =   drv_leds_open,</span><br><span class="line">    .write  =   drv_leds_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 加载和卸载内核时, 指定要调用的函数 =====</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_leds_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取寄存器起始地址的虚拟地址值. 其它寄存器基于此值再用偏移量.</span></span><br><span class="line">    <span class="comment">// gpio_base = ioremap(0x56000000, 0xD0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册驱动, 0表示动态分配主设备号</span></span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, DEVICE_NAME, &amp;drv_leds_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成系统设备信息, 供mdev自动创建设备节点使用</span></span><br><span class="line">    leds_class = class_create(THIS_MODULE, <span class="string">&quot;leds&quot;</span>);             <span class="comment">// 创建 leds 类</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(leds_class))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(leds_class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0-3 表示4个独立的led, 名称为 led0, led1, led2, led3</span></span><br><span class="line">    <span class="keyword">for</span> (minor = <span class="number">0</span>; minor &lt; <span class="number">4</span>; minor++) &#123;</span><br><span class="line">        leds_class_devs[minor] = class_device_create(leds_class, <span class="literal">NULL</span>, MKDEV(major, minor), <span class="literal">NULL</span>, <span class="string">&quot;led%d&quot;</span>, minor);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(IS_ERR(leds_class_devs[minor])))</span><br><span class="line">            <span class="keyword">return</span> PTR_ERR(leds_class_devs[minor]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(DEVICE_NAME <span class="string">&quot; initialized\n&quot;</span>);                       <span class="comment">// 调试用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drv_leds_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (minor = <span class="number">0</span>; minor &lt; <span class="number">4</span>; minor++) &#123;</span><br><span class="line">        class_device_unregister(leds_class_devs[minor]);        <span class="comment">// 删除设备节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    class_destroy(leds_class);                                  <span class="comment">// 删除设备类</span></span><br><span class="line">    unregister_chrdev(major, DEVICE_NAME);                      <span class="comment">// 卸载驱动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// iounmap(gpio_base);</span></span><br><span class="line">    printk(DEVICE_NAME <span class="string">&quot; deinitialized\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(drv_leds_init);</span><br><span class="line">module_exit(drv_leds_exit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 描述驱动程序的一些信息，不是必须的 =====</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;draapho&quot;</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">&quot;0.1.1&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;First Driver for LED&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>



<h1 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h1><h2 id="Q-How-many-types-of-IPC-mechanism-you-know"><a href="#Q-How-many-types-of-IPC-mechanism-you-know" class="headerlink" title="Q: How many types of IPC mechanism you know?"></a>Q: How many types of IPC mechanism you know?</h2><ul>
<li>Named pipes or FIFO</li>
<li>Semaphores</li>
<li>Shared memory</li>
<li>Message queue</li>
<li>Socket</li>
</ul>
<h2 id="Q-Explain-What-Is-Semaphore"><a href="#Q-Explain-What-Is-Semaphore" class="headerlink" title="Q: Explain What Is Semaphore?"></a>Q: Explain What Is Semaphore?</h2><p>A semaphore is an abstract datatype or variable that is used for controlling access, by multiple processes to a common resource in a concurrent system such as multiprogramming operating system.</p>
<p>Semaphores are commonly used for two purposes:</p>
<ul>
<li>To share a common memory space</li>
<li>To share access to files</li>
</ul>
<p>Semaphores are of two types:</p>
<ul>
<li>Binary semaphore: It can have only two values (0 and 1). The semaphore value is set to 1 by the process in charge, when the resource is available.</li>
<li>Counting semaphore: It can have value greater than one. It is used to control access to a pool of resources.</li>
</ul>
<h2 id="Q-What-is-difference-between-binary-semaphore-and-mutex"><a href="#Q-What-is-difference-between-binary-semaphore-and-mutex" class="headerlink" title="Q: What is difference between binary semaphore and mutex?"></a>Q: What is difference between binary semaphore and mutex?</h2><ul>
<li>Mutual exclusion and synchronization can be used by binary semaphore while mutex is used only for mutual exclusion.</li>
<li>A mutex can be released by the same thread which acquired it. Semaphore values can be changed by other thread also.</li>
<li>From an ISR, a mutex can not be used.</li>
<li>The advantage of semaphores is that, they can be used to synchronize two unrelated processes trying to access the same resource.</li>
<li>Semaphores can act as mutex, but the opposite is not possible.</li>
</ul>
<h2 id="Q-What-is-spin-lock"><a href="#Q-What-is-spin-lock" class="headerlink" title="Q: What is spin lock?"></a>Q: What is spin lock?</h2><p>If a resource is locked, a thread that wants to access that resource may repetitively check whether the resource is available. During that time, the thread may loop and check the resource without doing any useful work. Suck a lock is termed as spin lock.</p>
<h2 id="Q-Explain-Whether-We-Can-Use-Semaphore-Or-Mutex-Or-Spinlock-In-Interrupt-Context-In-Linux-Kernel"><a href="#Q-Explain-Whether-We-Can-Use-Semaphore-Or-Mutex-Or-Spinlock-In-Interrupt-Context-In-Linux-Kernel" class="headerlink" title="Q: Explain Whether We Can Use Semaphore Or Mutex Or Spinlock In Interrupt Context In Linux Kernel?"></a>Q: Explain Whether We Can Use Semaphore Or Mutex Or Spinlock In Interrupt Context In Linux Kernel?</h2><p>Mutex cannot be used for interrupt context in Linux Kernel.<br>Semaphore only can use <code>sema_post</code> in interrupt handler.<br>Spinlocks can be used for locking in interrupt context.</p>
<h2 id="Q-What-is-shared-memory"><a href="#Q-What-is-shared-memory" class="headerlink" title="Q: What is shared memory?"></a>Q: What is shared memory?</h2><p>Shared memory is the fastest interprocess communication mechanism. The operating system maps a memory segment in the address space of several processes, so that several processes can read and write in that memory segment without calling operating system functions. However, we need some kind of synchronization between processes that read and write shared memory.</p>
<h2 id="Q-How-to-come-out-of-deadlock"><a href="#Q-How-to-come-out-of-deadlock" class="headerlink" title="Q: How to come out of deadlock?"></a>Q: How to come out of deadlock?</h2><p>The most common error causing deadlock is self deadlock or recursive deadlock:</p>
<ul>
<li>a thread tries to acquire a lock it is already holding.</li>
<li>Recursive deadlock is very easy to program by mistake.</li>
</ul>
<p>Here are some simple guidelines for locking.</p>
<ul>
<li>Try not to hold locks across long operations like I/O where performance can be adversely affected.</li>
<li>Don’t hold locks when calling a function that is outside the module and that might reenter the module.</li>
<li>In general, start with a coarse-grained approach, identify bottlenecks, and add finer-grained locking where necessary to alleviate the bottlenecks. Most locks are held for short amounts of time and contention is rare, so fix only those locks that have measured contention.</li>
<li>When using multiple locks, avoid deadlocks by making sure that all threads acquire the locks in the same order.</li>
</ul>
<h2 id="Q-生产者-消费者写法"><a href="#Q-生产者-消费者写法" class="headerlink" title="Q: 生产者, 消费者写法"></a>Q: 生产者, 消费者写法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">goods</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">goods</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> m;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> has_product;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">goods</span> *<span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">goods</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;m);</span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct goods));</span><br><span class="line">        p-&gt;id = rand() % <span class="number">100</span>;</span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        head = p;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;produce %d\n&quot;</span>, p-&gt;id);</span><br><span class="line">        pthread_mutex_unlock(&amp;m);</span><br><span class="line">        pthread_cond_signal(&amp;has_product);</span><br><span class="line">        <span class="comment">//printf(&quot;produce %d\n&quot;, p-&gt;id);</span></span><br><span class="line">        sleep(rand() % <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">comsumer</span><span class="params">(<span class="keyword">void</span> *argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">goods</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;m);</span><br><span class="line">        <span class="comment">//思考：pthread_cond_wait()的作用？</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">NULL</span> == head)</span><br><span class="line">            pthread_cond_wait(&amp;has_product, &amp;m);</span><br><span class="line">        p = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;comsume %d\n&quot;</span>, p-&gt;id);</span><br><span class="line">        pthread_mutex_unlock(&amp;m);</span><br><span class="line">        <span class="comment">//printf(&quot;comsume %d\n&quot;, p-&gt;id);</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        sleep(rand() % <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启两个线程作为生产者，三个线程作为消费者</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//初始化条件变量和互斥量</span></span><br><span class="line">    pthread_mutex_init(&amp;m, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;has_product, <span class="literal">NULL</span>);</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> pro[<span class="number">2</span>], com[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        pthread_create(&amp;pro[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        pthread_create(&amp;com[i], <span class="literal">NULL</span>, comsumer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        pthread_join(pro[i], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        pthread_join(com[i], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//销毁条件变量和互斥量</span></span><br><span class="line">    pthread_mutex_destroy(&amp;m);</span><br><span class="line">    pthread_cond_destroy(&amp;has_product);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="bash-command"><a href="#bash-command" class="headerlink" title="bash command"></a>bash command</h1><h2 id="Q-How-can-I-redirect-both-stderr-and-stdin-at-once"><a href="#Q-How-can-I-redirect-both-stderr-and-stdin-at-once" class="headerlink" title="Q: How can I redirect both stderr and stdin at once?"></a>Q: How can I redirect both stderr and stdin at once?</h2><p>command <code>&gt; file.log 2&gt;&amp;1</code> : Redirect stderr to “where stdout is currently going”. In this case, that is a file opened in append mode. In other words, the <code>&amp;1</code> reuses the file descriptor which stdout currently uses.</p>
<h2 id="Q-what-is-proc-entry-and-how-it-is-useful"><a href="#Q-what-is-proc-entry-and-how-it-is-useful" class="headerlink" title="Q: what is /proc entry and how it is useful"></a>Q: what is <code>/proc</code> entry and how it is useful</h2><p>Virtual directory for system information, 虚拟档案系统. 数据都在内存当中,不占用硬盘空间.<br>主要包括系统核心,接口设备状态,网络状态.<br>比较重要的档案例: <code>proc/cpuinfo</code>  <code>/proc/interrupts</code>  <code>/proc/ioports</code></p>
<h2 id="How-can-we-edit-a-file-without-opening-in-Linux"><a href="#How-can-we-edit-a-file-without-opening-in-Linux" class="headerlink" title="How can we edit a file without opening in Linux?"></a>How can we edit a file without opening in Linux?</h2><p><code>sed</code> command is used to edit a file without opening.<br><code>sed</code> command is used to modify or change the contents of a file.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># For example, we have a text file with below content</span></span><br><span class="line">&gt; cat file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># replace “sed” with “vi”</span></span><br><span class="line">&gt;sed ‘s/sed/vi/’ file.txt</span><br></pre></td></tr></table></figure>

<h2 id="Q-How-can-you-find-out-how-much-memory-Linux-is-using"><a href="#Q-How-can-you-find-out-how-much-memory-Linux-is-using" class="headerlink" title="Q: How can you find out how much memory Linux is using?"></a>Q: How can you find out how much memory Linux is using?</h2><p><code>cat /proc/meminfo</code></p>
<h2 id="Q-Explain-grep-command-and-its-use"><a href="#Q-Explain-grep-command-and-its-use" class="headerlink" title="Q: Explain grep command and its use."></a>Q: Explain grep command and its use.</h2><p><code>grep</code> command in Linux is used to search a specific pattern. Grep command will help you to explore the string in a file or multiple files.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep ‘word’ filename</span><br><span class="line">grep ‘word’ file1 file2 file3</span><br><span class="line"><span class="built_in">command</span> | grep ‘string’</span><br><span class="line"></span><br><span class="line"><span class="comment"># For example,</span></span><br><span class="line"></span><br><span class="line">grep “smith” passwd</span><br><span class="line">grep “smith” passwd shadow</span><br><span class="line">netstat -an | grep 8083</span><br><span class="line">cat /etc/passwd | grep smith</span><br></pre></td></tr></table></figure>

<h2 id="Q-Explain-file-content-commands-along-with-the-description"><a href="#Q-Explain-file-content-commands-along-with-the-description" class="headerlink" title="Q: Explain file content commands along with the description."></a>Q: Explain file content commands along with the description.</h2><ul>
<li><code>head</code>: to check the starting of a file.</li>
<li><code>tail</code>: to check the ending of the file. It is the reverse of head command.</li>
<li><code>cat</code>: used to view, create, concatenate the files.</li>
<li><code>more</code>: used to display the text in the terminal window in pager form.</li>
<li><code>less</code>: used to view the text in the backward direction and also provides single line movement.</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.wisdomjobs.com/e-university/linux-embedded-systems-interview-questions.html">Linux Embedded systems Interview Questions &amp; Answers</a></li>
<li><a href="http://linuxdevicedrivercinterviewqs.blogspot.com.au/">Linux Device Driver,Embedded C Interview Questions</a></li>
</ul>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>佛教学习资料及一些感想</title>
    <url>/2018/07/08/1818-buddhism/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
<li><a href="https://draapho.github.io/2021/03/05/2107-tuibeitu1/">万年歌, 马前课, 梅花诗, 推背图 (上)</a></li>
<li><a href="https://draapho.github.io/2021/03/18/2108-tuibeitu2/">万年歌, 马前课, 梅花诗, 推背图 (下)</a></li>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/26/2123-caseofsatori/">见性者体验收集</a></li>
</ul>
<h1 id="传承中的变异"><a href="#传承中的变异" class="headerlink" title="传承中的变异"></a>传承中的变异</h1><p>知识,理论, 宗教的传承中, 变异是时刻都存在的. 简单如拷贝不走样这种游戏, 奖励机制是如果信息传递过程中没有走样, 就算赢, 属于正向激励, 其结果都往往是严重走样, 更别说实际的知识和理论的传播者往往是带有强烈目的性的, 更容易选择性的删去不利于自己的东西, 加入一些有利于自己的东西. 最终到了当下, 看到的理论也就不可能是干净和纯粹的了, 其中不知夹杂了多少传播者的私货! 辨别这种变异很容易, 就是看有没有利益关系. 知识/理论/宗教的传播多半需要统治者支持才能在空间广度上扩大影响, 时间宽度上通向未来, 那么这些”文化”需要部分有利于统治阶级也非常可以理解了. 简单举几个例子:</p>
<ul>
<li>后世的儒教早已和孔子的儒家分道扬镳, 儒教将儒家利于帝王统治和愚民的部分发扬光大, 将孔子的本意或含糊其辞或略去不表, 从而到达自己的目的. 这种对比, 可以去看下<a href="http://blog.sina.com.cn/s/articlelist_1215172700_8_1.html">缠中说禅的论语详解</a>, 至少我通读下来, 其解释更符合逻辑, 缠中说禅本人和论语也无什么明显的利害关系. 也可以去看看南怀瑾的<a href="http://www.quanxue.cn/CT_NanHuaiJin/LunYuIndex.html">论语别裁</a>, 反正最不可信的就是御用文官的解释, 最可信的就是直接出自孔子的语句.</li>
<li>马克思的资本论和马克思主义也是牛头不对马嘴的两套东西. 资本论分析了资本主义的发展过程, 并希望分析出社会的运动法则. 这是一套非常客观的分析, 当下的世界还没有跳出资本论的范畴. 苏维埃和中共, 都是将资本论作为革X命X的理论依据, 以此打天下(替资本论行道!). 到了坐天下时, 两者都走成了国家资本主义. 如果后世拿着中苏官方的研究文档去看资本论, 那就是南辕北辙!</li>
<li>再说说当世最严谨的科学研究: 科研项目需要资金支持, 资金有利益倾向. 因而有不少研究成果对资金利益有明显的倾向性已经是不争的事实. 有些”科学家”成为企业御用笔手也越来越常态化, 这和御用文人如出一辙! 这在医用, 保健品, 农业公司尤其明显!</li>
<li>佛教也是如此, 求神拜佛, 许愿放生自不用说, 哪怕想精进学习, 接触一点本质的东西, 也是真伪难辨. 粗看大乘小乘, 诸多流派, 就深深感受到传承中因自利而导致的变异. 大乘和禅的顿悟流行于中国一点都不奇怪, 国人向来好高骛远, 爱走捷径, 实修,  工匠精神之类的从来没有成为过主流(这里强调的是大乘和禅在中国广为流传的思想基础, 并不是说大乘和禅的高僧大德自身缺乏实修). 而印度本土佛教最终被印度教同化, 藏传佛教走上了政教合一. 这么多的演变, 什么是真, 什么是假, 具体门派的和尚们恐怕是只缘身在此山中, 门外汉更是茫茫然不知所措</li>
</ul>
<p>综上, 尽信书不如无书. 信不信一套东西, 最终还是要通过自己的思考, 辨别和选择. 非常可惜, 国内教育就是告诉你应该信这个, 不应该信那个. 独立性思维是从来没有提及的, 更不会去教授了. 当然这是自古以来的有意为之.</p>
<h1 id="佛教参考资料"><a href="#佛教参考资料" class="headerlink" title="佛教参考资料"></a>佛教参考资料</h1><ul>
<li><a href="http://www.hhfg.org/jcjx.html">慧海佛光-基础教学</a><ul>
<li><a href="http://www.hhfg.org/jcjx/f47.html">印度佛教史</a>, 必看</li>
</ul>
</li>
<li><a href="http://blog.sina.com.cn/s/articlelist_2570995211_0_1.html">Aggavara的博客</a><ul>
<li><a href="http://blog.sina.cn/dpool/blog/s/blog_993e460b0101alhp.html">原始佛教修学指南（博客导读）</a>, 实修, 推荐看</li>
<li><a href="http://blog.sina.cn/dpool/blog/s/blog_993e460b0101a70f.html?vt=4">个人推荐的一些禅修书籍下载（含阅读指导）</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_993e460b01012hsp.html">简述原始佛教核心思想</a></li>
<li><a href="https://www.meiwen.com.cn/subject/twmdsftx.html">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_6a0da51a0101asxu.html">几年来深入思考和佛法禅修实践的总结</a>, 对上图的补充说明</li>
</ul>
</li>
<li><a href="http://agama.buddhason.org/index.htm">莊春江工作站</a>, 最接近原始佛教的内容, 必看.<ul>
<li><a href="http://agama.buddhason.org/SN/index.htm">汉译相应部</a>, 建议从此处开始看.</li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E5%90%AB%E7%B6%93">阿含经与尼柯耶的关系</a></li>
</ul>
</li>
<li><a href="https://wenku.baidu.com/view/72640dea172ded630b1cb6a0.html">定慧之路-致光法师</a>, 介绍了定慧的关系, 定主要介绍的吐息法. 可看.</li>
<li>大佛顶首楞严经, 心经, 金刚经. 自己还没看, 暂不推荐.</li>
<li><a href="http://www.quanxue.cn/CT_NanHuaiJin/index.html">南怀瑾全集</a>. 太杂, 不成体系, 不推荐</li>
</ul>
<h1 id="我对佛教的认识"><a href="#我对佛教的认识" class="headerlink" title="我对佛教的认识"></a>我对佛教的认识</h1><p>接触佛教一年不到, 洋洋洒洒粗看了一些佛教相关的书籍, 对佛教的认识肯定是粗浅的. 现在将入门阶段的心得写下一二, 若有缘, 希望能帮助与我有类似背景的人入门能快一些, 少走一些弯路.</p>
<p>通读<a href="http://www.hhfg.org/jcjx/f47.html">印度佛教史</a>. 有助于快速抓住佛教的发展脉络, 大致了解原始佛教, 上座部(小乘), 大众部(发展为大乘)的区别和联系. 两者起源于释迦摩尼时代的原始佛教, 因为一些认知的差别, 分裂了. 小乘是大乘佛教对上座部的称呼, 上座部本身是不承认这个叫法的. 在我看来, 上座部更完整的传承了原始佛教, 大乘则更注重于佛教的发展和进化. 中国是流行大乘佛教的, 可惜大乘佛教资料繁杂, 派别众多, 很容易感觉无从入手, 纵览群书而不得要领. 看看<a href="http://www.hhfg.org/jcjx.html">慧海佛光-基础教学</a>里佛教的定义及分类, 便可知众人对佛教认知的多样性和复杂性了.</p>
<p>释迦摩尼的原始佛教其实并不复杂, 有明确的目标, 清晰的学习方法. 释迦摩尼就是教师, 告知大家<strong>诸行无常、诸法无我、涅槃寂静</strong>. 诸行无常是佛教的世界观, 诸法无我是教学的方法和纲领, 涅槃寂静是学习的最终目标. 释迦摩尼在世时, 唯一关注的重点就是教众人”离苦得乐”的方法, 即实修的方法, 以此为核心, 会根据不同的人的根性, 做相应的说法. 而对于形而上的哲学问题, 他一概认为不重要, 可参考 <a href="https://baike.baidu.com/item/%E5%8D%81%E5%9B%9B%E6%97%A0%E8%AE%B0">十四无记</a>, 另一个比喻是<a href="http://agama.buddhason.org/MA/MAsearch1.php?str=%E7%AE%AD%E5%96%BB&path=MA221.htm">中阿含221經/箭喻經</a>, 他将人生在世和轮回比喻为身中毒箭之人, 哪还需要去管什么箭从哪里来, 用什么做的, 给我看病的医生是谁这种不紧急的事.</p>
<p>逻辑上讲, 人生在世和不断轮回是苦, 是等同于身中毒箭之人这一观念是主观的, 对释迦摩尼而言, 十四无记里的问题是舍本求末, 没有意义的, 但不等于这些问题不值得探索. 而且, 如果去探讨毒箭何处射来, 用何材质, 飞行原理如何, 毒性如何, 都是有助于帮助更多身中毒箭的人离苦的. 在我看来, 释迦摩尼是消极厌世的, 他看到了太多的苦难, 觉得一切皆苦, 所以他的教学目的就是非常明确的涅槃寂静: 看到一切都是变化无常的, 变化无常就是苦, 现在有一种方法(诸法无我, 戒定慧)不但让你认识到诸行无常, 还能让人们脱离这种变化无常, 到达涅槃寂静.</p>
<p>还没完全信佛教, 那为什么还是想学佛法? 释迦摩尼时代的教徒, 也有很多人带着疑问在学佛, 并不是要全信了佛说的话才能学, 原始佛教是一门实修的课程, 有兴趣就能参加. 至于佛说的, 边学边去验证真伪不就行了, 释迦摩尼从来没说过学徒不能存疑. 进一步而言, 目的和方法是两回事情, 当下, 我无法认同原始佛教的最终目的, 但对佛教授的方法已经完全认同了. 如果用戒定慧的方法最终做到诸法无我, 相当于心无所执, 那无论做什么事情, 对个人对家庭对社会, 都是有百利而无一害, 看问题也会更通透. 至于神通, 轮回和诸行无常, 我已相信, 但没什么能力去证明. 而且对这些的信或不信, 丝毫不影响从戒定慧开始的实修.</p>
<p>再说一说为何要从原始佛教开始, 以及如何开始实修. 整个佛教体系, 是动态发展到当下这种情况的, 佛教的内部派系之间, 和外部宗教之间, 都充满了利益冲突, 如果都如雪山部与世无争, 其结局就是灭亡. 因而存活下来的佛教, 都是某种与人文环境妥协的产物. 由于这种原因, 看现代的佛教有如乱麻, 各种说法, 各种相面都有. 而抓住原始佛教这个源头, 有了一定观念和实修的基础以后在去了解后续变化发展后的佛教, 选择自己感兴趣的, 无疑就是最正确的学习方式了. 原始佛教的核心思想可参考 <a href="http://blog.sina.com.cn/s/blog_993e460b01012hsp.html">简述原始佛教核心思想</a>. 简单归纳如下:</p>
<ul>
<li>佛法实修的根本方法: 观察色法(物质现象)和名法(精神现象), 出发点都是<a href="https://baike.baidu.com/item/%E4%BA%94%E8%95%B4">五蕴</a>(可以简单理解为感官, 并把整个感受的过程细化开来).</li>
<li>佛法观察的对象: 四念处. 即: 身念处，受念处，心念处，法念处. 简单来说, 就是达到<a href="https://baike.baidu.com/item/%E5%9B%9B%E7%A6%85%E5%85%AB%E5%AE%9A#2_1">四禅八定</a>中的某一级别后(初禅二禅三禅四禅, 每一禅内部又分近行定和安止定两种), 去客观观察自身的种种感受和想法. 重点是客观, 是无我. 不能有控制, 想要之类的念头, 也不是学了一些方法后, 觉得自己观察到了方法中暗示的内容.</li>
<li>戒定慧的关系: 戒是身行, 人众时, 需要有明确的戒才能组织管理众人. 但行终究是给外人看的, 戒的重点在心而不在行. 定是通法而非佛法独有, 可以简单理解为心的专注程度, 练习定最简单的方法是以一念代万念, 难一点的是不生一念, 其它的如姿势等都没那么重要. 慧是佛法的重点, 这里的慧, 就是指通过观察四念处, 最终体悟到诸行无常、诸法无我. 没有定是观察不了四念的, 也就不可能有慧, 因而定是慧的基础. 但有一定程度的定以后, 则可以定慧相互促进. 定与慧的关系可参考 <a href="https://wenku.baidu.com/view/72640dea172ded630b1cb6a0.html">定慧之路-致光法师</a>. 目前面主流的灵修类书籍和体验, 大多停留在教人如何定的范畴里面. 释迦摩尼时代, 已经得定者众多(当时印度教派众多且流行苦行), 因而听了释迦摩尼的教导去观慧得解脱也要容易的多, 别人戒和定的基础都非常好. 现代人做到戒, 练习定都比较困难, 更别说进一步的慧了.</li>
<li>四念处直至涅槃的过程简述: 不用去详细了解, 实修到了哪个阶段, 再细细研判即可. 过程罗列如下<code>名色识别</code>-&gt;<code>生灭</code>-&gt;<code>缘起</code>-&gt;<code>厌离</code>-&gt;<code>舍</code>-&gt;<code>证悟</code></li>
<li>如何开始实修: 我个人是看了艾克哈特·托勒的《当下的力量》, 后来接触佛教后, 坚持了一阵打坐, 体验到了一些皮毛, 发现其中的益处后, 就容易坚定信心了.</li>
</ul>
<p>最后说说佛法的科学性. 维基百科对科学有如下定义: <code>科学是通过经验实证的方法，对现象（原来指自然现象，现泛指包括社会现象等现象）进行归因的学科。科学活动所得的知识是条件明确的（不能模棱两可或随意解读）、能经得起检验的，而且不能与任何适用范围内的已知事实产生矛盾。</code>. 我对科学的认知就是: 逻辑性的怀疑和批判精神, 如果一个理论在一定的认知范围内, 疑无可疑, 批无可批, 就是科学的理论. 而不科学并不一定就是错的, 其表达的内容为一个理论或想法, 或被证伪了(错的), 或存疑没有定论, 两者都是不科学. 因而可以这样说, 中医是不科学的, 但不意味着中医就是错的, 仅仅是因为当今的手段无法证伪或证真, 存疑而已. 而牛顿经典力学放在微观领域, 是不科学的, 这已经被证伪了.</p>
<p>通过前文的介绍, 想必已经知道释迦摩尼真正关注只是教人实修的方法, 并加了自己厌世的观点而提出了一个终极目标. 去掉明显带有主观性的终极目标, 其教授的这套方法其实是非常科学而客观的. 首先要求的就是戒定慧和诸法无我(经验实证的方法), 要去掉主观判断来观察自身的客观身心表现(对现象进行归因, 即诸行无常). 这一整套方法和体验已经被非常多的人重复过了(条件明确, 经得起检验). 定是先决条件, 就好比研究粒子现象需要粒子加速器, 要观察自身就需要定! 个人没有定, 体验不到慧, 并不能说佛法不科学. 人们总不能说, 我没亲眼看到过粒子加速器里粒子的表现, 就直接说量子力学是不科学的吧? 再进一步追问, 我们自己明明没有做过任何关于量子力学的实验, 为什么很自然的就认为量子力学是科学的?</p>
<p>综上, 只有从释迦摩尼亲自教导的实修方法出发, 才最少的受宗教, 神化, 利益等等世俗观念的影响, 最为客观, 最能直观佛法的核心, 方能自己去判断佛法的对错和真伪, 这也才是最科学的态度. 学习佛教, 千万别去纠结于流传于世的各种观念, 所有的这些观念都无助于实修.</p>
<h1 id="一个妄想"><a href="#一个妄想" class="headerlink" title="一个妄想"></a>一个妄想</h1><p>在<a href="https://www.meiwen.com.cn/subject/twmdsftx.html">一张简单图片演示的“甚深佛法”</a> 和 <a href="http://blog.sina.com.cn/s/blog_6a0da51a0101asxu.html">几年来深入思考和佛法禅修实践的总结</a> 提出了这么一点: <strong>“当观察存在了，则有被观察者的存在。因为观察生起，则被观察者生起，当观察不存在了，则没有被观察者的存在，因为观察的灭去，则有被观察者的灭去。”</strong>, 后文是对前文的补充, 就是反之亦然, 观察者和被观察者同生同灭. 这就很有意思了, 而且我认为这非常接近世界的本源了. 量子力学, 多多少少也体现了这么一种可能性.</p>
<p>这里, 我从交易市场出发, 来详细说明这里面的因果. 交易市场的最低级别是个人发出的一笔笔交易信息, 是断续的, 一份一份的. 最终走出的行情, 就如山峦一样起起伏伏. 请问, 交易市场这个事物, 是客观存在的吗? 是唯物的还是唯心的? 交易者(观察者)和股市市场(被观察者)是一种什么样的关系? 交易市场, 只要具有贪嗔的生命体在里面交易, 它就会一直客观的存在着! 当所有生命体不在关注股票市场时, 它就消亡了. 本质上, 交易市场诞生于人类的心念, 也可终结于人类的心念. 注意: 一二个个体的退出对股票市场毫无影响, 必须是参与其中的所有个体整体退出! 因而可以说: 交易市场诞生于人类的心念, 也可以由人类全体不参与股票市场而被终结! 这里可以进一步的说, 对应着由观察者心念生起而生起, 因观察者心念灭去而灭去! 而交易市场的灭去, 同样意味着所有观察交易市场的心念没了寄托之处, 也灭去了.</p>
<p>然后, 交易市场和观察者是如何因缘互动的呢? 当你我真金实银炒股时, 只要看一眼股市, 你我就由于贪嗔痴, 在当下与股市产生了互动. 因为这意味着将来某个时候你必定会基于当下这一眼的观察和后续一些列的观察而产生买卖操作. 你我一旦进行了买卖操作, 就事实上对股市走动产生了影响. 进一步推论就是: 只要你我真金实银的在炒股, 那么哪怕就是看一眼股市, 都会对股市走动产生影响(影响发生在未来)! 要在交易市场里涅槃, 对个人而言就比较简单: 没有参与其中的心念. 这时候, 你看走势就是走势, 你的心态和股市都毫无影响. 而大乘的观点是, 佛要参与到交易市场, 但是佛的心态毫无波澜, 并去告知交易市场充满了不确定性和痛苦, 赶快离开交易市场吧(这就是大乘佛教提出的终极目标). 交易市场的结论: 诸势无常, 诸利无我, 涅槃寂灭. 交易市场的走势是无常的, 交易市场的盈亏与我无关, 那么对于交易市场, 我涅槃寂静, 玩笑了.</p>
<p>分析好了交易市场, 那么再推广到人类创造的汽车, 轮船, 大楼, 城市, 以及不是由人创造的草木, 山水等事物, 又如何呢? 很难想象这些实物会因为人去而消失吧? 这里面有个级别问题. 学过缠论的话的知道, 走势有时空上的自相似性. 同一尺度下, 近期走势和历史走势有自相似性, 不同的时间层面上, 如15分钟, 60分钟, 天也有自相似性. 而所有这些自相似性, 我们是知道来源于那一笔笔包含着贪嗔痴的交易构成的. 假设那么一个炒股的人不知道股票的底细, 看着最低只提供到5分钟K线图的炒股软件, 那么这个人要如何去理解市场走势呢? 缠论给了明确的答案: 去理解级别的自相似性, 然后向下或向上推论即可.</p>
<p>在<a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">“我的终极思考-从细胞到星球生命”</a>里, 列出了这种级别关系(见下表), 并相信里面有着自相似性. 这种自相似性就是生命的本源, 甚至是一切事物的本源, 等同于”诸行无常”,”道”,”空”,”一” 这种观念. 有可能和KK提出的造物九律相关, 一定和数学里的概率论, 博弈论, 信息论相关, 是一种描述众多事物动态变化发展的理论, 这种永不停歇的动态变化发展就是诸行无常.</p>
<table>
<thead>
<tr>
<th>人的进化</th>
<th>人类的进化</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>细胞</td>
<td>人</td>
<td>低层次的基本单位</td>
</tr>
<tr>
<td>细菌</td>
<td>原始部落</td>
<td>自给自足</td>
</tr>
<tr>
<td>植物</td>
<td>原始帝国</td>
<td>职能分层</td>
</tr>
<tr>
<td>动物</td>
<td>现代社会</td>
<td>高度特质化</td>
</tr>
<tr>
<td>人</td>
<td>星球生命</td>
<td>高层次的基本单位</td>
</tr>
</tbody></table>
<ul>
<li>…(高分子, 分子, 原子, 粒子怎么来的?)</li>
<li>…(细胞怎么来的?)</li>
<li>在人体内, 充满了各种特质化的细胞, 细菌群落, 让人生存着, 发展着.</li>
<li>在人类社会, 充满了各种专职化的个人, 让人类社会生存着, 发展着.</li>
<li>在银河系内, 充满了各种专职化的星球, 让银河生命生存着, 发展着.</li>
<li>…(宇宙之外又是什么?)</li>
</ul>
<p>如果理解了交易市场是由人心构建的, 至少不难理解人类世界是由人心和物质共同的构建的, 或再进一步, 地球生态是由生命的贪嗔痴疑慢和物质共同构建的. 基于这一点, 往上推论是很简单的: 如果能星际移民, 那么行星就有可能变成细胞级别的生命体, 在星系级别去构建一个个巨大的生命体. 难的是往下推论: 物质是哪里来的? 最前沿的物理学给的答案似乎是: 从能量而来, 到能量而去, 随机变化. 佛教则对这个世界给了明确的答案: 诸行无常. 在当下的科学理解下, 生命体由物质构成, 生命体又似乎是特殊的物质, 其实倒过来想更简单: 微观物质和生命体同源, 宏观物质是微观物质构建起的某种稳态的常规表现, 而生命体是微观物质构建起的特殊表现, 好比某些复杂数学方程的特殊解. 此时, 宏观的一切东西, 都是微观物质的某种表现, 而微观物质的存在与否, 受我们不知道的因素所影响. 若所有这些因素消失, 整个世界便轰然倒塌. 当然, 这只是猜测, 不能证真也不能证伪. 整个构想, 基于朴素的无处不在的级别自相似性. 这种时空级别的自相似性, 从微观世界到宏观宇宙, 从细菌到细胞到简单生命体到人到人类社会(譬如博弈论就能解释很多生命现象, 细菌的生长和城市的扩张路径是类似的), 无处不在!</p>
<p>顺便一提, <a href="https://www.meiwen.com.cn/subject/twmdsftx.html">一张简单图片演示的“甚深佛法”</a> 的作者提到, 突然体验到<code>快速的生灭</code>, 感到<code>抓也抓不着，躲也躲不掉，无比煎熬</code>, 其中快速的生灭是客观描述, 无比煎熬是主观描述. 我关注的是, 如果提前说清楚了这么一种状态的存在, 是否就可以减轻这种苦的感觉. 这如同人第一次接触死人, 总是会特别惊悚, 但习惯了也就习惯了, 并不能因为第一次的惊悚, 就觉得人生就是惊悚(我始终对”一切皆苦”存疑). 另外, 猜测这种快速生灭的本质是, 在无我的状态下, 感受到了人体内细胞甚至更底层物质的永不停歇的自主活动. 或者放大一个层面去理解, 在国家层面内观, 一个国家的执政体系往往自我感觉良好, 可以对外战争, 对内收税, 对诸多活动控制的有条不紊, 政治经济发展井井有序, 无一不是自己的功劳(一种我的观念). 如果有一天, 这个执政体系解散(无政府状态), 它会发现所有的人一样在那里忙忙碌碌, 组织有序, 社会运行平稳, 原来一切都不受执政体系影响, 自顾自的运行着. 如果一个执政体系突然意识到自己一点都不重要, 是可有可无的, 多半也会焦虑不堪.</p>
<p>最后, 摘录Aggavara前辈在”原始佛教修学指南（博客导读）”里的语句:</p>
<blockquote>
<p>本人的观点仅供参考 读者应当保持足够的理性与怀疑态度<br>不要盲信任何观点包括本人的观点<br>本人观点是否正确, 需要每一位修行者严谨的通过理论学习以及禅修实践来判断</p>
</blockquote>
<p>理性的怀疑和批判, 亲力亲为的实验和实践, 这才是真正科学的态度. 释迦摩尼的佛法和科学, 并不冲突!</p>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>实修开始</title>
    <url>/2018/11/29/1819-start-meditation/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
<li><a href="https://draapho.github.io/2021/03/05/2107-tuibeitu1/">万年歌, 马前课, 梅花诗, 推背图 (上)</a></li>
<li><a href="https://draapho.github.io/2021/03/18/2108-tuibeitu2/">万年歌, 马前课, 梅花诗, 推背图 (下)</a></li>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/26/2123-caseofsatori/">见性者体验收集</a></li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接触冥想和佛教后, 虽然推倒了唯物论体系, 但始终对于修炼中的诸多规矩和方法存疑(如吃素禁欲出家等问题), 对佛教世界观存疑(主要是被后人过渡解读, 如极乐世界之类的概念). 所以, 近两年只能说处于一种半信半疑, 三天晒网两天打鱼的冥想打坐状态.</p>
<p>即便如此, 在修炼心性, 学习炒股的过程中, 依旧收获良多. 简单总结如下:</p>
<ul>
<li>一切皆相对: 本质就是”无常”. 贪嗔, 苦乐, 正邪, 美丑, 好坏, 时空, 都是个体的主观感受. 认识到这一点, 就能破很多象了, 譬如:<ul>
<li>欲望的相: 人好甜美之食, 恶酸臭之物. 但苍蝇反之. 人和苍蝇从物质上讲没什么区别哦, 所以只是需求不同导致的感受不同罢了!</li>
<li>宗教的相: 凡是用欲望来吸引教徒的, 皆不可信! 诸如天堂的黄金美女, 极乐世界的永恒安乐(一切无常, 哪来的永恒?).这也是笔者之前最终选择原始佛教的原因(但又比较排斥”一切皆苦”的论断, 因为这是一种主观判断, 不够客观).</li>
<li>科学的相: 经典物理有绝对时空观, 广义相对论有绝对光速. 物理学最严重的问题是, 为什么解释不了由原子分子构建成的生态圈和人类社会! 即便那个依稀可见的大统一理论, 也根本没把预测人类社会的发展作为目标, 只是想着统一四种基本力. 这里就产生了非常严重的矛盾: 如果物理学最终可以描述宇宙的起源和未来的发展, 而这个宇宙中包含人类, 而大统一理论又无法预测人类的未来, 那么物理学又如何能预测宇宙的未来? 所以, 一切理论皆相对真理, 只能描述和预测特定场景. 人类, 始终狂妄自大.</li>
<li>道德的相: 宣传越多的真善美, 事实就有越多的假恶丑, 因为充满了真善美后, 就成习惯, 不用再述说了! 人类的法律和道德说到底是为了社会稳定发展出的一种自我约束机制. 属于一种自组织的必然结果. 对和错只是群体对个体一种评价. 作为个体, 需要认识到这种道德的评价是群体强加给个体的. 作为群体中的个体, 需要遵守法律和道德, 但更需要认识到这只是相对的! 换一个群体, 评价体系也会跟着变化, 因而千万不要把道德要求绝对化. 一切看似错误的, 不可原谅的行为, 根本上讲, 是无所谓对错的.</li>
<li>数学的相: 笔者相信着数学和逻辑. 数学是目前人类公认最优美的, 最无歧义的语言. 但即便是数学, 也只能是相对的数学. 因为任何数学理论的建立, 都需要它自己的”锚”: 公理. 由于有这个”锚”, 其后续理论也只能是相对真理, 因为没人能保证这个”锚”不出问题.</li>
</ul>
</li>
</ul>
<ul>
<li>一花一世界, 世界是自相似的.<ul>
<li>笔者始终相信, 即便我们身处观察受限的”鱼缸”, 无法完整的观察出大千世界的真相, 但小世界和大世界, 以及众多平行世界本质上是自相似的. 正如同人类创造出的众多交易市场/虚拟游戏之间的关系.</li>
<li>有众多的交易市场, 单个交易市场内部的不同级别的K线图呈现一定的自相似性(规律性), 不同的交易市场存在自相似性. 虚拟游戏创造的可能性则千变万化, 但其本源依旧是贪嗔痴幻化而成的各种可能性.</li>
<li>量子力学诸多违背物质论常规知识也说明了本宇宙非物质性的可能性, 如果套用交易市场/虚拟游戏, 假设存在一更高层次的玩家便能更好的解释这一切(奥卡姆剃刀原则), 所以, 何不考虑一下道, 无常, 上帝, 真主的存在?</li>
</ul>
</li>
</ul>
<ul>
<li>科学精神: 一颗好奇的, 可以包罗万象的心.<ul>
<li>由于历史和现有的科学理论的成功, 大多数人已经迷信于科学理论体系了. 激进者甚至认为凡是现有科学解释不了的现象或事物, 便是不存在. 凡是不符合现有科学理论的古代知识, 便是假知识. 好熟悉的”二个凡是”. 这类人放在古代, 等同于宗教狂热者.</li>
<li>纵观科学的发展史, 便可知科学精神是探索, 是客观, 是开放, 是质疑. 探索是指: 不满足于已有知识, 探索未知的领域和世界. 客观是指: 不带主观目的和利益诉求的忠实记录各种观察数据. 开放是指: 分享自己的数据或理论, 欢迎大家来验证, 讨论和质疑. 质疑是指: 数据可重复实验出, 理论经得起考验.</li>
<li>集权国家不可能自发产生科学. 集权者为了维护自身利益和结构稳定, 是不可能允许个体具有探索, 客观, 开放, 质疑的精神, 所以中国不可能自发产生科学体系. 哪怕是思想界的百花, 都是在战乱时代才得以绽放. 而身处世外的得道之人, 即便主观上满足上述精神, 客观上通常无人知晓和传播. 对人类世界而言, 只是自生自灭的过客.</li>
<li>科学理论有自身的局限性, 自不必多言. 哪怕是科学的方法, 也是有非常大的局限性的. 问题就出在实验可重复这一条. 任何实验可分为观察者和被观察事物, 这就要求观察者的感知能力在同一水平, 被观察事物具有某种稳定性. 由此, 能被大家认可的观察结果必然属于某种特殊情况, 从唯心主义去讨论的话, 只有大家共同创造的事物, 才可被大家重复观察到. 当然, 为了有共同讨论的基础, 这也是没办法的事情, 属于”集体认知”的”锚”.</li>
<li>实修的科学性. 首先, 实修的方法是公开的, 实修的过程已经被相当充分的描述了, 实修的结果已经有历史上众多得道者, 高僧, (牧师?)公开说明. 这就已经证明实验可重复性. 过程和结果的客观性则被可相对独立的重复性保证了. 难点就是这些实修的过程和方法由于表述和传播的问题, 都有严重的变异, 其核心内容被严重的歪曲或掩盖.</li>
</ul>
</li>
</ul>
<ul>
<li>笔者的执念: 人类未来的发展.<ul>
<li>从高二某个节点, 突然就有了杞人之忧, 考虑起人类的未来. 之前因为兴趣学习天文学和物理学知识后, 知道宇宙无非就是热寂或坍塌. 既然死神永生, 剩下需要考虑的就是如何延长人类生存质量和寿命的问题了, 这个执念一直延续到此文, 结束了!</li>
<li>笔者的担忧和结论和伊隆·马斯克基本一致, 相必有类似想法的人不在少数, 但人的本性是执着于眼前的蝇头小利, 面对未来的不确定性, 当然是把握当下的利益更为重要.</li>
<li>简单而言, 这是一个机会成本的问题. 要发展, 就需要试错, 要试错就需要成本, 即需要机会成本来获得发展权. 就人类和地球的现状而言, 要全人类主动放弃发展权是不可能的, 这不是几个先知摇旗呐喊能改变的. 地球对人类而言已经变成那唯一一个鸡蛋了, 那就只有另外一条路, 增加机会, 星球殖民, 用物理空间隔离风险, 把人类放到多个鸡蛋里去试错发展. 当然只要走出这第一步, 行星生命体的自分裂就开始了, 在地球上类似的生命进化过程最终会在星系级别展开来, 然后在星空背景下述说并不新鲜的欲望与博弈.</li>
<li>人类当下的科技发展更专注于另外一个维度的扩展: 虚拟化. 主要就是基于电力, 硅基产生数字信号建立虚拟世界. 在无明显的生存压力下, 欲望当然更倾向于绝对权力, 做创始者, 而非培养竞争者, 这大概也是命中注定的一种选择.</li>
<li>从此文开始, 无此执念. 人类世界也不过是一个虚拟世界, 一场游戏, 一个进程, 一份体验罢了. 大千世界正在进行的就是一场无尽可能性的探索和体验.</li>
</ul>
</li>
</ul>
<ul>
<li>核心: 无我, 开放而包容的心. 放空掉一切理论道德欲望, 不去判断生死, 美丑, 善恶, 对错, 苦乐. 只是观察, 客观的观察.<ul>
<li>认识到此, 就是开悟了. 开悟可以是瞬间的.</li>
<li>然后坚定信心, 实修见证一切, 直到能自信的说出: 我看见道/佛/上帝了, 融于一体了. 实修必然是漫长的.</li>
</ul>
</li>
</ul>
<h1 id="理论来源"><a href="#理论来源" class="headerlink" title="理论来源"></a>理论来源</h1><p>寻寻觅觅, 终得元吾氏网站. 如获至宝. 带着疑问通读了全博客, 基本可信.</p>
<p>可信的理由如下:</p>
<ul>
<li>元吾氏有自力更生的能力, 早期不以修道求财, 后期存疑, 具有基本的科学素养, 力求描述客观.</li>
<li>深入浅出, 最基本的实修方法和笔者已知的是一致的, 最核心的观点和笔者自己的判断是一致的. (无我的观察)</li>
<li>文字浅显易懂, 不遮掩, 不神秘. 态度明确, 不授观点, 只讲客观体验.</li>
<li>知乎上的反对全部浏览了一遍. 部分实修者认同了其分享的经验, 持肯定态度. 道教中人多我正他邪, 先入为主, 不足为虑. 最大的争议就是后期的有偿解答和一些徒弟上的问题. (这样想来, 缠师早早过世倒不失其名誉了.)</li>
<li>需要注意的是: 在有一定的心定基础之前, 很可能初学者刻意追求出体体验有潜在风险.</li>
</ul>
<p>笔者一个门外汉级别的实修体验, 自然无法完全理解元吾氏全盘拖出的讲解. 于是计划按此大纲立个实修计划, 一步一个脚印走下来亲证去.</p>
<p>目录:</p>
<ul>
<li><a href="http://blog.sina.cn/dpool/blog/u/1760432301#type=-1">元吾氏的新浪博客</a></li>
<li><a href="http://jilu.yuanwushi.com/">元吾氏集录</a>  结构更清晰的第三方整理<ul>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-10/32.html">修道之心障</a><ul>
<li>意识封闭。大道无所不包一切之可见，无所不含一切之不可见。意识越宽广者，离道越近；越狭隘者，离道越远</li>
<li>我正他邪。万法归一。道学、佛学、儒学、基督、伊斯兰、哲学、科学等皆为求道之不同流派和不同方法。条条大路通罗马</li>
<li>以术为道。以道统术，以术得道。技术是修道的方法和工具，非道也</li>
<li>舍简求繁。大道至简，大法至易。不根于虚静者即是左道，不归于易简者即是旁门</li>
<li>轻本重末。神为本，形为末。老子曰：”伪道养形，真道养神；真神通道，能亡能存</li>
<li>强为偏执。大道自然，不是自残。 (注: 正常生活即可, 不必须出家, 不必须禁欲, 不必须素食. 修炼的目的是无我无欲达到与道合一的体验, 认识到世界的本质, 而非看上去无我无欲)</li>
<li>修道的过程：一个去除心障的过程。</li>
<li>修道的结果：去除了障碍，才能到达本源。消除“回家”路上的障碍，才能“到家”。</li>
</ul>
</li>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-10/42.html">终极真相—-所有问题的答案</a><ul>
<li>一个无限的、不生不灭、无形无相的自由意识(Freewil)/精神(Spirit)，有着无穷无尽的自发幻想(Imagination/思想Thoughts)，其景象（Imaginations/表现Expressions）就是无数多样的宇宙和万物及各自的规则和不规则。</li>
<li>从元吾氏的描述看, 此”终极真相”对应的就是道/涅槃/神/上帝/真主. 它不符合逻辑(把人类目前最美的语言, 数学直接给否了).</li>
<li><em>笔者注: 其描述和佛教的<code>非空非有, 非非空非有</code>, 道家的<code>道可道,非恒道</code> 是一致的. 这是语言的相对性和局限性产生的描述方法. 由于终极真相的绝对性, 语言描述只能是先基于一个概念(锚)进行描述, 再否定这个概念(锚)的存在, 所以其表现的结果就是逻辑上的难以理解和自相矛盾.</em></li>
<li><em>笔者注: 此条唯有亲证. 由于说的是终极真相, 和笔者一切相对的想法背离, 所以暂时存疑.</em></li>
</ul>
</li>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-10/37.html">道、求道、万法归一、现实性、透明性</a><ul>
<li>证道：自己亲身实证实见之道</li>
<li>悟道：自己悟出的道，还没有经过自己的实证。</li>
<li>闻道：听别人说的道，既不是自己悟出的，也没有经过自己的实证。</li>
<li>大道，最不怕传授给恶人。引恶人走上正道，世间之万幸。 传道者，坦坦荡荡，无人不传</li>
<li>法术，最害怕传授给恶人。教恶人滥用法术，世间之不幸。 传术者，神神秘秘，择人而传</li>
<li>实证为上。 (目前自己略有悟道, 需要实修完成证道.)</li>
</ul>
</li>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-11/45.html">我的修道经验—-我最常用的几种方法（正文）</a><ul>
<li>静观法. 打坐冥想, 动中禅. 日常修炼使用. 第一步入静, 第二步神游.</li>
<li>梦观法. 睡眠中的修炼使用. 直接进入神游状态.</li>
<li>心死神活法. 解决失眠问题.</li>
<li>技术共通点： 观-&gt;自然跟踪-&gt;得意忘形-&gt;无处不丹田.</li>
<li>静观内观法和观梦法高度互补, 日常实修使用. 心死神活法, 如果失眠, 用此法解决一下.</li>
<li><em>笔者的观点: 初学者以一念代万念来静心, 一定程度后只观念的来去进行静心, 不要强制去一念不生</em></li>
</ul>
</li>
<li><em>笔者的后续人生计划</em><ul>
<li>精进实修, 亲证”终极真相” (打引号是因为亲证前保持对”终极”的存疑, 目前一切皆相对是我的”锚”)</li>
<li>此生, 在生活中修炼, 平和的过正常人生活.</li>
<li>若有幸亲证, 后续可能的选择是尝试用人类最优美, 最无歧义的数学来告知众人, 道/涅槃/神/上帝/真主的”存在”, 以此为”开释”/“渡”.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="实修方法"><a href="#实修方法" class="headerlink" title="实修方法"></a>实修方法</h1><p>具体参考元吾氏的博文</p>
<ul>
<li><a href="http://blog.sina.cn/dpool/blog/s/blog_68ee10ad01014uij.html?type=-1">我最常用的几种修道方法（前言）</a></li>
<li><a href="http://blog.sina.cn/dpool/blog/s/blog_68ee10ad0100rmbf.html?type=-1">我最常用的几种修道方法（正文）</a></li>
</ul>
<p>下面针对笔者自身情况暂时选出的实修方法, 有删改.</p>
<h2 id="静观法"><a href="#静观法" class="headerlink" title="静观法"></a>静观法</h2><ol>
<li>闭目养神。</li>
<li><strong>表意识不思不想。</strong></li>
<li><strong>完全自然跟随潜意识。</strong></li>
<li><strong>静静地观察。</strong></li>
<li>不参与任何表意识杂念。</li>
<li>只是静静旁观潜意识。</li>
<li><strong>一切顺其自然</strong>。</li>
<li>真神自然显现。</li>
<li>或游走多维世界。</li>
<li>或化解人生疑难。</li>
<li>或回归万物本源。</li>
<li>一切顺其自然。</li>
<li><strong>至极至反至顺</strong>（暂时找不到更简单的描述）。</li>
</ol>
<p>注解：”至极至反至顺”</p>
<ol>
<li>即”舍己从人跟踪法”: 完全舍去自己，跟踪自然的动静和变化，与之合为一体，完全体验至极限。</li>
<li>如：有一个痛苦出现，则自然跟踪之，并完全与这个痛苦合一，体验痛苦”至极”。物极必反：至极之后会自动走向”至反”。反极必顺：至反之后自动回归”至顺”。痛苦会自动慢慢治好。 (<em>笔者注: 譬如观察一个病痛, 不做多想, 或不予理睬, 或简单回应”知道了”, 然后继续观察</em>)<br>3、一切自动化，只需耐心、舍己跟踪，直至最终。<br>4、故曰：至极至反至顺。亦曰：“舍己从人死心跟踪”。（舍己：要放弃一切恐惧，死心塌地、顺从自然。）<br>5、再重复要点：完全舍弃自己的主观，跟踪所观，死心塌地与所观合一，完全顺其自然。</li>
</ol>
<p>此法实用性极高：<br>a)用来治病，效果极好。（治病时：亦称”死心塌地跟踪法”, 静观病灶，死跟到底。病会自动慢慢治好。）<br>b)用来解决人生的问题，也是效果极好。（进入潜意识，静观人生问题，时间长了自然会”发酵”出解决办法。）<br>c)用来练精气神，亦称”舍己从神跟踪法”, 静观神意（或炁），死心跟踪，会自然水到渠成。<br>静观法的核心要点：①观；②何处不丹田。</p>
<p><em>笔者注:</em><br><em>如果初学者觉得做不到表意识的不思不想, 客观观察(就是总是被冒出来的想法牵着走), 那么先用一念代替万念的修炼方法静心. 譬如只念一句”阿弥陀佛”, 或者从观察呼吸等规律性的, 便于集中注意力的事物开始, 如*<em>数息观</em></em>, <strong>出入息观</strong>.*</p>
<p><em>对于观何处, 核心要点已经说得非常直观了: 何处不丹田! 观察适合自己的地方就行了.有感觉的地方就可以观, 可以想CT一样扫遍全身的观, 可以针对不适的地方观, 观念起念落, 观呼吸, 观声音变化, 观眼中光亮, 观动作, 等等等等, 无一不可! 关键是要让自己静下心来观!</em></p>
<p><em>此法用于日常的打坐冥想和动中禅实修.</em><br><em><strong>打坐冥想需每日固定时间练习, 每天早晚各一次, 每次30分至一小时, 即每天一小时至二小时.</strong></em><br><em><strong>动中禅随时可修. 动中禅较难, 毕竟无法闭目养神, 属于闹中取静, 但核心是一样的, 就是不思不想, 无为无我而观.</strong></em><br><em><strong>不断精进学习打坐冥想和动中禅的技术细节, 以提高实修效率</strong></em></p>
<h2 id="梦观法"><a href="#梦观法" class="headerlink" title="梦观法"></a>梦观法</h2><p>源自《梦观成就法》（请参考另篇博文：“藏密无上瑜伽—-《梦观成就法》”）。<br>有四个步骤：知梦、观梦、破梦、用梦。</p>
<ol>
<li><strong>清醒时：意识播种：’我在做梦’。</strong> （形成梦中知梦的潜意识惯性）</li>
<li><strong>入梦前：意识播种：’梦中知梦，醒来都记得’。</strong> （知梦）</li>
<li><strong>出梦后：立刻忠实笔录梦境，前后验证。</strong> （经验的记录、分析、比较、验证等作用）</li>
<li><strong>入梦后：’观察’梦境。</strong> （观梦：观=心法的核心）</li>
<li>时久，可观见梦境有两种。</li>
<li>第一种：’梦体’主观潜意识所创造的主观梦界。（’我’的梦界, 个体幻相界）</li>
<li>第二种：’梦体’离开肉体见到的客观梦界。（’我们’的梦界, 集体幻相界）</li>
<li>因此：’静化’主观潜意识，停止’创造’主观梦界。（破梦关键之一。否则依然是两种混合梦境、永远无法破梦）</li>
<li>逐渐：只剩下旁观潜意识和客观梦界，旁观其自然运作。（破梦关键之二。旁观梦境，顺其自然）</li>
<li>逐渐会发现：梦界一直在’创造’物质现象界。（初步发现物质现象界的源泉）</li>
<li>物质现象界原来也是一种梦界。</li>
<li>再逐渐会发现：梦界被更深的梦界’创造’。（发现梦界的多重源泉、梦界的梦中套梦）</li>
<li>亦可逐渐发现’多重梦体’：梦体被更深的梦体“创造”。（发现梦体的多重结构、梦体的梦中套梦）</li>
<li>一界又一界，一体又一体，更深循环，乃至极深。</li>
<li>一步步追本溯源，一直到’梦界的终极本源’。</li>
<li>由此：发现万物万界皆为梦幻，得以终极“苏醒”。（破梦的终极）</li>
<li>由此：从终极本源最深处，练习变梦及其实用。（用梦, 破梦前的变梦：可变第一种梦界，难变第二种梦界；破梦后的变梦：两者皆可）</li>
<li>实用一：在梦界中逐层化解梦体和梦界问题。（梦界影响梦界）</li>
<li>实用二：在梦界中化解肉体和物质现象界问题。（梦界影响物质现象界、连接两界）</li>
<li>随用随验，逐步提高用梦技术。</li>
<li>由此可逐步实现’梦想’。</li>
</ol>
<p>早期完全照搬古印度’那洛巴六成就法’之一的《梦观成就法》，后期融合西方清醒梦法和中国丹道睡功法，再加上本人四十年梦观经验。<br>此法与近代荷兰的“清醒梦法”如出一辙（可参考西方流传的各种清醒梦资料）。<br>中国丹道亦有类似方法，称为“睡功”（可参考陈希夷、吕纯阳、张三丰、白玉瞻等）。<br>我把《梦观成就法》的第二步“变梦”移到第四步，因为从经验上，破梦之后再变梦，效果更深更广更佳。（这是针对修梦者，玩梦者除外。）</p>
<p><em>笔者注:</em><br><em><strong>梦观法和静观法时间上高度互补, 所以计划同时修炼.</strong></em><br><em>感觉上, 静观法可定慧同修, 梦观法主要是修慧. 因而不能只用梦观法而不学静观法.</em><br><em>关于定慧的关系, 定理解为心静的程度(无我无念的程度), 心越静, 越容易得慧破幻.</em></p>
<h2 id="心死神活法"><a href="#心死神活法" class="headerlink" title="心死神活法"></a>心死神活法</h2><ol>
<li>闭目养神。</li>
<li>告诉自己已经死了。</li>
<li>已经听不到感觉不到这个世界的任何了。</li>
<li>自己已经不在这个世界了。</li>
<li>只剩下一个意识点了。</li>
<li>这个意识点已经没有可依附的肉体了。</li>
<li>这个意识点只好游离在宇宙中了。</li>
<li>不即不离反复重复以上意识。</li>
<li>一直自然跟随这个意识点。</li>
<li>不知不觉中自然出神。</li>
</ol>
<p>此方法的出发点：基于中国丹道的”心死神活”。其后融合了西方现代科学对濒死体验的研究成果。<br>其本质是：肉体意识停止，灵体意识得到自由。亦可称：心死神活法。<br>此法特点：入静较快，还可以用来解决失眠。<br>早期（79年-89年左右）总结的方法。</p>
<p>此法熟练后, 可使用Shift法/次元切换法</p>
<ol>
<li>闭目养神。</li>
<li>完全彻底忘掉肉体。</li>
<li>只剩下一个意识点。</li>
<li>决定这次具体目的。</li>
<li>告诉自己能不受次元限制。</li>
<li>能够直接切换次元</li>
<li>确信会直接到达目的地。</li>
<li>意念放松越深越好。</li>
<li>确信会自然到达目的地。</li>
<li>反复重复以上目的地。</li>
<li>一直自然跟随这个意识。</li>
<li>半知半觉中自然可达目的地。</li>
</ol>
<p>此方法的出发点：基于中国庄子的”忘我”。<br>其本质是：意识直接切换到多维世界，不再受肉体限制。亦可称：次元切换法。<br>此法特点：即可出神，亦可不出神只切换次元。换言之：既可出可入，也可不出不入。<br>中期（89年-99年左右）总结的方法。</p>
<p><em>笔者注:</em><br><em>两者本质一样, 只是前者没有目的性, 后者有目的性. 前者是基础, 后者难度更高.</em><br><em>很明显, 这种方法需要有相当的定力(需要先用静观法做到完全彻底忘掉肉体).</em><br><em>可以尝试用”心死神活法”解决偶尔的失眠问题, 否则暂不学习.</em></p>
<h2 id="经验中的最经验"><a href="#经验中的最经验" class="headerlink" title="经验中的最经验"></a>经验中的最经验</h2><ol>
<li>没有最好的方法，只有最适合你的方法。一人一法，万人万法，万法归一。</li>
<li>仅有方法不够，还需要耐心+悟性+目的（没有目的则原地打转）。</li>
<li>越复杂的方法效率越低，越简单的方法效率越高！！！</li>
<li>本人三十年来使用上百种方法之后，复杂的方法逐渐被淘汰，现在剩下来还继续使用的这些最有效的方法，都非常简单。常有人不信，觉得太简单，非说我没全盘端出，还有秘密藏着掖着。今天再次强调：我没有任何保留。大道的的确确至简，信不信由你，是真是假走到头便知！中途先别着急判断。</li>
</ol>
<p><em>笔者注:</em><br><em>笔者已对佛/道/灵修不疑不惑了, 此文就是明确目的, 培养信心, 持之以恒去实修实证的决心书. 后续实修过程遇到困难打退堂鼓时, 及时看看此文自我肯定, 补充信心即可.</em><br><strong>实修不设时间计划, 不求速成, 不影响工作生活, 唯时时日日修炼, 沿途欣赏风景, 自然精进.</strong>, 综合考虑后, 会以佛教的修行方法为主, 而非此文中的出体方法.</p>
<h1 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a><a href="http://jilu.yuanwushi.com/yuedu/2014-11-11/71.html">推荐书籍</a></h1><h2 id="大道经典"><a href="#大道经典" class="headerlink" title="大道经典"></a>大道经典</h2><ol>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-11/69.html">《天符經》</a></li>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-11/68.html">《道徳經》</a></li>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-11/51.html">《心經》</a></li>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-11/70.html">《金剛經》</a></li>
</ol>
<h2 id="修炼方法"><a href="#修炼方法" class="headerlink" title="修炼方法"></a>修炼方法</h2><ol>
<li>印度《合一经》（旧译《瑜伽经》）</li>
<li>印度和藏密的“中脉脉轮法”</li>
<li>印度《四禅八定法》</li>
<li>《通玄真經》</li>
<li>《老君西升經》</li>
<li>《太上老君內觀經》</li>
<li>《太上老君說了心經》</li>
<li>《张三丰內丹36訣 》</li>
<li>藏密《梦观成就法》 (梦中禅修)</li>
<li>藏密《神识出游法》</li>
<li>藏密《身外化身法》</li>
<li>美国“门罗出神法”（神游法）</li>
<li>荷兰“清醒梦法”（梦修法）</li>
<li>你自己喜欢的、适合你的有效方法（最好的方法=最适合你的方法）</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>《云笈七籖》</li>
<li>《性命圭旨 》</li>
<li>《伍柳仙宗 》</li>
<li>《唱道真言 》</li>
<li>《大成捷要 》（—-很多修道者的经验汇编）</li>
<li>丹经万卷，不如守一。</li>
</ol>
<h2 id="笔者的补充"><a href="#笔者的补充" class="headerlink" title="笔者的补充"></a><em>笔者的补充</em></h2><ul>
<li><a href="http://wyw.hwxnet.com/">文言文字典</a></li>
<li><a href="http://www.fodian.net/fodict/index.htm">佛学电子辞典</a></li>
</ul>
<ul>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-11/68.html">道德经</a></li>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-11/51.html">心經</a></li>
<li><a href="https://wenku.baidu.com/view/72640dea172ded630b1cb6a0.html">定慧之路(致光法师)</a></li>
<li><a href="http://blog.sina.cn/dpool/blog/s/blog_993e460b0101a70f.html?vt=4">个人推荐的一些禅修书籍下载（含阅读指导）</a><ul>
<li><a href="http://agama.buddhason.org/index.htm">南传经藏/阿含经</a></li>
<li>马哈希体系（禅修方法主要是观察六根门出现的对象 也就是法念处 或者说是四念处的综合）</li>
<li>雪乌敏体系（主要是心念处）</li>
<li>孙伦体系（主要是身念处 受念处 其中的受偏身受 关于心受可以参考马哈希以及雪乌敏体系）</li>
<li>隆波帕默</li>
</ul>
</li>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-11/70.html">金剛經</a></li>
</ul>
<ul>
<li>《当下的力量》/《当下的力量2》</li>
<li>《物理学之”道”》（卡普拉）<ul>
<li>此书是此文完成后看的, 算是对自己想法的一种补充和肯定.</li>
<li>唯物主义者和唯科学论者建议观看. 科学的最伟大之处不在于理论预测的准确性, 而在于能基于客观实验这个锚, 不断突破自我的相(科学理论的局限性).</li>
<li>书中称科学实验为实验, 冥想打坐类的体验为经验. 也略微描述了两者内在的相似之处.</li>
<li><strong>从信息论角度来说, 能重复的实验和能重复的体验是没有区别的! 都说明了被观察信息具有一定的稳定性, 便可以认为其”存在”.</strong></li>
</ul>
</li>
<li>《与神对话》（Neale Donald Walsh）<ul>
<li>此书是此文完成后看的, “与神对话1”的内容属于作者的自我开悟/觉醒, 对其内容表示理解和认同.</li>
<li>“与神对话”的2和3, 是作者自我开悟后尝试解决地球和世界问题的答案, 我基本无法认同, 因为不符合客观发展规律, 属于一厢情愿的建议.</li>
<li>此书体现了东西方思维方式的差异. 作者虽然认识到了一切相对, 但主观上依旧是人为至上, 爱和善最好. 道德经, 博弈论都明确无误的说明了: 物极必反, 至善则生恶!</li>
</ul>
</li>
</ul>
<ul>
<li><a href="http://blog.sina.com.cn/s/blog_486e105c010006n3.html">《论语》详解：给所有曲解孔子的人</a><ul>
<li>把《论语》也写上吧, 个人并不喜欢儒家, 因为它历来和权利走的太近, 是为权利服务的学说.</li>
<li>但孔子作为源头, 是无需背负这些骂名的, 看看”缠中说禅”的《论语》, 或许能看到孔子的原意.</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>本人的观点仅供参考 读者应当保持足够的理性与怀疑态度<br>不要盲信任何观点包括本人的观点<br>本人观点是否正确, 需要每一位修行者严谨的通过理论学习以及禅修实践来判断</p>
</blockquote>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>波浪理论简述</title>
    <url>/2019/04/26/1903-wave-principle/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2019/03/26/1902-trading-rule/">交易市场思考</a></li>
<li><a href="https://draapho.github.io/2019/04/26/1903-wave-principle/">波浪理论简述</a></li>
<li><a href="https://draapho.github.io/2019/06/25/1907-investor/">你将不会成为一个伟大的投资人</a></li>
<li><a href="https://draapho.github.io/2020/02/09/2001-exploration/">交易市场阶段性探索心得</a></li>
<li><a href="https://draapho.github.io/2020/08/06/2005-wave-mnemonic/">波浪理论口诀</a></li>
<li><a href="https://draapho.github.io/2020/08/07/2006-wave-thinking/">波浪理论感悟</a></li>
<li><a href="https://draapho.github.io/2021/02/03/2102-share-skill/">交易市场思路</a></li>
</ul>
<h1 id="波浪理论特性"><a href="#波浪理论特性" class="headerlink" title="波浪理论特性"></a>波浪理论特性</h1><ul>
<li>价格和速度构成的形态为主, 结合价格比例关系, 时间为辅的技术分析理论.</li>
<li>将数理引入了股市技术分析, 即斐波那契数列和黄金比率φ.</li>
<li><strong>对波浪形态进行了全分类, 并将不同波浪的特性进行了定性描述.</strong></li>
<li><strong>缺点1: 浓重的主观预测思维, 容易去做抄底逃顶操作, 而非随势而动</strong></li>
<li><strong>缺点2: 延长浪概念以及时间跨度的随意性, 导致级别混乱, 千人千浪.</strong></li>
<li>因为千人千浪, 此理论才可能延续至今.</li>
</ul>
<h1 id="波浪个性"><a href="#波浪个性" class="headerlink" title="波浪个性"></a>波浪个性</h1><ul>
<li>波浪个性的作用<ul>
<li>波浪个性可以预先告诉分析人员下一个波浪类型.</li>
<li>波浪个性有时可以帮助判定市场目前所处的位置.</li>
<li>大级别K线图中, 如果有几种可行的数浪结果。那么波浪个性可以辅助判定优选数浪方式.</li>
</ul>
</li>
<li><strong>第一浪</strong><ul>
<li>一半的第一浪是打底的过程, 常常被浪2大幅调整<ul>
<li>与熊市反弹相比, 技术上结构特征更明显 (子波五浪特征, 引导倾斜三角形)</li>
<li>成交量和广泛性轻度增加.</li>
</ul>
</li>
<li>另一半的第一浪会从先前调整浪形成的底部直接涨起来.<ul>
<li>这样的一浪一定是推动浪结构, 随后的二浪回撤也很小</li>
</ul>
</li>
<li>大多数人确信大趋势向下, 认为多了一次做空的反弹. 因此大量的卖空显而易见.</li>
<li>常常伴随着突破缺口</li>
</ul>
</li>
<li><strong>第二浪</strong><ul>
<li>第二浪常常回撤掉第一浪的大部分.</li>
<li>第二浪往往以成交量萎缩, 价格波幅减小结束, 表明卖压已经消失.</li>
</ul>
</li>
<li><strong>第三浪</strong><ul>
<li>第三浪令人惊心动魄, 走势强劲, 最强的广泛性. 必定是结构清晰的子波五浪推动.</li>
<li>突破, 持续跳空, 成交量放大, 异常的广泛性, 趋势性的价格运动.</li>
<li>常常是序列中最长的浪, 伴随着最强势的中继缺口.</li>
<li>道氏理论趋势的相互印证</li>
<li>第三浪以及B浪是最有价值的数浪线索</li>
</ul>
</li>
<li><strong>第四浪</strong><ul>
<li>第四浪的深度和形态是可预测的</li>
<li>其形态一般与二浪不同, 多呈现横向走势(即二浪四浪交替原则)</li>
<li>如果三浪5子波延长, 那么四浪陡直回撤可能性就大增(见5浪延长部分)</li>
<li>表现不佳的股票在第四浪做头并开始下跌</li>
</ul>
</li>
<li><strong>第五浪</strong><ul>
<li>广泛性降低, 成交量减少.</li>
<li>通常, 五浪的价格变化速度和幅度都比三浪要低, 多半伴随着衰竭缺口.</li>
<li>尽管广泛性逐渐变窄, 投资者的乐观情绪却异常高涨.</li>
<li>如果成交量和速度没有减弱, 可以考虑第五浪延长.</li>
<li>股票市场, 从未再顶部达到最高加速度! 即便是五浪延长, 五浪5也必然存在速度衰竭现象.<br><img src="https://draapho.github.io/images/1903/2-14.png" alt="图2-14"></li>
</ul>
</li>
<li><strong>A浪</strong><ul>
<li>A浪的结构为整个调整浪下了调子</li>
<li>五浪结构的A浪意味着锯齿型调整, B浪反弹不会太强势.</li>
<li>三浪结构的A浪意味着平台型或三角型调整, B浪反弹可能创新高.</li>
<li>大多数人认为这只是一次正常调整, 蜂拥买入</li>
</ul>
</li>
<li><strong>B浪</strong><ul>
<li>B浪是赝品, 假牛市. 情绪化的涨势</li>
<li>技术上也极少是强势，而且注定要被浪C完全回撤。</li>
<li>严重的分化, 走势曲折, 广泛性差, 只集中于少数股票, 指数之间无法相互印证</li>
<li>小级别的B浪, 成交量通常逐渐萎缩.</li>
<li><strong>超大级别的B浪, 特别是B浪c, 成交量会放大, 股票参与的广泛性也会增加, 会更像是牛市</strong></li>
<li>X浪的性质和B浪相同.</li>
</ul>
</li>
<li><strong>C浪</strong><ul>
<li>摧毁性极强, 具有第三浪的大部分属性. 恐惧控制了一切.</li>
<li>C浪持续时间长, 且广泛性强</li>
<li><strong>大熊市中, 调整浪中的上升C浪强劲有力, 很容易被误认为新的涨势开始. 需要注意识别区分.</strong></li>
</ul>
</li>
<li><strong>D浪</strong><ul>
<li>往往伴随着成交量的放大, 性质和B浪类似, 是假牛市.</li>
<li>参与上涨的股票范围很窄, 部分股票却大出风头, 市盈率高的离谱. 腾落指标早早做头.</li>
</ul>
</li>
<li><strong>E浪</strong><ul>
<li>E浪的参与心理同第五浪一样情绪化. 容易受到”消息面”的影响.</li>
<li>这些消息连同<strong>E浪将要对三角型调整浪的边界线形成最后的假突破.</strong></li>
<li>最后, 在大部分人的一致看空中迎来趋势的大反转.<br><img src="https://draapho.github.io/images/1903/2-15.png" alt="图2-15"></li>
</ul>
</li>
</ul>
<h1 id="波浪分类"><a href="#波浪分类" class="headerlink" title="波浪分类"></a>波浪分类</h1><p><img src="https://draapho.github.io/images/1903/3-14.png" alt="图3-14"></p>
<ul>
<li>驱动浪(motive):<ul>
<li><strong>推动浪</strong>(impulse): 多数驱动浪以推动浪的形态出现.<ul>
<li>小级别形态为五浪推动, 使用数字12345标注.</li>
<li><strong>浪4最低点高于浪1最高点, 两者无重叠价位.</strong> (少数市场例外, 如期货市场)</li>
<li><strong>浪3不是最短的子浪</strong>, 即要么浪1最短, 要么浪5最短.</li>
<li><strong>浪1,3,5三者之一通常会产生延长浪.</strong>, 能事前判断的也就浪三延长.</li>
<li><strong>浪2和浪4的简单/复杂形态几乎总是交替的.</strong> 一个调整浪属于锯齿型(简单), 另一个则为平台/三级/复合型(复杂)</li>
<li>推动浪通常可用平行线划出通道. <strong>5浪经常对通道翻越/假突破后结束.</strong></li>
</ul>
</li>
<li>延长浪:<ul>
<li><strong>延长浪通常只作用于1,3,5中的一个</strong>, 为将来的各个波浪长度提供了一定的预测指南.</li>
<li><strong>若1浪和3浪长度大致相等, 则5浪就可能成为一个延长的巨浪</strong></li>
<li><strong>股市中, 最为常见的就是3浪延长, 此时5浪必然简单, 且与1浪类似.</strong></li>
<li>另有一种几乎<strong>等长等速的九浪模式</strong>, 很难区分哪浪延长了.</li>
</ul>
</li>
<li><strong>倾斜三角型</strong>(diagonal triangle): 少见的变体, 也属于驱动浪.<ul>
<li>引导倾斜三角型, 5-3-5-3-5浪形, 主要出现在浪1和锯齿型调整浪的浪A.</li>
<li>终结倾斜三角型, 3-3-3-3-3浪形, 主要出现在浪5, 偶见于浪C.</li>
</ul>
</li>
</ul>
</li>
<li><strong>调整浪</strong>(corrective): 三浪调整或其变体.<ul>
<li><strong>与大级别趋势反向的最初5浪永远不是调整浪的结束, 而仅仅是调整浪的一部分.</strong></li>
<li><strong>锯齿型</strong>(zigzag), 5-3-5浪形, 最为简单的调整浪, 使用ABC标注.<ul>
<li>单锯齿型, 双锯齿型, 三锯齿型</li>
</ul>
</li>
<li><strong>平台型</strong>(flat), 3-3-5浪形, 使用ABC标注.<ul>
<li>普通平台型, 扩散平台型, 顺势平台型</li>
</ul>
</li>
<li><strong>三角型</strong>(triangle), 3-3-3-3-3浪形, 使用ABCDE标示<ul>
<li>三种收缩类型: 上升三角型, 下降三角型, 对称三角型.</li>
<li>一种扩散类型: 反对称三角型.</li>
</ul>
</li>
<li><strong>复合型</strong>(combination) 引入WXYXZ标示<ul>
<li>双重三浪, 三重三浪.</li>
</ul>
</li>
<li><strong>调整浪通常在同级别驱动浪的浪4范围内结束</strong></li>
<li><strong>调整浪的陡直/横向, 简单/复杂形态几乎总是交替出现</strong>, 即大级别中2浪调整和4浪调整通常是陡/横, 简/繁交替的.</li>
</ul>
</li>
<li>作用浪(action): 或顺势浪, 与大一级别波浪同向运动的波浪. 135ac属于作用浪<ul>
<li>多数作用浪由小一级别的驱动浪构成, 即五浪.</li>
<li>少数作用浪由小一级别的调整浪构成, 即三浪或其变体.</li>
</ul>
</li>
<li>反作用浪(reaction): 或逆势浪, 与大一级别波浪反向运动的波浪. 24b属于反作用浪</li>
</ul>
<h2 id="驱动浪特性"><a href="#驱动浪特性" class="headerlink" title="驱动浪特性"></a>驱动浪特性</h2><ul>
<li>重要规则如下:<ul>
<li><strong>浪4不进入浪1领域</strong></li>
<li><strong>1,3,5浪中, 浪3永远不是最短的一浪.</strong></li>
<li><strong>1,3,5浪中的某一浪通常会延长, 另两浪在时间和幅度上趋向等同(其次是0.618倍关系)</strong></li>
</ul>
</li>
<li>交替原则<ul>
<li><strong>调整浪的简/繁, 陡/平交替.</strong></li>
<li>倾斜三角型中的子浪2和4不会有交替性, 常见两者都是锯齿型调整浪.</li>
<li><strong>若推动浪的3浪延长, 则5浪时简单浪形, 和1浪相似.</strong></li>
<li><strong>若推动浪的1,3浪相似, 则5浪可能延长.</strong></li>
</ul>
</li>
<li>成交量<ul>
<li><strong>成交量的最低点常常与转折点同时发生</strong></li>
<li><strong>上升过程中, 调整阶段后期成交量的萎缩通常表示卖压下降.</strong></li>
<li>上升过程中, 第五浪的成交量与第三浪持平或放大, 且第一浪和第三浪长度基本相等, 那么可以预期五浪延长.</li>
</ul>
</li>
<li>延长浪<ul>
<li>浪3不是最短, 浪4不进入浪1领域 (图1-5, 图1-6)</li>
<li>正确的数浪: 若1,2浪确定后, 走出的3浪过短或与2浪重叠, 那么多半意味着延长的3浪正在形成.</li>
<li>去除延长浪后, 另两浪在时间和幅度上趋向等同(其次是0.618倍关系)<br><img src="https://draapho.github.io/images/1903/1-5.png" alt="图1-5"><br><img src="https://draapho.github.io/images/1903/1-8.png" alt="图1-8"></li>
</ul>
</li>
<li>趋势的结束:<ul>
<li><strong>5浪结束通常要包含小级别的推动子浪或终结倾斜三角型来确定.</strong></li>
<li>5浪翻越<ul>
<li>若成交量不足, 多半5浪无法翻越123浪构成的平行通道</li>
<li>若成交量放大, 5浪容易突破平行通道</li>
<li>若浪4或浪5中的第二浪跌破通道, 往往预示着浪5会翻越平行通道 (图2-10)<br><img src="https://draapho.github.io/images/1903/2-10.png" alt="图2-10"></li>
</ul>
</li>
<li>5浪失败/衰竭: 第5浪未能超过3浪最高点的情况. (图1-11)<br><img src="https://draapho.github.io/images/1903/1-11.png" alt="图1-11"></li>
<li>终结倾斜三角型 (图1-15)<ul>
<li>终结倾斜三角型, 3-3-3-3-3浪形, 主要出现在浪5, 偶见于浪C.</li>
<li><strong>形态为收敛的楔型, 其子浪5经常对趋势线有假突破(翻越)</strong><br><img src="https://draapho.github.io/images/1903/1-15.png" alt="图1-15"></li>
</ul>
</li>
</ul>
</li>
<li>5浪延长<ul>
<li><strong>5浪延长的判定</strong><ul>
<li>在三浪进入全新的价格领域后, 更容易出现五浪延长的情况</li>
<li>如果一三浪等长, 可以预测第五浪延长很可能发生.</li>
<li>如果四浪呈现平台型, 而一三浪没有延长, 第五浪延长高概率发生.</li>
<li>如果第五浪的成交量与第三浪持平或放大, 那么第五浪延长就有效.</li>
<li>少数情况, 三浪五浪同时延长, 那么成交量是判断延长是否有效的关键.</li>
</ul>
</li>
<li>5浪延长后的市场行为<ul>
<li><strong>如果第五浪是延长浪, 那么继而发生的调整将非常剧烈, 并会在五浪2的最低点附近找到支撑.</strong><ul>
<li>有时整个调整浪(ABC)会在五浪2处结束. 这种调整浪大多是5-3-5锯齿型.</li>
<li>有时浪A就会直接打到五浪2处, 随后浪B强势反弹, 即双重回撤.</li>
</ul>
</li>
<li><strong>5浪延长的双重回撤</strong> (图2-7)<ul>
<li><strong>若第五浪延长, 调整浪A或ABC会极大概率地会回撤到延长五浪的子浪2底部.</strong></li>
<li><strong>通常是浪A三波直接陡直下跌地下跌到位, 随后的调整浪B大概率还会反弹到五浪顶部区域甚至新高.</strong></li>
<li>但也可能需要锯齿型五浪甚至双锯齿型ABC才能下跌到位. 那样B浪只能是一个弱反弹.</li>
<li><strong>无论如何, 浪C必将形成迅速的5浪下杀, 很可能跌至先前牛市中的第5浪起点, 即第4浪区域.</strong></li>
<li>整个ABC调整浪大多是扩散的3-3-5平台型.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>回撤深度<ul>
<li>一般情况, 调整浪通常在同级别驱动浪的浪4范围内结束</li>
<li><strong>若第一浪延长, 调整浪abc通常回撤到同级别驱动浪的浪2底部 (图2-6)</strong></li>
<li><strong>若第五浪延长, 调整浪a通常陡直的回撤到延长五浪的浪2底部 (图2-7)</strong></li>
<li><strong>平台型或三角型调整浪, 特别是跟在延长浪后面的, 通常只以微小的幅度跌入三浪4或一浪4的领域.</strong></li>
<li><strong>当第二浪是之字型调整时, 有时会跌入到一浪2的区域. 双重底有时就是这样形成的.</strong><br><img src="https://draapho.github.io/images/1903/2-6.png" alt="图2-6"></li>
<li>陡直调整浪经常回撤掉先前波浪的0.5或0.618 (图4-1)<ul>
<li>多发生在浪二对浪一的回撤, 锯齿型浪B的回撤.</li>
</ul>
</li>
<li>横向调整浪经常回撤掉先前波浪的0.382 (图4-2)<br><img src="https://draapho.github.io/images/1903/4-1.png" alt="图4-1"></li>
</ul>
</li>
<li>驱动浪倍数关系<ul>
<li>一浪:三浪 = 1:1.618 或 1:2.618</li>
<li>浪四常常把整个趋势黄金分割, 这个点可以是浪四的起点, 终点或极限逆势点. (图4-6, 图4-7)<br><img src="https://draapho.github.io/images/1903/4-6.png" alt="图4-6"></li>
<li>三浪延长时, 一浪:五浪 = 1:1 或 1:0.618 (图4-3)</li>
<li>五浪延长时, 一+三浪:五浪 = 1:1.618 (图4-4)</li>
<li>一浪延长时, 一浪:三+五浪 = 1:0.618 (图4-5)<br><img src="https://draapho.github.io/images/1903/4-3.png" alt="图4-3"></li>
</ul>
</li>
</ul>
<h2 id="调整浪特性"><a href="#调整浪特性" class="headerlink" title="调整浪特性"></a>调整浪特性</h2><ul>
<li>重要规则如下:<ul>
<li>调整浪不会是五浪, 只有驱动浪才会构成五浪. 因此与趋势反向运动的最初五浪不是调整浪的结束, 而仅是调整浪的一部分.</li>
<li>各种调整过程呈现两种风格: 陡直(sharp)调整 和 横向(sideways)调整, 多交替出现.</li>
</ul>
</li>
<li>锯齿型(5-3-5)<ul>
<li>单锯齿型调整浪是一种简单的三浪模式,<ul>
<li>标示为A-B-C, 内部子浪为5-3-5 (图1-23)<br><img src="https://draapho.github.io/images/1903/1-23.png" alt="图1-23"></li>
</ul>
</li>
<li>双重/三重锯齿型调整浪: 由2-3个单锯齿型调整浪, 通过一个三浪结构连接的调整浪, 属于复合型.<ul>
<li>双重标示为 W-X-Y, 内部子浪为(5-3-5)-3-(5-3-5), 呈现为4波下跌. 三重标示为 W-X-Y-X-Z. (图1-26)<br><img src="https://draapho.github.io/images/1903/1-26.png" alt="图1-26"></li>
</ul>
</li>
<li>当第一个锯齿型调整浪没有达到正常目标时, 容易发生两次, 至多三次的锯齿型调整浪. <strong>用以补足幅度</strong></li>
</ul>
</li>
<li>平台型(3-3-5)<ul>
<li>标示为A-B-C, 内部子浪为3-3-5</li>
<li>平台型往往出现在趋势强劲有力的时候, 多出现在第四浪. 内在趋势越强, 平台型调整浪就越短暂.</li>
<li><strong>平台型的前面或后面大概率出现延长浪</strong><ul>
<li>三浪延长, 则四浪大概率走平台型调整浪.</li>
<li>如果一三浪没有延长, 四浪走出了平台型调整浪, 则五浪大概率延长.</li>
<li>五浪延长后, 通常走平台型调整浪, 并产生双回撤现象.</li>
</ul>
</li>
<li>规则平台型 (图1-30)<ul>
<li>作用浪A, 由于缺乏足够的破坏力, 只走出了3浪.</li>
<li>作用浪B, 同样缺乏足够的修复力, 3浪之后在浪A起点附近结束</li>
<li>作用浪C, 通常只在略微超过浪A终点的位置结束.<br><img src="https://draapho.github.io/images/1903/1-30.png" alt="图1-30"></li>
</ul>
</li>
<li>扩散平台型: B浪超过A浪起点, C浪超过远远超过A浪终点.</li>
<li>顺势平台型: B浪超过A浪起点, C浪不能走完全程, 不及A浪终点.<ul>
<li>形态上有点类似于推动浪的衰竭, 但本质是趋势推动力强劲!</li>
<li>如果B浪走成了5浪, 那就不是顺势平台型, 很可能是大级别的第一个上升浪!</li>
<li><strong>顺势平台型非常少见, 不建议提前标注这种类型!</strong> (顺势三角型较为常见)</li>
</ul>
</li>
<li>双重平台型, 属于复合型.</li>
</ul>
</li>
<li>三角型(3-3-3-3-3) (图1-42)<ul>
<li>标示为A-B-C-D-E, 内部子浪为3-3-3-3-3.</li>
<li>连接A,C终点, 以及B,D终点, 就会是一个三角型调整浪. <strong>浪E可能未达或超过A-C线.</strong><br><img src="https://draapho.github.io/images/1903/1-42.png" alt="图1-42"></li>
<li>对称三角型: 上下边共同收缩</li>
<li>下降三角型: 上边收缩快, 下边基本水平.</li>
<li>上升三角型: 上边基本水平, 下边收缩快.</li>
<li>顺势三角型: B浪超过A浪的起点, 即与主趋势方向一致. (形态上和终结倾斜三角型是类似的)</li>
<li>扩散三角型: 上下边共同扩散. 和扩散平台型的主要区别在浪C(5浪/3浪)</li>
<li><strong>三角型调整浪中, 大多数子浪是锯齿型调整浪, 但子浪中的一个浪会比其他子浪复杂</strong><ul>
<li><strong>复杂子浪(通常是C浪)会呈现出: 规则平台型, 扩散平台型或多重锯齿型的样子.</strong></li>
<li><strong>少数情况, E浪就是三角型调整, 从而构成一个九浪三角型. (图1-44)</strong><br><img src="https://draapho.github.io/images/1903/1-44.png" alt="图1-44"></li>
</ul>
</li>
<li>三角型调整浪总是出现在最后一个作用浪之前, 即原趋势的最后一次调整的位置.<ul>
<li><strong>即多出现在浪4浪B的位置, 意味着后面还会有一波推动浪:浪5或浪C</strong></li>
<li><strong>多重锯齿型, 联合型中的最后一个浪X, 通常呈现为三角型调整浪</strong></li>
<li>联合型调整浪中的最后一个作用模式出现.</li>
<li><strong>如果浪2看起来是三角型调整浪, 通常意味着这个浪2是一个复杂调整浪, 三角型只是其中的一部分!</strong></li>
</ul>
</li>
<li><strong>股市中, 浪4出现三角型调整, 那么浪5通常迅速敏捷, 大致运行浪4最宽部分的距离.</strong><ul>
<li>在强劲市场中, 也有可能走出延伸5浪. 如果幅度超出浪4最宽部分, 可以考虑延长的5浪. (多出现在商品中)</li>
<li>这种延长的5浪多半是推动浪, 但也可能走成终结倾斜三角型.</li>
</ul>
</li>
<li><strong>时间: 收缩三角型趋势线相交之处, 往往是市场转折之时.</strong></li>
</ul>
</li>
<li>复合型<ul>
<li>双重三浪, 标示为 W-X-Y</li>
<li>三重三浪, 标示为 W-X-Y-X-Z<ul>
<li>双重三浪较为普遍, 三重三浪是极限, 也较为少见.</li>
</ul>
</li>
<li><strong>内部子浪通常是平台型/锯齿型/三角型交替出现 (图1-47, 图1-48)</strong><ul>
<li>常见模式是平台型+锯齿型, 锯齿型+平台型.</li>
<li>平台型接上三角型是双重三浪的常见形式.</li>
<li><strong>X可以是任何调整模式, 以锯齿型调整浪居多, 三角型调整浪很少见.</strong></li>
<li><strong>内部最多只有一个三角型调整浪, 且只在最后一个子波之前出现.</strong></li>
</ul>
</li>
<li><strong>内部细节从简单平滑变为复杂曲折.</strong><ul>
<li>即第一个三浪往往容易辨别, 而最后一个三浪往往曲折复杂.</li>
<li>基本不会出现从复杂演变为简单的情况.</li>
</ul>
</li>
<li>双重或三重调整模式出现在价格到位后, 延长调整过程的持续时间.<br><img src="https://draapho.github.io/images/1903/1-47.png" alt="图1-47"><br><img src="https://draapho.github.io/images/1903/1-48.png" alt="图1-48"></li>
</ul>
</li>
<li>调整浪的倍数关系<ul>
<li>A浪和C浪通常时间和长度相等.</li>
<li>另一种常见的长度比例, A浪:C浪 = 1:1.618 或 1:0.618.</li>
<li>收敛三角型调整浪中至少有两个交替浪按0.618的比率减小波动幅度 (图4-12)<br><img src="https://draapho.github.io/images/1903/4-12.png" alt="图4-12"></li>
</ul>
</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>market</category>
      </categories>
      <tags>
        <tag>market</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas Dataframe 入门</title>
    <url>/2019/05/20/1905-python-pandas/</url>
    <content><![CDATA[<h1 id="1-创建DataFrame"><a href="#1-创建DataFrame" class="headerlink" title="1 创建DataFrame"></a>1 创建DataFrame</h1><p>对于一个用python做数据处理的人来说，pandas是必须要了解的。<br>对于一个数据处理工具来说，读写是最基本的，<br>下面是我最近整理的关于pandas一些基本本操作，主要包括以下内容：</p>
<ul>
<li>如何创建DataFrame</li>
<li>如何读取DataFrame的值，读一行/列、读多行/列</li>
<li>如何对DataFrame赋值</li>
<li>如何对DataFrame插入一（多）行/列</li>
<li>如何删除DataFrame的一（多）行/列</li>
</ul>
<p>开始前先引入两个库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>

<h2 id="1-1-利用字典创建"><a href="#1-1-利用字典创建" class="headerlink" title="1.1 利用字典创建"></a>1.1 利用字典创建</h2><p>利用字典创建DataFrame:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data=&#123;<span class="string">&quot;one&quot;</span>:np.random.randn(<span class="number">4</span>),<span class="string">&quot;two&quot;</span>:np.linspace(<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>),<span class="string">&quot;three&quot;</span>:[<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">999</span>,<span class="number">0.1</span>]&#125;</span><br><span class="line">df=pd.DataFrame(data,index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">        one  two     three</span><br><span class="line"><span class="number">1</span> -<span class="number">1.183802</span>  <span class="number">1.0</span>  zhangsan</span><br><span class="line"><span class="number">2</span>  <span class="number">1.426724</span>  <span class="number">2.0</span>        李四</span><br><span class="line"><span class="number">3</span> -<span class="number">1.530958</span>  <span class="number">3.0</span>       <span class="number">999</span></span><br><span class="line"><span class="number">4</span> -<span class="number">0.939147</span>  <span class="number">4.0</span>       <span class="number">0.1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果创建df时不指定索引，默认索引将是从0开时，步长为1的数组。</li>
<li>df的行、列可以是不同的数据类型，同行也可以有多种数据类型。</li>
<li>df创建完成好可以重新设置索引，通常用到3个函数：<code>set_index</code>、<code>reset_index</code>、<code>reindex</code></li>
</ul>
<h3 id="1-1-1-set-index"><a href="#1-1-1-set-index" class="headerlink" title="1.1.1 set_index"></a>1.1.1 <code>set_index</code></h3><p><code>set_index</code>用于将df中的一行或多行设置为索引. 用法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.set_index(<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">df.set_index([<span class="string">&#x27;one&#x27;</span>],drop=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 参数drop默认为True，意为将该列设置为索引后从数据中删除，如果设为False，将继续在数据中保留该行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.set_index(<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">           two     three</span><br><span class="line">one</span><br><span class="line">-<span class="number">1.183802</span>  <span class="number">1.0</span>  zhangsan</span><br><span class="line"> <span class="number">1.426724</span>  <span class="number">2.0</span>        李四</span><br><span class="line">-<span class="number">1.530958</span>  <span class="number">3.0</span>       <span class="number">999</span></span><br><span class="line">-<span class="number">0.939147</span>  <span class="number">4.0</span>       <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.set_index([<span class="string">&#x27;one&#x27;</span>],drop=<span class="literal">False</span>)</span><br><span class="line">                one  two     three</span><br><span class="line">one</span><br><span class="line">-<span class="number">1.183802</span> -<span class="number">1.183802</span>  <span class="number">1.0</span>  zhangsan</span><br><span class="line"> <span class="number">1.426724</span>  <span class="number">1.426724</span>  <span class="number">2.0</span>        李四</span><br><span class="line">-<span class="number">1.530958</span> -<span class="number">1.530958</span>  <span class="number">3.0</span>       <span class="number">999</span></span><br><span class="line">-<span class="number">0.939147</span> -<span class="number">0.939147</span>  <span class="number">4.0</span>       <span class="number">0.1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.set_index([<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>])</span><br><span class="line">df.index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="comment"># 如果要设置的索引不在数据中, 可以用index直接设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">        one  two     three</span><br><span class="line">a -<span class="number">1.183802</span>  <span class="number">1.0</span>  zhangsan</span><br><span class="line">b  <span class="number">1.426724</span>  <span class="number">2.0</span>        李四</span><br><span class="line">c -<span class="number">1.530958</span>  <span class="number">3.0</span>       <span class="number">999</span></span><br><span class="line">d -<span class="number">0.939147</span>  <span class="number">4.0</span>       <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.set_index([<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>])</span><br><span class="line">                  three</span><br><span class="line">one       two</span><br><span class="line">-<span class="number">1.183802</span> <span class="number">1.0</span>  zhangsan</span><br><span class="line"> <span class="number">1.426724</span> <span class="number">2.0</span>        李四</span><br><span class="line">-<span class="number">1.530958</span> <span class="number">3.0</span>       <span class="number">999</span></span><br><span class="line">-<span class="number">0.939147</span> <span class="number">4.0</span>       <span class="number">0.1</span></span><br></pre></td></tr></table></figure>


<h3 id="1-1-2-reset-index"><a href="#1-1-2-reset-index" class="headerlink" title="1.1.2 reset_index"></a>1.1.2 <code>reset_index</code></h3><p><code>reset_index</code>用于将索引还原成默认值，即从0开始步长为1的数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.reset_index(drop=<span class="literal">True</span>)</span><br><span class="line">df.set_index([<span class="string">&#x27;one&#x27;</span>],drop=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 参数drop默认值为False，意为将原来的索引做为数据列保留，如果设为True，原来的索引会直接删除。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.reset_index()</span><br><span class="line">  index       one  two     three</span><br><span class="line"><span class="number">0</span>     a -<span class="number">1.183802</span>  <span class="number">1.0</span>  zhangsan</span><br><span class="line"><span class="number">1</span>     b  <span class="number">1.426724</span>  <span class="number">2.0</span>        李四</span><br><span class="line"><span class="number">2</span>     c -<span class="number">1.530958</span>  <span class="number">3.0</span>       <span class="number">999</span></span><br><span class="line"><span class="number">3</span>     d -<span class="number">0.939147</span>  <span class="number">4.0</span>       <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.reset_index(drop=<span class="literal">True</span>)</span><br><span class="line">        one  two     three</span><br><span class="line"><span class="number">0</span> -<span class="number">1.183802</span>  <span class="number">1.0</span>  zhangsan</span><br><span class="line"><span class="number">1</span>  <span class="number">1.426724</span>  <span class="number">2.0</span>        李四</span><br><span class="line"><span class="number">2</span> -<span class="number">1.530958</span>  <span class="number">3.0</span>       <span class="number">999</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.939147</span>  <span class="number">4.0</span>       <span class="number">0.1</span></span><br></pre></td></tr></table></figure>

<h3 id="1-1-3-reindex"><a href="#1-1-3-reindex" class="headerlink" title="1.1.3 reindex"></a>1.1.3 <code>reindex</code></h3><p><code>reindex</code>比较复杂，也不常用到，这里是基础篇，不做大量说明，感兴趣的朋友可以看 <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.reindex.html">官方文档</a></p>
<h2 id="1-2-利用数组创建"><a href="#1-2-利用数组创建" class="headerlink" title="1.2 利用数组创建"></a>1.2 利用数组创建</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data=np.random.randn(<span class="number">6</span>,<span class="number">4</span>)       <span class="comment">#创建一个6行4列的数组</span></span><br><span class="line">df=pd.DataFrame(data,columns=<span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>),index=[<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;2006-10-1&#x27;</span>,<span class="string">&#x27;第六行&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">                  A         B         C         D</span><br><span class="line"><span class="number">1</span>         -<span class="number">0.173690</span>  <span class="number">0.004300</span> -<span class="number">0.896126</span>  <span class="number">0.360287</span></span><br><span class="line"><span class="number">2</span>          <span class="number">1.493732</span>  <span class="number">0.784469</span> -<span class="number">0.799769</span> -<span class="number">1.828341</span></span><br><span class="line">a         -<span class="number">0.678492</span>  <span class="number">0.613644</span>  <span class="number">1.835787</span>  <span class="number">0.252200</span></span><br><span class="line">b         -<span class="number">1.347327</span>  <span class="number">0.134869</span> -<span class="number">0.595432</span> -<span class="number">0.533671</span></span><br><span class="line"><span class="number">2006</span>-<span class="number">10</span>-<span class="number">1</span>  <span class="number">0.178216</span> -<span class="number">0.690090</span> -<span class="number">0.625436</span>  <span class="number">1.377065</span></span><br><span class="line">第六行    -<span class="number">1.534302</span> -<span class="number">0.147462</span>  <span class="number">0.703847</span>  <span class="number">0.221454</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-创建一个空DataFrame"><a href="#1-3-创建一个空DataFrame" class="headerlink" title="1.3 创建一个空DataFrame"></a>1.3 创建一个空DataFrame</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.DataFrame(columns=(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;grade&#x27;</span>,<span class="string">&#x27;class&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.DataFrame(columns=(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;grade&#x27;</span>,<span class="string">&#x27;class&#x27;</span>))</span><br><span class="line">Empty DataFrame</span><br><span class="line">Columns: [<span class="built_in">id</span>, name, grade, <span class="class"><span class="keyword">class</span>]</span></span><br><span class="line"><span class="class"><span class="title">Index</span>:</span> []</span><br></pre></td></tr></table></figure>


<h1 id="2-读DataFrame"><a href="#2-读DataFrame" class="headerlink" title="2 读DataFrame"></a>2 读DataFrame</h1><p>为了便于理解，以下面DataFrame为例，对其读写操作展开说明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data=np.random.randn(<span class="number">6</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df=pd.DataFrame(data,columns=<span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>),index=[<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;2006-10-1&#x27;</span>,<span class="string">&#x27;第六行&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">                  A         B         C         D</span><br><span class="line"><span class="number">1</span>         -<span class="number">0.173690</span>  <span class="number">0.004300</span> -<span class="number">0.896126</span>  <span class="number">0.360287</span></span><br><span class="line"><span class="number">2</span>          <span class="number">1.493732</span>  <span class="number">0.784469</span> -<span class="number">0.799769</span> -<span class="number">1.828341</span></span><br><span class="line">a         -<span class="number">0.678492</span>  <span class="number">0.613644</span>  <span class="number">1.835787</span>  <span class="number">0.252200</span></span><br><span class="line">b         -<span class="number">1.347327</span>  <span class="number">0.134869</span> -<span class="number">0.595432</span> -<span class="number">0.533671</span></span><br><span class="line"><span class="number">2006</span>-<span class="number">10</span>-<span class="number">1</span>  <span class="number">0.178216</span> -<span class="number">0.690090</span> -<span class="number">0.625436</span>  <span class="number">1.377065</span></span><br><span class="line">第六行    -<span class="number">1.534302</span> -<span class="number">0.147462</span>  <span class="number">0.703847</span>  <span class="number">0.221454</span></span><br></pre></td></tr></table></figure>

<h2 id="2-1-按列读取"><a href="#2-1-按列读取" class="headerlink" title="2.1 按列读取"></a>2.1 按列读取</h2><h3 id="2-1-1-df-列名"><a href="#2-1-1-df-列名" class="headerlink" title="2.1.1 df.列名"></a>2.1.1 <code>df.列名</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该方法每次只能读取一列。</span></span><br><span class="line">df.A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.A</span><br><span class="line"><span class="number">1</span>            <span class="number">1.787797</span></span><br><span class="line"><span class="number">2</span>            <span class="number">0.098504</span></span><br><span class="line">a           -<span class="number">0.361166</span></span><br><span class="line">b            <span class="number">0.337533</span></span><br><span class="line"><span class="number">2006</span>-<span class="number">10</span>-<span class="number">1</span>   -<span class="number">0.628970</span></span><br><span class="line">第六行          <span class="number">3.356526</span></span><br><span class="line">Name: A, dtype: float64</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-df-39-列名-39-df-39-列名-39-df-39-列名1-39-39-列名2-39-39-列名n-39"><a href="#2-1-2-df-39-列名-39-df-39-列名-39-df-39-列名1-39-39-列名2-39-39-列名n-39" class="headerlink" title="2.1.2 df[&#39;列名&#39;] df[[&#39;列名&#39;]] df[[&#39;列名1&#39;,&#39;列名2&#39;,&#39;列名n&#39;]]"></a>2.1.2 <code>df[&#39;列名&#39;]</code> <code>df[[&#39;列名&#39;]]</code> <code>df[[&#39;列名1&#39;,&#39;列名2&#39;,&#39;列名n&#39;]]</code></h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该方法每次只能读取一列。</span></span><br><span class="line">df[<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">df[[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># df[&#x27;A&#x27;]和 df[[&#x27;A&#x27;]] 返回结果的值相同，但数据结构有差异,</span></span><br><span class="line"><span class="comment"># 用 type(df[&#x27;A&#x27;]),type(df[[&#x27;A&#x27;]]) 查看。 前者为series, 后者为DataFrame.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line"><span class="number">1</span>            <span class="number">1.787797</span></span><br><span class="line"><span class="number">2</span>            <span class="number">0.098504</span></span><br><span class="line">a           -<span class="number">0.361166</span></span><br><span class="line">b            <span class="number">0.337533</span></span><br><span class="line"><span class="number">2006</span>-<span class="number">10</span>-<span class="number">1</span>   -<span class="number">0.628970</span></span><br><span class="line">第六行       <span class="number">3.356526</span></span><br><span class="line">Name: A, dtype: float64</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>]]</span><br><span class="line">                  A         C         D</span><br><span class="line"><span class="number">1</span>          <span class="number">1.787797</span> -<span class="number">0.668013</span>  <span class="number">0.554594</span></span><br><span class="line"><span class="number">2</span>          <span class="number">0.098504</span> -<span class="number">0.420558</span>  <span class="number">0.508395</span></span><br><span class="line">a         -<span class="number">0.361166</span>  <span class="number">0.423340</span> -<span class="number">2.039099</span></span><br><span class="line">b          <span class="number">0.337533</span>  <span class="number">0.378315</span>  <span class="number">0.485731</span></span><br><span class="line"><span class="number">2006</span>-<span class="number">10</span>-<span class="number">1</span> -<span class="number">0.628970</span>  <span class="number">1.152818</span> -<span class="number">0.671454</span></span><br><span class="line">第六行     <span class="number">3.356526</span>  <span class="number">0.854735</span> -<span class="number">0.768296</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(df[<span class="string">&#x27;A&#x27;</span>]),<span class="built_in">type</span>(df[[<span class="string">&#x27;A&#x27;</span>]])</span><br><span class="line">(&lt;class &#x27;pandas.core.series.Series&#x27;&gt;, &lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;)</span><br></pre></td></tr></table></figure>

<h3 id="2-1-3-iloc-colNo-iloc-colNo1-colNo2"><a href="#2-1-3-iloc-colNo-iloc-colNo1-colNo2" class="headerlink" title="2.1.3 .iloc[:,colNo] .iloc[:,colNo1:colNo2]"></a>2.1.3 <code>.iloc[:,colNo]</code> <code>.iloc[:,colNo1:colNo2]</code></h3><p>按列号读取，有时候我们可能更希望通过列号（1，2，3…）读取数据而不是列名，<br>又或着我们要读取多行的时候一个一个输入列名是很麻烦的，<br>我们希望有最简单的代码读取我们最想要的内容，<br><code>.iloc</code> 方法可以让我们通过列号索引数据，具体如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.iloc[:<span class="number">1</span>]         <span class="comment"># 读取第一列</span></span><br><span class="line">df.iloc[:,<span class="number">1</span>:<span class="number">3</span>]      <span class="comment"># 读取第1列到第3列</span></span><br><span class="line">df.iloc[:,<span class="number">2</span>:]       <span class="comment"># 读取第2列之后的数据</span></span><br><span class="line">df.iloc[:,:<span class="number">3</span>]       <span class="comment"># 读取前3列数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这其实是按单元格读取数据的特殊写法，如果有疑问请看 2.3 按单元格读取数据。</span></span><br></pre></td></tr></table></figure>


<h2 id="2-2-按行读取"><a href="#2-2-按行读取" class="headerlink" title="2.2 按行读取"></a>2.2 按行读取</h2><h3 id="2-2-1-loc-39-行标签-39-loc-39-行标签-39-loc-39-行标签1-39-39-行标签2-39-39-行标签n-39"><a href="#2-2-1-loc-39-行标签-39-loc-39-行标签-39-loc-39-行标签1-39-39-行标签2-39-39-行标签n-39" class="headerlink" title="2.2.1 .loc[&#39;行标签&#39;] .loc[[&#39;行标签&#39;]] .loc[[&#39;行标签1&#39;,&#39;行标签2&#39;,&#39;行标签n&#39;]]"></a>2.2.1 <code>.loc[&#39;行标签&#39;]</code> <code>.loc[[&#39;行标签&#39;]]</code> <code>.loc[[&#39;行标签1&#39;,&#39;行标签2&#39;,&#39;行标签n&#39;]]</code></h3><p><code>.loc</code>根据行标签索引数据，这里的行标签可以理解为索引（没有深入研究，但是在这里，行标签=索引）,<br>比如我们要分别读取第1行和第3行就是<code>df[[1]]</code>、<code>df[[&#39;a&#39;]]</code>，<br>如果该df的索引变为<code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]</code>，分别读取第1行和第3行的操作将变成<code>df[[&#39;a&#39;]]</code>,<code>df[[&#39;c&#39;]]</code>，<br>也就是说.loc后面的’行标签’必须在索引中。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">df.loc[[<span class="number">1</span>]]</span><br><span class="line">df.loc[[<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;2006-10-1&#x27;</span>]]</span><br><span class="line"><span class="comment"># df.loc[1] 和 df.loc[[1]] 返回结果的值相同，但数据结构有差异</span></span><br><span class="line"><span class="comment"># 用 type(df.loc[1]),type(df.loc[[1]]) 查看。 前者为series, 后者为DataFrame.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[[<span class="number">1</span>]]</span><br><span class="line">          A         B         C         D</span><br><span class="line"><span class="number">1</span>  <span class="number">1.787797</span>  <span class="number">0.366138</span> -<span class="number">0.668013</span>  <span class="number">0.554594</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[[<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;2006-10-1&#x27;</span>]]</span><br><span class="line">                  A         B         C         D</span><br><span class="line"><span class="number">1</span>          <span class="number">1.787797</span>  <span class="number">0.366138</span> -<span class="number">0.668013</span>  <span class="number">0.554594</span></span><br><span class="line">a         -<span class="number">0.361166</span> -<span class="number">0.427358</span>  <span class="number">0.423340</span> -<span class="number">2.039099</span></span><br><span class="line"><span class="number">2006</span>-<span class="number">10</span>-<span class="number">1</span> -<span class="number">0.628970</span> -<span class="number">1.219419</span>  <span class="number">1.152818</span> -<span class="number">0.671454</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(df.loc[<span class="number">1</span>]),<span class="built_in">type</span>(df.loc[[<span class="number">1</span>]])</span><br><span class="line">(&lt;class &#x27;pandas.core.series.Series&#x27;&gt;, &lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-iloc-39-行号-39-iloc-39-行号-39-iloc-39-行号1-39-39-行号2-39-39-行号n-39"><a href="#2-2-2-iloc-39-行号-39-iloc-39-行号-39-iloc-39-行号1-39-39-行号2-39-39-行号n-39" class="headerlink" title="2.2.2 .iloc[&#39;行号&#39;] .iloc[[&#39;行号&#39;]] .iloc[[&#39;行号1&#39;,&#39;行号2&#39;,&#39;行号n&#39;]]"></a>2.2.2 <code>.iloc[&#39;行号&#39;]</code> <code>.iloc[[&#39;行号&#39;]]</code> <code>.iloc[[&#39;行号1&#39;,&#39;行号2&#39;,&#39;行号n&#39;]]</code></h3><p><code>.iloc</code>根据行号索引数据，行号是固定不变的，不受索引变化的影响，<br>如果df的索引是默认值，则.loc和.iloc的用法没有区别，因为此时行号和行标签相同。</p>
<p><code>.iloc</code>还可以通过切片的方式读取数据，所谓切片就是给出要读数据的首尾位置，<br>然后读取首尾中间这“一片”数据（个人理解，可能理解的不对或比较片面，对此有疑惑的朋友请自行查阅相关资料）<br>比如我们要读取第1行到第4行的数据，利用切片的方法就是 <code>df.iloc[1:5]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.iloc[[<span class="number">1</span>]]</span><br><span class="line">df.iloc[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]]</span><br><span class="line">df.iloc[<span class="number">1</span>:<span class="number">5</span>]        <span class="comment"># 切片形式</span></span><br><span class="line">df.iloc[:<span class="number">5</span>]         <span class="comment"># 读取第0行到第4行的数据；</span></span><br><span class="line">df.iloc[<span class="number">8</span>:]         <span class="comment"># 读取第8行后所有数据，包括第8行；</span></span><br><span class="line">df.iloc[<span class="number">3</span>,<span class="number">6</span>]        <span class="comment"># 读取第3行到第6行的数据，包括第3行但不包括第6行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.iloc[[<span class="number">1</span>]]</span><br><span class="line">          A         B         C         D</span><br><span class="line"><span class="number">2</span>  <span class="number">0.098504</span> -<span class="number">1.332709</span> -<span class="number">0.420558</span>  <span class="number">0.508395</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到 df.loc[1] 和 df.iloc[1] 读到的内容是不一样的，</span></span><br><span class="line"><span class="comment"># df.loc[1] 读取的是索引号为1的那一行，df.iloc[1] 读取的是第1行。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.iloc[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]]</span><br><span class="line">            A         B         C         D</span><br><span class="line"><span class="number">2</span>    <span class="number">0.098504</span> -<span class="number">1.332709</span> -<span class="number">0.420558</span>  <span class="number">0.508395</span></span><br><span class="line">a   -<span class="number">0.361166</span> -<span class="number">0.427358</span>  <span class="number">0.423340</span> -<span class="number">2.039099</span></span><br><span class="line">第六行  <span class="number">3.356526</span> -<span class="number">0.945234</span>  <span class="number">0.854735</span> -<span class="number">0.768296</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.iloc[<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line">                  A         B         C         D</span><br><span class="line"><span class="number">2</span>          <span class="number">0.098504</span> -<span class="number">1.332709</span> -<span class="number">0.420558</span>  <span class="number">0.508395</span></span><br><span class="line">a         -<span class="number">0.361166</span> -<span class="number">0.427358</span>  <span class="number">0.423340</span> -<span class="number">2.039099</span></span><br><span class="line">b          <span class="number">0.337533</span>  <span class="number">1.770279</span>  <span class="number">0.378315</span>  <span class="number">0.485731</span></span><br><span class="line"><span class="number">2006</span>-<span class="number">10</span>-<span class="number">1</span> -<span class="number">0.628970</span> -<span class="number">1.219419</span>  <span class="number">1.152818</span> -<span class="number">0.671454</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-ix"><a href="#2-2-3-ix" class="headerlink" title="2.2.3 .ix"></a>2.2.3 <del><code>.ix</code></del></h3><p><code>.ix</code> 已经不推荐使用, 所以就不举例分析了.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.ix[[<span class="number">1</span>]]</span><br><span class="line">__main__:<span class="number">1</span>: DeprecationWarning:</span><br><span class="line">.ix <span class="keyword">is</span> deprecated. Please use</span><br><span class="line">.loc <span class="keyword">for</span> label based indexing <span class="keyword">or</span></span><br><span class="line">.iloc <span class="keyword">for</span> positional indexing</span><br></pre></td></tr></table></figure>

<h3 id="2-2-4-at-iat"><a href="#2-2-4-at-iat" class="headerlink" title="2.2.4 at iat"></a>2.2.4 <code>at</code> <code>iat</code></h3><p><code>at</code>、<code>iat</code> 这里就不做介绍了，因为上面的方法完全够用了，感兴趣的话可以看 <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.at.html">官方文档</a><br><code>.loc</code> <code>.iloc</code> 完全可以满足DataFrame的读取操作，所以<code>ix</code>,<code>at</code>,<code>iat</code>并不推荐使用。</p>
<h2 id="2-3-按单元格读取"><a href="#2-3-按单元格读取" class="headerlink" title="2.3 按单元格读取"></a>2.3 按单元格读取</h2><h3 id="2-3-1-df-col-row"><a href="#2-3-1-df-col-row" class="headerlink" title="2.3.1 df[col][row]"></a>2.3.1 <code>df[col][row]</code></h3><p>读取一个单元格的数据时推荐使用，也可以写成 <code>df.col[row]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;A&#x27;</span>][<span class="number">1</span>]</span><br><span class="line">df.A[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[<span class="string">&#x27;A&#x27;</span>][<span class="number">1</span>]</span><br><span class="line"><span class="number">1.7877970995354475</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.A[<span class="number">1</span>]</span><br><span class="line"><span class="number">1.7877970995354475</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-loc"><a href="#2-3-2-loc" class="headerlink" title="2.3.2 .loc"></a>2.3.2 <code>.loc</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取一个单元格：</span></span><br><span class="line">df.loc[row][col]</span><br><span class="line">df.loc[row,col]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取一行多列：</span></span><br><span class="line">df.loc[row][[col1,col2]]</span><br><span class="line">df.loc[row,[col1,col2]]</span><br><span class="line">df.loc[row][firstCol:endCol]</span><br><span class="line">df.loc[row,firstCol:endCol]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[<span class="number">1</span>][[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>]]</span><br><span class="line">A    <span class="number">1.787797</span></span><br><span class="line">B    <span class="number">0.366138</span></span><br><span class="line">Name: <span class="number">1</span>, dtype: float64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[<span class="number">1</span>,[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>]]</span><br><span class="line">A    <span class="number">1.787797</span></span><br><span class="line">B    <span class="number">0.366138</span></span><br><span class="line">Name: <span class="number">1</span>, dtype: float64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[<span class="number">1</span>][<span class="string">&#x27;A&#x27;</span>:<span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">A    <span class="number">1.787797</span></span><br><span class="line">B    <span class="number">0.366138</span></span><br><span class="line">C   -<span class="number">0.668013</span></span><br><span class="line">Name: <span class="number">1</span>, dtype: float64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[<span class="number">1</span>,<span class="string">&#x27;A&#x27;</span>:<span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">A    <span class="number">1.787797</span></span><br><span class="line">B    <span class="number">0.366138</span></span><br><span class="line">C   -<span class="number">0.668013</span></span><br><span class="line">Name: <span class="number">1</span>, dtype: float64</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取多行一列：</span></span><br><span class="line">df.loc[[row1,row2]][col]</span><br><span class="line">df.loc[[row1,row2]].col</span><br><span class="line">df.loc[[row1,row2],col]</span><br><span class="line"><span class="comment"># 行号不能用切片!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[[<span class="number">1</span>,<span class="number">2</span>]][<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line"><span class="number">1</span>    <span class="number">1.787797</span></span><br><span class="line"><span class="number">2</span>    <span class="number">0.098504</span></span><br><span class="line">Name: A, dtype: float64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[[<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>]].B</span><br><span class="line"><span class="number">1</span>    <span class="number">0.366138</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">1.332709</span></span><br><span class="line">b    <span class="number">1.770279</span></span><br><span class="line">Name: B, dtype: float64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[[<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>],<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line"><span class="number">1</span>    <span class="number">1.787797</span></span><br><span class="line">a   -<span class="number">0.361166</span></span><br><span class="line">Name: A, dtype: float64</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取多行多列:</span></span><br><span class="line">df.loc[[row1,row2],[col1,col2]]</span><br><span class="line">df.loc[[row1,row2]][[col1,col2]]</span><br><span class="line">df.loc[[row1,row3],firstCol:endCol]</span><br><span class="line"><span class="comment"># 行号不能用切片!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[[<span class="number">1</span>,<span class="number">2</span>]][[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;C&#x27;</span>]]</span><br><span class="line">          A         C</span><br><span class="line"><span class="number">1</span>  <span class="number">1.787797</span> -<span class="number">0.668013</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.098504</span> -<span class="number">0.420558</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[[<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>],[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>]]</span><br><span class="line">          A         B</span><br><span class="line"><span class="number">1</span>  <span class="number">1.787797</span>  <span class="number">0.366138</span></span><br><span class="line">b  <span class="number">0.337533</span>  <span class="number">1.770279</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[[<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>],<span class="string">&#x27;A&#x27;</span>:<span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">          A         B         C</span><br><span class="line"><span class="number">1</span>  <span class="number">1.787797</span>  <span class="number">0.366138</span> -<span class="number">0.668013</span></span><br><span class="line">b  <span class="number">0.337533</span>  <span class="number">1.770279</span>  <span class="number">0.378315</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-iloc"><a href="#2-3-3-iloc" class="headerlink" title="2.3.3 .iloc"></a>2.3.3 <code>.iloc</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取一个单元格：</span></span><br><span class="line">df.iloc[rowNo].col</span><br><span class="line">df.iloc[rowNo][col]</span><br><span class="line">df.iloc[rowNo,colNo]</span><br><span class="line"><span class="comment"># 不支持 df.iloc[rowNo,col]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取一行多列：</span></span><br><span class="line">df.iloc[rowNo,firestColNo,endColNo]</span><br><span class="line">df.iloc[rowNo][[col1,col2]]</span><br><span class="line">df.iloc[rowNo][firesCol:endCol]</span><br><span class="line"><span class="comment"># 不支持 df.iloc[rowNo,[col1,col2]]</span></span><br><span class="line"><span class="comment"># 不支持 df.iloc[rowNo,firstColNo:endColNo]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.iloc[<span class="number">0</span>,<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">B    <span class="number">0.366138</span></span><br><span class="line">C   -<span class="number">0.668013</span></span><br><span class="line">Name: <span class="number">1</span>, dtype: float64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.iloc[<span class="number">0</span>][[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>]]</span><br><span class="line">A    <span class="number">1.787797</span></span><br><span class="line">B    <span class="number">0.366138</span></span><br><span class="line">Name: <span class="number">1</span>, dtype: float64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.iloc[<span class="number">0</span>][<span class="string">&#x27;A&#x27;</span>:<span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">A    <span class="number">1.787797</span></span><br><span class="line">B    <span class="number">0.366138</span></span><br><span class="line">C   -<span class="number">0.668013</span></span><br><span class="line">Name: <span class="number">1</span>, dtype: float64</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取多行一列：</span></span><br><span class="line">df.iloc[[rowNo1,rowNo2],colNo]</span><br><span class="line">df.iloc[firstRowNo:endRowNo,colNo]</span><br><span class="line">df.iloc[[rowNo1,rowNo2]][col]</span><br><span class="line">df.iloc[firstRowNo,endRowNo][col]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.iloc[<span class="number">0</span>:<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"><span class="number">1</span>    <span class="number">0.366138</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">1.332709</span></span><br><span class="line">a   -<span class="number">0.427358</span></span><br><span class="line">Name: B, dtype: float64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.iloc[<span class="number">1</span>:<span class="number">3</span>][<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line"><span class="number">2</span>    <span class="number">0.098504</span></span><br><span class="line">a   -<span class="number">0.361166</span></span><br><span class="line">Name: A, dtype: float64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.iloc[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]][<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line"><span class="number">2</span>            <span class="number">0.098504</span></span><br><span class="line">a           -<span class="number">0.361166</span></span><br><span class="line"><span class="number">2006</span>-<span class="number">10</span>-<span class="number">1</span>   -<span class="number">0.628970</span></span><br><span class="line">Name: A, dtype: float64</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取多行多列：</span></span><br><span class="line">df.iloc[firstRowNo:endRowNo,firstColNo:endColNo]</span><br><span class="line">df.iloc[[RowNo1,RowNo2],[ColNo1,ColNo2]]</span><br><span class="line">df.iloc[firstRowNo:endRowNo][[col1,col2]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.iloc[<span class="number">0</span>:<span class="number">3</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">          B         C         D</span><br><span class="line"><span class="number">1</span>  <span class="number">0.366138</span> -<span class="number">0.668013</span>  <span class="number">0.554594</span></span><br><span class="line"><span class="number">2</span> -<span class="number">1.332709</span> -<span class="number">0.420558</span>  <span class="number">0.508395</span></span><br><span class="line">a -<span class="number">0.427358</span>  <span class="number">0.423340</span> -<span class="number">2.039099</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.iloc[<span class="number">0</span>:<span class="number">3</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">          B         C         D</span><br><span class="line"><span class="number">1</span>  <span class="number">0.366138</span> -<span class="number">0.668013</span>  <span class="number">0.554594</span></span><br><span class="line"><span class="number">2</span> -<span class="number">1.332709</span> -<span class="number">0.420558</span>  <span class="number">0.508395</span></span><br><span class="line">a -<span class="number">0.427358</span>  <span class="number">0.423340</span> -<span class="number">2.039099</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.iloc[<span class="number">1</span>:<span class="number">3</span>][[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>]]</span><br><span class="line">          A         B         C</span><br><span class="line"><span class="number">2</span>  <span class="number">0.098504</span> -<span class="number">1.332709</span> -<span class="number">0.420558</span></span><br><span class="line">a -<span class="number">0.361166</span> -<span class="number">0.427358</span>  <span class="number">0.423340</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-4-ix-at-iat"><a href="#2-3-4-ix-at-iat" class="headerlink" title="2.3.4 .ix at iat"></a>2.3.4 <del><code>.ix</code> <code>at</code> <code>iat</code></del></h3><p><code>ix</code>,<code>at</code>,<code>iat</code>不推荐使用</p>
<h1 id="3-写DataFrame-DataFrame赋值"><a href="#3-写DataFrame-DataFrame赋值" class="headerlink" title="3 写DataFrame/DataFrame赋值"></a>3 写DataFrame/DataFrame赋值</h1><h2 id="3-1-按列赋值"><a href="#3-1-按列赋值" class="headerlink" title="3.1 按列赋值"></a>3.1 按列赋值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.col=colList/colValue</span><br><span class="line">df[col]=colList/colValue</span><br><span class="line"><span class="comment"># 如果用一个列表或数组赋值，其长度必须和df的行数相同。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.A=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[<span class="string">&#x27;A&#x27;</span>]=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-按行赋值"><a href="#3-2-按行赋值" class="headerlink" title="3.2 按行赋值"></a>3.2 按行赋值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.loc[row]=rowList</span><br><span class="line">df.loc[row]=rowValue</span><br></pre></td></tr></table></figure>

<h2 id="3-3-给多行多列赋值"><a href="#3-3-给多行多列赋值" class="headerlink" title="3.3 给多行多列赋值"></a>3.3 给多行多列赋值</h2><p>DataFrame的读写操作是多变的，这里也仅仅列出了几种常用的方法，熟练一种方式即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.loc[[row1,row2],[col1,col2]]=value/valueList</span><br><span class="line">df.iloc[[rowNo1,rowNo2],[colNo1,colNo2]]=value/valueList</span><br><span class="line">df.iloc[[rowNo1,rowNo2]][[col1,col2]]=value/valueList</span><br><span class="line">df.ix[firstRow:endRow,firstCol:endCol]=value/valueList</span><br></pre></td></tr></table></figure>

<h1 id="4-DataFrame的插入"><a href="#4-DataFrame的插入" class="headerlink" title="4 DataFrame的插入"></a>4 DataFrame的插入</h1><p>初始化 DataFrame, 以下面DataFrame为例展开说明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data=&#123;<span class="string">&quot;one&quot;</span>:np.random.randn(<span class="number">4</span>),<span class="string">&quot;two&quot;</span>:np.linspace(<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>),<span class="string">&quot;three&quot;</span>:[<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">999</span>,<span class="number">0.1</span>]&#125;</span><br><span class="line">df=pd.DataFrame(data,index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得如下DataFrame</span></span><br><span class="line">        one  two     three</span><br><span class="line"><span class="number">1</span> -<span class="number">1.183802</span>  <span class="number">1.0</span>  zhangsan</span><br><span class="line"><span class="number">2</span>  <span class="number">1.426724</span>  <span class="number">2.0</span>        李四</span><br><span class="line"><span class="number">3</span> -<span class="number">1.530958</span>  <span class="number">3.0</span>       <span class="number">999</span></span><br><span class="line"><span class="number">4</span> -<span class="number">0.939147</span>  <span class="number">4.0</span>       <span class="number">0.1</span></span><br></pre></td></tr></table></figure>

<h2 id="4-1-在任意位置插入"><a href="#4-1-在任意位置插入" class="headerlink" title="4.1 在任意位置插入"></a>4.1 在任意位置插入</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插入一列</span></span><br><span class="line">insert(ioc,column,value)</span><br><span class="line"><span class="comment"># ioc:要插入的位置</span></span><br><span class="line"><span class="comment"># colunm:列名</span></span><br><span class="line"><span class="comment"># value:值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.insert(<span class="number">2</span>,<span class="string">&#x27;four&#x27;</span>,[<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">        one  two  four     three</span><br><span class="line"><span class="number">1</span> -<span class="number">1.417222</span>  <span class="number">1.0</span>    <span class="number">11</span>  zhangsan</span><br><span class="line"><span class="number">2</span>  <span class="number">1.251673</span>  <span class="number">2.0</span>    <span class="number">22</span>        李四</span><br><span class="line"><span class="number">3</span> -<span class="number">0.103710</span>  <span class="number">3.0</span>    <span class="number">33</span>       <span class="number">999</span></span><br><span class="line"><span class="number">4</span> -<span class="number">1.237722</span>  <span class="number">4.0</span>    <span class="number">44</span>       <span class="number">0.1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插入一行</span></span><br><span class="line">row=&#123;<span class="string">&#x27;one&#x27;</span>:<span class="number">111</span>,<span class="string">&#x27;two&#x27;</span>:<span class="number">222</span>,<span class="string">&#x27;three&#x27;</span>:<span class="number">333</span>&#125;</span><br><span class="line">df.loc[<span class="number">1</span>]=row       <span class="comment"># or</span></span><br><span class="line">df.iloc[<span class="number">1</span>]=row      <span class="comment"># or</span></span><br><span class="line">df.ix[<span class="number">1</span>]=row</span><br></pre></td></tr></table></figure>

<h2 id="4-2-在末尾插入"><a href="#4-2-在末尾插入" class="headerlink" title="4.2 在末尾插入"></a>4.2 在末尾插入</h2><p>如果插入一行或一列，用上面的方法把插入位置改为末尾即可，下面给出插入多行多列的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按列合并, 插入多行</span></span><br><span class="line">df.append(df2)</span><br><span class="line"><span class="comment"># 效果等同于 pd.concat([df,df2],axis=0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="comment"># 初始化列表df, df2, 用于列合并</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data=&#123;<span class="string">&quot;one&quot;</span>:np.random.randn(<span class="number">4</span>),<span class="string">&quot;two&quot;</span>:np.linspace(<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>),<span class="string">&quot;three&quot;</span>:[<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">999</span>,<span class="number">0.1</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df=pd.DataFrame(data,index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data=&#123;<span class="string">&quot;one&quot;</span>:[<span class="number">222</span>,<span class="number">214</span>],<span class="string">&quot;two&quot;</span>:np.linspace(<span class="number">11</span>,<span class="number">22</span>,<span class="number">2</span>), <span class="string">&quot;three&quot;</span>:[<span class="string">&#x27;AAA&#x27;</span>, <span class="string">&#x27;BBB&#x27;</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2=pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.append(df2)</span><br><span class="line">          one   two     three</span><br><span class="line"><span class="number">1</span>    <span class="number">0.168605</span>   <span class="number">1.0</span>  zhangsan</span><br><span class="line"><span class="number">2</span>    <span class="number">0.466244</span>   <span class="number">2.0</span>        李四</span><br><span class="line"><span class="number">3</span>   -<span class="number">0.176716</span>   <span class="number">3.0</span>       <span class="number">999</span></span><br><span class="line"><span class="number">4</span>    <span class="number">1.066139</span>   <span class="number">4.0</span>       <span class="number">0.1</span></span><br><span class="line"><span class="number">0</span>  <span class="number">222.000000</span>  <span class="number">11.0</span>       AAA</span><br><span class="line"><span class="number">1</span>  <span class="number">214.000000</span>  <span class="number">22.0</span>       BBB</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插入多行多列</span></span><br><span class="line">pandas.concat(objs, axis=<span class="number">0</span>, join_axes=<span class="literal">None</span>, ignore_index=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># objs:合并对象</span></span><br><span class="line"><span class="comment"># axis:合并方式，默认0表示按列合并，1表示按行合并</span></span><br><span class="line"><span class="comment"># ignore_index:是否忽略索引</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按行合并</span></span><br><span class="line">初始化列表df, df1, 用于行合并</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data=&#123;<span class="string">&quot;one&quot;</span>:np.random.randn(<span class="number">4</span>),<span class="string">&quot;two&quot;</span>:np.linspace(<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>),<span class="string">&quot;three&quot;</span>:[<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">999</span>,<span class="number">0.1</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df=pd.DataFrame(data,index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data=&#123;<span class="string">&quot;four&quot;</span>:np.random.randn(<span class="number">4</span>),<span class="string">&quot;five&quot;</span>:np.linspace(<span class="number">1</span>,<span class="number">100</span>,<span class="number">4</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df1=pd.DataFrame(data,index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df1</span><br><span class="line">       four   five</span><br><span class="line"><span class="number">1</span> -<span class="number">0.119780</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.290202</span>   <span class="number">34.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.209032</span>   <span class="number">67.0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.997500</span>  <span class="number">100.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.concat([df,df1],axis=<span class="number">1</span>)</span><br><span class="line">        one  two  four     three      four   five</span><br><span class="line"><span class="number">1</span> -<span class="number">1.417222</span>  <span class="number">1.0</span>    <span class="number">11</span>  zhangsan -<span class="number">0.119780</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1.251673</span>  <span class="number">2.0</span>    <span class="number">22</span>      李四 -<span class="number">0.290202</span>   <span class="number">34.0</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.103710</span>  <span class="number">3.0</span>    <span class="number">33</span>       <span class="number">999</span>  <span class="number">1.209032</span>   <span class="number">67.0</span></span><br><span class="line"><span class="number">4</span> -<span class="number">1.237722</span>  <span class="number">4.0</span>    <span class="number">44</span>       <span class="number">0.1</span>  <span class="number">0.997500</span>  <span class="number">100.0</span></span><br><span class="line"><span class="comment"># 若 df2 和 df 的列数不相同, 空缺的行内容会别填充为 NaN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按列合并</span></span><br><span class="line"><span class="comment"># 初始化列表df, df2, 用于列合并</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data=&#123;<span class="string">&quot;one&quot;</span>:np.random.randn(<span class="number">4</span>),<span class="string">&quot;two&quot;</span>:np.linspace(<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>),<span class="string">&quot;three&quot;</span>:[<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">999</span>,<span class="number">0.1</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df=pd.DataFrame(data,index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data=&#123;<span class="string">&quot;one&quot;</span>:[<span class="number">222</span>,<span class="number">214</span>],<span class="string">&quot;two&quot;</span>:np.linspace(<span class="number">11</span>,<span class="number">22</span>,<span class="number">2</span>), <span class="string">&quot;three&quot;</span>:[<span class="string">&#x27;AAA&#x27;</span>, <span class="string">&#x27;BBB&#x27;</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2=pd.DataFrame(data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2</span><br><span class="line">   one   two three</span><br><span class="line"><span class="number">0</span>  <span class="number">222</span>  <span class="number">11.0</span>   AAA</span><br><span class="line"><span class="number">1</span>  <span class="number">214</span>  <span class="number">22.0</span>   BBB</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.concat([df,df2],axis=<span class="number">0</span>)                                                                 &#125;</span><br><span class="line">          one   two     three</span><br><span class="line"><span class="number">1</span>    <span class="number">0.034967</span>   <span class="number">1.0</span>  zhangsan</span><br><span class="line"><span class="number">2</span>   -<span class="number">1.888495</span>   <span class="number">2.0</span>        李四</span><br><span class="line"><span class="number">3</span>    <span class="number">1.045013</span>   <span class="number">3.0</span>       <span class="number">999</span></span><br><span class="line"><span class="number">4</span>   -<span class="number">0.313027</span>   <span class="number">4.0</span>       <span class="number">0.1</span></span><br><span class="line"><span class="number">0</span>  <span class="number">222.000000</span>  <span class="number">11.0</span>       AAA</span><br><span class="line"><span class="number">1</span>  <span class="number">214.000000</span>  <span class="number">22.0</span>       BBB</span><br><span class="line"><span class="comment"># 若 df2 和 df 的列数不相同, 空缺的列内容会别填充为 NaN</span></span><br></pre></td></tr></table></figure>

<h1 id="5-DataFrame的删除操作"><a href="#5-DataFrame的删除操作" class="headerlink" title="5 DataFrame的删除操作"></a>5 DataFrame的删除操作</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">drop(labels, axis=<span class="number">0</span>, level=<span class="literal">None</span>, inplace=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># lables：要删除数据的标签</span></span><br><span class="line"><span class="comment"># axis：0表示删除行，1表示删除列，默认0</span></span><br><span class="line"><span class="comment"># inplace:是否在当前df中执行此操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果演示</span></span><br><span class="line"><span class="comment"># 下述操作不会影响 df 本身, 因为没有被重新赋值.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.drop([<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>],axis=<span class="number">1</span>)</span><br><span class="line">      three</span><br><span class="line"><span class="number">1</span>  zhangsan</span><br><span class="line"><span class="number">2</span>        李四</span><br><span class="line"><span class="number">3</span>       <span class="number">999</span></span><br><span class="line"><span class="number">4</span>       <span class="number">0.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.drop([<span class="number">1</span>,<span class="number">3</span>],axis=<span class="number">0</span>)</span><br><span class="line">        one  two three</span><br><span class="line"><span class="number">2</span>  <span class="number">0.466244</span>  <span class="number">2.0</span>    李四</span><br><span class="line"><span class="number">4</span>  <span class="number">1.066139</span>  <span class="number">4.0</span>   <span class="number">0.1</span></span><br></pre></td></tr></table></figure>

<h1 id="6-DataFrame的高级操作"><a href="#6-DataFrame的高级操作" class="headerlink" title="6 DataFrame的高级操作"></a>6 DataFrame的高级操作</h1><h2 id="6-1-drop-duplicates-删除重复行"><a href="#6-1-drop-duplicates-删除重复行" class="headerlink" title="6.1 drop_duplicates 删除重复行"></a>6.1 <code>drop_duplicates</code> 删除重复行</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.drop_duplicates()                    <span class="comment"># 删除重复行</span></span><br><span class="line">df.drop_duplicates([<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>])       <span class="comment"># 指定要判断的列, 删除重复内容的行.</span></span><br></pre></td></tr></table></figure>

<h2 id="6-2-fillnan-填充无效值"><a href="#6-2-fillnan-填充无效值" class="headerlink" title="6.2 fillnan 填充无效值"></a>6.2 <code>fillnan</code> 填充无效值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.fillna(<span class="string">&#x27;我是无效值&#x27;</span>)                  <span class="comment"># 将 NaN 替换为 &#x27;我是无效值&#x27;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><em><strong>转载自 <a href="https://blog.csdn.net/xtfge0915/article/details/52938740#">pandas 入门：DataFrame的创建，读写，插入和删除</a> 和 <a href="https://blog.csdn.net/xtfge0915/article/details/83477062">pandas进阶：DataFrame高级操作</a>有删改</strong></em></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</title>
    <url>/2019/07/05/1908-unified/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
<li><a href="https://draapho.github.io/2021/03/05/2107-tuibeitu1/">万年歌, 马前课, 梅花诗, 推背图 (上)</a></li>
<li><a href="https://draapho.github.io/2021/03/18/2108-tuibeitu2/">万年歌, 马前课, 梅花诗, 推背图 (下)</a></li>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/26/2123-caseofsatori/">见性者体验收集</a></li>
</ul>
<p><em><strong>转载自 <a href="https://program-think.blogspot.com/2014/09/oversimplification.html?m=1">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></strong></em></p>
<hr>
<p>这个话题，俺很早以前就想写了。因为牵涉的面比较广，总感觉没想全面，拖到这几天才开始动笔。</p>
<h1 id="★“一元化归因”的谬误"><a href="#★“一元化归因”的谬误" class="headerlink" title="★“一元化归因”的谬误"></a>★“一元化归因”的谬误</h1><p>　　“单一归因”是比较常见的，所以先从这个话题说起。<br>　　这个谬误的洋文是“fallacy of the single cause”，意思是：用单一的原因来解释某个事物，因此导致对其它原因的忽略。</p>
<h2 id="◇星座理论"><a href="#◇星座理论" class="headerlink" title="◇星座理论"></a>◇星座理论</h2><p>　　所谓的“星座理论”就是根据你出生的时辰，算出你属于某个星座；然后根据你属于哪个星座，来判断你的性格特征（甚至还可以推断你的人生运势）。<br>　　如果按照该理论来推演，同一个时辰出生的人，性格都应该是一样的。那这个世界上跟你同一个时辰出生的人，多了去了，难道这些人都跟你的性格一模一样？显然不可能嘛！<br>　　说到性格的形成，其实会受到很多因素的影响。比如“遗传因素、家庭环境、童年经历、受教育情况、社交圈”等等。而“星座理论”的荒诞之处就在于——企图用某个单一的因素（出生时间）来解释“性格的形成”——这就是“一元化归因”的谬误。<br>　　类似于“星座理论”的忽悠还有很多，比如“血型理论”啊、“生肖理论”啊。大伙儿不妨举一反三。</p>
<h2 id="◇阴谋论"><a href="#◇阴谋论" class="headerlink" title="◇阴谋论"></a>◇阴谋论</h2><p>　　另一个“单一归因”的常见例子就是“阴谋论”。<br>　　阴谋论的基本套路是这样滴——存在某个极其牛逼的组织（或政府机构），策划了各种各样的重大事件。关于“阴谋论”的批驳，可以看俺在几年前写的一篇专门的批驳文章《<a href="https://program-think.blogspot.com/2011/11/conspiracy-theory.html">聊聊阴谋论流行的原因及其弊端</a>》。</p>
<p>　　<strong>举例——《货币战争》</strong><br>　　《货币战争》是前几年很火的一本书。书中把历史上的种种大事（比如“拿破仑战争、美国南北战争、1929年大萧条、二战、金本位体系崩溃”等等）都说成是“罗斯柴尔德家族”在幕后操纵。</p>
<p>　　<strong>举例——海外反华势力/境外敌对势力</strong><br>　　这个阴谋论是咱们朝廷发明滴。你可以留意一下，天朝一旦出现啥不光彩的事情，喉舌们总喜欢搬出“海外反华势力/境外敌对势力”来作为解释，以此来推卸自己的责任，撇清自己的过错。<br>　　比如朝廷喉舌就把“六四民运”说成是“境外敌对势力发起的”。但其实捏，如果你看过俺写的<a href="https://program-think.blogspot.com/2011/06/june-fourth-incident-0.html">《回顾六四》系列</a>，你会明白当年爆发学潮的因素有很多，而“胡耀邦逝世”只是一个导火索而已。至于所谓的“敌对势力”和“幕后黑手”之说，基本上是朝廷转移视线的手法。</p>
<p>　　<strong>举例——党中央在下一盘很大的棋</strong><br>　　你如果多留意，还可以想出其它一些阴谋论的例子。比如国内论坛的时政板块，经常会出现这样一种言论，不妨称之为“党中央在下一盘很大的棋”。这种论调把朝廷捧得很高，哪怕是朝廷在外交方面的重大败笔，都可以说成是“裆中央”未雨绸缪的伏笔。</p>
<h1 id="★“一元化评价”的谬误"><a href="#★“一元化评价”的谬误" class="headerlink" title="★“一元化评价”的谬误"></a>★“一元化评价”的谬误</h1><p>　　“一元化评价”指的是：企图用某种过于简单的描述来评价某个过于复杂的对象。</p>
<h2 id="◇“智商”的谬误"><a href="#◇“智商”的谬误" class="headerlink" title="◇“智商”的谬误"></a>◇“智商”的谬误</h2><p>　　“智商”（洋文叫 IQ）这个词儿，好多人都听说过，俺就不解释了。关于“智商测试”，有很多种方法。此处不想具体评价某种测试方法是否科学。俺想说的是，“智商”这个概念本身就是一种谬误。<br>　　人的智力构成，包括很多种维度（比如：观察能力、记忆能力、分析能力、推理能力、归纳能力、创造能力……）。对这些不同的能力，相互之间是无法进行【量化换算】的。换句话说，你不可能把“观察能力”通过某种算法折算成“记忆能力”，反之亦然。另外，上述这几个能力只是“大类”，下面还分“小类”。比如“观察能力”还有“视觉”和“听觉”之分。<br>　　在这种情况下，要想客观全面地表示某个人的智力水平，至少要通过一个“矩阵”，才能把相关的信息完全表达出来（如果你不晓得啥是“矩阵”，自己去查维基百科）。<br>　　但是在“智商”这个概念中，企图用【单个】的数字（也就是“标量”）来全面地表示某个人的智力水平。其造成的结果就是“无意义”。也就是说，“智商测试”得到的这个数字【不能】表达出啥有用信息。所以是“无意义”的。<br>　　比方说，两个人的智商测试结果都是120，你能说这两个人的智力水平相似吗？【不能】<br>　　比方说，某人的智商测试结果是100，你能说这个人的智力跟普通大众相似吗？【不能】（有可能此人的某些指标非常非常高，而另一些指标非常非常低，因此导致最终测试结果是100，但这样的话，此人显然跟普通人完全不同）</p>
<h2 id="◇“左派-右派”之称的谬误"><a href="#◇“左派-右派”之称的谬误" class="headerlink" title="◇“左派/右派”之称的谬误"></a>◇“左派/右派”之称的谬误</h2><p>　　在网上讨论政治话题，经常会看到网友使用“左/右”来形容政治流派。这又是一种“一元化评价”的例子。因为不同的政治流派之间的差异，不是一个维度上的差异，而是【多个维度】上的差异。举例如下：<br>个人方面：个人主义 VS 集体主义 VS 国家主义<br>经济方面：放任 VS 管制<br>政府方面：大政府 VS 小政府 VS 无政府<br>外交方面：孤立主义 VS 国际主义<br>……（还有很多，就不一一列举了）<br>　　请注意：上述的每一个维度都【不是】只有两个端点，而是如同“数轴”一样，可以连续分布的。就好比“经济”这个维度：如今已经没有哪个国家是 100% 的自由放任（历史上的英国曾经出现过），如今也没有哪个国家是 100% 的管制（人类历史上，大概只有红色高棉做到了“废除货币，废除财产继承”，参见《<a href="https://program-think.blogspot.com/2012/10/history-of-red-khmers.html">最“纯正”的共产主义政权——红色高棉简史</a>》）。如今的国家要么偏向“放任”一端，要么偏向“管制”一端，当然也有一些是折中的。</p>
<p>　　从上面的举例可知，反映政治立场的维度有很多，而“左/右”的说法，充其量只能表达一个维度。所以用“左/右”来形容政治流派，显然是以偏概全。所以俺经常建议说：要称呼政治流派，最好直接用“某某主义”来称呼，比较准确，避免歧义和误解。比如曾经有读者问俺的政治立场，俺会回答说倾向于“古典自由主义”，而不会回答说俺是“左派”还是“右派”。</p>
<h2 id="◇“脸谱化-标签化”的谬误"><a href="#◇“脸谱化-标签化”的谬误" class="headerlink" title="◇“脸谱化/标签化”的谬误"></a>◇“脸谱化/标签化”的谬误</h2><p>　　所谓的“脸谱化”就是说，你对某个事物的认知，被某个特定的符号所取代。一提到该事物，你脑海中就【只会】出现该符号。<br>　　举例：<br>　　如比这几年“抗日神剧”热播。很多50后60后的中老年人，整天看着这些“抗日神剧”，其中一些人对“日本人”的认知就会变成“脸谱化”。一提到日本人，他们脑海中就只有“抗战中的日本鬼子”这个印象。除此之外，再没有其它印象。<br>　　“脸谱化”的例子还有很多，列位看官不妨自己琢磨一下。</p>
<h2 id="◇“评价成功人士”的谬误"><a href="#◇“评价成功人士”的谬误" class="headerlink" title="◇“评价成功人士”的谬误"></a>◇“评价成功人士”的谬误</h2><p>　　天朝的拜金主义盛行，已经是众所周知的了。在这样的大环境下，绝大多数人都以“身家的多寡”来评判某个人是否属于“成功人士”（这同样是一种“单一化评价”的谬误）。然后那些初入社会的年轻人，在这种评价体系的影响下，自然也被塑造成“拜金主义者”。如此就陷入某种恶性循环。<br>　　其实对“成功”的评价，可以有各种各样的标准。每个人都可以给自己的人生设定一个独特的“成功标准”，然后为之奋斗。如果你老是以别人的评判标准来作为自己的人生目标，那你一辈子都活在别人的眼光里。</p>
<h1 id="★对“标准答案”的幻想"><a href="#★对“标准答案”的幻想" class="headerlink" title="★对“标准答案”的幻想"></a>★对“标准答案”的幻想</h1><p>　　作为一个“理工男”，俺要特别针对“理工科”的网友强调一下——“理工科”（尤其是“理科”）更容易产生这样的谬误。因为在理科的领域里面，很多问题都是有标准答案的。随便举几个例子：<br>比如几何学：在二位平面上用定长的封闭曲线围出最大的面积，标准答案是圆形。<br>比如力学：给定一个物体，找出其重心，这个也是有标准答案的。<br>……<br>　　但是在现实生活中、在实际工作中，你碰到的绝大部分问题都是【没有】标准答案的。下面俺举几个不同领域的例子。</p>
<h2 id="◇举例——翻墙方面"><a href="#◇举例——翻墙方面" class="headerlink" title="◇举例——翻墙方面"></a>◇举例——翻墙方面</h2><p>　　先说一个大伙儿常见的例子——翻墙。“如何翻墙”这个问题，就没有标准答案。翻墙的方法有很多（看过俺博客的同学应该知道），每一种方法都有其优缺点。你没法说哪个方法就是最优的标准答案。<br>　　比如“修改 Hosts”方法，速度是最好的，但隐匿性是最差的，而且无法针对“IP 被屏蔽的网站”。而俺经常推荐的“多重代理”（参见《<a href="https://program-think.blogspot.com/2012/03/howto-cover-your-tracks-5.html">用多重代理隐匿公网 IP</a>》），速度和稳定性会变差，但是隐匿性非常好。</p>
<h2 id="◇举例——投资方面"><a href="#◇举例——投资方面" class="headerlink" title="◇举例——投资方面"></a>◇举例——投资方面</h2><p>　　经常看到有人在网上问，最好的投资渠道是啥？这个问题同样是没有标准答案的。<br>　　因为每个人的“知识结构”是不同的，每个人的“风险承受能力/风险偏好”是不同的，每个人的“资金量”是不同的……而且在不同国家，或者同一个国家的不同时期，投资环境又是不同的。因此，【不可能】给出某个普遍适用的解决方案。<br>　　就以“知识结构”来说吧。像巴菲特可以通过阅读财报，来分析某个上市公司是否具备可投资的价值。但是大部分网友去看财报，通常是一头雾水——因为不具备相关的知识结构。</p>
<p>　　类似的例子还可以举出很多：比如“择偶的方法、长寿的方法、教育子女的方法”等等，都是【没有】标准答案的。</p>
<h1 id="★对“银弹”的幻想"><a href="#★对“银弹”的幻想" class="headerlink" title="★对“银弹”的幻想"></a>★对“银弹”的幻想</h1><p>　　“银弹”一词出自西方，洋文称为“Silver Bullet”，相当于咱们这边所说的“万金油”（包治百病）。换一个比较严谨的说法就是：用单一工具来解决某个领域的大部分问题（甚至所有问题）。</p>
<h2 id="◇举例——软件开发方面的银弹"><a href="#◇举例——软件开发方面的银弹" class="headerlink" title="◇举例——软件开发方面的银弹"></a>◇举例——软件开发方面的银弹</h2><p>　　软件工程界的大牛 Brooks 在其代表作《人月神话》中，专门有一章叫做“没有银弹”，批驳的就是上述现象。俺个人认为，这一章是整本书最有价值的一章（09年刚开博客的时候，俺曾经写过此书的书评：<a href="https://program-think.blogspot.com/2009/03/book-review-mythical-man-month.html">《人月神话》——不朽的软件工程名著</a>，当时就特地强调了“没有银弹”这一章的重要性）。<br>　　最近半个世纪以来，软件开发领域出现过很多新技术。很多新玩意儿刚刚推出时，都被渲染成是“银弹”。比如在编程技术方面有：OOP、CORBA、COM、Java……流程方面有：RAD、RUP、CMM、Agile……上述这些，有的已经过气了（比如 CORBA），有的虽然还在使用（比如：敏捷开发），但并没能根本解决软件开发的根本性困难（也就是说：有用，但没有传说中那么牛）。<br>　　针对程序员读者补充说明一下：<br>　　《人月神话》中已经深刻分析了，软件开发的“根本性困难”到底啥。如果你真正理解了“软件开发的根本性困难”，自然就明白软件史上的那些银弹咋会失效。</p>
<h2 id="◇举例——医疗保健领域的银弹"><a href="#◇举例——医疗保健领域的银弹" class="headerlink" title="◇举例——医疗保健领域的银弹"></a>◇举例——医疗保健领域的银弹</h2><p>　　前几年，咱天朝出了一个张悟本，号称“绿豆神医”。此人在电视上（包括 CCTV）大肆鼓吹绿豆汤可以治疗各种各样的常见病（至少包括：近视、糖尿病、高血压、肿瘤……）。<br>　　这不就是把绿豆当“万金油”嘛 :) 还好这位张神医已经倒台了。否则的话，不知道还要误导多少人。<br>　　（后来听说这个张神医因为脑梗住院了，看来他连自己都没搞定啊）</p>
<h1 id="★对“终极”的幻想"><a href="#★对“终极”的幻想" class="headerlink" title="★对“终极”的幻想"></a>★对“终极”的幻想</h1><p>　　和“银弹”很接近的另一个话题就是“终极”（终极理论/终极体系/终极方法）。看完下面的介绍，你会发现：对“终极”的幻想，（从某种程度上）也可以算是“一元化思维的谬误”。</p>
<h2 id="◇政治领域：对“共产主义”的幻想"><a href="#◇政治领域：对“共产主义”的幻想" class="headerlink" title="◇政治领域：对“共产主义”的幻想"></a>◇政治领域：对“共产主义”的幻想</h2><p>　　估计出生在天朝的网友，通常都被灌输了马克思那套理论——<a href="https://zh.wikipedia.org/wiki/%E5%8E%86%E5%8F%B2%E5%94%AF%E7%89%A9%E4%B8%BB%E4%B9%89">历史唯物主义</a>（更贴切的术语是“历史决定论”）。作为共产运动的第一任教主，马克思预言说：共产主义社会是人类历史发展的终极目标/终极形态。<br>　　对“历史决定论”最成功最彻底的批判，来自于哲学大牛<a href="https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%B0%94%C2%B7%E6%B3%A2%E6%99%AE%E5%B0%94">波普尔</a>。他在50年代写了一本很有影响力的《历史决定论的贫困》，从各个角度反驳了马教主的那套理论（好几年前，<a href="https://github.com/programthink/books">俺的网盘</a>上就分享了此书的电子版）。<br>　　考虑到很多人不喜欢阅读枯燥的理论著作，俺把波普尔最核心的反驳，大致整理如下（俺的理论水平有限，如有纰漏，欢迎指出）：</p>
<ol>
<li>人类掌握的知识水平/科技水平对历史的发展有关键性的影响（对这点，马克思自己也承认的）</li>
<li>人类不可能预测未来年代“科技的发展和知识的增长”（通俗的说：如果某个知识你能够预测的话，那么该知识就属于“现在的知识”而不是“未来的知识”。或者换种说法：充其量只能预测“已知的未知”，但是无法预测“未知的未知”）</li>
<li>既然不能预测“知识的增长”和“科技的发展”，自然无法预测历史的发展。</li>
<li>如果连历史的发展都无法预测，那么更不可能去讨论“发展是否有终点”以及“如果有终点的话，终点是啥样的”　　（请注意：上述只是波普尔对“历史决定论”最致命的反驳。除了这个，波普尔还在其它几个方面指出了马克思的谬误）<br>　　上述推导过程的关键在第二步。波普尔在书中用了比较复杂的【逻辑证明】（人家给出的是“证明”哦，不是主观拍脑袋的哦）。在此书的序言中，波普尔说道：<br>我在书中提供的（对第2条）证明是复杂的——如果能找到较为简单的证明，我也不会惊异。我的证明在于指出了任何科学预测者——不管是一位科学家还是一部计算机——都不能用科学方法预测它自己未来的结果。只有在事后，这样做的尝试才能获得结果；但对于预测来说，已经为时太晚了——只有当预测已成为追溯（retrodiction），这些尝试才能得出结果。这个纯逻辑的论点适用于各种各样的科学预测者，包括相互配合的预测者“社会”。这意味着任何社会不可能科学地预测它自己未来的知识水平。　　说到这儿，顺便再抹黑一下党国。<br>　　马教主在政治和经济方面的理论，从发表到现在已经一百多年了。经过这一百多年，这两个领域已经有了长足进步。马教主的很多理论都已经过时了（比如“剩余价值理论”、“阶级斗争理论”，还有刚才提到的“历史决定论”），而且他的理论经过后人的大量批驳，都快成筛子（千疮百孔）。但是在咱们天朝，依然把马克思那些理论当宝贝一样供着，并且灌输给一代一代的年轻人。去年的《解放军报》，甚至还在社论中提到：我们信仰的主义，乃是宇宙的真理。连这种话都敢说，真是滑天下之大稽。<br>　　所以俺常说：天朝不愧是一个奇葩的国度。</li>
</ol>
<h2 id="◇理论物理领域：对“TOE”的幻想"><a href="#◇理论物理领域：对“TOE”的幻想" class="headerlink" title="◇理论物理领域：对“TOE”的幻想"></a>◇理论物理领域：对“TOE”的幻想</h2><p>　　（本小节涉及数理逻辑和理论物理，没有相关基础的同学请自行略过）<br>　　在理论物理领域，有一个很有名的东东，叫做“<a href="https://en.wikipedia.org/wiki/Theory_of_everything">TOE</a>”（洋文“Theory Of Everything”的缩写）。这玩意儿号称是理论物理的“圣杯”——从牛顿开始，很多理论物理学家就有“TOE 情结”，并视之为“物理学的终极目标”。<br>　　（注：为了避免歧义，俺写这篇博文时，特地在上述这段中标注了 TOE 的维基百科链接。TOE 可以有不同的理解——狭义的理解指“4种基本作用力的统一”；广义的理解，包括理论物理学发展史上的各种 TOE）<br>　　有好多著名的理论物理学家（其中不乏诺贝尔奖得主）都坚信：“总有一天可以实现（某种形式的）TOE 理论”。某些乐观的科学家甚至认为：TOE 在【不久的将来】就可以被搞定。持有这种观点的人至少包括“爱因斯坦、霍金、温伯格”等人。霍金甚至在上世纪80年代初期还信誓旦旦地宣称，TOE 已经“近在眼前，触手可及”。<br>　　但是到了本世纪初（大约2002年左右），霍金的态度出现180度转变。他之后在各种场合作了名为《哥德尔和物理学的终结》的演讲（<a href="http://www.damtp.cam.ac.uk/events/strings02/dirac/hawking/">洋文全文</a>，<a href="http://www.cssm.org.cn/view.php?id=3985">中文节译</a>），分享了他的观点。其大致意思是：物理学理论必定要基于某些数学模型。而数学理论会受到“<a href="https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86">哥德尔不完备定律</a>”的制约。所以建立在数学模型基础上的物理理论，必定也是不完备的。（提醒一下：这里所说的“完备性”是有专门定义的术语，不要想当然地去理解）<br>　　貌似现在有越来越多的理论物理学家开始意识到——TOE 永远都是可望而不可求的东东。<br>　　俺的观点是：哪怕将来有某个理论能够统一4种基本的力（目前4种里面已经统一2种了），该理论充其量也只能称之为“XXX统一理论”，而没有资格称之为“Theory Of Everything”。因为任何人都【没法证明】：宇宙间仅有这4种相互作用。说不定未来的某一天，会有人发现第5种【基本的】相互作用。</p>
<h1 id="★“一元化思维”的根源"><a href="#★“一元化思维”的根源" class="headerlink" title="★“一元化思维”的根源"></a>★“一元化思维”的根源</h1><p>　　俺大致分析了一下，有如下几种可能的根源（想得未必全面，欢迎大伙儿补充）。</p>
<h2 id="◇思维的惰性"><a href="#◇思维的惰性" class="headerlink" title="◇思维的惰性"></a>◇思维的惰性</h2><p>　　很多“单一化归因”和“单一化评价”，都跟“思维的惰性”有关。<br>　　比如“星座理论”能够盛行，原因之一是因为“思维惰性”。很多人因为思维惰性，懒得对某人进行更全面的观察和了解。以星座来判定某人的性格，几乎是最省事的。<br>　　引申阅读：<br>　　俺后来写如下这篇博文，从“心理学”和“脑神经科学”的层面介绍了“思维的惰性”——其根源是某种称之为“认知负担”的东东。<br>《<a href="https://program-think.blogspot.com/2019/03/Why-Thinking-Hard-So-Hard.html">为什么独立思考这么难？——谈谈心理学的成因，并分享俺的经验</a>》</p>
<h2 id="◇信息来源的单一"><a href="#◇信息来源的单一" class="headerlink" title="◇信息来源的单一"></a>◇信息来源的单一</h2><p>　　某些“单一化评价”是由于信息渠道的单一导致的。<br>　　比如前面提到“日本人的例子”。如果某人只通过“抗日神剧”这一信息渠道来接触到日本人，那么他/她对日本人就会产生严重的认知偏差。</p>
<h2 id="◇知识结构的单一"><a href="#◇知识结构的单一" class="headerlink" title="◇知识结构的单一"></a>◇知识结构的单一</h2><p>　　如果某人的知识结构比较单一，他/她在看待某个复杂事物的时候，往往只看到自己熟悉的那一面（那个维度），对于自己的知识面欠缺的其它维度，就容易忽略掉。所以这类人也比较容易出现“单一化归因”和“单一化评价”。</p>
<h2 id="◇一致性原则"><a href="#◇一致性原则" class="headerlink" title="◇一致性原则"></a>◇一致性原则</h2><p>　　心理学领域有一个很重要的原则叫“一致性原则”。俺在这几年的博文中不止一次提到过此原则，这里就不展开了。<br>　　俺觉得：某些“银弹情结”应该跟“一致性原则”有关。</p>
<h2 id="◇走捷径的心理"><a href="#◇走捷径的心理" class="headerlink" title="◇走捷径的心理"></a>◇走捷径的心理</h2><p>　　还有一些“银弹情结”跟“走捷径的心理”有关。比如前面提到张悟本的例子。<br>　　很多人宁愿相信“绿豆包治百病”的说法，因为这样一来，就可以省去看病/吃药的麻烦。于是就“宁可信其有”。</p>
<h2 id="◇过于追求完美"><a href="#◇过于追求完美" class="headerlink" title="◇过于追求完美"></a>◇过于追求完美</h2><p>　　前面提到理论物理学家对 TOE 的追求。这个属于“过度追求完美”导致的问题。</p>
<h1 id="★总结"><a href="#★总结" class="headerlink" title="★总结"></a>★总结</h1><p>　　本文写得杂七杂八的，所以最后要稍微总结一下。<br>　　当你企图用某个【过于简化】的东东（理论/工具/方法论）来处理某个【足够复杂】的对象，你通常会走入死胡同。常见的“死胡同”有如下4种：</p>
<ol>
<li>得到【片面】的结果（比如“脸谱化/标签化”的例子）</li>
<li>得到【错误】的结果（比如马克思对“共产主义社会”的预言）</li>
<li>得到【无意义】的结果（比如“智商”的例子）</li>
<li>【永远得不到】结果（比如理论物理领域的“TOE”）</li>
</ol>
<p><strong>俺博客上，和本文相关的帖子（需翻墙）：</strong><br>-《<a href="https://program-think.blogspot.com/2018/12/Book-Review-Antifragile-Things-That-Gain-from-Disorder.html">读书笔记：《反脆弱——从不确定性中获益》</a>》<br>-《<a href="https://program-think.blogspot.com/2019/03/Why-Thinking-Hard-So-Hard.html">为什么独立思考这么难？——谈谈心理学的成因，并分享俺的经验</a>》<br>-《<a href="https://program-think.blogspot.com/2015/05/Survivorship-Bias.html">思维的误区：幸存者偏见——顺便推荐巴菲特最著名的演讲</a>》<br>-《<a href="https://program-think.blogspot.com/2010/07/silent-proof.html">思维的误区：忽视沉默的大多数</a>》<br>-《<a href="https://program-think.blogspot.com/2014/06/sunk-cost-fallacy-and-loss-aversion.html">思维的误区：从“沉没成本谬误”到“损失厌恶情结”</a>》<br>-《<a href="https://program-think.blogspot.com/2010/04/how-to-attribute-success-failure.html">你是如何看待【成败】的？——兼谈【有效归因】</a>》<br>-《<a href="https://program-think.blogspot.com/2011/11/conspiracy-theory.html">聊聊【阴谋论】流行的原因及其弊端</a>》<br>-《<a href="https://program-think.blogspot.com/2012/10/history-of-red-khmers.html">最“纯正”的共产主义政权——红色高棉简史</a>》<br>-《<a href="https://program-think.blogspot.com/2009/03/book-review-mythical-man-month.html">书评：＜人月神话＞——不朽的软件工程名著</a>》</p>
<hr>
<p><em><strong>转载自 <a href="https://program-think.blogspot.com/2014/09/oversimplification.html?m=1">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></strong></em></p>
<hr>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>编程随想的博客是需要翻墙的, 如果要反洗脑, 可以多看看此人写的博客, 比那些一味唱衰中国, 唱多西方的”民主派”务实的多!<br>国内不少亲西方价值观的”民主派”以及受迫害移民到国外的”反共派”最大的问题就是这个<strong>一元化思维</strong>, 极端者真是为了黑而黑, 为了白而白.<br>民众, 政党, 国家, 三个不同的概念, 在众多人心中, 也包括共产党自己刻意的宣传, 变成了三位一体的存在. 事实上, 三者都有自己利益和诉求, 有时候一致, 有时候相反.</p>
<p>另外一个话题”终极”. 我个人观点是存在, 但求”终极”是求不到的, 反而会渐行渐远. 只有认识到一切相对/空无/幻像, 才有那么一点点的可能性亲证到”终极”的存在.</p>
<ul>
<li>道教: 从无到有, 无在”终极”内, 万物也在”终极”内, 一切相对, 阴阳互动.</li>
<li>佛教: 从有到无, 从四大皆空亲证”终极”.</li>
</ul>
<p>编程随想的本心是: 推动中国政治制度的改革. 因而他的文章基本集中在政治领域的思辨, 经济领域基本没有涉及.<br>    - 因为重点是中国, 他的博客缺少对西方世界的各种问题的关注.<br>    - 因为重点是政治制度, 他对中国的经济发展成就没有发表任何看法.<br>    - 由于缺乏对西方诸多现实问题的思考和分析, 会让人感觉上亲西方. 这是”一元化评价”的谬误, 即”黑中国=亲西方”<br>    - 综上, 初看者容易觉得此人为了黑中国而黑, 但他本人有明确的目的和严谨的逻辑.<br>    - 看他的博客, 可以从事实上和逻辑上, 对冲掉一些国内媒体的洗脑.</p>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>开悟是怎样一种体验？</title>
    <url>/2019/07/26/1910-satori/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
<li><a href="https://draapho.github.io/2021/03/05/2107-tuibeitu1/">万年歌, 马前课, 梅花诗, 推背图 (上)</a></li>
<li><a href="https://draapho.github.io/2021/03/18/2108-tuibeitu2/">万年歌, 马前课, 梅花诗, 推背图 (下)</a></li>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/26/2123-caseofsatori/">见性者体验收集</a></li>
</ul>
<p><em><strong>转载自 <a href="https://www.zhihu.com/people/yuan-chong-76/answers">灵天赐的回答</a></strong></em><br>2021年2月13日注: 作者已在知乎删除了这篇回答. 类似的回答放到了微信公众号: <code>禅医堂</code>, 由于两篇文章有诸多分别, 我都转载了, 见<a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></p>
<hr>
<h1 id="起"><a href="#起" class="headerlink" title="起"></a>起</h1><p>禅宗开悟, 必过三关:</p>
<p>初关,明心;<br>重关,见性;<br>末后牢关,无我.</p>
<h1 id="初关-明心"><a href="#初关-明心" class="headerlink" title="初关, 明心"></a>初关, 明心</h1><p>何为明心? 明心, 是知‘心’之所在.<br>要想知这‘心’之所在, 必须去刻苦锻炼‘观察’能力.</p>
<p>什么是‘观察’?<br>‘观察’是时时刻刻知道, 自己正在想什么? 自己正在做什么? 自己正在起什么情绪?<br>四念住, 日夜念一句咒语, 数数字, 数呼吸, 数佛珠等诸般法门, 都是为了收束心念, 凝聚意识强度, 增强意识敏感度.<br>使常人平日里飘忽散逸, 被外物牵引的意识, 逐渐全部集中起来, 并意识到曾经的自己, 是有多么‘失控’.<br>‘看见’常人看不见的现象, ‘察觉’常人察觉不到的思绪.<br>常人的意识, 是一只无法自主的提线木偶.<br>自以为客观理智自由, 实际上却被各种后天知见, 欲望, 情绪等诸般情绪操纵, 毫无半点自由可言.<br>随着观察力的锻炼, 意识清晰度的提高.<br>个人会逐渐觉察到, 脑海中一个个念头的飞速起落, 以及情绪不时在体内的翻涌.</p>
<p>此时, 有两个问题, 可助这个阶段的修行者, 求取进步.</p>
<p><strong>1. 情绪, 从哪来?</strong><br><strong>2. 脑海中, 一念起, 一念落, 二念之间的那道‘空白’, 究竟是什么?</strong></p>
<p>如果, 日常对观察力的锻炼时间, 积累的足够.<br>修行者, 会找到一个‘入处’, 可安放这颗顽心, 会觉一道保护罩, 将自己和外界隔绝.<br>外缘消散, 无有恐怖.</p>
<p>实际上, 这也只是一道前菜, 一段时间后, 这种感受就会迅速消失, 让人怅然若失.<br>它是路边一景, 看过便可, 不值一提.<br>不少人由于没有正确引导, 反复沉浸于一时的心景, 误以为那就是‘开悟’, 拼命的想‘回去’, 并‘保持’它.<br>从此, 止步不前, 捡了芝麻, 丢了西瓜.</p>
<p>之后, 经由这个‘入处’, 可导向‘心’之所在.<br>‘心’是什么? ‘心’在哪?<br>这个问题, 不能用语言文字去回答.</p>
<p>修行者, 不断思索上面的两个问题, 随着观察时间的不断积累, 每天缓缓进步.<br>这是水滴石穿的水磨功夫, 毫无任何取巧可言.<br>一段时间后, 某一天, 观察的火候达到, 终于能够清晰地捕捉到一念起, 一念落的瞬间.<br>在水滴石穿的刹那, 遁入了那丝‘空白’之中.</p>
<p>顿悟: 念头是念头, 情绪是情绪, 它们不是你.<br>念头和情绪, 只是天空中飘过的白云; 而你, 是白云背后那片无染的蓝天.<br>这一刻, 个人意识, 得到全面升华.</p>
<p>之前, 还需时时刻刻提醒自己, 每天去努力维持的客观‘观察’.<br>现在, ‘观察’自此恒定, 再也不需要去刻意维持.<br>无论白天黑夜, 无论现实梦境, 那股清晰的‘观察’, 永远伴随着你.<br>仿佛高度近视, 忽然戴上眼镜, 全世界都变得生动起来.</p>
<p>五祖弘忍, 考验弟子, 神秀和慧能留下的两首名偈, 这里一并说破:</p>
<blockquote>
<p>身是菩提树, 心如明镜台; 时时勤拂拭, 勿使惹尘埃.</p>
</blockquote>
<p>神秀的这一首, 表明见地, 未破初关, 还须每天去努力<strong>‘佛拭’</strong>.<br>依然停留在磨练<strong>‘观察’</strong>的阶段, 没有达到<strong>‘水滴石穿’</strong>的境地.</p>
<blockquote>
<p>菩提本无树, 明镜亦非台; 本来无一物, 何处惹尘埃.</p>
</blockquote>
<p>这一首说明六组慧能, 早破初关, 步入明心, 明白心是无需<strong>‘佛拭’</strong>的.<br>也是为何, 五祖在慧能头上敲三下, 让对方半夜来屋, 传其‘见性’之妙, 以及衣钵的奥秘所在.</p>
<p>这个心, 是<strong>‘本来无一物’</strong><br>初关的破关密钥, 只在三个字 – <strong>‘观察者’</strong></p>
<h1 id="重关-见性"><a href="#重关-见性" class="headerlink" title="重关, 见性"></a>重关, 见性</h1><p>重关的修行, 就变得较为复杂, 要从多方面去同时发展和进步.<br>这一关的突破, 很复杂.</p>
<p>简而言之, 需要诚心, 愿心, 决心, 善心, 真师, 天师.<br>六者, 缺一不可.</p>
<ul>
<li>诚心–不是不能说谎, 而是时刻不能欺xin,绝不可自欺, 对自己无条件真诚. 是就是, 不是就不是, 放下主观好恶, 放下傲慢与情绪, 感受一切.</li>
<li>愿心–唤来真师找你, 所发的愿心, 必须以‘无条件助人’为基本, 若自私自利, 只会招来‘假师’, 此生永绝道缘.</li>
<li>善心–为了让自己脱离自我狭隘的‘得失’‘好恶’等观念, 简单地说, 无善心之人, 终生无缘于道.</li>
<li>决心–升起对痛苦的厌倦, 下出脱离‘苦海’的大决心.</li>
<li>真师–若是愿心真, 生活中自会引来真师给你指路, 若你总是遇见各种所谓的‘名师’,‘大师’,‘大德’,‘高僧’之类的‘假大师’. 你应该回归‘愿心’与‘真诚’两点, 对自己进行深刻反思.<ul>
<li>真师的基本特征: ‘识货者可分文不取, 不识货者千金不卖’.</li>
<li>师父会仔细观察徒弟, 徒弟也要仔细观察师父, 双方彼此确认后, 也需付出信任和真诚, 方能加深彼此的感应.</li>
</ul>
</li>
<li>天师–此师比真师更高一筹, 是无所不在的大道之音.<ul>
<li>天师, 会在每次有所顿悟之时, 送来各类负面事件, 让修行者接受考验, 看修行者能否将此次所悟用行动表达出来. 天师是最为重要的一环, 修行者若不能从周围的人身上听见天师之声, 无法在生活中看见天师降下的考验和指引. 无论真师多厉害, 此生注定见性无望.</li>
</ul>
</li>
</ul>
<p>若想以最快速的突破重关, 此时切不可逃避社会, 切不可遁入空门.<br>烦恼即是无上菩提, 人世方为究竟道场.<br><strong>勿要在道离道, 又去求道.</strong></p>
<p>处理现实中的各种矛盾, 各种负性事件, 直面痛苦, 是修行者快速进步的苦口良药.<br>感触不断深入, 如果修行者走在正确的路上, 随时间推移, 会切实的转变自身环境, 以及他们的每一个家人.<br>心能转境, 心能转运, 真实不虚.<br>任何方法, 任何书籍, 任何教派, 都可以拿来用, 加深感悟.</p>
<p>会逐渐认知到以下几点:</p>
<ul>
<li><strong>1. 诸教同源</strong></li>
<li><strong>2. 外界是心相的投影, 心变则境变, 而非境变则心变</strong></li>
<li><strong>3. 一切烦恼, 皆起于后天妄想</strong></li>
<li><strong>4. 三心不可得</strong></li>
</ul>
<p>期间, 多流眼泪, 让心彻底柔软下来, 回忆童年中所有的负面记忆, 找出所有负面情景, 忏悔和宽恕, 不停的倾倒‘心灵垃圾’.<br>释放埋藏于记忆深处的一切仇恨与恐惧.</p>
<p>修行过程中, 会遭遇种种异相, 遭遇种种暂时性的心景, 不一而足, 因人而异.<br>比如, 一个月左右, 无法进食任何肉类, 吃鸡蛋也会吐等等.<br>过了那个心景, 一切会恢复正常.</p>
<p>最后, 不停地专注于内心提升.</p>
<p>待到功夫用尽, 身清体净, 诸缘聚合之下.<br>某个瞬间, 由于某个或普通或是古怪的契机, 就会一眼瞥见世界的‘真相’.<br>是无数人心中, 念念不忘, 无比神圣的‘巅峰体验’, 所谓的‘大彻大悟’.<br>虚空破碎, 天地颠倒等等异相, 会在感知中真实不虚的发生.<br>出现什么, 则因人而异, 不一而足.</p>
<p>唯一的特点, 是这种强大体验降临的时刻, 将永远从内到外的改变一个人, 让其脱胎换骨.<br>那时一股务必强大, 充满震撼的磅礴能量.<br>种种喜悦, 无法用言语来形容.<br>世人所追求的性高潮, 也不及其中万分之一.<br>更别提, 所谓的幻想之流.</p>
<p>那种感受中, 会真实明白, 什么是真正的:<br>“朝闻道, 夕可死.”<br>死了也无妨, 那种无上限的绝对幸福感, 此后再没有世间的任何感受, 能够超越它.</p>
<p>这是‘见性’, 见证你的‘真如本性’, 彻底脱离五官意识的幻相, 体验到一刹那的‘绝对真实’.</p>
<p>巅峰体验后, 很长一段时间, 自动进入‘心生法喜’的阶段.<br>什么都不想干, 看见什么都觉得很幸福, 觉得万物在对你微笑.<br>每天有事没事, 会情不自禁的露出微笑.</p>
<p>是啊, 怎能不高兴呢?<br>离家多年的游子, 回到家中.<br>惊讶发现, 原来, 自己从未有一日, 真正离开过家.<br>除狂喜之外, 再无言语, 可以形容.</p>
<p><strong>我有明珠一颗, 久被尘劳关锁; 而今尘尽光生, 照破山河万朵.</strong></p>
<h1 id="末后牢关-无我"><a href="#末后牢关-无我" class="headerlink" title="末后牢关, 无我"></a>末后牢关, 无我</h1><p>目前, 市面上的‘开悟者’们, 到处讲道讲经, 声名鹊起, 自称为的‘开悟者’之流.<br>大部分, 都在初关徘徊, 各种邪知邪见很多.<br>少数勘破重关的, 算是凤毛麟角, 至少不会去有意无意的害人.<br>真正突破最后一关的, 以网络上而言, 屈指可数.</p>
<p>国内特别有名气的”大师”中, 目前还没有哪一位的言行, 表现出他已过了末后牢关.<br>至于南怀瑾之流, 非是恶意贬低, 而是此人见地不纯, 著书又多, 小有名气, 极易误导真修, 步入知见的无底坑, 荒废一生.<br>若自认为修行者, 却对南怀瑾之流, 推崇备至.<br>及时警醒, 还来得及.<br>修行不是念书, 念的书再多, 没有切实的修行印证, 都是知见与猜测, 什么都悟不到.</p>
<p>末后牢关的突破, 比见性而言, 更加困难.<br>因为, 这是一道‘隐形的门’.</p>
<p>突破重关的人, 会100%的确信无疑, 他是‘开悟’了.<br>无论问自己多少次, 总会得出准确无疑的回答.<br>“是的, 我见证了绝对真理, 知晓前世今生, 明白人生于此的意义, 绝对是开悟了!”<br>心中欣喜若狂, 恨不得奔走相告, 将感悟和每一个人都分享.</p>
<p>一段时间后, 生活中的习气席卷, 根性重返, 各种不足与矛盾重新冒出来.<br>淡化许多, 却依然存在.<br>没有过来人之路, 此人会逐渐被傲慢侵蚀, 试图指点江山, 评判他人悟境.<br>最后会发现, 世事并不按所预料的那样发展.</p>
<p>过来人, 不会直接给他们指出来, 只会侧面提点, 因为明白对方听不进去.<br>这人会在这种‘自满’之中, 呆很长一段时间.<br>只有那些对自己绝对真诚的人, 才会逐渐对开悟升起迷惑.<br>特别是在进入社会, 与周围进行交互时, 这种迷惑会不断强化.</p>
<p>如果, 能对‘自己开悟了’这件事的产生疑惑, 便算是踏出关键性的一步.</p>
<p>末后牢关, 比起前两关, 平凡无奇.<br>没有任何稀奇古怪的心景, 却是三关中, 最为凶险的地方.<br>任何一步踏错, 任何一个细微的认知失调, 就再也听不进任何言语.<br>要去成佛成仙, 普度众生了.</p>
<p>一辈子, 卡死在这一关的修行者, 不知凡几..<br>至死, 他们都不知道自己做错了什么, 错在哪里.<br>反而觉得, 所有的一切, 真是好极了.<br>所见一切, 完美符合他们曾对‘开悟’有过的一切美好幻想.<br>不少会觉醒‘天赋’或是‘天命’, 有的还会修出一些不可思议的‘神通’.<br>他们因此洋洋得意, 有的人从此门徒络绎不绝, 在史书中留下名讳, 还能自成一派.</p>
<p>但是, 唯有那些, 对自己的修行, 做到了100%真诚.<br>在修行上绝不欺骗自己, 始终对一切异见保持真正开放态度的修行者, 才能有惊无险的度过这关.</p>
<p>悟的契机, 十分平凡, 有人盆落而悟, 有人鸟飞而悟.<br>顿悟一个显而易见的事实.<br><strong>开悟, 并不存在.</strong></p>
<p>为什么?<br>原因, 很简单:<br><strong>你所以为的这个‘你’, 是不存在的.</strong></p>
<p>这句话, 十分深奥.<br>其中, 有特别多微妙的讲究, 很深的领悟境地, 以及诸多修行细节和火候, 还有更多玄妙难言的东西.<br>这里, 不能讲.<br>讲了, 会影响那些即将突破此关的修行者.</p>
<p>所以, 诸位记住这句话, 到达此关时, 有空多思索就好.<br>有人以为, 自己曾在别处看过这句话很多遍, 领悟特别深刻.<br>事实上, 错了.<br>真正突破末后牢关前, 是不会懂这句话的.<br>也不会明白, 这句话, 到底厉害在哪里.</p>
<p><strong>‘你’不存在, 所谓的开悟, 也不存在.</strong><br>这就是为什么, 禅宗讲<br><strong>“悟前, 砍柴挑水吃茶; 悟后, 砍柴挑水吃茶”.</strong><br>也是”见山还是山, 见水还是水”的第三重境界.</p>
<p>区别在哪? 区别, 就在这个<strong>‘我’</strong>字上.<br>不能讲得更多了.<br>讲得太清楚, 会被瞎眼汉们和假修们, 拿去招摇撞骗, 误人子弟.</p>
<p>也是为何, 真正的入道者, 不会和人嚷嚷‘我开悟了!’.<br>因为, 他们明白, 没有开悟这回事.<br>事实上, 以为自己开悟了, 感觉自己开悟了, 宣称自己开悟了, 认为有开悟这回事的人, 都还是画中人, 都有一个‘我’在.<br>以后, 看见宣称自己‘开悟’的人.<br>就知道, 是个没‘悟’的.</p>
<p>判断标准, 很简单.<br>不需要懂修行, 只要喊‘我开悟了’, 便是见地不纯.<br>看到这里, 已度过‘修行’阶段的行者们, 会露出一抹会心微笑.</p>
<p>突破三关之后, 觉者, 随心所欲, 言行无碍, 随缘应物.<br>绝不会承认, ‘开悟’这种东西的可观存在.<br>教别人‘开悟’, 就是让对方终生无缘‘开悟’.<br>千古玄机, 我讲明白了.</p>
<p>就是不知道, 你, 听明白了吗?<br><strong>何期自性, 本自清净;</strong><br><strong>何期自性, 本不生灭;</strong><br><strong>何期自性, 本自具足;</strong><br><strong>何期自性, 本不动摇;</strong><br><strong>何期自性, 能生万法;</strong></p>
<h2 id="终"><a href="#终" class="headerlink" title="终"></a>终</h2><p>以上，禅宗的三关隐秘，清清楚楚的写出来了。<br>因为我曾经的发心，所以，大家才有机会，看见这篇‘解密’的文字。</p>
<p>如果，不是实修实证，是看不懂这篇文章的。<br>只会觉得信息量过大，大脑过载，自以为理解，其实完全无法理解到底写了什么。</p>
<p>这些东西，本已脱离大脑思辨的领域。<br>这也是为何，禅宗要参话头，打机锋的意义所在。<br>目的，就是让大脑逻辑自爆，停止运作。</p>
<p>明白本文是珍宝的人，是他们的福气；对本文不屑一顾的，是他们这一世的命运。<br>修行，天地会给你证，何须心外之物？<br>这点都看不透，也别自称修行者了。</p>
<p>开悟，并非某种耗费一生去艰难求取，也难以获得的梦幻状态。<br>是不懂的人，没有实修实证与内行引路的人。<br>将开悟‘妖魔化’、‘神通化’和‘理想化’了。<br>事实上，突破末后牢关后，只是宇宙中一个心识进化的基础起点。</p>
<p>人类要达到那个‘点’，并非一件极其困难的事情，只是以人类的狭隘心智，将这些修行复杂化和歪曲化了。<br>这也是为何，会有所谓的‘悟后起修’，没悟之前的‘修’，都是水中捞月，你不知道自己在干什么。</p>
<p>三关心境上，有一个地方很有趣。<br>若将修行比喻为爬山，<br>在山下面的，永远看不清他上面的人，只会觉得云里雾里，不断猜测对方所说的东西，试图分析比较对方与自己的高度所在，总觉得对方东西自己似乎明白，又似乎不明白。<br>在山上的，却能一眼看穿山下的人以及对方正在走的路，从他的视角看无比清晰，因为他曾亲自走过。</p>
<p>真正突破这三关的觉者之间，没什么好说的。<br>彼此之间毫无比较之心，只需几句话，就能知道对方的‘厉害’。<br>只会心悦诚服，顶礼赞叹。</p>
<p>破三关的觉者，之后还有一段路程要走，这段路，在他们自己的生活中。<br>无上正觉已经很好了，却和无上正等正觉，是截然不同的东西。<br>区别，便在于初心，最初见地中任何最微小的偏差，也会生出截然不同的果。<br>希望，后来的修行者们，在修行上都能少走点弯路，少受点不必要的教训，少掉几个爬不出来无底坑。</p>
<h1 id="临别语"><a href="#临别语" class="headerlink" title="临别语"></a>临别语</h1><p>评论区，明眼人，都知道这篇回答的 <strong>‘含道量’</strong><br>反对声，理所当然占多数。<br>毕竟，不能让下士大笑，就不足以为道了，不是吗？：）</p>
<p>修为这种东西，对实修者，是藏不住的。<br>一开口，底裤就漏得干干净净，怎么装都没用。<br>有自我的人，和自我消亡的人，是两种截然不同的存在。</p>
<p>毕竟夏虫不可语冰，我对此表示深深的理解。<br>因为，我也是从夏虫过来的。<br>有的人，还需多轮转一些人世，才会对此有所感悟。<br>这一点，急不来。</p>
<p>破了三关，才知突破三关，和个人命运有深切的联系，没有累世积累，是不行的。<br>不仅需要因缘聚合，还要100%的诚心，天生的觉悟，本能的担当，以及累世慧根。<br>几年前的我，若能有幸能看见这篇答案。<br>只会瞬间被其折服，珍重的保存起来，反复琢磨，有空就拿出来印证和思索。</p>
<p><strong>仰天大笑出门去，我辈乃是蓬蒿人。</strong></p>
<h1 id="11天后-的补充"><a href="#11天后-的补充" class="headerlink" title="11天后(的补充)"></a>11天后(的补充)</h1><p>这篇回答，我已将之前提到的一些修行细节与诸多隐秘，全部隐去。<br>我之前不明白，以为将东西全部拿出来，是对别人好。<br>现在才明白，不是的。<br>每个人在人世间，都有他们自己的路径要走，揠苗助长不是好事。<br>法不轻传，道不轻授，很重要。<br>所以，我也不是藏私，而是真心为各位好。</p>
<p>不仅为各位诚心求道的修行者们好，更为那些看见本答案心生嫉妒、愤怒、怨恨、烦恼，忍不住对本答案发起攻击与诽谤的朋友们好。<br>谤正法这种事情，对他们自己，真的很不好。<br>我之前从未看过六祖坛经，前几天才看到《六祖坛经》里的一段话。</p>
<blockquote>
<p><strong>善知识，后代得吾法者，将此顿教法门，于同见同行，发愿受持，如事佛故，终身而不退者，定入圣位。然须传授，从上以来，默传分付，不得匿其正法。若不同见同行，在别法中，不得传付。损彼前人，究竟无益。恐愚人不解，谤此法门，百劫千生，断佛种性。</strong></p>
</blockquote>
<p>不至于百劫千生，自断佛种性这么夸张；可这一世，断绝佛缘，再难寸进，会是一个既定事实。<br>我之前本能的对此有所感觉。<br>所以，之前才会有那句‘那些无法对本答案心悦诚服，顶礼赞叹的人，这一世，基本上没什么机会，突破第三关了。’</p>
<p>我说这句话，是作为给这些人的善意提醒。<br>然而，正是这句话，刺激到了他们心之中的那个‘小我’。<br>反而让人起了更强烈的情绪，生出诋毁与恶法之心。<br>我不得不感慨，都是我的错。<br>所以，我将这些隐秘消去，至少，能让他们谤法的后果减轻很多。<br>在这里，真诚向那些怨恨我的，骂我的，嫉妒我的，讨厌我的朋友们道歉。<br>深深地检讨，是我的做得不好。</p>
<p>之前的回答风格，也是我这人天生的性格如此。<br>我在修行上，有一说一，有二说二，真不是狂。<br>禅宗修行，佛挡杀佛，神挡杀神，佛祖泥像放在面前，也会上去一脚把泥土偶相给踢个粉碎。<br>最后，连这个‘自己’，也是要一刀宰杀干净的。<br>‘修行’时，才是真的狂。</p>
<p>昔日的修行之路，我走得太快。<br>导致我完全无法理解，那些‘纯度’不够的人。<br>我不明白为什么有人会闻听‘正法’而毫无感觉？我是会兴奋到头皮发麻，脑子空空，完全不能自已的。</p>
<p>还记得，我当初决意修行时，还在想我这么年轻，余生几十年，若能侥幸见性，便已做梦都会笑醒。<br>‘开悟’之类的东西，想都不敢想。<br>而实际上，我只花了短短四年，就把修行之路彻底走完。<br>两年破三关，两年到如今。</p>
<p>我的真师，与我真师的真师，都对我进度，感到十分惊讶。<br>我明白，这与我的累世积累有关，更与我修行之初，所发愿心密切相关。<br>因为，我此生来人世的意义，就是要‘唤醒他人灵魂深处的荣光’。<br>所以，我的修行，不是一个人修行，是与我的兄弟姐妹在一起修行。<br>我先行一步，他们会在冥冥之中，齐心协力的推我。<br>待我醒来后，又转身去拉大家。</p>
<p>这是我修行的愿心，也是这篇‘解密’答案，出现在给位面前的缘由。<br>我口中的‘真修’，也是我们来此人世之前，就提前约定好的兄弟姐妹们。<br>约好了，待我醒了，一定会叫醒他们。<br>也约好了，在我出现时，他们一定会在内心深处，一眼就能认出我来。<br>这是彼此出生前的约定，我还活着，就记起来了。<br>所以，我一直在履行这个约定。</p>
<p>禅宗的很多东西，必须经过认真考察，才能当面传授的，里面，有很多很深刻的考虑。<br>我以前没教过人，修行进度又太快，一直不懂，禅宗前辈们，干嘛总是藏着掖着？<br>直接拿出来，大家一起顿悟，多好？<br>现在，我才明白。<br>非是禅宗藏私，而是这些‘当下直指’，‘当下顿悟’的东西，要很深的火候、讲究和准备才行。<br>天时地利人和，缺一不可。<br>将答案直接告诉别人，不是助人，是在害人。</p>
<p>减少了别人探索的乐趣，也容易让这些人着于相，只看见手指而忘记手所指的那个‘月’。<br>所以，各位别再找我拜师什么的了，你拿一百亿给我，也是不教的，和钱没关系。<br>不仅因为法不轻传，而是教了你也学不会；禅宗收徒，不收钱，只收‘诚心’一种学费。</p>
<p>然而，世上交得起这份‘诚心’的人，并不多。<br>很多人，还需多轮转一些人世，才能攒得齐这份‘学费’，这个只能靠他们自己的心量了。<br>我现在，只是在无条件助人，没到收徒的时候。<br>因为我的路走得太快，虽然我一直不觉得自己根器怎样，现在也不得不承认，我是禅宗里所谓的‘上上根器’。</p>
<p>事实上，根器没有优劣之别，就像有的人吃半碗饭就饱了，有的人要吃十碗才能饱一样。<br>都是为了吃饱，结果上没有区别。<br>可我走的路太短，所以，我只教得了那些根器很猛的人。</p>
<p>两年来，各种渠道找我求教的人很多。<br>可惜，我连突破明心都没能教出一个，真的很惭愧。<br>所以，我不推荐你们找我求教。</p>
<p>你们可以去天涯论坛，找帖子“性的另一出口：《山居性纪》——性是种子禅是花开”。<br>电脑端搜不到了，手机端还可以：<br><a href="https://bbs.tianya.cn/m/post_share_weilun.jsp?id=1736800&item=free&f=i">性的另一出口：《山居性纪》—性是种子禅是花开（已出版）</a><br>我的真师就是在帖子里，随着他的真师走出来的。<br>书已出版，他们两人，现在也都离开帖子，回归生活。</p>
<p>可曾经的足迹依然还在那里，各位可以去里面一页页的看下来。<br>里面有过很多实修出现，在里面彼此交锋后，留下的种种交流足迹。<br>那里，是他们搭建的一个网络道场，有很强的能量场，你们现在依然可以去里面，仔细的‘感应’与‘修行’。<br>各位不需要找我教，我真不是一个好老师。</p>
<p>至于我真师的真师，他说过他根器很差，属于下下根器。<br>所以，辛辛苦苦花了二十几年，山中闭关，西藏随密宗上师隐秘修行等等，将各种修法都折腾个遍，才终于‘吃饱’了。<br>也正因如此，他写东西和教人，才能够无论根器利钝，一网全收。<br>他说过，连他这种都能修出来；这世上只要能发真心，就没人是不能修出来的。<br>这也是为何，以他的心力，能建得起那个网络道场的缘故。<br>这一点，我发自内心的敬佩与感激。</p>
<p>现在，我也还在向他学习。<br>你们若读他的文字，就会直接感觉到那股直刺人心，却又洗涤心灵的纯净力量。<br>很多人，看他写的文字，是会被直接看哭的。</p>
<p>这里，我也可以回答一下。<br>评论区，有人曾好奇问我，破三关之后，我与真师，还有真师的真师之间的关系。<br>之后，‘真师’也就变成了你的‘道友’，是那种血浓于水的轮回‘道友’。<br>不是所谓的‘师徒’或是‘父子’的关系，是比它们更亲切的一种超越血缘的平等关系。<br>彼此之间，很乐意无私帮助，却基本不会要求对方给自己帮忙。<br>因为，我们各自能把自己的人生过得很好，也并不需要在生活中让对方来帮什么忙。</p>
<p>一年聚上一两次，一起吃个饭，交流和感受一下彼此的感悟与境界，互相学习。<br>我们彼此都在探索截然不同的人生课题，现实中做的事情，往往没有半点交集，住的地方也是天南地北。<br>每年，专门跋山涉水，不远千里，去见这么一两面，找他们取取经。<br>知道还有这样的人在远方，就会知道，在人世之中。<br>自己，并不孤单。</p>
<p>可能，很多人不太能理解我的这种感受。<br>我们时常处于一种‘教师’状态，总是在教那些从网络上，来到面前‘求教’的人。<br>现实里，则是一种彻底融入‘平凡’的状态。<br>不是修行人，现实里和我们聊天，我们一个修行相关的字眼都不会提。<br>各自心中，对这个世界的深刻感悟，也没法同周围的人交流，网络上也是一样。</p>
<p>讲了，大家也听不懂，理解不了，思维已不在同一个维度。<br>所以，心中知道有那么两个人在远方，每年想去时都可以去见到，去交心。<br>真的，会让人有一种让人发自内心的幸福与愉悦。</p>
<p>评论区里，我从未因任何人的评论而生气过。<br>毕竟，自我都没了的人，怎会因为网络言论而生气呢？<br>我的每一句回复，都是出于无私助人的目的，只是我的语气很直接，我习惯了在网络上这样沟通而已。<br>对于那些无条件攻击我的人，我很感谢对方，谢谢他们出现，帮我打开心量。</p>
<p>也多亏这篇回答。<br>前几天，我从真师的真师那里，得到一个意料之外的‘印章’。<br>这个‘章’往下一盖，我整个人，就彻底清净了。<br>这个章，盖和不盖，说的话一样，做的事一样，讲的东西一样，区别很微小，却是截然不同的两种东西。<br>看过之前那个回答，再看现在这个回答的人，能够感受到。<br>这个区别，究竟在哪。</p>
<p>很感谢，来评论区里，每一位顶礼赞叹的人，以及每一位诋毁辱骂的人。<br>很多人我没有去回，可每一条评论，我都有用心看，用心的去感受。<br>大家都是真佛，看似我度众人，实则众人度我。<br>深深感激，合十。</p>
<p>这里，也是本答案中，我未曾提到的第四关。<br>可惜，却是不能再讲了。<br>各位若有机缘，能来此处，自会明白的。</p>
<p><strong>一是一切，一切是一。</strong></p>
<hr>
<p><em><strong>转载自 <a href="https://www.zhihu.com/people/yuan-chong-76/answers">灵天赐的回答</a></strong></em></p>
<hr>
<h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><p>这是内修之路的一份藏宝图. 提纲挈领, 详略得当. 指明了不同阶段的路标, 潜坑, 探宝要点. 这么一份藏宝图, 若非过来之人, 绝不可能写的如此逻辑清晰, 层次分明, 轻重缓急, 信手拈来. 不敢说他一定走到了终点, 但已远远超出绝大部分的修行人. 元吾氏卡在了”末后牢关”.</p>
<ol>
<li><p>初关, 明心</p>
<ul>
<li>要点: <strong>观察</strong><ul>
<li>方法诸多, 不一而足, 建议南传佛教.</li>
<li>细分步骤: 先修定, 再修慧, 定慧同修.</li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
</ul>
</li>
<li>潜坑: <strong>水滴石穿</strong><ul>
<li>即没有捷径, 确定方法后, 下苦功即可.</li>
<li>其实有一个更大的坑: 方向的错误! 内修之重点在于实修, 而非学和知.</li>
<li>少花时间(用脑)看书, 多花时间(用心)实修.</li>
</ul>
</li>
<li>路标: 知道 <strong>情绪, 从哪来?</strong>; <strong>脑海中, 一念起, 一念落, 二念之间的那道‘空白’, 究竟是什么?</strong>; <strong>‘心’是什么? ‘心’在哪?</strong><ul>
<li>这个知道, 不是思考的知道, 不是逻辑的知道, 不是知识的知道, 是亲证的知道.</li>
<li>就像一种技能, 如开车游泳. 会了就是会了, 知道就是知道. 不会之前, 再怎么智商超群, 逻辑清晰, 辩才无碍, 也还是不会.</li>
</ul>
</li>
</ul>
</li>
<li><p>重关, 见性</p>
<ul>
<li>要点: <strong>诚心, 愿心, 决心, 善心, 真师, 天师</strong>, <strong>让心彻底柔软下来</strong><ul>
<li>若时机成熟, 发愿带着诚心, 登门顶礼请灵天赐带一程路.</li>
</ul>
</li>
<li>潜坑: <strong>六者, 缺一不可</strong>, <strong>烦恼即是无上菩提, 人世方为究竟道场</strong>, 勿要在道离道, 又去求道.<ul>
<li><strong>六者, 缺一不可</strong> 的结论存疑, 毕竟样本太小, 而且有反例.</li>
<li>暂时认为, 此六者, 对”多数”实修者, 是通关的必要条件.</li>
</ul>
</li>
<li>路标: <strong>惊讶发现, 原来, 自己从未有一日, 真正离开过家.</strong><ul>
<li>以下描述, 咨询过灵天赐本人, 属于重关的路标.</li>
<li>&lt;道德经&gt;: 有物混成，先天地生。寂兮寥兮，独立不改，周行而不殆，可以为天下母。吾不知其名，字之曰道，强为之名曰大</li>
<li>元吾氏: 一个无限/不生不灭的自由意识（Freewill/神Spirit）有着无穷无尽的自发幻想，其景象就是无数多样的宇宙和万物及各自的规则和不规则。</li>
<li>C Hilbert: <a href="https://zhuanlan.zhihu.com/p/67670425">宇宙，世界，一切的意义和真相是什么？</a> 部分触及到了重关的路标.</li>
<li>确认了我的一个疑惑: 这个就是终极真相? “开悟”? 结论是, 继续保持疑惑…</li>
</ul>
</li>
</ul>
</li>
<li><p>末后牢关, 无我</p>
<ul>
<li>要点: 对自己的修行, 做到了100%真诚; 对一切异见保持真正开放的态度.</li>
<li>潜坑: 突破重关的人, 会100%的确信无疑, 他是‘开悟’了. 这是一道‘隐形的门’.</li>
<li>路标: <strong>开悟, 并不存在.</strong>, <strong>你所以为的这个‘你’, 是不存在的.</strong>, <strong>我</strong></li>
</ul>
</li>
<li><p>临别语</p>
<ul>
<li>这些东西，本已脱离大脑思辨的领域. (逻辑无用!)</li>
<li>开悟，并非某种耗费一生去艰难求取，也难以获得的梦幻状态。</li>
<li>若将修行比喻为爬山， 山下的看不清山上, 山上的能一眼看穿山下的.</li>
<li><strong>初心</strong>，最初见地中任何最微小的偏差，也会生出截然不同的果。</li>
<li>法不轻传，道不轻授，很重要。 (小我的学习和伪装能力太强, 成为公开知识有害无益)</li>
<li>禅宗修行，佛挡杀佛，神挡杀神, 最后，连这个‘自己’，也是要一刀宰杀干净的。</li>
<li>禅宗收徒，不收钱，只收‘诚心’一种学费。</li>
<li>第四关: <strong>一是一切，一切是一。</strong></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>与神对话读后感-矛盾与困惑</title>
    <url>/2021/01/28/2101-confusion/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
<li><a href="https://draapho.github.io/2021/03/05/2107-tuibeitu1/">万年歌, 马前课, 梅花诗, 推背图 (上)</a></li>
<li><a href="https://draapho.github.io/2021/03/18/2108-tuibeitu2/">万年歌, 马前课, 梅花诗, 推背图 (下)</a></li>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/26/2123-caseofsatori/">见性者体验收集</a></li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一路追寻着世界是什么样子的, 人类会走向哪里, 自己是谁之类的问题. 先是求助于科学, 发现物理界梦寐以求的大一统理论, 却对人文世界无能为力且毫不关心. 一个简单的推论: 物质世界包括人类, 如果不能预测人类行为, 哪来的自信说什么大一统, 科学也不过是一种认知世界的方法, 不等于正确, 不等于真理. 于是开始研究人性, 研究政经哲史. 再由于生活上的无法忍受的焦虑, 又开始接触灵修和宗教, 抱着开放的心态, 尝试着做了一些冥想, 确实有效果. 但科学的方法, 逻辑思辨依旧是我判断选择分析的本, 或者说是锚, 有明显的利益关系或逻辑矛盾的文字, 我会采取不信任的态度不予采纳.</p>
<p>因为这种批判的怀疑的阅读, 在读大多数灵修类的书时, 有一种深深的困惑感和排斥感, 他们只要一提到现实世界里的问题, 解决方法就是满口的美好世界, 只要人人爱-爱-爱, 世界就会变得更美好, 这说了等于没说. 这种感觉, 读&lt;新世界：灵性的觉醒&gt;有之, &lt;与神对话2,3&gt;第一遍读的时候直接就跳着看了. 元吾氏的文字初看有点狂傲, 但有其内在的逻辑性和合理性, 我反而比较容易接受.</p>
<p>被人再度推荐之后, 再读&lt;与神对话&gt;系列, 这种深深的内在矛盾感依旧让我非常难受, 因而有了此文.<br>但这个文章不是用来评判他人对错的, 只是记录一下自己当下矛盾和怀疑的心态, 前面强调了, 我目前依赖的还是开放包容的科学逻辑分析, 觉得不合理的就要去质疑, 而不是无条件地相信. 尽管 明心见性/开悟 是那么的美好, 世界的真相比自己的一切想象还要友善: 是回家啊! 是体验共享啊! 但对这些人的话语和期望, 于我而言, 必须放到普通人的体验范畴面前, 对他们的言行进行客观的观察和评价, 而不是无条件的相信. 毕竟基于自身体验的言行, 都可以说是先入为主的, 更何况他们的这些特殊体验, 世人鲜有能共情的.</p>
<h1 id="真知灼见"><a href="#真知灼见" class="headerlink" title="真知灼见"></a>真知灼见</h1><p>&lt;与神对话&gt;中的一部分话语, 那么地充满真知灼见, 完全能和道德经, 心经, 金刚经的内容对上.譬如:</p>
<ul>
<li>对传统基督教的解构和否定, 破坏了一个旧世界, 旧观念.</li>
<li>神圣的二分法, 神的困境. (讲的非常透彻了, 讲法也和道德经/佛教思想类似. )<ul>
<li>矛盾的事物和谐统一的同处一处.</li>
<li>在绝对界域, 一切所有都是本是, 应是. 不证自明的, 毫无道理的. (原书用的是”爱”, 主观性太强了)</li>
</ul>
</li>
<li>生命（生活）是一单一事件宇宙中当下此刻正在发生的事件。一切都正在发生, 在一切的地方…… 没有“时间”，只有此时。没有“空间”，只有此处 …… 此时与此处就是一切.<ul>
<li>无处须去，无事须做，除了做现在的自己的以外, 你无须去做任何多余的事.</li>
<li>真相是：并没有什么旅程。你是你想要做的人，你现在正处在你想要去的地方.</li>
<li>每一刻都结束于它的开始之际。(明心需要观察到的现象)</li>
</ul>
</li>
<li>好吧。那这本书又怎么样呢？这本书总真正是真的了吧.<ul>
<li>我很不愿意对你这样说，但我还是要说：这书是透过你的过滤器而出现的。我承认，你已成为非常好的过滤器。但你仍只是过滤器.</li>
<li>因此，不要去“试图相信”你可以做这样的事情，而应试图走向完全的觉察状态。那时，就不需要相信。完全的认知会自现神迹.</li>
<li>不；你不能用相信（ believe）的。你只能知晓（know）它</li>
<li>(这里是全书中, 为数不多的”神”的自我否定, 不需要无脑的”相信”, 而是去行动, 去亲证. )</li>
</ul>
</li>
<li>如果你必须向别人表明来证明你是神，则你就还不知道你是. 神不求对任何人证明它自己，因为神没有这个需求。那些知道自己与神为一的人，或在自己之内体验到神的人，不需向任何人证明，更不需向自己证明，因而也不会去寻求如此去做.<ul>
<li>开悟了的人, 不会说自己开悟了.</li>
<li>类似于扶贫先扶志吧. 开悟者知道直接给期望的结果不但没有帮助, 反而有害. 因而只能不断的提供”致富”的思想和机会. 有些扶不起志的人就会攻击说: “你那么富有, 你倒是直接给钱啊, 省事又方便”.</li>
</ul>
</li>
<li>任何事物，当你了解它不是真的时，它就不致让你痛苦.<ul>
<li>就像是一部电影，一场戏，在你的心灵舞台上上演。际遇是你创造的，角色是你创造的。剧本是你写的.</li>
<li>这是对象，是观察者，卷起合而为一了。</li>
<li>它们从来就不异于一. 是你们把它们展开, 以便生活可以在你面前展开.</li>
<li>发自内心的接受, 包容. 世界本就是这样, 不求更多, 无需更少. 不贪求不缺憾.</li>
</ul>
</li>
</ul>
<h1 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h1><p>在行为上的提示也是非常有帮助的, 这个可能需要一些信任, 但好在尝试验证起来也不难. 譬如:</p>
<ul>
<li><strong>BE-DO-HAVE,  是-做-有, 意念-行动-体验</strong> 范型. 这个需要重点讲一讲.<ul>
<li>大部分人的观念是完全反的, 即 “有-做-是”, 必须先有了钱/时间/对象, 才能创业/锻炼/恋爱, 最后体验创业的成功/健康的身体/幸福. 这种范型, 基本只能收获缺失感.</li>
<li>中国传统观念更喜欢强调 “做-有-是” 范型. 这非常困难, 但坚持下来也能成功, 属于事倍功半的选择.<ul>
<li>你可以要求你的身体去做你的心所不相信的某件事而如果你的身体去做此事的时期够长，你的心就会开始将它对此事原先的想法改变，而创造另一种新想法，你就走上一个历程，将此事物创造为你生命中的一个永久面向，而不仅仅是你做出来的某种事物.</li>
</ul>
</li>
<li>使用 <strong>是-做-有</strong> 范型的:<ul>
<li>埃克哈特.托利在&lt;新世界: 灵性的觉醒&gt;中提到, 买彩票付房租.</li>
<li>威尔斯·威尔德的&lt;亚当理论&gt; 中吉姆的买房经历以及工作方式.</li>
<li>乔希·维茨金的&lt;学习之道&gt; 大量的”意念”式的学习和练习. 大量的自我暗示.</li>
<li>如果无法违心的暗示自己 “是”, 那就改为 “正在”, 进行心理暗示. 不要用 “想要” “会” 这种未来的时态.</li>
<li>假装有钱, 购买奢侈品, 获得暂时的满足感. 这是自欺欺人, 你自己知道仅仅购买这个动作, 是无法触发有钱这个结果的.</li>
</ul>
</li>
<li>心诚则灵, 不是妄言. 但要心诚却非常难, 很多信徒虽然按要求做很多善事, 但心并不诚, 他们是有求的心(典型的, 求来世). 真正的心诚, 是不强求结果的.</li>
<li>知不是随体验而来 – 知先于体验. 强调了我们是故意忘记了所有的知识, 以便获取体验.</li>
<li>你的一生, 并不必须去做任何事. 全部的问题只在你是什么.<ul>
<li>神性层面认为自己是什么, 就来体验什么, 就会拥有什么. 人生的目标, 由神我预设, 由做来达到或改变目标, 收获的是体验.</li>
</ul>
</li>
<li>巴夏视频中, 也着重强调了这种范型. 但估计大多数人看巴夏更像神棍, 他超喜欢预测, 没一次是准的.</li>
</ul>
</li>
<li>如果你现在处在一个群体中, 此群体的意识又不能反映你的意识, 而你在此时又还不能有效的改变这群体意识, 则离开此群体乃是明智之举, 不然它会带著你走。它会走向它要走向的地方，而不管你要不要去. (群体意识自有惯性, 在内心和外在冲突时, 要遵循内心的渴望和指引)</li>
<li>让每个灵魂走自己的路. (尊重他人的体验和选择, 不要随便评判对错.)</li>
<li>学会尊重和接受别人所做的选择. 耶稣不要求别人接受他的更高想法，而仅仅是邀请.<ul>
<li>因为耶稣知道，对某些人来说，通往他们是谁的最快途径乃是通过他们不是谁.</li>
<li>释迦摩尼在这方面做的更”过分”, 第四次”放任”了琉璃王大军对自己祖国的进攻.</li>
<li>做任何事, 尽可能换位思考, 然后做到问心无愧即可. 在巨大冲突矛盾中, 理性已经接近崩溃, 只能用直觉行事了, 此刻最终的选择最能代表自己是谁, 体验了什么.</li>
</ul>
</li>
<li>你们是身、心、灵的合一体。这既是你们的荣耀，也是你们的奇妙。因为你们往住同时在这三个层面做決定和选择一一而又并非相合无间。你们常常身体要某一事，心寻求的是另一事，灵渴望的却是第三种。这种情況尤其在孩子身上可以看到，因为还没有成熟到足以分辨哪些是对身体“好玩”的事，哪些是对心有意义的事，更不用说哪些是跟灵共鸣的事了。你们的选择互相冲突, 身、心、灵不是一体运作. 创造历程就在所有的层次同时运作，产生混杂的结果。如果你的生命是和谐的，你的选择是一致的，则令人惊奇的成果便会产生。<ul>
<li>痛苦和矛盾往往来自于身、心、灵的不和谐.</li>
<li>当身心随着贪嗔惯性般的依赖原有路径时, 砰地一声撞到痛苦之墙, 此时就给了自我一个反思和改变的契机.</li>
</ul>
</li>
<li>你们死时的意识是什么, 你们就经验到什么<ul>
<li>相信地狱, 便体验地狱. 相信天堂, 便体验天堂.</li>
<li>佛教比较通透: 哪有什么佛祖恶魔, 天堂地狱, 一切皆幻相!</li>
</ul>
</li>
<li>为了有意识的实行你的新观念，最重要的途径就是去做你的经验的原因，而不是承受你经验的后果。要知道，为了知晓和体验你真正是谁、你选择是谁，你并不必须在你个人的空间或个人的经历中，创造跟你是谁相反的东西.<ul>
<li>佛祖试图阻止灭国战争三次, 但失败了, 但真的失败了吗? 从现实世界看, 是的.</li>
<li>但从更高角度看, 他们的灵魂经受了考验, 坚决不自己打自己, 从而, 升华了, 去体验更高的层次了.</li>
<li>当理想与现实冲突时, 不同的选择. 逃避逍遥? 委屈隐忍? 出卖理想顺从现实? 矛盾困惑?</li>
</ul>
</li>
<li>最后要注意的是，不要试图“摆脱”任何东西。凡你抗拒的(ress), 就会坚持(per”sist)。当下接受, 承认, 就会慢慢消融.</li>
<li>到底应该先有信念, 还是先有观察? 那才是问题的中心!!! …科学的结论说，没有任何被观察到的东西是不受观察者影响的…观察的局限性: 你看见的是你所想看见的! 忽视了不想观察到的东西.<ul>
<li>即不盲目相信理论/信念, 也不盲目相信观察. 这是个本位问题, 用科学的精神和方法, 相互促进.</li>
<li>顺便一提: 当下的物理界走上了先射箭(理论先行), 再画靶(查找现象)的道路. 这和宗教创造一套理论, 再用个例来证明, 有本质上的区别吗?</li>
</ul>
</li>
</ul>
<h1 id="自相矛盾"><a href="#自相矛盾" class="headerlink" title="自相矛盾"></a>自相矛盾</h1><p>但另一个方面, 作者绕来绕去, 又在反复强调宗教的爱, 只有爱能解决一切问题… 而且举的例子基本没有一个是科学承认无疑异, 简直就是听说过什么, 大差不差就拿来当论据了. 这种看着很有启发, 看着看着又发现逻辑无法自洽, 自相矛盾的书, 真是头疼. 而灵性类的书, 往往具有这种特点. 灵修类的书籍在这个节点上, 大声疾呼的本意当然是好的, 但给出的解决方案: 爱-爱-爱, 真的是让我看的有点可悲. 但凡研究过一下政经哲史, 学过一点囚徒困境和博弈论, 就会知道, 还有七情六欲比较心的人, 真去执行, 就会害了人家而非帮助人家. 因为真信了, 现世报的结果必然是吃亏, 越信越吃亏, 由于得失心尚在, 绝大多数人是放不下这种吃亏的感觉而泰然处之的.</p>
<ul>
<li>如 &lt; 山居性纪:性是种子禅是花开 &gt;, 作者已明心见性. 但主观上明显对中国传统文化有袒护之心, 居然将日本的经济腾飞归因于禅道文化的良好传承. 事实是美国当时需要利用日本对苏联和中国进行地缘包围, 因而对其进行了大量的投资, 是地缘政治的因素决定了日本和亚洲四小龙的经济腾飞!</li>
<li>如 <a href="https://www.youtube.com/watch?v=Mn4SRwwh5L0">萨古鲁TED自述他的开悟经历</a>, 他讲的万物同体经验我完全相信, 对于他的理想, 没有任何嘲笑的意思, 我只能说比较理想主义. 他的想法和行动的核心内容是:”如果我们的领导人也有这种万物同体的感受, 那他就一定会爱每一人, 社会一定会变得更好”. 显然, 他不清楚权力的来源. 权力来源于他人的认同, 他人的认同来源于当权者符合他人的期望和利益. 如果领导人的行动不符合他手下一帮人的利益, 集团就会从内部分化. 这也是为什么&lt;让子弹飞&gt;中, 理想主义的张牧之必然会被一起出生入死的兄弟们背叛. 当然萨古鲁在用实际行动践行自己的理想, 以他的修为, 结果不重要, 过程最重要.</li>
<li>&lt;与神对话&gt; 里, 举例的随意性:<ul>
<li>有极为先进的科技, 没有先进的思想, 导致毁灭. 举例是亚特兰蒂斯, 学术界高度存疑…</li>
<li>强调母系社会的存在和美好, 学术界存疑…</li>
<li>环境问题的举例: 广泛种植大麻…</li>
</ul>
</li>
<li>&lt;与神对话&gt; 里, 对爱的误用和偷换概念, 及其它相互矛盾的说法:<ul>
<li>作者对爱的定义: “爱，是那没有限制的。它没有始，也没有终。没有前，也没有后。爱永远是（存在）：现在是，过去是，未来是”… “所以爱也是永远，它是永远的实相”…”爱没有要求. 这就是爱之所以为爱”<ul>
<li>正常的爱: 恨的反义词, 有恨才有爱. 作者整个就是重新定义了一遍爱. 然后反复强调”爱”的重要性.</li>
<li>把句式中的爱, 替换为 神/道/一/真理 任何一个想强调的词汇, 没有任何问题!</li>
</ul>
</li>
<li>你们无法忍受神对任何人的爱都不特别，因此便发明了虚构的想像，认为神只为了某些理由而爱某些人。你们把这种虚构的想像称为宗教。我却称它为亵渎。因为任何想法若以为神对某人的爱多于另一个，就是虚妄的.<ul>
<li>无区别的爱, 没比较的爱, 怎么体现出爱? 爱这个概念, 天然的就有比较关系在里面.</li>
<li>道德经多直接, 这个神, 也就是天地. “天地不仁, 以万物为刍狗”.</li>
</ul>
</li>
<li>然而我告诉你们：我的爱是没有限制的，没有条件的.<ul>
<li>等同于, 你们都不特别, 神无所谓你们中特别的一个.</li>
<li>因而, 战场上以爱的名义, 相互残杀, 神不爱不恨不惋惜不救助. 需要的只是千种万般的体验.</li>
</ul>
</li>
<li>然而，你们的“基本本能”不是生存，而是公正、合一与爱。这是一切处所、一切有情众生的基本本能。这是你们的细胞记忆。这是你们的天性….. 你们基本天性不可能是“邪恶”的本能与天性.<ul>
<li>屁股放在现世的生命感受中, 从实际共同的经验出发, 从植物到动物, 都在相互”竞争”之中, 获得更多的资源, 从动物交配中, 从大自然中. 资源是增量的, 可以合作共赢; 资源是存量的, 竞争生存. 资源是减量的, 相互伤害.</li>
<li>一切皆神/我, 为合一. 因为体验合一, 没了分别心, 是为公正. 但公正/合一也只是一个瞬态, 而非永恒. 万物合一的当下, 立刻就自己摔个粉碎, 从一个个最底层, 最自私的我, 慢慢获得体验, 获得回忆.</li>
</ul>
</li>
<li>凡是忽视了我们一体性的意念，凡是将我们分别的观念，凡是宣称我们并非一体的行为，都是”幻相”。“另一队”不是真实的存在，而是你们实相的一部分.<ul>
<li>扯淡. 都是幻象, 或者都是实相.</li>
</ul>
</li>
</ul>
</li>
<li>我对&lt;与神对话&gt;系列的评价:<ul>
<li>是有益的突破, 是有害的新宗教.  他以人类存续为目的, 打破了一个旧宗教, 却潜藏着一个新宗教, 这是一种执念, 执念是船, 是工具. 如果利用了执念, 最终没有告知这是执念, 没有告诉大家这只是船, 你们要把执念放下, 把船砸个稀烂. 那他的理论就可以被统治者轻易利用, 就是屠龙者成恶龙的故事.</li>
<li>作者只是抛弃了一个他自己不喜欢神(有奖惩机制的神), 选择了一个他喜欢的神(慈爱的, 宽容的神). 奉劝大家, 要信任后面一个”真神”. 他终究, 是没把”神”请下神位.</li>
</ul>
</li>
<li>第二种范型转移 - 精神转移, 也就是灵性的觉醒.<ul>
<li>这要发生的话, 就是一次新的”文艺复兴”. 至少是资本主义走到极值, 崩塌. 权力走到极值, 崩塌. 整个人类旧信仰崩溃, 从文化废墟上新生而出.</li>
<li>以千万年来叙事, 告诉别人会有全人类灵性的觉醒这么一天的, 没任何意义. 我们都知道太阳会燃尽, 但这不是普罗大众会去担心的事情.</li>
</ul>
</li>
</ul>
<h1 id="理论启示"><a href="#理论启示" class="headerlink" title="理论启示"></a>理论启示</h1><p>还有一部分, 对我认知更宏大世界的理论框架也有很大的帮助和启示. 譬如:</p>
<ul>
<li>灵魂的惟一愿望是，把对自己最大的理念变成最大的体验. 在此之前，所有的只是玄思默想. (诸相非相, 皆为幻相)。</li>
<li>醒是此一意识被唤醒，万有的各个层面觉察到其本身实实在在说，那真的是自我意识 … 然后，渐渐的，它意识到所有别人，然后，意试到没有别这一事实-一切都是同一个 … 最终，是辉煌灿烂的我 (这段描述和终极真相, 回家的感觉有点相似)</li>
<li>由于灵魂（神）的最大欲望，就是体验它自身为创造者，又由于一切都已被创造，因而除了找一条路忘掉一切我们的创造外，我们别无选择.</li>
<li>藉由你们，我体验我是谁，我是什么. 若非你们，我可以知道，却不能体验到. 知道与体验到，是不同的东西. 我会时时都选择体验, 我真的这样做–藉由你. 这乃是神成为神的行为。这乃是我成为我一-藉由你. 这乃是一切生命的意义.<ul>
<li>于我而言, 这一段回答了各个面向的问题, 我是谁以及存在的意义, “神”的目的.</li>
</ul>
</li>
<li>生命中的一切都只是视角的问题。如果你能继续看清这个真相，你将开始领会到神的宏观真相, 会解开整个宇宙的奥秘：一切都是同一回事……如果你们能够记得这个真理一一你们的视角创造了你们的意念，而你们的意念创造了一切如果你们在脱离肉体前记得这个真理，而不是在脱离之后，则你们整个的人生都将改变. 而要控制你的意念之路，就是去改变你的视角.<ul>
<li>因而, 无所谓是非对错善恶, 无本可位, 特定的观察角度, 产生本, 进而产生阴阳之位.</li>
<li>屁股决定了脑袋. 观察角度决定了相对观念.</li>
<li>切换视角后, 能有全新的理念在科学界非常之多:<ul>
<li>从坚持地心说而不得不采用的”均轮”和”本轮”, 到易于理解的日心说.</li>
<li>从经典物理学的绝对时空观, 到相对论的绝对光速.</li>
<li>傅里叶变换, 将震动信号在时域和频域之间转换. (如果万物皆震动, 那时间也只是由观察方法带来的一种属性, 转换视角就可以不存在时间, 万物已存在, 正存在, 将存在).</li>
<li>欧氏几何-&gt;非欧几何(罗氏几何/双曲几何, 黎曼几何/椭圆几何). 数学界先有本, 后有位. 故而本一变, 位全变.</li>
</ul>
</li>
</ul>
</li>
<li>如果灵魂以人的形态回来，那总是由于要更进一步体验，演化。人类本身就有许多演化层次，这是可以观察与证明的,一个灵魂可以回来千百次，而仍继续向上演化。然而这向上的，这灵魂最大的渴望，是不能由回到较低的生命层次而达成的. 因此，这样的回返是不会发生的。在灵魂和“一切万有”达成最终的重新结合之前，这是不会发生的.<ul>
<li>灵魂是在完美的状态下, 直接失去所有, 降到最底层, 再慢慢往上累积体验, 回到完美的状态.</li>
<li>可以解释 <strong>博弈论的不对称性问题</strong>. 即善恶不对等问题.<ul>
<li>假设一个群体全部是”善的合作”, 那么只要有一个人变为”恶的自利”, 立刻可以获得额外收益.</li>
<li>假设一个群体全部是”恶的自利”, 那么至少需要二个人以上同时愿意”善的合作”, 才可能获得额外收益.</li>
<li>因而, 纯理性的逻辑角度考虑, 产生了善恶不对等问题, 整个体系更容易向”恶的自利”发展, 最终推导就是人人自私自利. 但事实上并非如此.</li>
<li>万物的本性都隐约记得”万有合一”, 且由于演化上的”向上”, “善的合作”的比例会越来越大.</li>
<li>而到了”极善”之后, 立刻”将自己摔个粉碎”, 忘却合一, 来到”极恶”的状态, 再慢慢地回复到”极善”. 周而复始.</li>
</ul>
</li>
</ul>
</li>
<li>试把宇宙之轮想像为光碟机。所有的结局都已存在。宇宙只是街头看你们这一次选择什么。而当游戏结束，不管你是输、是赢宇宙都会问你：“要再玩一次吗?”<ul>
<li>开放式的游戏体验: 速度自己选, 路径自己选, 感知强度自己选.</li>
<li>创造的含义: 是观察角度的创造. 不同的身份, 不同的频率, 不同的路径, 造成不同的体验. 而所有可能的结果, 都已预设其中.</li>
<li>因而: 所谓因果律, 是路径问题. 如果路径是一个回环, 就会由果得因.</li>
<li>“路径” 也很可能不是固定不变的, 而受到观察/被观察的影响.</li>
<li>这个假设, 直接解释了开悟者无所谓人类存亡的态度, 因为没什么需要改变的, 只是每个”我”的选择不同.</li>
<li>可以参考 <a href="https://writings.stephenwolfram.com/2020/04/finally-we-may-have-a-path-to-the-fundamental-theory-of-physics-and-its-beautiful/">stephen wolfram theory of everything</a>, 用简单的规则替换, 不断的重复, 就能构建出不同的图形. 重要的是, 这个模型在底层设计上, 符合观察者-被观察者模式.</li>
</ul>
</li>
<li>永恒时刻包含所有“可能的各种可能性”。</li>
<li>天才并非创造答案的人，而是发现答案已然在那儿的人。一个天才并不创造答案，是发现答案.</li>
<li>你是生命与道路。世界将跟随你。这件事由不得你选择。这是唯一你不能有自由选择的事它就是那样。你对你自己的理念如何, 世界将跟随。一向如此，永远如此。你对你自己的意念在先，外在世界的物象表现随之.<ul>
<li>如果一个路径代表一个自认为的”我”, 那就是同一时刻有无数个”我”, 再体验所有的可能性.</li>
<li>“我”的改变, 到底是否能改变集体的幻相路径? 存疑. 根据假设: 人类灭绝和人类度过环境危机的结局同时存在.</li>
</ul>
</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>到底哪边是现实, 哪边是幻想, 到底谁处在信息茧房中? 亦或是都对, 只是观察角度不同, 时空概念不同, 从而结论也就不同?</p>
<p>我, 作为一个普通人(没有特异功能, 没有任何异于常人的体验, 没有明心见性), 在对这个可观察世界的尽可能客观的观察分析后 , 需要在此把这些感受写下来, 把这些困惑和矛盾写下来. 然后才能放下这些困惑, 继续在灵修上前行, 去追求亲证. 如果忘了这些感受, 跳过诸多的步骤, 直接告诉大家世界是美好的, 要大家相信世界是美好的 – 那等同于以自己亲历的主观感受, 讲了一个大多数人无法理解和认同的理念,  那和”何不食肉糜”又有什么本质上的不同?</p>
<p>就普通人可观察理解的世界而言, 分析历史, 分析政治博弈, 分析统治手段后, 我的结论是: 这是一个以人性的贪婪和恐惧为基础, 以枪杆子威胁, 以钱袋子诱惑, 以笔杆子洗脑, 相互博弈而来的一个弱肉强食的世界. 枪杆子和钱袋子利用的正是人性中最根本的恐惧与贪婪; 枪杆子能剥夺你已有的, 钱袋子能给与你更多的; 笔杆子来洗脑, 形成道德和文化, 使得权力/资本的交接有了惯性, 有利于低成本的提供社会稳定性, 形成这种惯性后, 笔杆子更可以部分替代枪杆子和钱袋子, 对人进行予取予夺.(集体主义文化中的荣誉感, 耻辱感. 宗教主义文化的天堂地狱轮回说. 消费主义文化中的笑贫不笑娼, 物质攀比).</p>
<p>在接触了解了宗教灵修后, 也必须承认, 极少部分人修身养性去掉了贪嗔痴疑慢的, 但比例太少, 基本不对世俗世界构成影响, 这类人也不太关心政经界的博弈法则, 更无意先适应后改变这种法则; 同样不可否认的是, 绝大部分人内心是向往被包容, 被理解, 被博爱的. 我相信, 这种天然的需求来自于那个”万有”, 我之前的结论忽略了这个基本属性, 有了这个属性, 才能解释为何有那么多的理想主义者. 但在权力和资本博弈的最中心, 这种需求也是靠边站的. 因而当下的世界, 只要抓住主要矛盾: 阶级矛盾, 权力和资本的斗争, 国与国之间的发展走向和对应措施, 是可以通过博弈论分析出潜在的各种走向的.</p>
<p>目前全球是资本主义世界,  核心矛盾是资本分配问题. 只有让资本主义发展到极致, 资本主义才会灭亡. 从这个角度看, 马克思的资本论是极大延长了资本主义的. 资本主义的龙头国家是美国, 美国不倒, 资本主义不死. 而美国目前只是盛极而衰的阶段, 离完全倒塌尚有时日. 资本vs权力, 由于资本天然的见利忘义属性, 资本必败. 中央集权的龙头国家是中国, 兴百姓苦, 亡百姓苦, 权力模式不变, 中国就不会走出历史周期律. 只是当下世界, 资本更为强大, 因而权力在利用民意对抗资本的侵蚀, 人民群众也寄希望于通过集权的方式, 选出政治强人去解决日益疯狂的资本. 那权力胜利之后呢? 如何解决权力分配问题? 中国不倒, 中央集权不亡. 在全球或和平或武力统一之前, 阶级/国家/信仰/民族矛盾将混杂着影响这个世界的走势. 这是历史的惯性, 这种巨大的惯性, 是不以个人的意志为转移的. 个人身在其中, 可以有自己的选择, 却很难改变什么. 即时势造英雄, 而非英雄造时势. 而资本的趋势和权力的趋势, 我实在是看不出百年之内有什么改变的契机. 境随心转, 个人周边的事物较容易做到; 但我理解不了一个群体性的境又如何随个人的心而转呢? 像玩游戏一样, 死后直接跳出这个世界? 选一个自己喜欢的和平世界体验?</p>
<p>综上, 我只能在矛盾中前行, 信自己判断分析后相信的修行方法, 去亲自实践验证. 通过此文的分析, 对于人性我倒是多了一份理解和希望, 除了贪嗔痴疑慢, 还要加上一个自己遗忘了的终极目的 – 体验”合一”.</p>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>修行总领——明心见性</title>
    <url>/2021/02/13/2104-satori/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
<li><a href="https://draapho.github.io/2021/03/05/2107-tuibeitu1/">万年歌, 马前课, 梅花诗, 推背图 (上)</a></li>
<li><a href="https://draapho.github.io/2021/03/18/2108-tuibeitu2/">万年歌, 马前课, 梅花诗, 推背图 (下)</a></li>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/26/2123-caseofsatori/">见性者体验收集</a></li>
</ul>
<p><em><strong>转载自 微信公众号 禅医堂 灵天赐 <a href="https://weixin.sogou.com/weixin?type=2&s_from=input&query=%E4%BF%AE%E8%A1%8C%E6%80%BB%E9%A2%86%E2%80%94%E2%80%94%E6%98%8E%E5%BF%83%E8%A7%81%E6%80%A7">修行总领——明心见性</a></strong></em></p>
<p>另见作者最早在知乎的一篇回答, 由于两篇文章有诸多分别, 我都转载了. 见<a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></p>
<hr>
<p>真修自求自印，假修外求外印；<br>有感禅宗衰微，邪知邪见盛行；<br>以下，皆为禅宗以心传心之秘。<br>顺应时代发展，在此无私分享给诸位实修实证的求道者。</p>
<p>若无实修实证，或未到所言之处的修行者。只会‘自以为’能懂。<br>事实上，绝无可能真正理解。<br>大脑领域以外的存在，注定无法用大脑理解。<br>若是真修，有此缘法，勿要自大，心生我慢，以至此文，明珠暗投。</p>
<h1 id="起"><a href="#起" class="headerlink" title="起"></a>起</h1><p>禅宗开悟，需过三关：<br><strong>初关——明心</strong><br><strong>重关——见性</strong><br><strong>末后牢关——承担</strong></p>
<h1 id="初关——明心"><a href="#初关——明心" class="headerlink" title="初关——明心"></a>初关——明心</h1><p>何谓明心？<br>明心，即知‘心’之所在。<br>想知‘心’之所在，必苦炼<strong>‘观察’</strong>。<br>何为<strong>‘观察’</strong>？<br><strong>‘观察’</strong>即时时刻刻知道，自己正在想什么？自己正在做什么？自己正在起何种情绪？<br>常规所见的四念住、日夜念同一句咒语、数数字、数呼吸、数佛珠等诸般法门，只是为了收束心念，凝聚意识强度，增强意识敏感度。<br>本质上，是为了增强<strong>“观察”</strong>力。<br>使常人平日里飘忽散逸，被外物牵引的意识，全部集中起来，逐渐意识到曾经的自己，有多么‘失控’。<br>‘看见’常人看不见的现象，‘察觉’常人察觉不到的思绪。</p>
<p>常人意识，为一无法自主的提线木偶。<br>自认为客观理智自由，实际被各类后天知见、欲望、情绪等外物操纵，毫无半点自由可言。<br>随着观察力的持续锻炼，意识清晰度的不断提高。<br>个人将逐渐体察，脑内一个个念头的飞速起落，情绪不时在体内的上下翻涌。</p>
<p>这个阶段的修行者，应常思以下两问：<br><strong>1、情绪，从哪来？</strong><br><strong>2、脑中，一念起，一念落，二念之间的那道‘空白’，是什么？</strong></p>
<p>日常，对观察力的锻炼，积累得足够。<br>修行者，可找到一个‘入处’，安放顽心。<br>一道保护罩，将自己和外界隔绝。<br>外缘消散，无有恐怖。<br>实际上，这只是一道前菜。<br>出现后，细心保任。<br>一段时间后，感受会消失，令人怅然若失。<br>然而，此处不过路边一景。<br>看过即可，不值一提。<br>不少修行者，无过来人的指引。<br>至此处，反复沉浸于一时心景。<br>误以为这是‘开悟’，努力的想‘回去’，并试图‘保持’。<br>从此，止步不前。<br>捡了芝麻，丢了西瓜。<br>然而，经由此‘入处’，却可入手寻求‘心’之所在。</p>
<p><strong>‘心’是什么？</strong><br><strong>‘心’在哪？</strong></p>
<p>以上两问，为明心关卡的究竟之问。<br>无法用言语、文字、逻辑回答。<br>任何人脑想出来的答案，都是错误的。<br>只有真正见证，方能真正明白。<br>修行者，不断感受上面的两个问题。<br>继续让观察随时间，积累增进，逐日进步。<br>此处，乃水滴石穿的细腻功夫，无半分取巧可言。<br>一段时间后。<br>某一天，观察火候达到。<br>清晰地捕捉到，那一念起，一念落的瞬间。<br>水滴石穿的刹那，遁入了那丝‘空白’中。<br>当下顿悟：<br><strong>念头是念头，情绪是情绪，它们不是你。</strong><br>念头和情绪，是天空中飘过的白云；你，是白云背后那片无染蓝天。<br>这一刻，个人意识，全面升华。<br>之前，还需时刻提醒自己。<br>努力维持的不间断的‘观察’。<br>此后，‘观察’永远恒定，再不需刻意维持。<br>无论白天黑夜，无论现实梦境，清晰的‘觉察’，永恒随身。<br>仿若盲人，忽然睁开双眼。<br>整个世界，都生动活泼起来。</p>
<p>五祖弘忍，考验弟子。<br>神秀和慧能，因此留下的传世名偈。<br>在此，一并说破：<br><strong>《神秀》<br>身是菩提树，心如明镜台；<br>时时勤拂拭，莫使有尘埃。</strong><br>神秀认为：<br>人的身体是智慧觉悟之树，心仿佛放置明镜的梳妆台。<br>应要时时刻刻的擦拭打扫，不要让身心之中残留尘埃。<br>神秀的见地，未破初关。<br>他觉得，自己要去努力<strong>‘拂拭’</strong>。<br>因此，见地停留于磨练<strong>‘观察’</strong>的阶段，远未达到<strong>‘水滴石穿’</strong>的境地。<br>所以，五祖才会说：<br>若依此法修行，常人可不堕恶道。<br>但，依然不得门而入，无法获得无上菩提。<br><strong>《慧能》<br>呈自本心，不识本心，学法无益。识心见性，即悟大意。<br>菩提本无树，明镜亦无台；<br>佛性常清净，何处染尘埃。<br>又偈曰：<br>心是菩提树，身为明镜台；<br>明镜本清净，何处染尘埃。</strong><br>慧能的偈子分为三个部分，在此逐一阐释。<br><strong>呈自本心，不识本心，学法无益。识心见性，即悟大意。</strong><br>解：我下面写的这两首偈子，是我的本心自然呈现的，人如果不能认识到自己的本心，而去学习各种修行法门，是毫无助益的。如果，能识得本心，见证本性，便可领悟一切修行法门的本意。</p>
<p><strong>菩提本无树，明镜亦无台；<br>佛性常清净，何处染尘埃。</strong><br>解：智慧是无需树体支撑的，明镜也无需台子支撑，佛性是一直清净的，哪里会染上尘埃呢？</p>
<p><strong>心是菩提树，身为明镜台；<br>明镜本清净，何处染尘埃。</strong><br>解：心才是那颗智慧与觉悟之树，身体才是那个存放明镜的台子，明镜是心，心是本来清净的，哪里会染上尘埃呢？<br>六祖慧能当时的偈子，表明他不仅突破初关，彻底明心。<br>同时，也对<strong>‘性’</strong>也有了瞥见。<br>明白，心是<strong>‘本清净’</strong>的，佛性也是<strong>‘常清净’</strong>的，不会沾染尘埃，所以无需拂拭。<br>也是为何，五祖会让慧能，半夜入屋。<br>使其顿悟‘见性’之妙，及衣钵传承的奥秘所在。<br>初关的破关秘钥，只在三个字——<strong>“观察者”</strong>。</p>
<h1 id="重关——见性"><a href="#重关——见性" class="headerlink" title="重关——见性"></a>重关——见性</h1><p>人的心智，渴望攀援境界。<br>见过无数修行者，明心未到，急于要<strong>‘见性’</strong>。<br>甚至误以为，自己已经开悟，不退转即可。<br>讲见性之前，给诸位留下一个标准。<br>无论何人，均可以此标准，衡量自己是否完成明心的修行。<br>真正明心的标准，只有一条：<br><strong>每天24小时，时刻不忘不丢的“觉知”</strong><br>是的，每天的24小时中，少了哪怕一秒，也是不对。<br>无论做梦还是清醒，无论梦里是否还记得自己，都无法停止的“觉知”，方是踏入明心的标志。<br>也是禅宗修行中，第一个入门的门槛。<br>当然，常人会觉得不可能。<br>然而，修行本就行走于常人无法想象的未知领域，为不可思议之学问。<br>这，只是入门。</p>
<p>不少狂人，以为是涅槃，是开悟，是究竟。<br>闻听此处，当下忏悔，还来得及。<br>没明心的人，见性无从下手，不必过度奢求见性。<br>明心到见性的时间间隔，无论再短，也会有一个过程。<br>哪怕一悟到底，也须从明心入手，方可避免被相带走。<br>如今修行者，渴望瞬间开悟，究竟涅槃。<br>不去虚心求取，也无诚心问法。<br>不识本心自性，终究落于狂禅。</p>
<p>重关修行，只在三点：<br>诚心、真师、消融自我。<br><strong>诚心：</strong>秉持内心中最真诚的愿望，诚心诚意的求取正法<br><strong>真师：</strong>修行过来人的指点，言传身教，以心传心<br><strong>消融自我：</strong>时时刻刻于一言一行之中，不断消融自我，除去后天虚妄假我，先天本性自然现前<br>没有诚心的人，无法听闻正法，无法信任正法；<br>没有真师的人，陷入邪知邪见，难以醒觉自拔；<br>不去消融自我的人，被贡高我慢束缚，自高自大，自以为是，聋而不听，瞎而不见，邪知邪见，害人害己。<br>想快速的突破重关，不必逃避社会，不必遁入山林。<br>烦恼即是无上菩提，人世方为究竟道场。<br>勿要在道离道，又去求道。<br>处理各种矛盾，各种事件，直面痛苦，实为修行者进步的苦口良药，是消融自我的天赐良机。<br>真心是道场，真心是净土。<br>烦恼与菩提，本为一枚硬币的两个面向。<br>逃避烦恼，即是逃避觉悟。<br>直面烦恼，秉持真心，不断捶打，剔除自我，返还本来。<br>感触，不断深入。<br>如果，修行者走在正确的消融自我之路。<br>随时间推移，将切实的转变所在环境，及周围每一个人。<br>心能转境，心能转运，真实不虚。</p>
<p>任何方法，任何书籍，任何教派，都可一用，不受拘束。<br>智慧增长，逐步体认到以下四点：<br><strong>1、诸教同源<br>2、外界为心的投影，心变则境变，而非境变则心变。<br>3、一切烦恼，皆起于后天妄想<br>4、三心不可得</strong><br>多流泪，使心彻底柔软。<br>回忆幼时一切痛苦回忆，找出所有痛苦情景。<br>带入当下，忏悔和宽恕，倾倒出所有的垃圾。<br>释放埋藏于记忆深处，一切的仇恨、恐惧、情绪。<br>修行过程中，遭遇种种异相，种种暂时性的心景，不一而足，因人而异。<br>过了心景，一切会恢复正常，<br>最后，专注于不停的打击自我。<br>待功夫用尽，身清体净，诸缘聚合之下。<br>‘自我’失去喂养，越来越虚弱，越来越无力。<br>对心的遮蔽与操纵，越来越无法维持。<br>某个瞬间，由某个或普通、或古怪的契机。<br>便可一眼瞥见世界‘真相’。<br>此刻，即是无数人心中，念念不忘，无比神圣的‘巅峰体验’。<br>所谓——‘大彻大悟’。<br>虚空破碎、天地颠倒等等异相，在感知领域真实不虚的发生。<br>出现什么，因人而异，不一而足。<br>唯一特点，是这种强大体验降临的时刻，永远从内到外的改变一个人，使其脱胎换骨。</p>
<p>一股无比强大，充满震撼的磅礴能量。<br>自我消融，种种喜悦，无法用言语形容。<br>世人追求的性高潮，不及其中万一。<br>更不提，幻想之流。<br>那种感受中，会真实明白，何谓真正的：<br>“朝闻道，夕可死。”<br>死亡也无妨，无上限的绝对幸福感。<br>此后，再无世间任何感受，能够超越。<br>这即是‘见性’，见证你的‘真如本性’，彻底脱离五官意识的幻相，体验到一刹那的‘绝对真实’。</p>
<p>巅峰体验后，很长一段时间，自动进入‘心生法喜’的阶段。<br>什么都不想干，看见什么都觉得很幸福。<br>万物都有意识，万物都在微笑。<br>每日，都会情不自禁的露出微笑。<br>是啊，怎能不开心呢？<br>离家多年的游子，回到家中。<br>惊讶发现，原来，自己从未有一日，真正离开过家。<br>除狂喜以外，再无言语，可以形容。</p>
<p><strong>我有明珠一颗，久被尘劳关锁；<br>而今尘尽光生，照破山河万朵。</strong><br>见性的破关密钥，只在四个字——<strong>“消融自我”</strong>。<br>然而，这也是见性终关前的一个大景。<br>不过，见性之景，较明心之景，不可同日而语。<br>若地之鱼蚁，与天之鲲鹏。<br>无上美妙，让人迷恋，误以为这就是终点。<br>见证本性后，会有一道极为玄妙的‘隐形之门’。<br>见证者，将100%的确信无疑，他‘开悟’了，无论问自己多少次，都会得到准确无疑的回答。<br><strong>“是的，我见证了绝对真理，知晓前世今生，明白人生于此的意义，绝对是开悟了！”</strong><br>心中欣喜若狂，恨不得奔走相告，将感悟和与所有人分享。<br>一段时间后，习气席卷。<br>根性重返，各种不足与矛盾，重新冒头。<br>淡化许多，依然存在。<br>无过来人指路，此人会逐渐被傲慢侵蚀。<br>妄图指点江山，评判他人悟境。<br>最终，不得不承认，世事无常。<br>各类形式的‘满足’中，会困惑很长一段时间。<br>进入社会，与周围进行交互的过程中，迷惑将进一步强化。<br>如果，能对<strong>‘我开悟了’</strong>这件事，产生疑惑。<br>算是踏出了，关键性的第一步。<br>此处，平凡无奇。<br>无任何稀奇古怪的心景，没有什么印证。<br>却是见性中，最为凶险之所在。<br>任何一步踏错，任何一个细微的认知失调，便再听不进任何言语。<br>要成佛成仙，普度众生了。</p>
<p>终其一生，卡死此关的修行者，不知凡几。<br>到死，他们都不知道。<br>自己到底做错什么，又错在哪里。<br>反而觉得，所有一切，真是好极了。<br>所见一切，完美符合自己对‘开悟’有过的一切美好幻想。<br>不少人会觉醒‘天赋’或‘天命’，有的还会修出一些不可思议的‘神通’。<br>因此洋洋自得，有的人从此门徒络绎不绝，或是史书中留下名讳，或是自成一派。</p>
<p>唯独，对修行做到了100%真诚。<br>绝不欺骗自己，始终对一切异见，保持开放态度的修行者，才可有惊无险的度过此关。<br>契机，十分平凡。<br>有人盆落而悟，有人鸟飞而悟。<br>顿悟，一个显而易见的事实。<br><strong>开悟，并不存在。</strong><br>为什么？<br>原因，很简单：<br><strong>‘你’，不存在。</strong><br>这句话，十分深奥。<br>其中，特别多微妙的讲究，很深的领悟境地，以及诸多修行细节和火候，还有更多玄妙难言的东西。<br>这里，用文字无法讲述。<br>只可心传，心印。<br>记住这句，到此关时，多加感受。<br><strong>‘你’不存在。<br>开悟，也不存在。</strong><br>这是为什么，禅宗讲：<br>“悟前，砍柴挑水吃茶；悟后，砍柴挑水吃茶”。<br>亦是“见山还是山，见水还是水”的第三重境界。</p>
<p>区别在哪？<br>区别，在这个<strong>‘我’</strong>字。<br><strong>你，是谁？</strong><br>见性，将会亲眼目睹这个答案。<br>如同见一树一鸟，真实不虚的见到。<br>入道者，不会向人嚷嚷。<br><strong>‘我开悟了！’。</strong><br>因为，他们明白，没有开悟这回事。<br>以为自己开悟了，感觉自己开悟了，宣称自己开悟了，认为有开悟这回事，均是画中人，是<strong>‘我’</strong>在作怪。</p>
<p>此关后，觉者随心所欲，言行无碍，随缘应物。<br>不强调‘开悟’这种东西。<br><strong>虽名得道,实无所得;为化众生,名为得道;能悟之者,可传圣道。</strong><br>千古玄机，我讲明白了。<br>不知道，你，听明白了吗？</p>
<h1 id="末后牢关——承担"><a href="#末后牢关——承担" class="headerlink" title="末后牢关——承担"></a>末后牢关——承担</h1><p>六祖慧能累世智慧，由见性到末后牢关。<br>当下承担，一悟到底，无有迟疑。<br>其他人，到此处。<br>不停反复，向外求取；<br>无法确认，无法安心；<br>无法清净，无法笃定。</p>
<p>此处，其实没什么是文字能讲的。<br>不当面以心传心，听的人没有见性的见地，完全无法讲，根本无法听。<br>五祖传给六祖的法，最关键也最后的，便是这个部分。<br>在此，我也留一个偈子：<br><strong>一切过去未来，当下永恒交织；<br>抬头苦海踏舟，低头彼岸花开；<br>轮回因果不真，因果轮回不空；<br>善恶一心同体，佛魔一体不二；<br>死生不来不去，一切凡圣无别；<br>外离诸境无乱，生死如是涅槃。</strong></p>
<h1 id="末"><a href="#末" class="headerlink" title="末"></a>末</h1><p>禅宗三关隐秘，在此清晰写出。<br>只因我昔日的发心，在场诸位，才有机会目睹这篇文字。<br>虽然只是概要，简明指路。<br>可若不是实修实证，依然看不懂这篇文章。<br>会觉信息量过大，大脑过载。<br>自以为理解，其实完全无法理解到底是在写什么，讲什么。<br>这些东西，本已脱离大脑思辨的领域。<br>也是为何，禅宗要参话头，打机锋的意义所在。<br>目的，是让大脑逻辑自爆，停止运作。</p>
<p>开悟，非某种耗费一生去艰难求取，难以获得的梦幻状态。<br>不懂的人，没有实修实证，没有过来人引路。<br>将开悟‘妖魔化’、‘神通化’和‘理想化’。<br>事实上，见性之后，只是宇宙中一个心识进化的起点。<br>往后的境界，是无尽的。</p>
<p>人类，想到达那个‘点’，见证永恒不灭的生命，并非一件极其困难的事。<br>不过，以人类的狭隘心智，将修行过程复杂化和歪曲了。<br>也是为何，会有所谓的‘悟后起修’。<br>没悟之前的‘修’，是水中捞月，不知自己在干什么。<br>将修行比喻为爬山，山下的人，永远看不清上面的人。<br>只觉云里雾里，不断猜测对方所说的东西，试图分析比较对方与自己的高度所在，觉得对方的东西自己似乎明白，又似乎有点不明白。<br>山上，则能一眼看穿山下的人，以及对方正在走的路。<br>从他的视角来看，无比清晰，因为这些路他都走过。</p>
<p>见性后，觉者间也没什么可说的。<br>相互之间，毫无比较。<br>听闻对方的寥寥几句话，便知对方的‘厉害’。<br>心悦诚服，顶礼赞叹，相互学习。</p>
<h1 id="心读法"><a href="#心读法" class="headerlink" title="心读法"></a>心读法</h1><p>不少修行者，都希望向我寻一个正法的‘入手处’。<br>早期的佛经道典，时代久远，有文字与文化上的隔阂，很难让人读懂。<br>这里，推荐几本现代修行的正法书籍。</p>
<p>跟这些书看下来，见地十分纯正，走不偏。<br><strong>《当下的力量》埃克哈特·托尔<br>《与神对话1、2、3》尼尔·唐纳德·沃尔什<br>《山居性纪》吴光磊</strong>——性是种子，禅是花开（若开头误以为黄书，不想想，中央编译出版社会出黄书？）<br><strong>《深入浅出说心经》释戒悲</strong>——天涯论坛<br><strong>巴夏视频系列</strong>——在土豆网搜索关键字‘bashar’或是‘巴夏’，寻找你需要的短视频进行观看，可忽略外星人的部分，只看意识转化的部分。<br><strong>《新世界——灵性的觉醒》埃克哈特·托尔</strong></p>
<p>结合上面的资料，去看下面的古典资料，一切都会变得简单易懂，无需任何翻译：<br><strong>《心经》<br>《金刚经》<br>《六祖坛经》</strong>————看敦煌版，传世版已被改得面目全非<br><strong>《清净经》<br>《道德经》<br>《马太福音》、《马可福音》、《路加福音》、《约翰福音》</strong>——不必看被篡改过的《圣经》，四本福音书已经足够</p>
<p>最后，给各位推荐一个读经的正确方法。<br>名为<strong>‘心读法’</strong>，用感应而不是思辨。<br>没有古文功底，也不必买那些翻译或诠释的版本。<br>只需一遍又一遍，反复的看原始版本便可。<br>蕴含真理的书籍，是简朴无华的。<br>有文字隔阂，影响也不大。<br>看不懂便看不懂，看完放一边，无需背诵。<br>隔一段时间，重新拿起，每次会有不同的体会。<br>体悟增加，每次看懂的东西，也会更多。<br>这样，才能越过文字的表相，读取到文字背后的真实内容。<br>如此，方是正确的读经法。</p>
<p>( 补充说明: 作者在其它回答中, 还推荐了如下书籍, 可供参考:<br><strong>《一休本来是情僧》吴光磊<br>《菩提树下的微笑-金刚经解密》蔡志忠<br>《庄子说》蔡志忠<br>《异界生活助理神》</strong> (这个作者很有意思, 笑~)<br><strong><a href="http://www.guoxuedashi.com/a/1481k/">《韩诗外传》</a></strong>  (真正蕴含儒家心法的一本书)<br>)</p>
<p>=========</p>
<p>事实上，修行之路，不一定必须经由禅宗。<br>无论何种教派，身处何种修行体系。<br>人类心智的进化之旅，都是异曲同工的，无高低优劣之分。</p>
<p>以前曾以为，修行者独自修行，也没什么大问题。<br>后来认识到，整个修行始末的过程，必须要有过来人，不断引导。<br>诚心再足，累世智慧再强，根器再好，愿心再强。<br>依然要虔诚的求法，让过来人在自己步入歧途时，及时帮一把。</p>
<p>古代圣贤的积累，不是当今个体，能轻易超越的。<br>释迦牟尼若在今天，闻听今日之法，必能更早觉悟。<br>唯有站在古代一众圣贤的肩上，方能探索那无尽而又当下圆满的境界。</p>
<p>见性后，我不知走入过多少次岔路。<br>每一次，都是我的师父与师爷，不断将我拉回正途。<br>曾经，自以为修行结束。<br>其实没有，只因我还未当下承担。<br>有人骂我，还是赞我；<br>有人喜欢我，还是讨厌我；<br>有人认同我，还是不认同我；<br>有人诋毁驳斥我，还是顶礼赞扬我；<br>对我而言，都没有区别。</p>
<p>以前，会对不诚心者、误入歧途者、贡高我慢者、自高自大者，生出一种恨铁不成钢的心情。<br>不自觉的争辩，回应。<br>如今，我已全不在意。<br>佛性本是清净无染的，是喜怒哀乐都无染的。<br>笑也好，悲也罢，高兴也好，不高兴也罢，都是无住。<br>从此处，方得真清净。</p>
<p>最后，再说说坛经。<br>传世版的坛经，是失传之后，由六祖的弟子，世面上流传的三种版本，汇编在一起形成的。<br>中间，存在诸多谬误。<br>禅宗的偈子，一个字不对，意境感悟就歪到十万八千里。<br>各位若有兴趣，务必看敦煌版的《坛经》。<br>以前，我只看过《心经》与《金刚经》两书，后来才看《坛经》，总觉不是那个味。<br>直到师父指点，要看敦煌版《坛经》，这才明白是为何。<br>敦煌版中，不讲神通，不谈玄虚。<br>言语朴实直接，无遮掩亦无修饰。<br>就像能悟的人，与不悟之人的差距。</p>
<p><strong>《坛经》<br>善知识，后代得吾法者，常见吾法身不离汝左右。<br>善知识！将此顿教法门，同见同行，发愿受持，如是佛教，终身而受持不退者，欲入圣位，然须传受。<br>从上以来，默传付衣法，发大誓愿，不退菩提，即须分付。<br>若不同见解，无有志愿，在在处处，勿妄宣传。<br>损彼前人，究竟无益。<br>若愚人不解，谤此法门，百劫千生，断佛种性。</strong></p>
<p>======</p>
<p>若有疑问，欢迎留言。<br>有意义的问题，我会作记录，日后发文解答。<br>喜欢这些文字，欢迎点击下方的喜欢、点亮、收藏。<br>越多的点亮与喜欢，就会有越多类似这样难得一见的内容，浮现出世。<br>你的每一份无私付出，都将化为一个个能量涟漪，为人类社会带来更加光明的未来。</p>
<hr>
<p><em><strong>转载自 微信公众号 禅医堂 灵天赐 <a href="https://weixin.sogou.com/weixin?type=2&s_from=input&query=%E4%BF%AE%E8%A1%8C%E6%80%BB%E9%A2%86%E2%80%94%E2%80%94%E6%98%8E%E5%BF%83%E8%A7%81%E6%80%A7">修行总领——明心见性</a></strong></em></p>
<hr>
<h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><p>自己比较喜欢从全局看事物, 在发现灵天赐的这份修行总纲之前, 要自修自证太难有全局观了. 由于缺少参考系, 很难评估自己到底修到了哪个程度. 心性不够的都必然在某一个阶段, 体会到一些”异相”之后, 认为自己开悟了, 觉醒了.</p>
<p>之前决定<a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a>时, 也是因为反复论证了道是一种”事物”, 是一种”体验”, 是可以追求和亲证的. 但道教之路比佛教之路更晦涩难懂, 潜在风险也更大(修行起来更积极主动, 也就更容易走火入魔). 所以心中对修行的过程和步骤充满了疑惑.</p>
<p>内心真是万分感谢灵天赐的分享和交流. 幸得有缘, 看到这前后两篇逻辑清晰, 层次分明的修行总领, 于我而言是如获至宝, 彻底理顺了修行路径, 进一步坚定了修行的信念.</p>
<p>依旧需要在此强调一下, 灵天赐只是修行方面的老师, 不盲信, 不崇拜.<br>尤其是对社会现实方面的观点和为人处世, 当下问心无愧即可. 目前的我对灵修界人士的很多现世观点是无法认同的, 社会发展明显有其自身的规律和惯性, 不会以少部分人的意识转换和升华而改变, 它是符合大道, 但法无常法, 其具体的规律依旧需要依靠研究和观察, 方能较为正确的发掘和获得.</p>
<p>修行, 我主要会参考佛教的系统来, 毕竟祖师爷释迦牟尼重点讲的就是修行的方法. 而对事物的认知, 理性分析下来, 我更接受中国传统的易经和道家文化, 以及西方的科学方法.</p>
<p>再次摘录Aggavara前辈在”原始佛教修学指南（博客导读）”里的语句:</p>
<blockquote>
<p>本人的观点仅供参考 读者应当保持足够的理性与怀疑态度<br>不要盲信任何观点包括本人的观点<br>本人观点是否正确, 需要每一位修行者严谨的通过理论学习以及禅修实践来判断</p>
</blockquote>
<p>理性的怀疑和批判, 亲力亲为的实验和实践, 这才是真正科学的态度. 修行和科学, 并不冲突,  进一步地, 我们应该用科学的态度来实修, 去伪存真, 精炼出一套适合更多人的修行方法!</p>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>修道之路-起疑</title>
    <url>/2021/03/01/2106-dao-doubt/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2021/02/14/2105-dao-outline/">修道之路-总纲</a></li>
<li><strong><a href="https://draapho.github.io/2021/03/01/2106-dao-doubt/">修道之路-起疑</a></strong></li>
</ul>
<h1 id="起疑"><a href="#起疑" class="headerlink" title="起疑"></a>起疑</h1><p>身处互联网时代, 一个信息爆炸的时代. 信息茧房一词不绝于耳. 事实上, 信息茧房始终存在, 因为我们的思维会习惯于选择接受符合已有认知的信息, 进行不断自我强化. 互联网的分发机制不过是发现了这个需求, 加以强化. 知识泛滥, 远比知识匮乏来得好, 至少有得选.</p>
<p>思维会作茧自缚式的把自己保护起来. 这个茧, 他人是破不得的, 从外部破, 那是暴力强拆, 只会激发起自我和思维的抗拒和害怕, 把自己包裹的更紧. <strong>只有自己破茧而出, 才可能化蛹成蝶.</strong></p>
<h2 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h2><p>最先要强调的就是方法论, 这是思维/认知的本. 我对待事物和概念, 其本, 就是本位方法论. 由于本位方法论不可避免地要用到推论, 因而逻辑学也成为了本.<br>本位方法论, 大概也可归类于朴素辩证法. 核心要点如下:</p>
<ul>
<li>本: 一定范围内的普适性, 规律性, 绝对性.</li>
<li>位: 相(第四声). 相对性, 相互关系.</li>
<li>无位可本, 无本可位, 本位一体, 本位相生.<ul>
<li>本非本, 由位生本.</li>
<li>本无位, 由本生位.</li>
<li>无所位而生其本, 无所本而生其位.</li>
</ul>
</li>
<li>无论本位方法论对于不存在绝对真理的假设是否自相矛盾, 都可以不断地逼近绝对真理.</li>
</ul>
<h2 id="政治和经济"><a href="#政治和经济" class="headerlink" title="政治和经济"></a>政治和经济</h2><p>单独从人文学科里取政治和经济, 是因为这两者基本能对应枪杆子和钱袋子, 可以用来观察当前人文世界运行的本质.<br>推荐的书籍和资料如下:</p>
<ul>
<li>《自私的基因》, 里查德.道金斯</li>
<li>《人类简史》, 尤瓦尔·赫拉利</li>
<li>《失控》, 凯文·凯利</li>
<li>《枪炮, 病菌和钢铁》, 贾雷德·戴蒙德</li>
<li>《乡土中国》, 费孝通</li>
<li>《潜规则》,《血酬定律》,《我想重新解释历史》, 吴思历史三部曲</li>
<li>《气候创造历史》, 许靖华</li>
<li>《让子弹飞》, 姜文<ul>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
</ul>
</li>
<li>《中国历代政治得失》, 钱穆</li>
<li>《全球化与国家竞争》,《解构现代化》,《八次危机》,温铁军</li>
<li>《卢瑟经济学》, 安生</li>
<li>《斯坦福极简经济学》, 蒂莫西·泰勒</li>
<li>《进化动力学：探索生命的方程》, Martin A.Nowa</li>
<li>B站&lt;鬼谷说&gt;生物系列, <a href="https://space.bilibili.com/72270557">芳斯塔芙</a></li>
</ul>
<p>个人拙见.</p>
<ul>
<li>政治和经济, 分解后的最小单位都是人, 更基础地说就是人性. 任何其它因素(如环境)对政经的影响, 都必然首先通过人性作用于人, 方能通过人来影响政治和经济.<ul>
<li>通过研究政治, 会发现社会是以暴力为依托, 利用人性的贪婪和恐惧, 通过一整套奖惩机制进行管理和统治, 来保持社会层面的稳定性.</li>
<li>枪杆子为大棒, 可以带来失去的恐惧. 钱袋子为胡萝卜, 可以带来获得的贪婪. 笔杆子造就概念/主义/文化/习俗, 形成思维惯性后, 就能低成本地在思维层面进行予取予夺地管控, 部分替代成本更高的肉身和物质上的剥夺和给予.</li>
<li>经济模式基本决定了蛋糕总量. 政治模式基本决定了分配方式. 蛋糕总量很重要, 决定了理论上的人口上限, 但由于损不足以奉有余, 历史上真正决定经济周期和政治周期的是分配方式.</li>
<li><strong>脑中如文化习俗, 道德规范, 遵纪守法的概念, 都只是相对的本, 不应该作为自己为人处世的原则</strong>.<ul>
<li><strong>文化习俗的本, 必须基于生存环境这个位来看</strong>. 汉人入胡地则胡化, 胡人入汉地则汉化. 寒带的人坚韧, 热带的人懒散. 不同的环境, 决定人的生存方式和组织方式. 由此代代相传, 形成一套适合在某种环境下生存的文化习俗, 甚至部分地内化为基因. 因而文化习俗惯性最强, 即便是帝王将相, 也只能顺应或灭族, 无法强行改变.</li>
<li><strong>道德规范. 是以群体稳定为目的, 发展而出的概念</strong>. 道德规范多来自于人们经验性的共识, 少部分来自于政治强人的引导. 违反道德规范, 往往会受到周遭的舆论压力, 物理性伤害不大, 精神性伤害极大. 在一个道德规范要求高度一致的群体里(如儒学君臣父子, 中国唯物主义, 西方白左), 异类多半会隐藏自己的想法来自保.</li>
<li><strong>遵纪守法. 根本上讲, 法律是为统治阶级服务的.</strong> 法律是依托暴力来维护的, 因而只有暴力机构有能力要求人们遵纪守法. 只有统治阶级才会拥有”合法”的暴力机构.</li>
</ul>
</li>
</ul>
</li>
<li>西方整套的经济学理论, 其根基就是错的. 但经济学居然也被归类于科学…<ul>
<li>微观经济学的基本假定: 市场出清、完全理性、充分信息. 对应于到人, 没有一条是成立的! 整套理论建立在流沙之上!<ul>
<li>完全理性. 假设不完全成立, 不具备普适性. 但对政治和经济玩到高层次的玩家, 基本成立. 观察消费市场就能明显地知道: 越感性的人群, 越有消费潜力可挖.</li>
<li>充分信息. 人与人之间的大部分信息传递, 包括商业领域的核心信息, 更近似于短程力, 往往局限于某一个范围之内. 故假设不成立.</li>
<li>市场出清. 充分信息, 双方都有替代方案的自由博弈是市场出清的前提条件. 思考一下钻石行业, 消费者端被洗脑, 生产者端完全垄断, 限量供应. 而谈及博弈, 还和组织方式, 权力分配有关. 一盘散沙的普通民众面对强权和垄断资本时, 根本没有任何选择权进行博弈.</li>
</ul>
</li>
<li>宏观经济学的基本假定: 市场失灵、政府有效.<ul>
<li>市场失灵. 其本质是人之道, “损不足以奉有余”. 贫富差距过大, 分配方面出了问题.</li>
<li>政府有效. 其核心为天之道, “损有余而补不足”. 一鲸落而万物生, 需要进行合理再分配才可能有效.<ul>
<li>自由资本主义遇到经济危机, 是大家一起死! 然后迎来新生.</li>
<li>建制派政府高层早已和资本高度绑定, 自己就是鲸. 能行何道, 能否有效, 一目了然.</li>
<li>拼命印钱, 扩大开支, 而不去解决分配问题, 其本质是劫贫救富, 是向未来/他国埋雷来延缓本国的危机.</li>
</ul>
</li>
</ul>
</li>
<li>举个例子, 以蛋壳公寓暴雷为例.<ul>
<li>传统的租房本质只涉及到房东和租客, 中介只是一个牵线搭桥的作用. 这种关系是对等的, 易于理解的, 权力和义务不言而喻的.</li>
<li>蛋壳公寓的本质是, 蛋壳将租客作为抵押物抵押给了银行, 获得一次性贷款后, 向房东租赁房屋, 然后将服务”免费”提供给租客.  这里面的关系立马复杂起来, 而最为恶劣的是, 作为弱势群体的租客, 由于传统的租房意识, 根本没几个认识到, 自己的本质是”抵押物”.</li>
<li>这里面, 信息传递不充分, 房东和租客很少会理解相互关系的本质; 租客风险意识不够, 非理性人; 若资本垄断租赁行业后, 那么租赁价格将不再透明, 市场出清无效.</li>
<li>市场出清失效在外卖行业已有所体现, 一些小型餐饮店的客源渠道被外卖平台垄断, 外卖骑手送餐时间被恶意压缩, 并对引起的社会矛盾转嫁到消费者身上. 事实是, 配送时间的压缩不过是平台竞争算法的必然结果, 是有意为之的.</li>
</ul>
</li>
<li>一些列的量化工作, 作为原始数据, 对后续的研究很有帮助.</li>
</ul>
</li>
<li>中国政治和治乱循环.<ul>
<li>纵向读中国史书, 有个很有意思的现象: 外戚和宦官集团基本都是为非作歹, 祸国殃民的. 最靠近皇权的势力, 也就宦官集团, 外戚集团和士大夫集团. 一个合格的皇帝, 只能在这三股势力之间玩平衡. 直至明朝, 笔杆子一直掌握在士大夫集团手上, 也就不难理解在史书中, 另外两大集团的历史评价了. 至于一直忧国忧民的士大夫集团的底色, 看看明朝末年的表现就足够了.</li>
<li>从根本上讲, 乱起源于经济上的分配问题. 底层农民被盘剥地生存堪忧, 此时若遇到点天灾或外敌, 那就断了活路. 人性使然, 反他娘的!</li>
<li>因而, 历朝历代(包括本朝), 要治, 必须替天行道, 打土豪分田地. 对农民进行生产资料再分配.</li>
<li>但中央集权的政治制度决定了, 王朝后续只可能朝着”损不足以奉有余”方向大踏步前进. 因为此时的中下层没有任何话语权和政治权力去影响财富分配过程. 唯一的暴力反抗途径, 是会被暴力灭肉身的. 由此, 大部分时间只能盼青天了.</li>
<li>于国家而言, 中共是成绩斐然, 出类拔萃的. 于人民而言, 是被成本转嫁的, 从农民工到下岗工人, 再到如今中产996, 一以贯之.</li>
</ul>
</li>
<li>资本主义和民主选举<ul>
<li>横向看西方语境, 敌对势力的制度和人权都是有问题的, 需要按照西方体制进行改造. 至于改造结果, 改好了是民主自由的胜利, 改乱了敌人当然也有利于自己.</li>
<li>当下的世界是资本主导的世界, 主要矛盾是世界范围内的经济分配问题. 博弈方式却是以国家为单位. 作为资本龙头的美国不倒, 资本主义不死.</li>
<li>国际资本进行国家级别的割韭菜后, 该国必然乱象丛生. 对非民主国家, 国际资本会动用笔杆子宣扬民主自由, 鼓动热血青年和底层民众反抗政府. 对于民主国家, 台上的民选政府就成了国际资本的白手套和替罪羊, 还可暗地里扶持一批亲资本的政客.</li>
<li>国际资本进行收割时, 已经属于抢蛋糕的经济战了, 用非战时的制度根本无法应对, 唯有战时制度或政治强人才能与之对抗.</li>
<li>但在稳定时期, 民主选举制度, 民众的舆论自由权, 都是中下层争取自身利益, 参与分配过程的有效手段.</li>
</ul>
</li>
<li><strong>只用政治和经济看世界, 会过于理性和势利. 仅看到人性的贪婪和恐惧.</strong></li>
</ul>
<h2 id="知的局限性"><a href="#知的局限性" class="headerlink" title="知的局限性"></a>知的局限性</h2><p>涉及到经验主义还是先验主义. 从科学的角度来说, 经验主义是基础, 有经验才可能发展出一定的先验.<br>而先验的理论也必须通过经验来验证, 否则只能是假设! 因而, 经验主义才是科学的本.</p>
<ul>
<li>数学和哲学是根据自我假定的本, 基于逻辑学推论而来的知识, 是完全先验的. 但要落地成为实用的知识, 必须有经验主义的支持.</li>
<li>譬如物理发展史上, 经典物理是经验主义为先, 牛顿因为解题需要弄出了一套微积分.</li>
<li>广义相对论则是先有了黎曼几何, 爱因斯坦觉得这个先验的数学工具能很好的量化他的相对论, 最终推演出广义相对论. 随后还进行了若干针对性的实验, 广义相对论的地位才变得不可撼动.</li>
<li>量子力学的诞生, 并归类于一种科学理论, 进一步说明了经验主义在科学中的重要性. 另外对于”观察”这个动作的敏感性, 不得不让人联想到佛教的缘起法”此生故彼生, 此有故彼有”.</li>
<li>我的一个猜想是: 量子力学领域, 人类的观察手段不够了, 只能用粒子轰击粒子. 用相近的频率去观察相近的频率, 能提取出个鬼的稳定信息哦.</li>
</ul>
<p>如果承认我们获取的知识, 是来源于经验主义的, 是离不开观察和感受的. 那就继续讨论经验主义的局限性:</p>
<ul>
<li>无论向内观察还是向外观察, 观察者必须有相应的观察感知能力, 被观察事物/现象必须可观察. 其实可以直接用信息论进行抽象分析了.</li>
<li>因而, 观察者可认知的事物极其有限, 受限于如下条件:<ul>
<li>被观察信息本身具有一定地稳定性或周期性. (前提条件)</li>
<li>可感知(传感器和数据分析识别, 采样频率至少是被观察信号频率的两倍)</li>
<li>可重复感知(经验主义的必要条件, 否则只能当成偶然现象)</li>
<li>可一致性的重复感知(科学的必要条件, 观察者具有类似的感知能力.)</li>
<li>思想实验: 如果你在这个时代, 经历了狄奥伦娜相同的四维空间经历, 你能向世人证明什么吗, 世人会怎么的反应? (相关故事情节见, &lt;三体3, 第一部, 公元1453年5月，魔法师之死&gt;)</li>
</ul>
</li>
<li>由上分析可知:<ul>
<li>如果在可观察的视窗期内, 被观察信息本身处在不可观察的状态, 那无论如何都无法被认知.</li>
<li>如果观察者本身能力有限, 事物同样无法被认知. (和草履虫谈声音和光线, 毫无意义. 而宗教里的神通/灵异现象, 一般人无法理解, 科学拒绝承认. 都是因为观察方法不同, 因而各自的经验也就不同)</li>
<li>科学对观察者和被观察事物的要求都非常高! 因而科学可以研究的领域其实并不大.</li>
<li>科学的伟大之处在于局部领域从经验走向了先验, 实现了精确预言!</li>
<li><strong>科学的更伟大之处是找到了一套方法, 让西方世界突破了宗教本位, 实现了理论-实验的螺旋式本位互生, 形成科技大爆炸, 极大地丰富了物质世界.</strong></li>
</ul>
</li>
</ul>
<p>科学理论有自身的局限性, 自不必多言. 哪怕是科学的方法, 也有非常大的局限性.</p>
<ul>
<li>任何实验可分为观察者和被观察事物, 这就要求观察者的感知能力在同一水平, 被观察事物具有某种稳定性.</li>
<li>因而, 能被大家认可的观察结果必然属于某种特殊情况.</li>
<li>从唯心主义去讨论的话, 只有大家共同创造出的事物, 才具有稳定性, 才更容易被大家重复观察. 譬如股市.</li>
<li>当然, 为了有共同讨论的基础, 这也是没办法的事情, 属于”集体认知”的本.</li>
</ul>
<p><strong>保持科学的精神是最重要的: 一颗好奇的, 求实的, 开放的, 质疑的心.</strong></p>
<ul>
<li>有好奇心, 方能不满足于已有知识, 探索未知的领域和世界.</li>
<li>有求实心, 方能客观地, 不带主观目和利益诉求, 忠实记录各种观察数据和实验结果.</li>
<li>有开放心, 方能分享自己的数据或理论, 愿意和大家验证和共享这些成果.</li>
<li>有质疑心, 方能愿意思辨, 去伪存真, 让经验, 思想, 理论经得起考验.</li>
<li>如果我们具有科学的精神, 就不会武断地用已有的理论和知识去排除可能的未知, 去否定研究未知领域的先行者.</li>
</ul>
<h2 id="科学和宗教"><a href="#科学和宗教" class="headerlink" title="科学和宗教"></a>科学和宗教</h2><p>主要列举一些具有相当科学背景的人, 对宗教的看法, 以及他们的一些特殊经历. 而宗教界人士蹭科学热度来证明自己的正确性, 可以不看, 因为这些人利益相关, 容易先入为主, 缺乏客观性.<br>推荐的书籍和资料如下:</p>
<ul>
<li>霍金三部曲 (了解科学前沿理论中的宇宙, 认知时空的相对性.)<ul>
<li>整个科学的进化史, 是一部转变认知视角的历史.</li>
<li>地心说(人类中心)-&gt;日心说-&gt;牛顿力学(绝对时空)-&gt;相对论(绝对光速)-&gt;弦论(万物振动)?</li>
</ul>
</li>
<li>《物理学之”道”》, 卡普拉<ul>
<li>从信息论来说, 能重复的实验和能重复的体验是没有区别的. 都说明了被观察信息具有一定的稳定性, 便可以认为其”存在”.</li>
</ul>
</li>
<li>《学习之道》, 乔希·维茨金<ul>
<li>大量的”意念”式的学习和练习. 大量的自我暗示.</li>
</ul>
</li>
<li>《左脑中风，右脑开悟》, 吉尔·泰勒<ul>
<li><a href="https://www.ted.com/talks/jill_bolte_taylor_my_stroke_of_insight?language=en">TED演讲: My stroke of insight</a></li>
<li>无宗教背景, 医学博士, 神经解剖学家.</li>
</ul>
</li>
<li>《前世今生》, 布莱恩·魏斯<ul>
<li>无宗教背景, 结合他所处的年代和背景, 此书对他而言, 风险大于收益.</li>
<li>后续还出版了《生命轮回》,《返璞归真》,《前世今生》2,《前世今生来生缘》</li>
</ul>
</li>
<li><a href="http://media.zhengjian.org/media/zjbooks/reincarnationwesternresearch/reincarnationwesternresearchf.htm#_Toc41827606">西方轮回研究介绍</a>, <a href="http://bbs.tianya.cn/post-no01-119677-1.shtml">天涯转载</a><ul>
<li>先说明一下, &lt;西方轮回研究介绍&gt;是法轮功官网收集的资料. 引用这篇文章是因为非宗教背景下, 轮回相关研究的中文资料太少了. 此文至少列出了作者和书籍, 我会按图索骥核查一下英文资料, 确定真实性.</li>
<li>这里不求所有的轮回案例都真实有效, 只要有一例疑无可疑, 确认为真的事迹即可.</li>
<li>伊安·史蒂文森(1918-2007)<ul>
<li>母亲对神学有兴趣, 他自己获得医学博士学位, 借助学术手段研究”前世记忆”现象.</li>
<li>英文书籍极多, 中文资料较少, 比较有名的是《二十案例示轮回》.</li>
<li>更多信息见维基百科 <a href="https://en.wikipedia.org/wiki/Ian_Stevenson">Ian Stevenson</a>.</li>
</ul>
</li>
<li>海伦·瓦默巴赫(1925-1986).<ul>
<li>无宗教背景, 博士学位. 出了两本书</li>
<li><a href="https://www.amazon.com/Life-Before-Helen-Wambach/dp/0553124501">Life Before Life</a></li>
<li><a href="https://www.amazon.com/Reliving-Past-Lives-Evidence-Hypnosis/dp/B00201FIMM">Reliving Past Lives:The Evidence under Hypnosis</a></li>
</ul>
</li>
<li>吉娜·瑟敏纳拉(1914-1984).<ul>
<li>美国作家, 无科学训练背景, 可忽略.</li>
<li>维基百科 <a href="https://en.wikipedia.org/wiki/Gina_Cerminara">Gina Cerminara</a></li>
</ul>
</li>
<li>《往世疗法》, <a href="https://www.amazon.com/Past-Lives-Therapy-Morris-Netherton/dp/0688032982">书籍存在</a>. 作者背景没有查到.</li>
<li>《转世之间》, <a href="https://www.amazon.com.au/Life-Between-Joel-L-Whitton/dp/0446347620">Life between Life</a><ul>
<li>Joel L. Whitton 生平没找到, 有书籍<a href="http://regressionjournal.org/book_writer/joel-l-whitton/">相关介绍</a></li>
<li><a href="https://en.wikipedia.org/wiki/Joe_Fisher_(journalist)">Joe Fisher</a>, 新闻工作者.</li>
</ul>
</li>
<li>布兰·魏斯(1944-)<ul>
<li>翻译问题, 就是《前世今生》的作者布莱恩·魏斯</li>
</ul>
</li>
<li>卡洛·鲍曼(1950-)<ul>
<li>美国作家, 治疗师, 无科学训练背景, 可忽略.</li>
<li>维基百科 <a href="https://en.wikipedia.org/wiki/Carol_Bowman">Carol Bowman</a></li>
</ul>
</li>
</ul>
</li>
<li>宗教人士的书籍, 真假自辩.<ul>
<li><strong><a href="https://weixin.sogou.com/weixin?type=2&s_from=input&query=%E8%BD%AE%E5%9B%9E%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8?%E6%88%91%E7%9A%84%E8%BD%AE%E5%9B%9E%E6%8E%A2%E7%B4%A2%E4%B9%8B%E6%97%85(%E6%B7%B1%E5%BA%A6%E5%A5%BD%E6%96%87)">&lt;轮回是否存在？我的轮回探索之旅&gt;, 宗翎法師</a></strong><ul>
<li>宗翎法師关于佛教的文章, 思辨能力和逻辑性都很强, 推荐一看.</li>
<li>他信佛的目的性很强, 是求来世的. 但在我看来, 求来世和求今世没有本质区别.</li>
</ul>
</li>
<li>《前世今生论》, 慈诚罗珠堪布</li>
<li>《西藏生死书》, 索甲仁波切</li>
</ul>
</li>
<li>个人收集的资料, 真假自辩<ul>
<li>缠中说禅 <a href="http://blog.sina.com.cn/s/blog_486e105c01000cjc.html">教你打坐7：神鬼、神通、神异景象</a></li>
<li>央视主持人<a href="https://zh.wikipedia.org/wiki/%E5%AE%8B%E8%8B%B1%E6%9D%B0">宋英杰</a>, 于2018年5月10日发微博声称<a href="http://www.360doc.com/content/18/0621/22/46877006_764262185.shtml">4岁儿子自称是从汶川大地震时的北川转世而来，拥有“前世记忆”</a>, 后迫于舆论压力删除微博, 其妻子出面辟谣, 给出了合理解释.<ul>
<li>一个在唯物主义教育下成长起来的, 拥有稳定工作的体制内中年大叔, 拿自己小孩开玩笑的可能性微乎其微.</li>
<li>后续的删除和辟谣工作, 是在那个舆论环境下的正确自保动作.</li>
</ul>
</li>
<li>知乎. 灵性, 生死, 轮回, 道教相关话题下, 会有涉及.</li>
</ul>
</li>
</ul>
<p>下面, 对宗教中的一些特殊现象, 进行推理和分析.</p>
<ul>
<li>逻辑上, 只要找到一个“存在前世”的真实例子, 就可以用反证法推翻“没有前世”的命题。</li>
<li>概率上的推论, 宗翎法師已经在&lt;轮回是否存在？我的轮回探索之旅&gt;一文中推算过, 从赌博角度看, 还是相信轮回存在的胜率高的多.</li>
<li>而对于我们自己, 缺少的无非就是: <strong>基于直觉的相信, 基于逻辑的相信, 基于经验的相信.</strong><ul>
<li>在”知的局限性”中, 已经强调过, 其实经验主义是先验主义的本, 因而个人的一些亲身经历, 或者自身推导出来的思考, 最容易打破自身思维上的先验概念和框架.</li>
<li>因此亲身经历最具有说服力, 但可遇不可求, 而且只能说服自己, 很难说服他人.</li>
<li>我们必须仔细想一想, 这些先验的概念和框架是从哪里来的? 真的是不证自明的吗? 我们从小被灌输的是非概念, 真就对是对, 错是错吗?</li>
<li>进入社会后, 依然只讲对错吗? 走出象牙塔, 世界变成了灰色, 变得以利害为导向了. 思想里的概念, 真的完全和我们自身的经验, 我们周遭人的经验相符的吗?</li>
<li>有了主见的我们, 就不再是一张白纸, 对于不同的信息, 意识里会进行是否可信的判断, 符合已有认知的就更可信, 更容易接受; 同样的信息, 出自于信任的人所说, 这条信息也会变得更可信, 更容易接受.</li>
<li>如果我们生活在西方中世纪, 从小接受着一整套神学和宗教的概念框架, 对于异类且反动的”日心说”, 我们会是什么样的态度?</li>
</ul>
</li>
<li>科学和宗教/灵修并不完全对立.<ul>
<li>科学不是万能的, 它只能解决和预测局部领域的问题.</li>
<li>多数人心中的宗教/灵修是主观的, 道听途说的, 并没有真正尝试去了解过, 没有读过最核心的书籍.</li>
<li>自然科学及其带来的物质繁荣, 是人向外求真的集大成者.</li>
<li>宗教, 是人向内心求真的集大成者. 但是所有的宗教, 都被向外求的人心蒙上了一层厚重的欲望之尘. 譬如天堂, 轮回, 彼岸等概念后面, 都是一颗有求的, 利益交换的心.</li>
<li>在后续的文章中, 我会详细说明基于佛教的修行方法是经得起科学方法检验的, 是可以带着怀疑的态度, 逐步验证其说法和步骤是否正确的.</li>
<li>但这个验证的过程, 想要获得修行的成果, 必须亲自进行实验, 无人可以代劳. 因为这个实验的仪器, 是每个人的自身, 无法通过眼耳鼻舌身意来传达, 只能自己全身心的去感受.</li>
</ul>
</li>
<li><strong>只用宗教看世界, 会过于理想和天真. 希望有一个理想世界, 人性无私而美好.</strong></li>
</ul>
<h2 id="哲学和数学"><a href="#哲学和数学" class="headerlink" title="哲学和数学"></a>哲学和数学</h2><p>先表明态度. 不建议陷到哲学里去. 有兴趣可以随便看看, 用哲学思维来撬动固有观念.</p>
<ul>
<li>数学, 由本生本. 前面的本是公理和定义. 然后基于逻辑推理获得后面的本.<ul>
<li>公理的本质是大家可以公认的假设, 是对话的基础.</li>
<li>定义则精确化了概念的适用范围. 排除了在数学领域偷换概念的可能性.</li>
<li>数学是高度抽象化的, 脱离实际应用和体验的.</li>
<li>数学落地的前提是, 某些事物/现象, 在符合某一套数学公理的前提下, 可以直接用这套数学理论获得整个事物/现象的相互关系和内在规律.</li>
</ul>
</li>
<li>哲学, 由本生本. 前面的本每个哲学家都可以自己定义. 然后基于逻辑推理获得后面的本.<ul>
<li>由本生本, 整套理论是形而上的, 无法验证真伪的, 在落地之前, 都是没有实际作用的.</li>
<li>哲学的问题是, 文无第一, 为了前面的本, 即前提假设, 就可以开始互挖墙脚吵半天.</li>
<li>我们讨论问题的前提条件是有相同的, 至少是类似的认知或经验. 前提条件都无法达成共识, 还能讨论出什么真理?</li>
<li>哲学家遇到普通人, 相当于秀才遇上兵. 普通人和兵完胜, 因为普通人基于经验, 兵手里有刀.</li>
</ul>
</li>
<li>B站 <a href="https://space.bilibili.com/23191782">未明子</a>, 主义主义哲学史分类<ul>
<li><a href="https://www.bilibili.com/video/BV12a4y1s78w">【十分钟哲学】为什么学哲学</a><ul>
<li>哲学可以获得管理员权限.</li>
<li>宗教可以格式化系统盘.</li>
<li>儒释道是新的操作系统.</li>
</ul>
</li>
<li><a href="https://www.bilibili.com/video/BV1JT4y1K7dp">【主义主义】哲学意识形态大全-总纲</a><ul>
<li>本质是思维上的细分再细分, 试图从思维上进行穷举. 但细分的部分真的做到相互独立了吗? 能不能同时具备2种特质呢, 譬如秩序+对立, 对立中存在秩序?</li>
<li>推论里面, 假设的东西太多了. 而且只是假设, 没有验证. 空对空.</li>
</ul>
</li>
<li>具体到某个主义. 譬如 <a href="https://www.bilibili.com/video/BV1Sy4y1B7X6">【三分钟哲学】【辩证法】两次跨入同一条河流？</a><ul>
<li>我就一个问题, 凭什么大家要按照哲学要求的方法去认知和思考问题?<ul>
<li>语言不是哲学家定义出来的. 是普罗大众约定成俗地创造出来的.</li>
<li>特定词汇的概念, 本就可以一词多义, 而且可以利用一词多义来同时表达自己的多种观念.</li>
<li>哲学使用或者说借用的是普通的词汇和语法, 并没有像数学建立起一套独立的, 毫无歧义的符号描述体系. 哲学没有权力说某个词汇或语法就应该这么解读.</li>
<li>同一句话本就可以有不同的重音/解读/理解. 用哲学一贯严谨的思辨立场, 是不是应该把每种解读都分析归类一遍才对? (累死人)</li>
</ul>
</li>
<li>一千个人心中有一千个哈姆雷特. 还是让哲学的单独归哲学家所有吧…</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="过的好不好"><a href="#过的好不好" class="headerlink" title="过的好不好"></a>过的好不好</h2><p><strong>让我们一起扪心自问: 在这丰富多彩的物质世界, 向外求索的人生中, 自己过的好吗?</strong></p>
<ul>
<li>我们在追求什么? 收获了什么? 终点在哪里?</li>
<li>我们的本心是什么? 充实? 满足? 理解? 平和? 喜乐?</li>
</ul>
<p>人类心理一个很有意思的现象</p>
<ul>
<li>恋爱中的另一半是完美无缺的, 婚后的另一半是无法令人满意的, .</li>
<li>别人家的小孩是可爱懂事的, 自己家的小孩是调皮捣蛋的.</li>
<li>捐一百亩地, 一百万是可以的, 捐一头牛是不行的. (我真有一头牛)</li>
<li>汉朝和罗马帝国是相互吹捧的, 清朝是被欧洲国家轰开国门的.</li>
<li>自己所处的时代是糟糕的, 上古时期是美好的, 未来也将是美好的.</li>
<li>地球上的异类文明是需要消灭的敌人, 想象中的外星文明可以成为朋友.</li>
<li>这说明: <strong>当事物和自己无直接利益冲突时, 我们的本性是追求真善美的.</strong></li>
<li>当事物离自己越来越近, 相关度提高, 涉及到自身体验时, 我们则显示出强烈的得失心和比较心.</li>
<li>距离产生美, 这种心理特性和恐怖谷理论中的曲线很相似.<ul>
<li>这条曲线的最低谷, 就是生命对自身存在的执着, 对死亡的恐惧.</li>
<li>以上现象描述的是最低谷右侧的变化情况, 属于向外求索的路径.</li>
<li>最低谷左侧的变化情况, 则属于向内求索的路径, 属于灵修之路.</li>
</ul>
</li>
</ul>
<p>人类内在的本性是: <strong>永不忘却的合一和完美.</strong> 因为皆自道而来, 所以必向道而去.</p>
<ul>
<li>每个人意识里是孤独和缺失的. 只有这样, 才有机会体验合一和完美.</li>
<li><strong>当通过感官和思维向外追寻这份本性时, 必然演化为贪婪和恐惧.</strong><ul>
<li>个体由于这份缺失感, 就会不停地向外索取, 以填补自己的缺失, 期望以此充实自己. 是为贪婪. 永无止境.</li>
<li>意识以群体为本时, 会希望自己成仁成圣, 救苦救难, 希望所在的群体能达到自己心中的完美, 这也是一种贪婪.</li>
<li>个体由于这份缺失感, 会觉得失去一些东西时, 自己会变地更不完整, 损害了自己的完美程度. 是为恐惧.</li>
<li>意识以群体为本时, 会自觉维护此群体的利益, 以此获得一种归属感. 本质是一种害怕失去的恐惧.</li>
</ul>
</li>
<li><strong>用心向内寻求这份本性时. 可以最终体验到自己就是合一和完美. 无需获得更多, 也没什么可以失去.</strong><ul>
<li>亲证感官和思维的断续和生灭.</li>
<li>亲证有物混成, 万有合一的完美.</li>
<li>至此, 逻辑上便是到头了.</li>
<li>再言便是: 无孤独无缺失, 无合一无完美; 无本, 无位; 无对立, 无统一; 无有, 无无, 无他, 无我.</li>
<li>万物当下都展示着自己应有的相面, 处于自己应有的位置, 既完美又缺失, 既天堂又地狱. 世界就是那只薛定谔的猫, 只取决于我们自己怎么”观察”.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>dao</category>
      </categories>
      <tags>
        <tag>dao</tag>
      </tags>
  </entry>
  <entry>
    <title>使用OMV搭建家庭NAS</title>
    <url>/2021/03/31/2109-nuc-omv/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>5年前写过一篇 <a href="https://draapho.github.io/2016/10/03/1606-WinSoft-cloud/">Windows 软件系列-基于NFS的家庭网</a>, 就有了搭建一个较为理想的NAS的愿望. 正好利用起淘汰下来的NUC5i5, 尝试自建.<br>优先级由高到低, 需求如下:</p>
<ul>
<li>24小时开机. 因而必须低功耗, 静音.</li>
<li>支持共享文件, 支持Windows网络映射.</li>
<li>手机端资料单向备份, 电脑端资料单向同步. 不需要版本控制.</li>
<li>NAS系统盘备份功能. 若NAS系统意外崩溃, 可迅速恢复.</li>
<li>NAS数据盘能在熟悉的windows系统下, 自己进行恢复.</li>
<li>下面的功能, 精力有限, 尽量避坑. 实现起来太困难就直接放弃.</li>
<li>内网可以直接看电影.</li>
<li>自动下载大文件.</li>
<li>外网可访问.</li>
</ul>
<h1 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h1><ul>
<li>硬件没得纠结, NUC5i5优缺点都很明显.<ul>
<li>BIOS关闭所有不需要的外设, 降低风扇频率, 跑linux系统妥妥的超低功耗.</li>
<li>缺点是支持的盘位有限. 能用的就是一块SSD, 一块SATA硬盘. 剩下的就只有USB3.0的接口了.</li>
</ul>
</li>
<li>对于数据安全问题, 其实除了备份冗余, 同样重要的是数据恢复和异地存储.<ul>
<li>只关注备份冗余程度, 而不关注恢复价格和恢复难度, 那是没有意义的.</li>
<li>真正的数据安全, 还要防止物理地点上被一锅端的可能性. 如盗窃, 火灾. 因而最核心的资料必须有异地存储.</li>
</ul>
</li>
<li>故而, NUC5i5的缺点与我而言也不算大缺点.<ul>
<li>规划上够用, SSD放备份手机数据, SATA盘备份电脑数据, USB硬盘放影视资料.</li>
<li>为了异地存储, 我还会定期使用移动硬盘对核心资料进行单向备份, 然后将移动硬盘放在办公地点.</li>
<li>用RAID或者非常见的磁盘格式, 就意味着很难在自己熟悉的环境下进行数据恢复. (只接受FAT/NTFS/EXT系列的格式)<ul>
<li><strong>windows下识别ext4的方法: 安装<a href="https://sourceforge.net/projects/ext2fsd/files/Ext2fsd/0.69/">ext2fsd-0.69.exe</a>后, ext4硬盘会直接识别</strong></li>
</ul>
</li>
<li>单向备份本身就是一种RAID1模式, 再加上异地存储的移动硬盘, 对于普通家庭来说, 冗余度已经足够高了.</li>
</ul>
</li>
<li>为了配置省心, 免费和硬件低功耗, 选择了<a href="https://www.openmediavault.org/">OMV</a></li>
</ul>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ul>
<li>第一步, <a href="https://openmediavault.readthedocs.io/en/5.x/installation/index.html">安装OMV</a>. 过程略, 可参考<a href="https://post.smzdm.com/p/av7z2564/">OMV安装：系统安装设置及一些功能的开启</a>. 注意点如下:<ul>
<li>我使用的是U盘安装, 然后安装到U盘里. 因而需要不同容量的U盘, 便于区分.</li>
<li>容量小的U盘用来烧录OMV安装文件. 容量大的U盘作为OMV系统盘, 容量至少是<code>8G+RAM</code>, 建议直接上32G或64G, 再大也没必要.</li>
<li>BIOS最好打开<code>legacy</code>启动模式. OMV5也支持<code>UEFI</code>, 只是系统盘会多一个UEFI区.</li>
<li>将待安装的系统U盘, 用DiskGenius格式化为MBR磁盘. 否则装到一半容易报错, 内容如下:<ul>
<li><code>Partition(s) 1 on /dev/sda have been written, but we have been unable to inform the kernel of the change, probably because it they are in use. As a result, the old part it ion(s) will remain in use. You should reboot now before making further changes ERROR</code></li>
</ul>
</li>
<li>如果出错了, 删除EFI分区需要用到<code>diskpart</code>内的<code>clean</code>指令. 可参考<a href="https://blog.csdn.net/u013005025/article/details/52947632">DOS命令diskpart格式化磁盘</a>. <strong>务必再三确认, 谨慎操作!!!</strong></li>
<li>键盘选择 <code>keymap</code> 建议选 <code>British English</code>, 不选 <code>American English</code>. 我遇到了标点符号乱码的情况.</li>
<li><code>Root password</code> 要填写并记好.</li>
<li>安装完毕, 提示<code>Finsih the installation</code>, <strong>不要拔出安装用的U盘. 否则可能进不了OMV系统.</strong> 进过一次系统后, 可以安全拔出安装U盘.</li>
</ul>
</li>
<li>第二步, 配置OMV, 过程略, 继续参考 <a href="https://post.smzdm.com/p/av7z2564/">OMV安装：系统安装设置及一些功能的开启</a>. 注意点如下:<ul>
<li>配置 <code>网络-&gt;接口</code>时, DNS必须填, 一般填自己的网关地址即可.</li>
<li><code>更新管理</code> 里面有很多是用不到的软件包, 不建议无脑全部安装. 如果驱动没问题, 不更新也可以.</li>
<li><code>插件</code>部分, 我安装了 <code>backup</code>, <code>flashmemory</code>, <code>resetperms</code>, <code>omvextrasorg</code></li>
<li>一路安装到<code>Docker</code>和<code>portainer</code>即可. <code>cockpit</code>安装后运行失败, 也不知道开发者何时解决这个常见问题, 不装了.</li>
</ul>
</li>
<li>第三步, 挂载文件系统, smb共享. 基本配置可参考 <a href="https://www.jianshu.com/p/67b3587bb597">OpenMediaVault(OMV)共享文件夹/SMB设置</a>. 注意点如下:<ul>
<li><code>存储器</code>-&gt;<code>S.M.A.R.T</code>. 我没有激活SMART监测. 但是配置了测试计划, 每年进行一次短暂自检.</li>
<li>设置<code>共享文件夹</code>时, 先了解一下权限的相关知识, omv这一块做的很复杂.<ul>
<li><a href="https://www.flysfeq.site/index.php/archives/60/">OpenMediaVault 共享权限注意事项</a></li>
<li><a href="https://post.smzdm.com/p/a4wmvovk/">OMV使用篇三：文件共享</a></li>
<li><code>resetperms</code>插件就是用来恢复默认权限的.</li>
</ul>
</li>
<li>设置 <code>SMB/CIFS</code>共享文件时, 可以启用<code>权限继承</code></li>
</ul>
</li>
<li>第四步, 其它配置<ul>
<li><code>通告</code>, 配置一下SMTP, 这样OMV会及时发送email, 通告系统运行情况</li>
<li>插件 <code>backup</code> 要配置, 我用的 <code>fsarchiver</code>方式, 定期自动备份到指定目录. 可参考 <a href="https://opts-22.github.io/2020/10/17/omvbackup/">NAS系统备份与恢复以OMV为案例的几种方法</a></li>
<li>用的U盘当系统盘, 因而需要插件 <code>flashmemory</code>, 按照该插件<code>Notes(optional)</code>里的步骤, 用ssh, root权限依次修改执行.</li>
<li>omv挂载硬盘的名称又臭又长. 可以重命名磁盘名称, 并在<code>~</code>目录下建立软连接<ul>
<li>重命名ext格式磁盘名称: <code>e2label /dev/sdXX &quot;ssd-disk&quot;</code>. 其他格式的指令自查.</li>
<li>建立软连接: 譬如 <code>ln -s /srv/dev-disk-by-XXXXXXX/ ~/ssd-disk</code></li>
</ul>
</li>
<li>如果U盘容量不够, 可以考虑修改<code>docker</code>存储地址. 参考 <a href="https://www.youtube.com/watch?v=stTK4YBKSw4">如何修改 Docker 默认存储位置</a></li>
</ul>
</li>
</ul>
<h1 id="Docker之路"><a href="#Docker之路" class="headerlink" title="Docker之路"></a>Docker之路</h1><ul>
<li>镜像的安装<ul>
<li><a href="https://hub.docker.com/">Docker Hub</a>基本上都能搜到.</li>
<li>安装方式有命令行模式和docker compose. 推荐后者, 只需要一个yml文件.</li>
<li>命令行模式, 直接ssh即可. 也可以选择<code>Containers</code>进行配置. 参考 <a href="https://sspai.com/post/59364">Omv的Docker之路</a></li>
<li>docker compose. 更推荐. 参考 <a href="http://loonlog.com/2020/7/2/openmediavault5-omv5-docker-portainer-jellyfin/">OMV5利用图形化Docker工具Portainer部署jellyfin</a></li>
</ul>
</li>
<li>镜像的选择. 我这边按需选择, 尽量少折腾.(依然被折腾的够呛)<ul>
<li>先看看别人的选择.<ul>
<li><a href="https://post.smzdm.com/p/a8307lel/">NAS也能用上【统一认证】</a></li>
<li><a href="https://post.smzdm.com/p/alpompze/">谈谈如何使用docker，搭建一台“群晖”</a></li>
<li><a href="https://post.smzdm.com/p/ax02p2d9/">unraid折腾笔记 篇七：必装Docker推荐</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/143264028">NAS 上的 Docker</a></li>
</ul>
</li>
<li>简单评估和实验后的选择:<ul>
<li><a href="https://hub.docker.com/r/linuxserver/heimdall">heimdall</a>, 相当于收藏夹功能. 有用且方便. 不用记一大堆的端口号了.</li>
<li><del><a href="https://hub.docker.com/r/osixia/openldap">openLDAP</a>, 统一认证功能. 试了一下, 配置繁琐, 而且不是所有的应用都支持LDAP功能, 放弃使用.</del></li>
<li><a href="https://hub.docker.com/r/jellyfin/jellyfin">jellyfin</a>, 影音播放</li>
<li><a href="https://github.com/P3TERX/Aria2-Pro-Docker">aria2-pro</a>, 下载工具</li>
<li><a href="https://hub.docker.com/r/linuxserver/syncthing">syncthing</a>, 同步备份软件. 放弃了收费的 Resilio_sync</li>
<li><a href="https://hub.docker.com/r/filebrowser/filebrowser">filebrowser</a>, 文件管理</li>
<li><a href="https://github.com/butlerx/wetty">wetty</a>  网页版ssh</li>
</ul>
</li>
<li>外网访问:<ul>
<li>方案总结, 见 <a href="https://www.simongong.net/neiwangchuantouyuanchengkongzhiduankouyingshenzhongfangfahuizong/">内网穿透、远程控制、端口映射，N种方法汇总</a></li>
<li>不愿意折腾, 一度是放弃的. 我用的是 <a href="https://amplifi.com/">Ubiquiti AmpliFi</a> 路由器, 支持手机端的远程访问, 但不支持电脑.</li>
<li>找到了 <a href="https://www.zerotier.com/">zerotier</a>, 免费, 似乎简单易配置, 决定尝试一下.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="heimdall-收藏夹"><a href="#heimdall-收藏夹" class="headerlink" title="heimdall 收藏夹"></a><code>heimdall</code> 收藏夹</h2><ul>
<li><a href="https://hub.docker.com/r/linuxserver/heimdall">heimdall</a>, 使用docker-compose安装即可</li>
<li>PUID和GUID的值, 指令 <code>id user_name</code></li>
<li>TZ配置项, 参考<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">List of tz database time zones</a></li>
<li>ports, 为了避免冲突, 使用高位端口, 如 <code>8880:80</code>, 用8880映射80端口.</li>
<li>OMV的docker-compose, 选择<code>portainer.io</code>-&gt;<code>local</code>-&gt;<code>Stacks</code>-&gt;<code>Add stack</code>即可.</li>
</ul>
<h2 id="jellyfin-影音播放"><a href="#jellyfin-影音播放" class="headerlink" title="jellyfin 影音播放"></a><code>jellyfin</code> 影音播放</h2><ul>
<li><a href="https://hub.docker.com/r/linuxserver/jellyfin">jellyfin</a>, 使用docker-compose安装即可. 官网地址为 <a href="https://jellyfin.org/docs/">Welcome to the Jellyfin Documentation</a></li>
<li>OMV需要先共享音视频文件夹.</li>
<li>然后在<code>docker-compose</code>的<code>volumes</code>一栏下, 映射好相关文件夹.</li>
<li>输入<code>jellyfin</code>的地址<code>192.168.xx.xx:8096</code>, 设置<code>Users</code>, 添加<code>Libraries</code>即可.</li>
</ul>
<h2 id="filebrowsers-文件管理"><a href="#filebrowsers-文件管理" class="headerlink" title="filebrowsers 文件管理"></a><code>filebrowsers</code> 文件管理</h2><ul>
<li><a href="https://github.com/filebrowser/filebrowser">filebrowsers</a>, 使用如下docker-compose安装即可.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;2.1&quot;</span><br><span class="line">services:</span><br><span class="line">  filebrowser:</span><br><span class="line">    image: filebrowser&#x2F;filebrowser</span><br><span class="line">    container_name: filebrowser</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;srv:&#x2F;srv</span><br><span class="line">      #- .&#x2F;config.json:&#x2F;config.json     # 要自己指定配置文件的话, 必须先存在文件.</span><br><span class="line">      #- .&#x2F;database.db:&#x2F;database.db</span><br><span class="line">    ports:</span><br><span class="line">      - 8888:80</span><br><span class="line">    restart: unless-stopped</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="wetty-网页版ssh"><a href="#wetty-网页版ssh" class="headerlink" title="wetty 网页版ssh"></a>wetty 网页版ssh</h2><ul>
<li><a href="https://github.com/butlerx/wetty">wetty</a>, 使用如下命令安装即可.</li>
<li>docker指令安装 <code>docker run --restart always -p 3000:3000 wettyoss/wetty --ssh-host=192.168.xx.xx</code></li>
<li>网址登录 <code>192.168.xx.xx:3000/wetty</code></li>
<li>android端输入法, 推荐 <code>Hacker&#39;s Keyboard</code></li>
</ul>
<h2 id="aria2pro-下载工具"><a href="#aria2pro-下载工具" class="headerlink" title="aria2pro 下载工具"></a>aria2pro 下载工具</h2><ul>
<li><a href="https://p3terx.com/archives/docker-aria2-pro.html">aria2pro</a>, 使用如下docker-compose安装即可.</li>
<li>初次登录会显示认证失败, 需要在AriaNg设置-&gt;RPC(192.168.XX.XX)里面输入<code>RPC_SECRET</code>里设置的密码.</li>
<li>可参考 <a href="https://yiwangmeng.com/aria2-status-page-to-prompt-the-solution-of">打开Aria2状态页面提示认证失败的解决办法</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3.8&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  aria2-pro:</span><br><span class="line">    container_name: aria2-pro</span><br><span class="line">    image: p3terx&#x2F;aria2-pro</span><br><span class="line">    environment:</span><br><span class="line">      - PUID&#x3D;1000</span><br><span class="line">      - PGID&#x3D;1000</span><br><span class="line">      - UMASK_SET&#x3D;022</span><br><span class="line">      - RPC_SECRET&#x3D;1234abcd     # 设置一个密码, 用来连接Aria2</span><br><span class="line">      - RPC_PORT&#x3D;6800</span><br><span class="line">      - LISTEN_PORT&#x3D;6888</span><br><span class="line">      - DISK_CACHE&#x3D;64M</span><br><span class="line">      - IPV6_MODE&#x3D;false</span><br><span class="line">      - UPDATE_TRACKERS&#x3D;true</span><br><span class="line">      - CUSTOM_TRACKER_URL&#x3D;</span><br><span class="line">      - TZ&#x3D;Australia&#x2F;Melbourne</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;path&#x2F;to&#x2F;docker_data&#x2F;aria2&#x2F;config:&#x2F;config</span><br><span class="line">      - &#x2F;path&#x2F;to&#x2F;download_file:&#x2F;downloads</span><br><span class="line"># If you use host network mode, then no port mapping is required.</span><br><span class="line"># This is the easiest way to use IPv6 networks.</span><br><span class="line">    network_mode: host</span><br><span class="line">#    network_mode: bridge</span><br><span class="line">#    ports:</span><br><span class="line">#      - 6800:6800</span><br><span class="line">#      - 6888:6888</span><br><span class="line">#      - 6888:6888&#x2F;udp</span><br><span class="line">    restart: unless-stopped</span><br><span class="line"># Since Aria2 will continue to generate logs, limit the log size to 1M to prevent your hard disk from running out of space.</span><br><span class="line">    logging:</span><br><span class="line">      driver: json-file</span><br><span class="line">      options:</span><br><span class="line">        max-size: 1m</span><br><span class="line"></span><br><span class="line"># AriaNg is just a static web page, usually you only need to deploy on a single host.</span><br><span class="line">  ariang:</span><br><span class="line">    container_name: ariang</span><br><span class="line">    image: p3terx&#x2F;ariang</span><br><span class="line">#    command: --port 6880 --ipv6</span><br><span class="line">    network_mode: host</span><br><span class="line">#    network_mode: bridge</span><br><span class="line">#    ports:</span><br><span class="line">#      - 6880:6880</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">    logging:</span><br><span class="line">      driver: json-file</span><br><span class="line">      options:</span><br><span class="line">        max-size: 1m</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="syncthing-同步工具"><a href="#syncthing-同步工具" class="headerlink" title="syncthing 同步工具"></a>syncthing 同步工具</h2><ul>
<li><a href="https://syncthing.net/">syncthing</a>, 好用的全平台同步工具.<ul>
<li>自己的需求很简单, 只需要内网同步.</li>
<li>手机和NAS, <code>Pictures</code>, <code>DCIM</code>, <code>Download</code>文件夹双向同步</li>
<li>电脑和NAS, 单向同步. NAS作为备份端即可.</li>
<li>不需要版本控制.</li>
</ul>
</li>
<li>Windows端名称为<code>SyncTrayzor</code>, Android端就是<code>syncthing</code></li>
<li>OMV端安装到Docker中, 使用如下docker-compose安装即可. 参考 <a href="https://hub.docker.com/r/linuxserver/syncthing">linuxserver/syncthing</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;2.1&quot;</span><br><span class="line">services:</span><br><span class="line">  syncthing:</span><br><span class="line">    image: ghcr.io&#x2F;linuxserver&#x2F;syncthing</span><br><span class="line">    container_name: syncthing</span><br><span class="line">    hostname: syncthing #optional</span><br><span class="line">    environment:</span><br><span class="line">      - PUID&#x3D;1000</span><br><span class="line">      - PGID&#x3D;1000</span><br><span class="line">      - TZ&#x3D;Australia&#x2F;Melbourne</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;path&#x2F;to&#x2F;docker_data&#x2F;syncthing&#x2F;config:&#x2F;config  # syncthing的默认路径</span><br><span class="line">      - &#x2F;path&#x2F;to&#x2F;data:&#x2F;data                 # 电脑数据单向备份</span><br><span class="line">      - &#x2F;path&#x2F;to&#x2F;smartphone:&#x2F;smartphone     # 手机数据双向备份</span><br><span class="line">    ports:</span><br><span class="line">      - 8384:8384               # GUI界面端口</span><br><span class="line">      - 22000:22000             # 数据同步端口</span><br><span class="line">      - 21027:21027&#x2F;udp         # 设备监听端口</span><br><span class="line">    restart: unless-stopped</span><br></pre></td></tr></table></figure></li>
<li>应用<ul>
<li>先匹配设备, 再从备份源一端共享目录, 这样最方便.</li>
<li>关联文件夹使用的是 <code>文件夹ID</code>, 默认会给出随机字符, 且创建共享文件夹后不可修改, 建议自己提前设置成有意义的名字.</li>
</ul>
</li>
<li>配置<ul>
<li>所有电脑都在同一个局域网下的话, 系统<code>设置</code>-&gt;<code>连接</code>-&gt;反选<code>全球发现</code>, 反选<code>启用 NAT 遍历</code>, 反选<code>开启中继</code></li>
<li>OMV端的文件夹权限需要改成777, 可以在OMV共享文件夹设置里, <code>Reset Permissions</code> -&gt; <code>每个人:读/写.</code></li>
<li><code>文件夹选项</code>. <code>高级</code>. 如果是和Windows/Android同步, 勾选 <code>忽略文件夹权限</code></li>
<li><code>文件夹选项</code>. 忽略模式. 忽略Linux隐藏文件, Windows回收站, 系统文件等.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.*</span><br><span class="line">!.gitignore</span><br><span class="line">*RECYCLE*\</span><br><span class="line">*Recycle*\</span><br><span class="line">**\desktop.ini</span><br><span class="line">**\thumbs.db</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>参考资料<ul>
<li><a href="https://zhuanlan.zhihu.com/p/121544814">(二十三)小众但好用: Syncthing 把手机变成同步网盘</a></li>
<li><a href="https://www.appinn.com/syncthing/">Syncthing – 数据同步新选择，手把手教你做自己的网盘</a></li>
<li><a href="https://ld246.com/article/1597823746488">论多设备同步文件，它说第二，没人敢说第一：Syncthing 使用笔记</a></li>
<li>权限问题的讨论, 里面用了ACL模式. <a href="https://forum.yunohost.org/t/syncthing-permissions-create-a-share-with-existing-folder/8265">Syncthing / permissions — Create a share with existing folder</a></li>
</ul>
</li>
</ul>
<h2 id="zerotier-外网访问"><a href="#zerotier-外网访问" class="headerlink" title="zerotier 外网访问"></a>zerotier 外网访问</h2><ul>
<li>zerotier 建议直接在NAS主机运行, 不要用docker.</li>
<li>图文教程, 参考<a href="https://blog.csdn.net/RadiantJeral/article/details/104150070">ZeroTier 的安装与使用</a>.</li>
<li>安装指南参考<a href="https://www.zerotier.com/download/#downloadLinux">zerotier官网</a><ul>
<li>先zerotier官网创建一个账号, <code>Create A Network</code>, 获取<code>Network ID</code></li>
<li>安装curl <code>sudo apt install curl</code></li>
<li>安装zerotier <code>curl -s https://install.zerotier.com | sudo bash</code><ul>
<li>安装成功, 最后会显示 <code>Success! You are ZeroTier address [ 7cXXXXXX6f ]</code></li>
</ul>
</li>
<li><code>zerotier-cli join 35xxxxxxxxxxxx22</code> 将设备通过<code>Network ID</code>加入到zerotier网络.</li>
<li><code>zerotier-cli set 35xxxxxxxxxxxx22 allowManaged=1</code></li>
<li><code>zerotier-cli info</code> 检查连接状态. 返回值 <code>200 info 7cXXXXXX6f 1.6.4 ONLINE</code></li>
<li>在另外一台设备上, 如windows或手机端. 安装zerotier, 加入网络. 网页端使能加入的网络.</li>
<li>两个设备相互ping zerotier给出的ip地址.</li>
<li>然后再测试外网的情况. 如果外网情况也能相互ping通, 继续设置.</li>
<li>在zerotier官网管理界面 <code>Managed Routes</code>, 添加转发规则 <code>家庭局域网IP/24 via NAS在zero-tier端的IP</code>,<ul>
<li>譬如 <code>192.168.1.0/24 via 10.147.17.111</code>.</li>
<li>其中的<code>192.168.1.0</code>是家庭局域网地址段,</li>
<li>其中的<code>10.147.17.111</code>是zero-tier分配给NAS的地址.</li>
</ul>
</li>
<li>NAS端打开IP转发 <code>sudo sysctl -w net.ipv4.ip_forward=1</code></li>
<li>测试: 外网电脑登录OMV控制界面.</li>
<li>安装完成.</li>
</ul>
</li>
<li>我这边, 一共试了三到四次, 总是失败. 最后发现是路由器的问题.<ul>
<li><code>Amplifi</code>需要关闭<code>硬件NAT</code>功能, 有线连接的设备才能正常使用第三方VPN.</li>
<li>参考资料 <a href="https://community.amplifi.com/topic/3916/unable-to-connect-to-my-work-vpn">UNABLE TO CONNECT TO MY WORK VPN</a></li>
<li>把折腾过程也记录一下, 仅供参考.</li>
</ul>
</li>
</ul>
<h2 id="zerotier-折腾记"><a href="#zerotier-折腾记" class="headerlink" title="zerotier 折腾记"></a><del>zerotier 折腾记</del></h2><ul>
<li>凭着记忆记录下折腾过程. 没有遇到问题的话, 不需要看.</li>
<li>现象: NAS端显示连接zerotier成功, 有ip地址, 返回200, 显示ONLINE. 但内外网都ping不通.</li>
<li>一通查资料和修改, 突然ping通了内网. 大概的折腾过程如下:<ul>
<li><code>apt-get install net-tools</code> 安装 netstat.  <code>netstat -ntulp | grep 9993</code> 查看9993端口使用情况.</li>
<li><code>ip link</code> 查看网卡状态. zerotier的网卡名字为 zt开头的一串数字字母组合.</li>
<li><a href="https://github.com/zerotier/ZeroTierOne/issues/74">Make MTU configurable</a><ul>
<li>默认的mtu=2800, 应该有问题. 我设置成了<code>ip link set ztxxxxxxxx mtu 1500</code></li>
</ul>
</li>
<li><a href="https://github.com/zerotier/ZeroTierOne/issues/809">Failing to assign IP to network interface</a><ul>
<li><code>modprobe tun</code> 确定tun可用</li>
<li><code>nano /lib/systemd/system/zerotier-one.service</code> 加入<code>-U</code></li>
<li>删除<code>zerotier-one</code>的user和group:<ul>
<li><code>id zerotier-one</code> 查看用户信息 <code>nano /etc/group</code> 查看组信息</li>
<li><code>userdel zerotier-one</code>  删除用户</li>
<li><code>groupdel group</code> 删除用户组</li>
</ul>
</li>
<li>后面还提到了添加 <code>/etc/systemd/network/50-zerotier.conf</code>文件<ul>
<li><code>Name=zt* Unmanaged=yes</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>这样可以ping内网, 但还是ping不通外网. 继续瞎折腾<ul>
<li>参考资料.<ul>
<li><a href="https://chrisatech.wordpress.com/2020/02/09/setting-up-a-zerotier-network/">设置ZeroTier网络</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/getting-started-software-defined-networking-creating-vpn-zerotier-one">Getting Started with Software-Defined Networking and Creating a VPN with ZeroTier One</a></li>
<li><a href="https://www.v2ex.com/t/681731">Zerotier 异地组网问题</a></li>
<li><code>zerotier-cli listnetworks</code> 查看状态</li>
<li><code>zerotier-cli info</code> 查看是否在线</li>
<li><code>systemctl restart zerotier-one</code> 重启服务. 另stop则停止, start则开始.</li>
</ul>
</li>
<li>最后放弃. 想着自己的路由器是AmpliFi, 可以很方便的实现手机外网访问.</li>
</ul>
</li>
<li>彻底卸载 Zerotier-one 的方法<ul>
<li>参考 <a href="https://www.taodudu.cc/news/show-1734416.html">搭建Zerotier内网穿透网络及彻底删除zerotier方法</a></li>
<li><code>sudo dpkg -P zerotier-one</code></li>
<li><code>sudo rm -rf /var/lib/zerotier-one/</code></li>
</ul>
</li>
<li>最后一次尝试前, 查了一下路由器端的资料, 关了硬件NAT, 重新安装配置, 一切顺利…</li>
</ul>
<h1 id="Clonezilla-系统盘备份"><a href="#Clonezilla-系统盘备份" class="headerlink" title="Clonezilla 系统盘备份"></a>Clonezilla 系统盘备份</h1><ul>
<li>防止系统盘损害, 无法启动. 直接替换克隆下的系统U盘即可.</li>
<li>克隆系统U盘方法如下:<ul>
<li>NAS-OMV主页-&gt;<code>磁盘</code>-&gt;<strong>确定系统盘的序列号, 记录下来</strong></li>
<li>插入目标U盘-&gt;方法同上, 记录下序列号.</li>
<li>NAS-OMV主页-&gt;<code>OMV-extras</code>-&gt;<code>内核</code>-&gt;<code>再生龙 Clonezilla</code>-&gt;安装</li>
<li>然后点击下面的<code>从再生龙 Clonezilla 启动一次</code>.</li>
<li>重启 NAS-OMV, 等待进入Clonezilla系统.</li>
<li>使用ssh, 登录到Clonezilla界面. 用户名<code>user</code>, 密码<code>live</code></li>
<li>输入指令 <code>sudo clonezilla</code>, 启动该软件.</li>
<li>选择第二项, 设备到设备. <code>device-device work directly from ...</code></li>
<li>选初学者模式 <code>beginner ...</code></li>
<li>选磁盘到磁盘 <code>disk to local disk</code></li>
<li>然后选择母盘, <strong>注意序列号, 千万别选错!!!</strong></li>
<li>然后选目标盘, <strong>注意序列号, 千万别选错!!!</strong></li>
<li>选第一项 <code>sfsck</code> 跳过文件系统检查</li>
<li>然后选完成后的动作. 选第一项即可 <code>-pa choose</code></li>
<li>一路 <code>y</code> 就开始克隆了.</li>
<li>拔掉母盘, 输入 <code>reboot</code>, 测试是否克隆成功.</li>
</ul>
</li>
<li>参考资料<a href="https://www.bilibili.com/s/video/BV1S7411h7PH">Clonezilla 克隆系统盘 OMV 无限续命大法 再生龙 | 一台电脑的 NAS 之旅</a></li>
</ul>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>NAS</tag>
        <tag>OMV</tag>
      </tags>
  </entry>
  <entry>
    <title>开悟是怎样一种体验？(新)</title>
    <url>/2021/04/05/2110-satori2/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
<li><a href="https://draapho.github.io/2021/03/05/2107-tuibeitu1/">万年歌, 马前课, 梅花诗, 推背图 (上)</a></li>
<li><a href="https://draapho.github.io/2021/03/18/2108-tuibeitu2/">万年歌, 马前课, 梅花诗, 推背图 (下)</a></li>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/26/2123-caseofsatori/">见性者体验收集</a></li>
</ul>
<h1 id="天赐问答"><a href="#天赐问答" class="headerlink" title="天赐问答"></a>天赐问答</h1><ul>
<li><a href="https://draapho.github.io/2021/04/14/2111-answer1/">天赐问答1: 知行合一, 方为真知.</a></li>
<li><a href="https://draapho.github.io/2021/04/15/2112-answer2/">天赐问答2: 总是拖延, 该怎么办?</a></li>
<li><a href="https://draapho.github.io/2021/04/16/2113-answer3/">天赐问答3: 凡夫一向动, 小乘一向静</a></li>
<li><a href="https://draapho.github.io/2021/04/17/2114-answer4/">天赐问答4: 烦恼名众生, 悟解名菩提</a></li>
<li><a href="https://draapho.github.io/2021/04/18/2115-answer5/">天赐问答5: 如何放下对结果的期待</a></li>
<li><a href="https://draapho.github.io/2021/04/19/2116-answer6/">天赐问答6: 为什么真正的境界不会退转?</a></li>
<li><a href="https://draapho.github.io/2021/04/20/2117-answer7/">天赐问答7: 为什么开悟的似乎都是男人, 女人呢?</a></li>
<li><a href="https://draapho.github.io/2021/04/21/2118-answer8/">天赐问答8: 男女欲望该怎么处理?</a></li>
<li><a href="https://draapho.github.io/2021/04/22/2119-answer9/">天赐问答9: 不完美, 才会独一无二</a></li>
<li><a href="https://draapho.github.io/2021/04/23/2120-answer10/">天赐问答10: 不要辜负你的生命</a></li>
<li><a href="https://draapho.github.io/2021/04/24/2121-answer11/">天赐问答11: 100多年前的马克思主义, 过时了吗?</a></li>
<li><a href="https://draapho.github.io/2021/04/25/2122-believe/">我们到底该信什么，不该信什么？</a></li>
</ul>
<p><em><strong>转载自 <a href="https://www.zhihu.com/people/LingTC/answers">灵天赐的回答</a></strong></em><br>灵天赐在知乎关于开悟的两篇回答, 不断地删改着. 之前一度完全删除. 现发现又有更新, 并加上了许多个人体悟.<br>对于第一版的<a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a>, 给我的感觉是: “不敢说他一定走到了终点, 但已远远超出绝大部分的修行人. “<br>他另有一篇类似的回答放到了微信公众号: <code>禅医堂</code>, 两篇文章有诸多分别, 我也转载了, 见<a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></p>
<p>而这一篇对<code>开悟</code>的回答, 是灵天赐在删除之后, 于2021年2月23日又重新公开出来. 新增的体悟, 清澈而通透, 不再有普渡众生之类的念头, 无任何执着了. 在我看来: <strong>“他将隐未隐, 完全是个得道者了. 公开的修行之言, 估计这会是灵天赐的最后一篇.”</strong></p>
<hr>
<h1 id="灵天赐解释开悟"><a href="#灵天赐解释开悟" class="headerlink" title="灵天赐解释开悟"></a>灵天赐解释开悟</h1><p>开悟，<strong>指人类通过对自我认知的提升，从而达到一种内在圆满的精神状态。</strong></p>
<p>与烧香拜泥，磕头念经，从属什么类型的信仰体系，没有直接关系。</p>
<p>‘开悟’这个词所描述的，是一种人类意识向内攀登，达到认知顶峰时产生深刻智慧的状态，与神通无关。</p>
<p>开悟不会让人无所不能，也不会让人永生不死，更不会让人拥有什么超能力。</p>
<p>但是，开悟比以上三种超现实能力更厉害。</p>
<p>为什么？</p>
<p>无所不能的人，也不能免除烦恼；</p>
<p>永生不死的人，也不能消除孤独；</p>
<p>神通具足的人，也不能停止苦受。</p>
<p>可是，开悟能消融烦恼，忘却孤独，能让人在每一个无论美好与否的当下，都收获幸福与平和。</p>
<h1 id="灵天赐的心得体会"><a href="#灵天赐的心得体会" class="headerlink" title="灵天赐的心得体会"></a>灵天赐的心得体会</h1><p>之前，我的本意，是将本回答删除不写。</p>
<p>后来感觉，还是应给后来人留下一条道路，作为参考。</p>
<p>一年多前写的这个回答，随着我的认知深入，修改过多次。</p>
<p>这一次，是最后一次了。</p>
<p>以前，我有很多想说的，很多想教的，很多想分享的。</p>
<p>从现在开始，没有了。</p>
<p>万事万物都以道的韵律自在变化，没必要去刻意的干扰。</p>
<p>每个人都有独一无二的心灵觉悟之路，也有独一无二的内证体验。</p>
<p>我的体验，我的道路，永远只能作为别人的参考，不能给别人作为标准答案，去照猫画虎。</p>
<p>以前写的东西，现在的我，已全部忘却。</p>
<p>此刻，方才明白。</p>
<p>为何古代圣人们，留下的大道文字，从来不提任何内证相关的东西。</p>
<p>因为这些细节，只会被人的恭高我慢利用，成为人脑的思维用来营造幻觉的最佳材料。</p>
<p>同时，因为真实性，也会被某些心怀不轨者利用。</p>
<p>摘抄只言片语，用来误人子弟。</p>
<p>所以，不能怪圣人们，不把经典写得奇异有趣。</p>
<p>有些话，有些经验，不是对的人，不是有切身体会的人，是不能阐述的。</p>
<p>不是秘密，也非藏私，而是不必阐述。</p>
<p>就像一个登上喜马拉雅山顶峰的人，为一个站在山脚的人，阐述再多他自己攀爬喜马拉雅山所见的沿途风景，自己登山所用的技巧方法，都是毫无意义的。</p>
<p>并不能凭借这些，让山脚这人成功登上山顶。</p>
<p>因为山脚这人，未必与你走同一条路。</p>
<p>即使走的是同一条路，也未必会见到完全相同的风景。</p>
<p>即使见到完全相同的风景，也未必会有一模一样的阻碍。</p>
<p>所以，你所讲述的沿途景色，容易给对方造成各种误解。</p>
<p>对方到某处时，没见到与你叙述相同的景色。</p>
<p>会心生疑惑，怀疑是否走错了路，以至于走向完全错误的方向。</p>
<p>若无人点醒，终生难以寸进。</p>
<p>圣人们一生精力有限，能与他们接触的人也有限，不可能在每个人身边时时提点。</p>
<p>以朴实无华的语言描述大道，才是最有益于众生的。</p>
<p>毕竟，道是无法阐述的，也是无法定义的。</p>
<p>用语言文字去阐述的瞬间，这种阐述本身，也就演变为另一种误解。</p>
<p>释迦牟尼才会说，他不曾说一法。</p>
<p>老子才会说，道可道，非常道。</p>
<h1 id="灵天赐讲禅宗"><a href="#灵天赐讲禅宗" class="headerlink" title="灵天赐讲禅宗"></a>灵天赐讲禅宗</h1><p><strong>因此，而有禅宗神秘的‘以心传心’。</strong></p>
<p>越过语言文字和物质表象，借助心灵高度契合的瞬间，直接向对方传递自己的领悟。</p>
<p>这是一种超越人类目前认知的学习方式，举个形象的例子：</p>
<p>一名驾龄30年的顶尖赛车手，和一名甚至没开过车的新手，两人坐在一起。</p>
<p>他们默默对视一分钟。</p>
<p>或是沉默之后，赛车手突然开口，说了一句话。</p>
<p>下一刻，这位新手心中就豁然开朗，又哭又笑。</p>
<p>从这时起，这位新手明确无疑的知晓。</p>
<p>他已彻底学会了这位顶尖赛车手的所有技术，仿佛他自己也亲自开了30年的赛车一样。</p>
<p>唯独，只欠一点经验。</p>
<p>一旦坐在驾驶座上，新手司机就会自然而然的知道该怎么开车，遇见各种突发情况时要如何避让。</p>
<p><strong>与赛车手相比，只在熟练度上有所差别。</strong></p>
<p><strong>技术上，赛车手会的，新手全都会了。</strong></p>
<p>这种不可思议的高等级学习方式，是超越人类现有认知的。</p>
<p>对师者与学者，均有极高的要求，不是能普传的。</p>
<p>学者对师者的信任，但凡差了一丝，哪怕只是亿分之一的差距。</p>
<p>师者只会对牛弹琴，以心传心绝不会发生。</p>
<p>对学者而言，就像毫无征兆的从万丈高峰跳下，心怀担忧与恐惧，却依然坚信站在下方的师者，一定能准确无误的接住自己。</p>
<p>因此，以心传心对师者的要求，也是极高。</p>
<p>学者付出了无条件的绝对信任，一旦选错师者，无异于舍身掉入万丈深渊。</p>
<p>学者若福缘善财不足，加上没有正眼，误认一个糟糕的老师，相当于踏上了通向地狱的直通车。（这个地狱，指活着的地狱————一人入狱=全家入狱。）</p>
<p><strong>能达到以心传心标准的学者，极其稀少。</strong></p>
<p><strong>能进行以心传心教授的师者，凤毛麟角。</strong></p>
<p>所以，生活中没这个机缘，也没必要强求。</p>
<p>依我所见，许多追求觉悟的学者，基本都是抱着半吊子的诚心，坐在各种通向地狱的直通车上。</p>
<p>也是为什么，本准备删除的回答，改为重写一次。</p>
<p>留下一条我的道路，仅供诸位参考。</p>
<p>禅宗修行，有三关。</p>
<p><strong>第一关，明心；</strong></p>
<p><strong>第二关，见性；</strong></p>
<p><strong>第三关，入道。</strong></p>
<p>最初修行的本质。是从外界的各种意相牵引中，收回被外界带走的注意力，将注意力安住在内在的觉知中，并将其永远的固定下来。</p>
<p><strong>找回这种后天失去的觉知，将其恒定，便是‘明心’。</strong></p>
<p>凭借这份觉知，察觉自我的存在，一步一步的打击和消亡自我。</p>
<p>自我消亡的刹那，本性就会自然而然的彰显出来。</p>
<p>本性彰显之后，人就会从认假为真中脱离。</p>
<p>明白以前所误以为的自己，不过是一个朝生夕灭的概念自我，是虚幻不真的一时现象。</p>
<p>唯独这个不生不灭的本性，才是真实的自己。</p>
<p><strong>自我短暂消亡，本性彰显而出的瞬间，便是‘见性’。</strong></p>
<p>本性彰显之后，直觉会得到增强，对道产生感应。</p>
<p>道，不再是人脑中的概念化认知，而是一种切实的感触。</p>
<p>开始能在日常生活中，看见道的玄奥轨迹。</p>
<p>自我在生活中陷入沉寂，其实并未消失，只是化作一种更难以察觉的方式。</p>
<p>幻化成种种欲望，试图将你引离正确的道路。</p>
<p>比如：</p>
<p>物质世界的成就，来自他人的崇拜，声名显赫的诱惑，教导他人的傲慢等等。</p>
<p>通过生活经历的指引，一个个的识破幻相。</p>
<p>最终，会进入一个无自我领域。</p>
<p>如果，一定要形容此刻的感触，便是“清静”。</p>
<p><strong>湮灭私欲，无人无我舍己应道，便是‘入道’。</strong></p>
<h1 id="各阶段的具体方法"><a href="#各阶段的具体方法" class="headerlink" title="各阶段的具体方法"></a>各阶段的具体方法</h1><h2 id="1-明心阶段："><a href="#1-明心阶段：" class="headerlink" title="1. 明心阶段："></a><strong>1. 明心阶段：</strong></h2><p>明心，需刻苦练习的，只有一个————<strong>‘观察’</strong>。</p>
<p>‘观察’指时时刻刻的知道，自己脑中正在浮动什么念头，自己心中正在起什么情绪，自己对于事物正在浮现什么感觉。</p>
<p>‘观察’能力的锻炼，有两种方式。</p>
<h3 id="第一种方式：全情投入的做事，以至于忘记一切，进入无时间的心流状态。"><a href="#第一种方式：全情投入的做事，以至于忘记一切，进入无时间的心流状态。" class="headerlink" title="第一种方式：全情投入的做事，以至于忘记一切，进入无时间的心流状态。"></a><strong>第一种方式：全情投入的做事，以至于忘记一切，进入无时间的心流状态。</strong></h3><p>这种方式很简单，只在你需要做事的时候使用就好。</p>
<p>比如工作的时候、学习的时候、看电影的时候、玩游戏的时候，或者其他任何需要投入你所有注意力的时候。</p>
<p>全身心的投入进去，心无杂念的去做，这样就是最好的练习。</p>
<h3 id="第二种方式：时时刻刻的反观脑海。"><a href="#第二种方式：时时刻刻的反观脑海。" class="headerlink" title="第二种方式：时时刻刻的反观脑海。"></a><strong>第二种方式：时时刻刻的反观脑海。</strong></h3><p>上一种方式，主要作为第二种方式的补充，日常练习以第二种方式为主。</p>
<p>第二种方式，是将注意力，从面前的事物中抽离出来。</p>
<p>就像是给自己设定了一个第三视角监控，时时刻刻监测自己脑海中的心念起伏，以及自己每时每刻的情绪变化。</p>
<p>时常有人对此产生误解，误以为看到这些念头、情绪、感觉之后，应去控制或是压抑它们。</p>
<p>这是错误的，你不需要做任何事。</p>
<p>只是默默地‘看见’，已经足够了。</p>
<p>不必画蛇添足，试图去控制和压抑。</p>
<p>试图这样做的瞬间，你就已从‘观察’中彻底脱离，陷入了与空气斗智斗勇的徒劳。</p>
<h3 id="补充：-四念住"><a href="#补充：-四念住" class="headerlink" title="补充： (四念住)"></a><strong>补充：</strong> (四念住)</h3><p>除去这两种方式外，还有一种方式，可作为不时练习的补充。</p>
<p>这种方式叫‘四念住’，具体方式如下：</p>
<p>吃饭的时候，全身心吃饭，将你的所有五感扩大到极致，感受牙齿的碰撞，饭菜的味道再舌头上泛开，微风吹拂你脸上的汗毛，远方传来的声音，屁股与椅子相互的支撑，脚底与地面的阻力，腰椎对全身的支撑等等……</p>
<p>走路时，洗碗时，扫地时，也是同理。</p>
<p>不需要太频繁，也不需要太久，几天一次， 一次几分钟就足够了。</p>
<p>能感受多少，就竭尽全力的感受多少信息。</p>
<p>通过以上三种方式的交替练习，对内在的‘观察’会被逐渐恒定下来，直到不投注关注也能维持为止。</p>
<p>这时，这种‘观察’就能连贯一天中的24个小时。</p>
<p>连睡梦中，也不再丢失这份观察之后。</p>
<p>就会明白‘心’在何处，‘心’是什么？</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>观察本身应是毫不费力的，‘观察’只会对需要你全情投入的事情产生干扰，比如学习一本书或者写一篇文章。</p>
<p>这种时候，只需切换为第一种方式即可。</p>
<p>若在走路时，发现观察干扰了正常走路，或是你与朋友的对话，说明观察的方法过于用力，错了。</p>
<p>‘观察’是一种自热而然的觉知，是无需用力的，就像眼角余光一样。</p>
<h2 id="2-见性的方法："><a href="#2-见性的方法：" class="headerlink" title="2. 见性的方法："></a><strong>2. 见性的方法：</strong></h2><p>此后，会对日常生活中的一切，拥有不间断的觉察。</p>
<p>凭借这种观察，去观察生活中的一切问题，解决自己心中关于人生、世界、形而上学的各种疑惑。</p>
<p>不断的学习知识，同时越来越多的帮助他人，成就他人。</p>
<p>就会越来与与道相应，内心也会变得越来越柔软温暖。</p>
<p>不断的宽恕过去，不断的释放未来，越来越深的进入当下。</p>
<p>这个阶段，不是只在意识之中下功夫。</p>
<p>更多是要在现实之中下功夫。</p>
<p>易怒者，会调理自己的秉性逐渐变得平和；</p>
<p>悲观者，会转变自己的信念逐渐变得积极；</p>
<p>记仇者，会扭转自己的心胸逐渐变得宽广。</p>
<p>同时，也与自己现实生活中的一切矛盾，进行和解。</p>
<p>与父母兄弟的矛盾，与亲戚朋友的矛盾等等。</p>
<p>所有的和解，都要通过转变自己内心深处对他人的看法，宽恕他人的罪过，从而实现。</p>
<p>这个阶段，有一个简单易行的方法：</p>
<p><strong>舍弃自我！</strong></p>
<p><strong>最好的舍弃自我，是行善。</strong></p>
<p><strong>以不求回报、不求被人知晓的方式，默默无闻的帮助别人，连对方的感激也不需要。</strong></p>
<p>对一切真诚，决不可自欺欺人。</p>
<p>明白的，就是明白；不明白的，就是不明白。</p>
<p>如果能够始终保持自己的真诚与善良，继续积攒善财，就会不可避免的遇见真正的师者。</p>
<p>会从对方的话语中受到触动，并升起自然而然的信任。</p>
<p>伴随师者的指导解惑，不断的舍我成就他人，不断的反省和打击自己身上那些自私自利的部分。</p>
<p>最终，一切的付出，都会在某个不可思议的契机中，得到回报。</p>
<p>见性的契机，每个人都不一样。</p>
<p>有人盆落而悟，有人鸟飞而悟。</p>
<p>倒不是因为，顿悟契机多么罕见或多么神奇。</p>
<p>而是积累的火候到了，无论什么东西，都可以成为见性的契机。</p>
<p>比如我，因为从小爱看小说。</p>
<p>当时，我便是坐在阳光灿烂的草坪上，在手机上看《异界生活助理神》这本小说，心生触动从而见性。</p>
<p>‘见性’之后，会勘破生死的本质。</p>
<p>此后，不再畏惧和担忧死亡。</p>
<p>因为，亲眼见证了那不生不灭的本在。</p>
<p>从此热烈的拥抱生命，被一种无法言语的喜乐，疗愈过去的所有苦痛。</p>
<h2 id="3-入道的方法："><a href="#3-入道的方法：" class="headerlink" title="3. 入道的方法："></a><strong>3. 入道的方法：</strong></h2><p>明心的人，易被我慢驱使而不自知，陷入自我之中难以自拔。</p>
<p>见性的人，易被他人的顽执而激怒，陷入执着辩解无法自拔。</p>
<p>见性之后，直觉的指引十分明确，可自我也会随之进入一种变得更难察觉的隐态，试图混淆直觉的指引。</p>
<p>这个时候，很难分清什么是真我的愿望，什么又是自我的欲望，易被贪执带偏。</p>
<p>要不断的经历，一点一点的辨别。</p>
<p>比如，一年多前，我刚写下这篇回答时，就处于见性后，入道前的状态。</p>
<p>评论区有实在看不过去的评论，会回复几句。</p>
<p>现在就不会了，赞扬也好，诋毁也罢，都看得过去，都不必回复。</p>
<p>说到这里，顺便一提。</p>
<p>虽然之前基本不回评论，可知乎上，目前为止，每一个回答下每一个人的评论，我都认真看过。</p>
<p>因为，我能通过自己面对不同评论时的反应，从而测试自己面对不同水平的人时，心中下意识的反应。</p>
<p>这一点，是无法自欺的。</p>
<p>一般而言，完全见性之后，就有资格当老师了。</p>
<p>毕竟，全中国的修行者，即便算上深山老林、荒寺破观中藏着的那一批，能达到这种水平的也不超过50人。</p>
<p>见性者对学生，怎么教都没问题。</p>
<p>基本没有答不上的问题，寥寥几句，就能让人豁然开朗。</p>
<p>不过，自我也为见性者，设下一个无形陷阱。</p>
<p>见性者，沉浸于老师的身份，好为人师。</p>
<p>不明平等智的真谛，放不下老师的身份，此后会不得存进。</p>
<p>即使如此，他们在生活中，也能造福一方。</p>
<p>可以产出令人瞩目的成就，帮到很多人。</p>
<p>只不过，对见性者自身而言。</p>
<p>会因为自我阻碍，无法进入下一个境界罢了。</p>
<p>见性之后，若能始终跟随直觉，不抗拒不期待不固守，随顺事物的变化。</p>
<p>会被指引着，经历各种事情，向几位不同风格的师者学习。</p>
<p>将自己知行上的各种缺失，都逐一填充圆满之后。</p>
<p>便会落尽人世的凡执妄想。</p>
<p>进入无我的寂静世界，清净随缘应物，从此再不为世物所迷。</p>
<p>入道最关键的秘诀是什么？</p>
<p>我的道路，便是——<strong>献祭。</strong></p>
<p>将自己所有的一切，完全献祭给天地。</p>
<p>天地便将我拥入怀中，从此归于无穷无尽的寂静……</p>
<h1 id="零天赐提供的一个机缘"><a href="#零天赐提供的一个机缘" class="headerlink" title="零天赐提供的一个机缘"></a>零天赐提供的一个机缘</h1><p>见性和入道阶段的方法，没有详写。</p>
<p>两个阶段，十分凶险。</p>
<p>我曾无数次步入歧途，无数次的被两位引路人，及时拉回正道。</p>
<p>写多了，只会误导各位。</p>
<p>在这里，留下一道门径。</p>
<p>如果，你沿着我留下的明心方法，看我推荐的书，从而明心了。</p>
<p>试着来找我，我给你一个机缘。</p>
<h1 id="开悟是终点吗？"><a href="#开悟是终点吗？" class="headerlink" title="开悟是终点吗？"></a>开悟是终点吗？</h1><p><strong>不是。</strong></p>
<p>每一位真正目睹了开悟风景的过来人。</p>
<p>一定都会这样，明确无误的告诉你：</p>
<p><strong>开悟不是终点，只是起点。</strong></p>
<p>开悟没有想象中那么困难，开悟只是人类意识内在圆满的一个毕业点。</p>
<p>此前，你学习各种修行方法，通过各种方式去‘努力’修行。</p>
<p>开悟后，你会忘记过往所有的修行方法，过往所有的师者教导，过往所有的神奇领悟。</p>
<p>此后，吃饭拉屎睡觉，都是修行用功。</p>
<p>除此以外，再无别物。</p>
<p>古代的禅宗公案，在你眼前都跟透明的一样。</p>
<p>哪怕是第一次看，你也知道这些禅师在说什么，在干什么，想教什么，全都简单得不行。</p>
<p>不过，是那些停留在思维领域的人，无法理解罢了。</p>
<p>开悟之后，也有无穷的探索。</p>
<p>比如像《当下的力量》那本书的外国作者，开悟肯定是开了。</p>
<p>每过几年，他写的东西就会更加深入，他自己也还会继续往下进步，直到死亡为止。</p>
<p>开悟后，并非从此告别俗世，远离人间烟火。</p>
<p>该挣钱还要挣钱，只不过，无论锦衣玉食，还是粗茶淡饭，都能自在舒适。</p>
<p>该度人还是度人，只不过，无论勇猛精进，还是执迷不悟，都能随顺因缘。</p>
<p>以切身感触举例：</p>
<p>真正想做的事情，无论难易，都能做成；</p>
<p>真正想见到的人，无论显隐，都能见到；</p>
<p>没什么成就，没什么名气，没什么金钱。</p>
<p>每天依然过得开心、快乐、充实、幸福、圆满。</p>
<p>手里没有多余的闲钱，一旦真正需要的时候，一定会有够我花的钱。</p>
<p>金钱、名气、权利，已不再是我的人生追求。</p>
<p>见性之后，也曾想过弄个公众号，写更多的修行文章，更直接的帮助别人。</p>
<p>也想过赚些钱，让自己有名气，去成为他人的榜样，也算帮助和鼓舞他人。</p>
<p>入道后，这些便放下了。</p>
<p>该有的钱，自然会有的；</p>
<p>该有的名，自然会有的；</p>
<p>人生不过是一场游戏，以上都是毫无无意义的外物。</p>
<p>对我而言，每天更有意义的事，是如何不求回报的，以何种方式，去更好的利益世界。</p>
<p>这才是，我每天在做的乐事。</p>
<p>比如，多年来，很多人跑来向我求教，我从没因别人向我提问，而收过一分钱。</p>
<p>能教的，我都尽量在教；能讲的，我都尽量在讲；学不会的，我也实在没办法。</p>
<p>包括这篇回答。</p>
<p>大笑~</p>
<h1 id="灵天赐讲开悟和禅"><a href="#灵天赐讲开悟和禅" class="headerlink" title="灵天赐讲开悟和禅"></a>灵天赐讲开悟和禅</h1><p><strong>开悟，代表告别人世，出家去当和尚道士吗？</strong></p>
<p><strong>开悟，代表舍弃名利，每天衣不覆体，食不果腹吗？</strong></p>
<p>不是。</p>
<p>禅，是一种脱离宗教、脱离迷信、脱离知识的神秘派系。</p>
<p>它既不像道家之于道教，也不像佛家之于佛教。</p>
<p>禅，是一种超越知识承载个体局限性的神秘传承。</p>
<p>它的存在，超越了哲学。</p>
<p>无论现代哲学，如何看似客观理智的，用逻辑去推理论断。</p>
<p>停留在人脑思辨领域的哲学，永远无法抵达人类精神认知的那片未知领域。</p>
<p>禅，是不限派系的。</p>
<p>你可以是佛教徒、道教徒、真主教徒、或是儒家思想信奉者。</p>
<p>也可以是无神论者、有神论者、或是任何学派与哲学的信奉者。</p>
<p>你的派系，并不影响你通过禅的修行，从而收获智慧。</p>
<p>以自身举例。</p>
<p>我是一个马克思主义者。</p>
<p>我坚信，人类可以创造出相对于当前社会而言的乌托邦。</p>
<p>人类目前的认知水平，认知和想象不到那样的社会境界，并不代表那样的社会境界不存在和无法实现。</p>
<p>马克思主义信奉者的身份，并不妨碍我通过禅的修行方式。</p>
<p>博采众长，汲取儒家、佛家、道家的思想精华，从而开悟，抵达个人内在的精神圆满。</p>
<h1 id="灵天赐讲开悟的意义"><a href="#灵天赐讲开悟的意义" class="headerlink" title="灵天赐讲开悟的意义"></a>灵天赐讲开悟的意义</h1><p><strong>开悟，对于人生，有怎样的意义？</strong></p>
<p><strong>收获精神层面的内在圆满，对一个普通人而言，有何现实意义？</strong></p>
<p>可以这样说，无论从事什么行业。</p>
<p>明心者，一定能成为该行业的顶尖高手。</p>
<p>见性者，一定能成为该行业的顶级大师。</p>
<p>入道者，入世可名震一方成为开派宗师；隐世即厚德载物孕育天地人杰。</p>
<p>隐世深者如老子，几乎没留下什么明确记载。</p>
<p>依然教导了孔子，培养了文子，指引了当时的无数学生，并留下一本《道德经》五千言，造就了庄子，影响了整个华夏的思想走向。</p>
<p>《韩诗外传》中能看出，孔子对于他向老子请教学问这件事，是十分高兴的。</p>
<p>这件事，当时也是广为人知的。</p>
<p>老子的弟子文子，各位或许不太熟悉，文子后来培养了一个弟子，名叫范蠡。</p>
<p>范蠡辅助越王勾践，成功的报仇复国。</p>
<p>范蠡功成后便归隐，带走了西施，成为古今天下名士的典范。</p>
<p>所以，我们今天所熟悉的古语里，才会有‘卧薪尝胆’和“飞鸟尽，良弓藏；狡兔死，走狗烹”。</p>
<p>当然，说这些。</p>
<p>不是因为，我已到达老子、释迦牟尼那样的精神境界。</p>
<p>正因为入道了。</p>
<p>所以，我十分清楚，我还没有达到。</p>
<p>同样，我也很清楚：我已踏上和他们相同的道路。</p>
<p>至少，我看到了，他们的背影。</p>
<h1 id="灵天赐推荐一些书籍"><a href="#灵天赐推荐一些书籍" class="headerlink" title="灵天赐推荐一些书籍"></a>灵天赐推荐一些书籍</h1><p>这篇回答，明白的看了，自然就明白。</p>
<p>该震撼的，看了我写的寥寥几句，就会被震撼。</p>
<p>不明白的，说得再多，也不会明白。</p>
<p>所以，这样就够了。</p>
<p>修行相关的回答，仅此一篇。</p>
<p>最后，推荐一些书。</p>
<p>真金白银的东西，许多人平白得到，不懂得珍惜。</p>
<p><strong>以下任何一个资料，都可以颠覆旧有认知，打开一个新的认知世界。</strong></p>
<p><strong>任何一本，都足以让人的修行突飞猛进。</strong></p>
<p><strong>均是我修行过程中，从中受益匪浅的圣书，不是凡书。</strong></p>
<p>可惜，上面这三句话，没几个人信。</p>
<h2 id="灵天赐推荐近现代资料"><a href="#灵天赐推荐近现代资料" class="headerlink" title="灵天赐推荐近现代资料"></a>灵天赐推荐近现代资料</h2><p>基本上，近现代与修行有关的名书，我都看过。</p>
<p>选出的，是对我修行有过极大助益的资料。</p>
<p>许多挺有名的书，之所以没放上来，或是因为作者见地歪了，或是对人的助益没有那么大，或是写得不够深刻。</p>
<p>以下资料，据我自己的接触时间早晚排序：</p>
<p><strong>《当下的力量》埃克哈特·托尔</strong></p>
<p><strong>《与神对话1、2、3》尼尔·唐纳德·沃尔什</strong>（这个作者的与神对话全系列约有十几本，可以逐一去看，我全部看过 ）</p>
<p><strong>《山居性纪》吴光磊</strong>——（中央编译出版社）</p>
<p>吴光磊老师，是我的引路人的引路人。</p>
<p>每年我都会去见对方至少一面，在网络上不知沟通了多少次。</p>
<p>我所走的，也正是他耗费一生，历经千辛万苦，遍访深山老林，闭死关寻藏密，方才重续上的禅宗法脉。</p>
<p>我无比尊敬与感激吴光磊老师，没有他，没有这本书，也就没有我的今天。</p>
<p>书里其实没什么剧情，文字很美。</p>
<p>厉害的地方在于，用心反复阅读能净化人心，能提升根器。</p>
<p>除了这本书以外，目前，我还从没见过其他任何能真正提升根器的办法。</p>
<p>书最开始发布在天涯论坛，有过不少修行讨论，我的引路人也是在帖子中得到教导而顿悟的，然后才找到了我。</p>
<p>不过，我并未在里面出现过。</p>
<p>最终，这本书历经波折，终于出版。</p>
<p>天涯论坛的帖子很长，帖子全名为“性的另一出口：《山居性纪》—性是种子，禅是花开”。</p>
<p>有兴趣的朋友，可以自己去翻来慢慢看，会很有收获的。</p>
<p>光磊老师最近几乎不教人了。</p>
<p>近两年，在弄一个叫‘禅医堂’的公众号，感兴趣可以去B站上搜‘禅医堂’。</p>
<p>发展挺快的，完全不需要我的推荐了。</p>
<p>过十年左右，他就会成为中医界的泰斗宗师。</p>
<p>如果，你是年轻新手中医，或者志向是从道这一层面学习真正的中医，可以借这个机会，找路子去给他帮忙，随他学习。</p>
<p>之前，有个年轻人，因为看了我一年前写的回答。</p>
<p>看了他写的书，自己找了过去，已经跟在身边了。</p>
<p>以后，没这么好的机会了。</p>
<p>其实，现在点破，已经算晚了。</p>
<p>只能说，个人有个人的缘法吧。</p>
<p><strong>《一休本来是情僧》吴光磊</strong></p>
<p><strong>巴夏视频系列</strong>——在土豆网搜索关键字‘bashar’或是‘巴夏’，根据标题找你需要的短视频进行观看，可忽略外星人的部分，只看意识转化的部分，巴夏系列的所有视频，我全看过。</p>
<p><strong>《新世界——灵性的觉醒》埃克哈特·托尔</strong></p>
<p><strong>《菩提树下的微笑-金刚经解密》蔡志忠</strong></p>
<p>蔡志忠老师的这本书，让我真正毫无阻碍的看懂了金刚经。</p>
<p>9月，偶然看了梁东采访他的一个视频《生命·觉者》，生出与蔡志忠老师一见的想法。</p>
<p>12月，见到了蔡志忠老师，与其一番深聊后。</p>
<p>他允许我以文字助理的身份，随其学习了两个月。</p>
<p>蔡志忠老师，是一个极其纯粹的修行人，他身上有我所欠缺的可贵品质。</p>
<p>经过两个月的学习，我的修行终于圆满。</p>
<p>因此，我选择与蔡志忠老师告别。</p>
<p>回来后，没几天，我便入道了。</p>
<p>所以，我才在回答中，当下担当。</p>
<p>直接说开悟。</p>
<p>以前不说开悟，无非是心中不安。</p>
<p>此刻，心中，再无任何不笃定的东西。</p>
<p>不愿借用蔡志忠老师的名气，这也是他所不喜的。</p>
<p>所以，我只在这篇回答里，简单提一下。</p>
<p>我手里，留下了一些文字记录。</p>
<p>日后，时机成熟时。</p>
<p>我会把这些记录，专门写成一本书的。</p>
<p><strong>《庄子说》蔡志忠</strong>——中国目前没人比他更懂庄子，看完这本漫画，大家会明白的。</p>
<h2 id="灵天赐推荐古代资料"><a href="#灵天赐推荐古代资料" class="headerlink" title="灵天赐推荐古代资料"></a>灵天赐推荐古代资料</h2><p>结合上面的资料，去看下方的古代资料，便没什么困难了：</p>
<p><strong>《心经》</strong></p>
<p><strong>《金刚经》</strong></p>
<p><strong>《马太福音》、《马可福音》、《路加福音》、《约翰福音》</strong>——不看被篡改的《圣经》，只看四本福音书，重点是耶稣的言行。</p>
<p><strong>《六祖坛经》</strong>————看敦煌版，传世版已被改得面目全非</p>
<p><strong>《太上老君说常清净经》</strong></p>
<p><strong>《道德经》</strong></p>
<p><strong>《达摩悟性论》、《达摩血脉论》</strong>——应见性后再看，内容较深，没有切身感悟，不易看懂；这种类型的古书，别看现代翻译，翻不出来的，只会误导。</p>
<h2 id="灵天赐推荐放松读物"><a href="#灵天赐推荐放松读物" class="headerlink" title="灵天赐推荐放松读物"></a>灵天赐推荐放松读物</h2><p>推荐两本放松读物：</p>
<p><strong>《异界生活助理神》</strong>（起点的网络小说，这个作者将自身对修行感悟的融入于小说剧情，并非言之无物，有点意思。因多年前所看，内容已忘了，作者境界具体如何，后来没有去重看过，也没看过他的新书，不作评价。）</p>
<p><strong>《韩诗外传》</strong>（一本蕴含儒家心法的书，书名是讲诗，其实是讲故事。适合让被拜物教物欲社会彻底洗脑的人，看看古代社会一名具备品德的人，是什么样的。毕竟，现在的人，精神上都活得不太像人。语言间隔较远，非圣人所写的经典，直接看现代翻译即可。）</p>
<h2 id="灵天赐介绍心读法"><a href="#灵天赐介绍心读法" class="headerlink" title="灵天赐介绍心读法"></a>灵天赐介绍心读法</h2><p><strong>读经的心读法：</strong></p>
<p>用感应而非思辨。</p>
<p>没有古文功底，不必买翻译或诠释的版本。</p>
<p>一遍又一遍，反复看原始版本便可。</p>
<p>蕴含真理的书籍，往往是简朴无华的。</p>
<p>有文字隔阂，影响也不大。</p>
<p>看不懂便看不懂，看完放一边，无需背诵。</p>
<p>隔一段时间，重新拿起，每次都有不同体会。</p>
<p>体悟增加，每次看懂的东西，也会逐渐增加。</p>
<p>这样，才能越过文字的表相，读取到文字背后的真实内容。</p>
<p>如此，方是正确的读经法。</p>
<p>灵天赐</p>
<p>2021年2月23日晚19点00分</p>
<hr>
<p><em><strong>转载自 <a href="https://www.zhihu.com/people/LingTC/answers">灵天赐的回答</a></strong></em></p>
<hr>
]]></content>
      <categories>
        <category>灵天赐</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>天赐问答2</title>
    <url>/2021/04/15/2112-answer2/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/14/2111-answer1/">天赐问答1: 知行合一, 方为真知.</a></li>
<li><a href="https://draapho.github.io/2021/04/15/2112-answer2/">天赐问答2: 总是拖延, 该怎么办?</a></li>
<li><a href="https://draapho.github.io/2021/04/16/2113-answer3/">天赐问答3: 凡夫一向动, 小乘一向静</a></li>
<li><a href="https://draapho.github.io/2021/04/17/2114-answer4/">天赐问答4: 烦恼名众生, 悟解名菩提</a></li>
<li><a href="https://draapho.github.io/2021/04/18/2115-answer5/">天赐问答5: 如何放下对结果的期待</a></li>
<li><a href="https://draapho.github.io/2021/04/19/2116-answer6/">天赐问答6: 为什么真正的境界不会退转?</a></li>
<li><a href="https://draapho.github.io/2021/04/20/2117-answer7/">天赐问答7: 为什么开悟的似乎都是男人, 女人呢?</a></li>
<li><a href="https://draapho.github.io/2021/04/21/2118-answer8/">天赐问答8: 男女欲望该怎么处理?</a></li>
<li><a href="https://draapho.github.io/2021/04/22/2119-answer9/">天赐问答9: 不完美, 才会独一无二</a></li>
<li><a href="https://draapho.github.io/2021/04/23/2120-answer10/">天赐问答10: 不要辜负你的生命</a></li>
<li><a href="https://draapho.github.io/2021/04/24/2121-answer11/">天赐问答11: 100多年前的马克思主义, 过时了吗?</a></li>
<li><a href="https://draapho.github.io/2021/04/25/2122-believe/">我们到底该信什么，不该信什么？</a></li>
</ul>
<p>以上所有内容, 皆转载自微信公众号: 自愈之光<br>此系列为灵天赐入道开悟后的资料收集.</p>
<hr>
<h1 id="2021-3-6，第二期："><a href="#2021-3-6，第二期：" class="headerlink" title="2021/3/6，第二期："></a>2021/3/6，第二期：</h1><p><strong>天赐问答，包罗万象。</strong><br><strong>从宇宙真理，到人生智慧；从心灵觉悟，到禅学修行；从心理哲学，到生命真谛。</strong><br><strong>你来问，我来答。</strong></p>
<p><strong>我也不知道，自己会说些什么。</strong><br><strong>我只是一个传递信息的管道，怀着与你一样期待的心情，等待讯息的自然浮现。</strong></p>
<p><strong>每一个讯息，只因提问者而出现。</strong><br><strong>每一个讯息，将利益每一位阅读者以及答者自己。</strong></p>
<p><strong>我怀着与你相同的喜悦、感恩、祝福，与你一起在这些信息中学习、成长。</strong><br><strong>真诚的，向你发起邀请。</strong><br><strong>请问，今天，你想以何种方式，让我为你服务？</strong></p>
<h1 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h1><p><em><strong>天赐哥，有什么能让自己不拖延的方法吗，感觉很多事都是只停留在想的层面，但少有能付诸行动的。像练习观察这件事也是，了解了不少，却不知从何时开始，于是慢慢的就耽搁了。天赐哥，想问问你是如何解决拖延呢，或者说如何做到想做的事当下念起就直接去实践呢？</strong></em></p>
<p>答：首先，练习观察不存在不知何时开始。<br>当你有意识地察觉脑海中每时每刻的思维，当你‘观察’自己的时候，就已经自然而然的开始了。<br>区别，不过是你能否坚持多久，能否时常提醒自己，让它成为你的第二本能。<br>不过，拖延倒是个常见的问题。<br>以前，我也有过和你一样的困惑。</p>
<p>我以前一直不明白，拖延的原理。<br>为什么，很多事情自己明明想去做，可是身体仿佛不听指挥，要在那时候去做一些无关紧要的事。<br>明明有的事情，自己也知道，一旦开始去做，本身一点也不难，可是身心却仿佛失去了控制。<br>一来到自己安排或者计划的时间点，就会忍不住被牵引着，去做其他事情。<br>把想做的事情不停往后推，一直往后推到这件事半途而废，或是这件事再也无法继续拖延下去为止。</p>
<p>不仅仅是你，很多人都有一样的困惑。<br>问题，其实很简单。</p>
<p>问题本身，就是一个陷阱。<br>从发起提问的思维，就已经错了。<br>无论怎么思考和解答，都只会导向错误的答案。</p>
<p>如果，去客观如实的观察。<br>将发现两个真相：</p>
<p><strong>1. 所有你所拖延的事，都并非你发自内心想做的。</strong><br><strong>2. 或虽是你发自内心想做的，却并非要以你心所预设的‘那种方式’、‘那种时机’、‘那种状态’去做。</strong></p>
<p>一切拖延的秘密，就隐藏在这两句话之内。<br>倘若能如实观照，自己一整天的心念变化，就会发觉一个事实。</p>
<p>人，从早上起床的那一刻开始，就已开始一场心智的自我说服。<br>你会不断说服自己，某个时间去做这件事，某个时间去做那件事。<br>有时候，是用对未来美好期待的诱惑；<br>有时候，是用过去曾吃到教训的恐惧；<br>有时候，是用逃避当下某些事的欲求。</p>
<p>早上起床的时候，体内能量充沛，这种说服就比较容易成功。<br>等到下午和晚上，体内能量耗尽，这种说服会变得很难生效。</p>
<p>所以，该做的是什么？<br>寻找提升说服的效力的手段？增强人体内的能量储备？寻找更好的说服方法？教导自己如何更容易的屈从于说服？</p>
<p>错了，这些都是陷阱。<br>用上述方法，加上自虐式的自律。<br>或许能成为他人眼中的‘成功人士’。<br>可是，你所错过的，远超乎你想象的多。<br>你失去了活出自己人生中，那个独一无二最高成就的机会。<br>同时，也失去了将你内在闪光具现化到现实的奇妙时机。</p>
<p>面对拖延，最重要的。<br>不是去提高说服的技巧，不是去增强说服的频率，不是提高体内的能量以承受更高强度的说服。<br>而是——停止说服！</p>
<p>是的，停止说服自己，去做你自己并不真正想做的事。<br>停止说服自己，以你并不真正想要的方式，去做你并不真正想做的事情。</p>
<p>有人误以为，这是逃避现实。<br>实际上，这才是真正勇敢的面对自己。</p>
<p>说服本身，是一种能量内耗。<br>为什么有人从事某些机械、无聊而又简单的工作，一天下来，整个人会感觉身体和灵魂都仿佛被掏空？</p>
<p>因为，这种生活意味着生命停止成长。<br>当一个人的心灵停止成长的时候。<br>即使肉体还在呼吸，依然有自己的喜怒哀乐，依然在体验人生。</p>
<p>可从生命的至高层面。<br>这个人已经彻底死亡，并与一具行尸走肉无异。</p>
<p>所以，当一个人被拖延所困的时候。<br>说明这个人没有活出自己的真实生命，没有去响应生命对他发出的召唤。</p>
<p>克服拖延的秘诀是：</p>
<p><strong>跟随兴奋，停止规划过去未来，放下一切期待，全然活在每时每刻的当下。</strong></p>
<p>这句话貌似简单，可很多人不信。<br>信了，也不敢去尝试。<br>本质上，还是不信。</p>
<p>落实到人生中，就是放下你给未来设置所有预期。<br>这些预期，是虚幻不真的存在。<br>即便你是自律狂，你可以无视自己的感受，100%按照想象中的计划去行动。<br>你也几乎不可能，只凭借你的计划，去达成你人生中的最高预期。<br>因为，现实从不按你的预期来一步步的变化。</p>
<p>你以为，根据你的人生计划，未来一定是一条倾斜向上直斜线。<br>最终，你会发现，未来是一段不停上下波动不稳定的振幅。<br>你永远不知道，生活将把你带向何方。</p>
<p>要区分，什么是期待，什么是兴奋：<br>期待，往往无视你的现有条件，让你去期待奇迹般的变化。<br>兴奋，往往基于你的现实条件，让你亲手创造奇迹的变化。</p>
<p>举个例子：<br>比如，你很想喝可乐，冰箱里也恰好有一瓶可乐。<br>你不会拖延说，虽然我现在特别想喝可乐，可打开冰箱太麻烦，还是不喝可乐了，打开冰箱喝点水也一样。<br>而是直接打开冰箱，喝掉可乐。<br>然后，继续做下一件你想做的事。<br>这，就是跟随当下的兴奋。</p>
<p>同样的例子，你想喝可乐，冰箱里恰好有一瓶可乐。<br>你突然想起，昨天给自己设定了每天喝牛奶的任务。<br>而且，可乐有害健康，牛奶有益健康，我应该喝牛奶才对。<br>于是，你强忍自己喝可乐的真实想法，逼着自己喝了一瓶牛奶。<br>结果，你乳糖不耐受，晚上一直在拉肚子。<br>这就是‘期待’。</p>
<p>期待，来自于外界灌输给你的事实，而非你发自内心的事实。<br>很多人在生活中，都处于这种乳糖不耐受，也依然强迫自己每天喝牛奶的状态。</p>
<p>不是每个人的天赋，都是要读清华、北大和常春藤的。<br>并不是对于别人重要的东西，对你也那么的重要。</p>
<p>如果，每一天的每一分钟，你都能如实的依照心中的真实兴奋，去全然的做。<br>那么，你会发现，你的生活根本不需要计划，也不需要规划。</p>
<p>一切你发自内心想做的事情，会以最完美的时机，最完美的状态来到你面前。<br>你则会一分不多一分不少的，完成它。<br>那些并非你生命真正必须的事情，不会浪费你生命的哪怕一秒钟。</p>
<p>当你全然沉浸在自己的兴奋之中时，你是不会感到疲倦的，你甚至不会消耗你的能量。<br>甚至会从你所做的事情中，得到能量的补充，像个永动机一样孜孜不倦。</p>
<p>再举个现实例子：<br>不少人喜欢玩游戏，极少数人是因为，打游戏的确是他们的热爱以及天赋所在。<br>未来，他们可以凭借打游戏的天赋与兴奋，去成就更高的人生。<br>可更多的人，只是因为他们找不到自己的兴奋，周围的环境并不支持他们的兴奋，他们也又无法说服自己去做。<br>所以，才会用更简单轻松的打游戏，来逃避内心深处的空虚。</p>
<p>他们无法认识到，人生是一场为他们精心准备的最高游戏。<br>只要他们愿意去那个，只为他们所准备的，独一无二的位置。<br>一切，都将是水到渠成般自然、轻松、美好而又毫不费力。</p>
<p>这，就是生命最真实的组织形式，也是最顺应于道的生命。<br>这，就是无为的真谛。<br>无为，而无不为。</p>
<p>仿佛宇宙星空的运转，生命的形成，意识的诞生。<br>世间万物，皆浑然天成。</p>
<p>这个世上，没有不美妙的造物，也没有真正无用的天赋。<br>无非，是人的认知以及狭隘自我。<br>阻碍了人们，走向那个命中注定的王座。</p>
<h1 id="问：-1"><a href="#问：-1" class="headerlink" title="问："></a>问：</h1><p><em><strong>天赐老师您好，我自己内心一直都很不平和，我找不到那种平和的时候。我的注意力很不集中，我不知道是因为我不爱这样的生活还是怎么样，我想尽力的去体验生活中的每一秒，把每一天当成最后一天来过，我发现我根本做不到。这种情况是从有了轻生的想法之后开始的，注意力就再也集中不了，什么事也做不了，但是现在没有那种念头了，就只想努力生活。您推荐的书我也看了，《让阳光自然播撒》我看了之后，我感觉自己无法相信，我相信科学，但是我真的没办法相信里面的话。《当下的力量》看起来特别费劲，看着很想睡觉，而且还看不懂。请您对于我自己和看书方面给予一些指导，谢谢您。</strong></em></p>
<p>答：一切的问题，产生于你的认知。<br>你的问题，你自己其实已经回答了。<br>你无法将现在过的每一天，当做你生命中的最后一天来过，不正是因为你完全不爱自己现在的生活吗？<br>如果，这一天当做你生命之中的最后一天。<br>最后一秒所留给你的，显然只会是悔恨。</p>
<p>既然，你不爱自己现在的生活，都有轻生的想法。<br>为何不在轻生前，先试试将现在的生活彻底换掉，无视他人的看法以及束缚，开始过一种你真正想要的生活呢？</p>
<p>你真的相信科学吗？你了解科学吗？<br>推荐《让阳光自然播撒》给抑郁症患者，因为里面提到了一种自愈方式。<br>针对那些因长期自我认知扭曲而导致的躯体性疾病，医药无效的情况下，往往可以通过这种方式，获得快速康复。</p>
<p>方法很简单：<br>取一张A4白纸，一只笔，坐在桌子前开始回忆，从你幼年开始，一直到现在，每一个让你难过、尴尬、痛苦、悔恨的人或是事，就把名字写下来。<br>哪怕只是一颗童年时将你绊倒的小石子，如果你回忆时发现心中有恨，有情绪，也要把名字写下来。<br>写下来之后，如果认真了，往往会写出不少，甚至是连一张纸都不够写。<br>接着，对着这些名字，挨个忏悔。<br>原谅、宽恕、释放你记忆中的每一份负面情绪。<br>这个过程，如果用心了，真的意识到了，就会痛哭流涕，会有不同的生理反应。</p>
<p>比如，不停的打嗝、放屁等排病反应。<br>一般而言，对于那些长期心理压抑导致的伴生生理疾病，反复几遍之后，能快速康复。<br>如果，做到位了。<br>一起康复的，通常不仅是生理问题，还有心理问题。</p>
<p>你说，你相信科学。<br>那么，我从科学的角度，告诉你它的科学道理。</p>
<p>首先，市面上任何一款药物推出时，即使已通过人体试验证明其安全，新药也必须经过严格的‘双盲测试’来证明其疗效。<br>什么是‘双盲测试’？<br>新药诞生时，为什么须经过这种测试，才能批准上市？<br>其目的，正是为了避免人的心理作用。</p>
<p>测试，会把病人分为两组。<br>一组让医生给病人开刚研发的新药，另一组让医生给他们开与新药外貌、味道全都一模一样的糖丸。<br>两组病人包括负责开药的医生，都不知道自己手里的药，到底是糖丸还是新药。<br>研究团队，会观察两组病人的具体康复情况，以及康复率之间的差异。<br>根据数据来判断，这款新药是否具备真实可靠的疗效。<br>每年，大多数新研发的药，都因为无法通过‘双盲测试’，而无法上市销售。</p>
<p>这个测试中，蕴含了一个极其深刻的道理。<br>少有人，去认真思索。</p>
<p><strong>为什么，那些只吃下糖丸的病人，也会出现康复率或治疗效果？</strong></p>
<p>也就是说，哪怕只是糖丸。<br>因为是病人所信任的权威医生，所开的药。<br>拿到糖丸的那一组病人，会认为这是药。<br>不仅是病人的主观认知，部分人连身体都会这样认为。<br>因此，糖丸也能在一些人身上，奇迹般的出现真药才能产生的效果。</p>
<p>是因为，糖丸有多神奇吗？<br>不是的。<br>无非是因为，病人的心理作用，对疾病出现了正向效果。</p>
<p>人体是一个紧密的仪器，它会随着人的心理变化而随时变化。<br>人在消极、难过、痛苦等负面状态下，更容易生病，而且很容易得一些难以治疗的‘怪病’。<br>被负面状态影响越深，越久；越是容易出现各种生理性疾病。</p>
<p>原因是是什么？<br>就是因为，人的内在认知，对于躯体的调控作用。</p>
<p>这也是为什么，大家都公认，积极心态有助于疾病康复。<br>因为，你的心灵激活了内在的正向能量。</p>
<p>白纸忏悔法的奥秘，就是通过忏悔，让你去释放自己的童年阴影，你对他人的怨恨、怨毒、嫉妒、仇恨、痛苦等等负面情绪。<br>这些负面情绪，沉淀在你的记忆中。</p>
<p>每一次，当你回忆起这些痛苦的记忆时。<br>你都会将这种痛苦的记忆，再一次带入当下。<br>让你的身体，在此刻，又去经历一次曾经的‘破坏性’情绪。</p>
<p>这就是为什么，当你每一次，回忆难过那些让你撕心裂肺的痛苦记忆时。<br>总是会心痛、胸闷、头疼、头晕、喘不过气、浑身不舒服等等。<br>你抓着记忆不放，对于你的‘仇人’和让你无意识‘痛恨’的人来说，是毫无影响的。<br>每一次，这些记忆中的负面情绪，真正影响和破坏的，只有你的身体与心灵状态。</p>
<p>所以，对于你的个人建议。<br>看不进去的书，没必要强看。</p>
<p>不喜欢《当下的力量》，就去看《与神对话》；不喜欢《与神对话》，就去看巴夏系列视频，不喜欢巴夏系列视频，就去看《山居性纪》……<br>总有一个资料，适合你阅读。</p>
<p>资料，永远只是辅助。<br>最重要的，永远是你对自己人生的真实认识。<br>最重要的，永远是你是否敢于活出独一无二，而又真实无悔的人生。</p>
<hr>
<p>无论点亮或不点亮，喜欢或不喜欢，关注或不关注。<br>祝你，平安喜乐~</p>
]]></content>
      <categories>
        <category>灵天赐</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>天赐问答3</title>
    <url>/2021/04/16/2113-answer3/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/14/2111-answer1/">天赐问答1: 知行合一, 方为真知.</a></li>
<li><a href="https://draapho.github.io/2021/04/15/2112-answer2/">天赐问答2: 总是拖延, 该怎么办?</a></li>
<li><a href="https://draapho.github.io/2021/04/16/2113-answer3/">天赐问答3: 凡夫一向动, 小乘一向静</a></li>
<li><a href="https://draapho.github.io/2021/04/17/2114-answer4/">天赐问答4: 烦恼名众生, 悟解名菩提</a></li>
<li><a href="https://draapho.github.io/2021/04/18/2115-answer5/">天赐问答5: 如何放下对结果的期待</a></li>
<li><a href="https://draapho.github.io/2021/04/19/2116-answer6/">天赐问答6: 为什么真正的境界不会退转?</a></li>
<li><a href="https://draapho.github.io/2021/04/20/2117-answer7/">天赐问答7: 为什么开悟的似乎都是男人, 女人呢?</a></li>
<li><a href="https://draapho.github.io/2021/04/21/2118-answer8/">天赐问答8: 男女欲望该怎么处理?</a></li>
<li><a href="https://draapho.github.io/2021/04/22/2119-answer9/">天赐问答9: 不完美, 才会独一无二</a></li>
<li><a href="https://draapho.github.io/2021/04/23/2120-answer10/">天赐问答10: 不要辜负你的生命</a></li>
<li><a href="https://draapho.github.io/2021/04/24/2121-answer11/">天赐问答11: 100多年前的马克思主义, 过时了吗?</a></li>
<li><a href="https://draapho.github.io/2021/04/25/2122-believe/">我们到底该信什么，不该信什么？</a></li>
</ul>
<p>以上所有内容, 皆转载自微信公众号: 自愈之光<br>此系列为灵天赐入道开悟后的资料收集.</p>
<hr>
<h1 id="提问："><a href="#提问：" class="headerlink" title="提问："></a>提问：</h1><p><em><strong>先生你好，我是一名高三学生，关注您和吴光磊先生也有一些时间了，学到了不少东西。当下的力量与山居性纪以前都买来看了几遍了，的确是很有感觉。我想要问的是，怎么能更加集中地学习（因为平常其实不怎么喜欢学习，但是还是要考学啊），减少心中纷乱的杂念（感觉自己总是想很多乱七八糟的，停不下来 观察念头的方法又难以坚持），以及怎么摆脱负面情绪。谢谢您的指教！——林泉</strong></em></p>
<p>答：高三，是一个比较特殊的时间点。</p>
<p>我也切身经历过这个阶段。</p>
<p>这个时间段，处在这种大环境，很容易心浮气躁，容易被周围人带走。</p>
<p>这个阶段，不必忙着练习观察之类的，专心把你该做的事情做好。</p>
<p>一年转瞬即逝，专心把这一年的时间，利用到极致。</p>
<p>对你的心智，也会是一种极好的成长与磨练。</p>
<p>相对于修行来说，高考这种难度的问题，实在是太简单和基础。</p>
<p>倘若，你连这一点，都做不到去正视和面对。</p>
<p>你真正试着去修行时，就会发现。</p>
<p>修行上的任何一个关卡，你都做不到正视以及面对。</p>
<p>修行，是大丈夫之路。</p>
<p>心灵成长以及觉悟，需要极大的决心、诚心以及持续艰辛的付出。</p>
<p>这就是为什么，修行上，你每过一个关卡。</p>
<p>现实中所面临的许多问题，就会轻轻松松的迎刃而解。</p>
<p>之前有人问我，知与行的问题。</p>
<p>我回答的是：</p>
<p><strong>知行合一，方为真知。</strong></p>
<p>你平时看《山居性纪》、《当下的力量》这些书，无非是道理上极其粗浅的明白，并没有理解。</p>
<p>所以，面对高考，是一个极好的机会。</p>
<p>让你将书中教导的东西，踏踏实实的用到你每一天的生活与学习之中。</p>
<p>一步一步的，去调整自己心里那些不正确的负面概念。</p>
<p>你如果真正踏实做到了。</p>
<p>两年之后，你再回头看这两本书。</p>
<p>就会惊讶的发现，你将看见完全不同的两本书。</p>
<p>你看见书中的多少资料，和你看了多少遍没有关系，只和你的心灵水平有关。</p>
<p>你站得越高，就会看见书中越多的隐秘，升起越强烈的共鸣。</p>
<p>所以，不必着急。</p>
<p>先练习平心静气，问心无悔吧。</p>
<p>下面，我会给这一年中，饮食、环境、心灵三方面的具体建议：</p>
<p>饮食方面：</p>
<p>平时吃清淡一点，少放鸡精味精，少吃肉，增加蔬菜的摄入。</p>
<p>每一顿尽量做到进食80%以上的蔬菜，20%以下的肉类。</p>
<p>蔬菜做到多样化，不要只单调的进食一、两种蔬菜。</p>
<p>每天，至少进食5种以上不同蔬菜为益。</p>
<p>尽量少吃甜食，比如蛋糕、甜点、零食之类的高盐、高糖食品。</p>
<p>实在想念甜食，可以蜂蜜或天然甜品代替。</p>
<p>辣椒之类的天然植物调味品，不在限制范围，可以自由吃。</p>
<p>环境方面：</p>
<p>周六日或者放假的时候，多往自然里跑跑。</p>
<p>比如山里，或者树木很多的丛林与公园，湖边也可以。</p>
<p>尽量独自一人，或者周围人少一点，比较安静，看不见你。</p>
<p>找颗树下坐着，随便你做什么。</p>
<p>听音乐、看小说、或者看杂书、玩手机也好。</p>
<p>把这个地方，当做你的放松地，多与自然相处。</p>
<p>虽然你感受不到什么。</p>
<p>一段时间之后，你就会有感触，与自然接触，是可以疗愈心灵的。</p>
<p>心灵方面：</p>
<p>对待学习，要有正确的心态。</p>
<p>每一次的考试，只是一次自我测试。</p>
<p>只从成绩上分析自己短处，和接下来需要调整的学习方法。</p>
<p>停止和别人比较长短，考完试的当天，立即放下考试，只是考虑接下来怎么提高。</p>
<p>有的时候浪费了时间，跑去玩耍，或者分心了。</p>
<p>不要自我批判，而是接纳。</p>
<p>告诉自己，学习成绩的提高，不是靠删减天然需要和日常娱乐取得。</p>
<p>而是依靠正确的心态，与高效率的方法而得到。</p>
<p>记住，学习不是与他人比较，和别人比较只会让你心力憔悴。</p>
<p>学习，永远是独自一人的旅途。</p>
<p>你一点一点的提高，一点一点的认知，一点一点的进步。</p>
<p>这个过程本身，就是一种快乐，而不是痛苦。</p>
<p>忘记给自己定下的目标，忘记学习计划。</p>
<p>每一天的学习，只关注这一天；每一节课的学习，只关注这一节课。</p>
<p>不必跟着老师走，走你自己的节奏。</p>
<p>回归学习的本质，不停的查缺补漏。</p>
<p>不必执着于做了多少题目，刷了多少张试卷。</p>
<p>无意义的刷题，是在浪费生命。</p>
<p>少做那些会做的，让你感到轻松的题目。</p>
<p>专注于那些不会的，很难的题。</p>
<p>一遍又一遍的做曾经的错题，直到再也不错为止。</p>
<p>一遍又一遍的反复感悟课本，直到完全铭记于心。</p>
<p>记住，你高考的最终目的，不是考清华北大、985、211、本科、专科等等。</p>
<p>而是在每个当下，竭尽全力，做到最好的自己。</p>
<p><strong>你的目标，不是去超常发挥。</strong></p>
<p><strong>只是做到，最好的自己。</strong></p>
<p>如果，你真正用心尽力去做了。</p>
<p>高考结束时，无论成绩考得如何。</p>
<p>一定不会留下遗憾。</p>
<p>因为，你已在当下，成为了最好的自己。</p>
<p>不需要更多了。</p>
<p>通过高考，你获得的这种感悟，会让你受益终身。</p>
<p>未来，当你追随你的天赋与兴奋，再去做任何你想做的事情时。</p>
<p>你，一定，不会平庸。</p>
<h1 id="提问：-1"><a href="#提问：-1" class="headerlink" title="提问："></a>提问：</h1><p><em><strong>天赐哥，你好，关于人生的意义是什么，来到世界上是为了干什么，我是谁这类的问题，我真的能想出个结果来吗，你花了一个月的时间想出了唤醒他人灵魂深处的荣光，蔡志忠老师四岁就想到要画画，我这样顽劣的人也能有一个结果吗？</strong></em></p>
<p><em><strong>诚心是什么？怎么找到自己的诚心？我现在没有，这辈子还能不能觉悟了？每当我看到一些网友找到吴光磊老师和你，能跟你们这样的人修行，我真是嫉妒，羡慕，又后悔，想到别人已经先走一步了，我又着急，自己真是丑陋，转念一想，我还是回归当下，回到眼前，好好的和眼前的生活过吧</strong></em></p>
<p>答：</p>
<p>春来雨落花开，秋至落叶结果。</p>
<p>一切都是自然而然的生长，因缘聚集的成熟。</p>
<p>小草有小草的快乐，大树有大树的安宁。</p>
<p>人的生命，不在于活成别人的模样。</p>
<p>生命，只在于成就最美好的自己。</p>
<p>见性后，我一直在人们身上。</p>
<p>看到一种普遍的匮乏，看到一种普遍的贪婪。</p>
<p>匮乏，是感恩之心的匮乏，是不愿付出的匮乏。</p>
<p>贪婪，是对当下永不满足的欲求。</p>
<p>长久以来，我也在真正的见性者身上，从开始到最后，始终看到一种普遍的品德，一种普遍的满足。</p>
<p>品德，是懂得感恩的品德，是愿意付出的品德。</p>
<p>满足，是对不圆满当下的接纳， 对不圆满人生的满足。</p>
<p>曾经的修行过程中，我时常觉得。</p>
<p>自己肯定是下下根器，最多也就中下根器。</p>
<p>我时常觉得，自己实在是太糟糕。</p>
<p>为什么我总是这么顽固，从不吸取教训呢？</p>
<p>为什么，总是给自己创造痛苦而不自知呢？</p>
<p>甚至，我那时候时常在想。</p>
<p>哇！我这一生，能明心，就非常开心，非常不错了。</p>
<p>见性、入道什么的，想都不敢想。</p>
<p>于是，拼命捶打，自虐式的提高诚心，竭尽全力的帮助别人。</p>
<p>直到，花两年时间，明心见性后。</p>
<p>引路人才和我说，我根器勇猛，是难得一见的大根利器。</p>
<p>后来，光磊老师也告诉我，说我根器猛烈，与我的引路人如出一辙，都是大根器。</p>
<p>不过，无论是我，还是我的引路人。</p>
<p>我们在修行过程中，从没觉得自己根器多高，或多么厉害过。</p>
<p>我们始终觉得，自己真是太糟糕，自己太渺小，自己太渺茫了。</p>
<p>不断反省，不断打击自我。</p>
<p>生怕自己，出现哪怕一瞬间的自以为是。</p>
<p>一直觉得，自己真是低到谷底般的糟糕。</p>
<p>举个例子：</p>
<p>我的引路人，遇见吴光磊老师之前，洋洋自得。</p>
<p>给自己了‘无来去’的网名，意为如来的‘无所从来，亦无所去’。</p>
<p>后来，接触正法，踏上真正的修行之路后。</p>
<p>见到了真正的高山，从而发心忏悔，认识到心中的自高自大，羞愧难当。</p>
<p>从此，网名改为‘狗屁无来去’。</p>
<p>网上的口头禅，也变成了“我就是个狗屁不如的玩意。”</p>
<p>让别人叫他狗屁，自称狗屁。</p>
<p>所以，我的引路人，真正踏上修行之后，从没觉得自己是上上根器。</p>
<p>吴光磊老师，也一直在说，他自己是下下根器，挺糟糕的那种。</p>
<p>所以他能成，大家都能成，不用再吃他的这些苦头。</p>
<p>这种心态下，他写《山居性纪》，把自己一生所得无私奉献出来。</p>
<p>当初，我‘见性’后，也一直觉得。</p>
<p>连我都能见证，大家一定都可以，每个人都可以！</p>
<p>直到，面前走过一个个自认为根器上佳、自以为通天晓地的修行者们，往往连门径在哪，甚至连山在哪，都不知道。</p>
<p>这时，我才认识到。</p>
<p>原来，我所自以为的糟糕根器，那极小的诚心，竟如纯金般难得。</p>
<p>没有诚心的人，苦口婆心、说破口舌、对方也不会有丝毫领悟，甚至都不会感动。</p>
<p>只会以己度人，觉得别人藏私，觉得别人不怀好意。</p>
<p>一些不值一提的小道，人们总是削减了脑袋去琢磨。</p>
<p>大道，圣人们以白纸黑字写就。</p>
<p>没有几个人，愿意静心去感悟，去观看。</p>
<p>我自己，也常在深思。</p>
<p>我、引路人、吴光磊老师，我们和别人的区别，到底在哪呢？</p>
<p>为什么？如此易行的道路，吃尽无数苦头才探出来的康庄大道，大家始终走不上去呢？</p>
<p>大家始终嘴上信，行动上一直不愿踏实去做呢？</p>
<p>最后，我明白了。</p>
<p>我在每一位有诚心的修行者身上，在每一位觉悟者身上，每一位孜孜不倦的求道者身上，所看见的共同品质。</p>
<p>就是大家都懂得去舍我付出，大家都懂得感恩珍惜，大家都敢于接纳这个不圆满的当下，大家愿意去拥抱和原谅这个不圆满的自己。</p>
<p>其实，哪有什么根器限制？</p>
<p>根器的本质，诚心的本质。</p>
<p>无非，看这个人懂不懂得感恩，懂不懂得去舍我付出罢了。</p>
<p>越是懂得感恩的人，对于真理的感应越强；</p>
<p>越是懂得付出的人，对于真理的领悟越深。</p>
<p>越是懂得以上两者的人，遇见真理时也越懂得去珍惜珍贵，越懂得去孜孜不倦的求取以及不懈的行动。</p>
<p>懂得感恩的人，才知道一切理所当然的东西，究竟多么的来之不易。</p>
<p>有缘能听闻本身，就已经是一种无上的幸福。</p>
<p>就像大家理所当然的和平，在人类历史上，是极少数光辉时光。</p>
<p>人类的历史，战争才是常态。</p>
<p>是你的出生，让你吃得饱穿得暖，有地方住，不必担心某天吃饭时就被一颗炸弹带走。</p>
<p>今天，谁会为了能吃饱穿暖，不被人随意屠杀这件事，而感到发自内心的满足呢？</p>
<p>你的这个问题。</p>
<p>提问的心态就错了。</p>
<p>我能有今天的感悟、智慧、收获，是区区一个月的思考吗？</p>
<p>重点，难道不是我经过无数常人难以想象的痛苦童年，有那么多理由可以去敌视、仇恨、嫉妒他人，有那么多的理由去反社会、反人类、反常人，可我却依然选择了善良，依然决定用余生去给予那些陷入黑暗、痛苦、绝望之中的人以希望吗？</p>
<p>重点，难道不是经历常人难以承受的黑暗之后，经历了无人拯救的绝望之后，依然愿意义无反顾的选择光明吗？</p>
<p>重点，难道不是经过一个月深思后，连续7年，日日夜夜、刻骨铭心、不曾间断的疯狂找寻、刻苦修行、自我捶打、自我蜕变吗？</p>
<p>为什么，你只看到了一个月，和一个四岁呢？</p>
<p>去买本蔡老师的自传看一看，他四岁之后的人生，经历过些什么，从四岁起就从此一帆风顺、大富大贵了吗？</p>
<p>明心前，练习观察的方法。</p>
<p>我的引路人，教我的时候，可不像我现在这般清楚。</p>
<p>毕竟，引路人是跳过明心，直下见性的极少数。</p>
<p>明心观察的三种方式，是我在修行过程中，浪费半年多时间。</p>
<p>经历种种烦恼、痛苦、迷茫与纠结。</p>
<p>一点一点探索，不断请教引路人，反复叩问天地。</p>
<p>好不容易，才总结出的一套完整方法。</p>
<p>这些东西，随便拿出一点。</p>
<p>都是你跑遍深山老庙，苦寻各种高僧大德隐士，磕头拜师荒废一生，交多少多少学费，也难以得见的至深奥秘。</p>
<p>大道至简。</p>
<p>最深奥的道理，永远用最简单的话语来传承。</p>
<p>你既然追着我，到了这个公众号。</p>
<p>显然也知道，我反反复复提过的‘观察’法。</p>
<p>你，有踏踏实实的，按照我给的方式，去日日夜夜的做过吗？</p>
<p>坚持不懈的，天天提醒自己，认真练习超过半年吗？</p>
<p>有过吗？</p>
<p>比如现在，你发起提问时，你心中嫉妒、迷茫、困惑、难过。</p>
<p>还记得观察它们吗？</p>
<p>你的观察，还在吗？</p>
<p>我一年明心。</p>
<p>靠的，正是我亲身摸索出的这三种观察之法。</p>
<p>三种方法，建立在吴光磊老师耗费半生的痛苦探索，引路人近十年摸索与找寻，以及我的日夜实践与自我救赎上。</p>
<p>最终，才形成这样一条简单直接的康庄大道。</p>
<p>这条道路，是无视根器，无视派别的。</p>
<p>无论你根器多差，完全可以用诚心与行动，直接填平。</p>
<p>踏步而上，斩断烦恼，当下解脱。</p>
<p>什么是诚心？</p>
<p>诚心是感应到了，愿意去相信，愿意踏踏实实的去做。</p>
<p>然后，你越做越有信心，越做越有收获。</p>
<p>形成一个不间断的正向循环。</p>
<p>除掉一切无用知识，和无关外物的误导。</p>
<p>真正切实有效的方法，仅此而已。</p>
<p>其他教导，无非是闲聊。</p>
<p>如此珍贵的东西。</p>
<p>我在这里，无偿写了出来，无偿给予了你，你能无偿见到。</p>
<p>不发自内心感恩，不抓住机会去日夜练习。</p>
<p>反而在这里，羡慕那些随吴光磊老师修行，羡慕那些能接触到我的人。</p>
<p>说你本末倒置，都轻了。</p>
<p>交流群的公告，我明明白白的写出来了。</p>
<p>欢迎明心者随时来找我，我会无私指出之后的路。</p>
<p>这，不又是一个无比珍贵的机会吗？</p>
<p>明心之前。</p>
<p>除了那三个观察法，真正的修行秘诀。</p>
<p>实在没什么可说的。</p>
<p>之前，网上通过各种途径，来找到我的人。</p>
<p>诚心不足的，一般几句话后，我便懒得理会。</p>
<p>极其苛刻的条件下。</p>
<p>几年来，也有足足16人找到了我身边。</p>
<p>这16人中，目前为止，依然只有一人真正明心，朝着见性前进。</p>
<p>不少人随我学习，一样卡在明心前，始终踏不进去。</p>
<p>和你，是同一个问题。</p>
<p>总觉得，还需要听闻更多、学习更多、知道更多。</p>
<p>唯一一个明心的，还是我以前读研的同学。</p>
<p>一开始，他自己来找我提问，很不服气。</p>
<p>找我反复辩论，纠结于各种心理知识、派别，试图用心理学来定义和学禅。</p>
<p>我都不怎么搭理他。</p>
<p>是他自己孜孜不倦的，死抓住我不放，不停向我求取。</p>
<p>最后，终于在他的记忆深处。</p>
<p>找回了心中丢失的那份善良与真诚，那份爱与感恩之心。</p>
<p>从此，彻底放下顾虑，踏踏实实的练习观察。</p>
<p>之后没多久，他就明心了。</p>
<p>另一个例子，知乎上有一个人。</p>
<p>和我私信了两年。</p>
<p>我经常十几天、一两月回复一次，不时会忘记回复。</p>
<p>他是谁，我和他曾经聊过什么，这个人是谁？</p>
<p>我完全没概念。</p>
<p>找我聊过的人，实在太多。</p>
<p>我对谁，都一视同仁。</p>
<p>看你的诚心，根据你目前的状态，以你当下所需不同的态度，回答你的问题。</p>
<p>最后，无路你是否接受，会指出一条相同道路：</p>
<p>练习观察，练习观察。</p>
<p>上周，他明心了。</p>
<p>找到我，经过几个提问，我印可了他。</p>
<p>我连他是谁，和他聊过多久，我也不清楚。</p>
<p>都是我问了他，才知道原来和我聊过两年。</p>
<p>可他的见地，不会骗人。</p>
<p>他自己，也很清楚。</p>
<p>所以，不是一定要跟在身边，才能进步。</p>
<p>禅，从不是死跟住引路人，就能成的。</p>
<p>没这么简单。</p>
<p>禅，是‘给单独者的礼物’。</p>
<p>向来是自力更生的。</p>
<p>明心，无非是入门。</p>
<p>明心前的修行，没什么可说的。</p>
<p>随我学习的16人，我教他们的修禅方法。</p>
<p>与我在这里告诉大家，没有区别。</p>
<p>甚至，还没有文章里讲得细致。</p>
<p>有人也是跑去看了我写的文章。</p>
<p>才知道，有些细节，因为他们没有主动问，我也忘了告诉他们。</p>
<p>你看。</p>
<p>交流群里，你有能与我进行文字沟通的固定时段。</p>
<p>公众号里，你可以看到别人的疑惑，以及我认真细致的回答。</p>
<p>这么早，就来到了公众号，能有机会留下你的一堆提问。</p>
<p>可以让我来长篇大论，挨个挨个的仔细回答。</p>
<p>随我学习的人，我一般也就随便讲几句话。</p>
<p>少有超过一千字的时候。</p>
<p>明心之后，继续往上的机会，也都给你准备好了。</p>
<p>还不觉得幸福吗？</p>
<p>我修行的时候，可没有这么多的机会。</p>
<p>引路人在我面前一闪而过，我隐隐有感觉。</p>
<p>就像溺水的人，抓住救命稻草一样，拼尽全力的死死抓住。</p>
<p>引路人跑到那里，我就追到那里。</p>
<p>每天，都去追着提问。</p>
<p>我从不会把引路人对我说过的任何一句话。</p>
<p>不当回事，不去认真练习。</p>
<p>即使最差最差的情况。</p>
<p>即使，你一生无法明心，无法见性。</p>
<p>那有什么关系呢？</p>
<p>你也能通过思考别人的提问，我的回答。</p>
<p>用这些方法，让你的人生，生活得更真实，更快乐，更圆满、更美好。</p>
<p>这样，还不感激？</p>
<p>这样，还不感到满足？</p>
<p>这样，还不愿付诸行动？</p>
<p>要等到什么时候，才愿意打开内心，开始成长？</p>
<p>要等到什么时候，才愿意打开内在的宝库，收获生命的真谛？</p>
<p>真理，不是等来的，也不是别人喂给你的，更不是去信来的。</p>
<p>真理，是经过你孜孜不倦的求取，无私无畏的不断付出后。</p>
<p>从你的内在，生发而出的。</p>
<p>我这里，从来没有智慧，也向来没有真理。</p>
<p>只有你自己的心里，才有。</p>
<h1 id="提问：-2"><a href="#提问：-2" class="headerlink" title="提问："></a>提问：</h1><p><em><strong>您的明心方法中除了“抽离”，还有一种“全情投入”，适用于不同的时候，这两种方法难道不是截然相反吗。为什么“全情投入”不是着相呢？这难道不是对事物的一种痴迷？另一个方法上的问题是，您为什么不推荐冥想/打坐呢？</strong></em></p>
<p>答：</p>
<p>这两种方法，原理一致。</p>
<p>沉浸在人脑的思维中，所以无法认知。</p>
<p>不是‘抽离’，而是你开始观察自己的瞬间，就会自然而然的脱离。</p>
<p>从什么之中，脱离出来呢？</p>
<p>从你的脑海中，那看似永不间断的思维流中，从你自以为的这个‘我’中，自动脱离出来了。</p>
<p>这一刻，你会看见脑海中流动的思维。</p>
<p>然后，会无可避免的认知到：</p>
<p>既然，我能看见这些流动的思维。</p>
<p>很显然，这些思维念头不是我，只是我以前误以为它们是我。</p>
<p>不需要画蛇添足了，这种认知本身，就是一种极其强大的改变。</p>
<p>那么，为什么‘全情投入’也有同样的效果呢？</p>
<p>因为，‘全情投入’也是一种脱离。</p>
<p>如果，你不是真正的绝对专注，你是无法进入无时间领域的。</p>
<p>当你处于无时间领域的瞬间，就脱离了思维的认同。</p>
<p>这一瞬间，你没有杂念，也没有自己，只有面前正在做的事情。</p>
<p>这一刻，思维平息。</p>
<p>大脑的功能，被全部用于处理面前的事情。</p>
<p>没有一个无关紧要的‘我’存在。</p>
<p>你自己做个试验。</p>
<p>当你全情投入的时候，心中一旦出现任何杂念。</p>
<p>或者一瞬间产生了‘我在做什么’的思维，或者是‘这个东西怎么做才能更好’的思维。</p>
<p>又或者，你下意识的看一眼时间，惊讶发现居然过去了几个小时。</p>
<p>一刹那，你就会从这种状态里出来。</p>
<p>想再次回到状态中，需要一段不被打扰的时间，才能重新进入。</p>
<p>你‘着相’的时候，是不可能进入‘全情投入’状态的。</p>
<p>就像你看电影的时候，如果你还记得自己是坐在电影院里的观众，你肯定无法进入电影的世界去享受。</p>
<p>你对‘着相’理解，完全错误。</p>
<p>‘着相’，指人被外在的外在物质表象或者自己的认知观念带走，并不自知。</p>
<p>一个人着相的时候，会显得特别执着，特别顽固。特别自我。</p>
<p>因为，这个人满脑里想的都是‘自己’，或者‘自己的所有物’，或者‘自己的未来’等等。</p>
<p>全是是以自我为基础的存在。</p>
<p>一个人，进入‘全情投入’的状态时。</p>
<p>会忘记‘自己’， 甚至不只是自己。</p>
<p>他会连自己为什么做这件事，做这件事是为了什么，都会暂时性的全部忘记。</p>
<p>他只是知道，自己在做一件事。</p>
<p>只剩下，眼前的这件事。</p>
<p>世界、时间、自我，他全然忘却了。</p>
<p>这种状态，即是‘活在当下’。</p>
<p>对你的最后一个问题。</p>
<p>不否定打坐，但也不提倡。</p>
<p>必须认识到，光凭打坐和冥想，无法增长智慧。</p>
<p>因为，常人一坐。</p>
<p>脑子里就会冒出种种念头以及颠倒幻想。</p>
<p>试图观呼吸、观声音、数数等等。</p>
<p>易陷入我执，越练越偏执。</p>
<p>易出现一些特殊功能与幻想，被自我利用。</p>
<p>达摩说过：“凡夫一向动，小乘一向静。”</p>
<p>就是说，一般人总是静不下来，时时刻刻都要动；小乘的修行者们，总是一味的执着于静定的状态。</p>
<p>执着于冥想和打坐，以为能借此获得觉悟的人。</p>
<p>都落入了‘小乘求静’的陷阱中。</p>
<p>那么，如何解决这个问题呢？</p>
<p>达摩也说：“离诸动定，名大坐禅。”</p>
<p>大坐禅，是一种更高级的打坐与冥想方式。</p>
<p>你日常从动静之中抽离，即是一种很深的禅定。</p>
<p>如何离诸动静呢？</p>
<p>不执于动，不执于静。</p>
<p>走路也好跑步也罢，打坐也好冥想也罢。</p>
<p>心安处，即家乡。</p>
<p>此心一安，忘却动静，自然入了大坐禅。</p>
<p>一举一动，天地清净。</p>
<p>自在无拘。</p>
]]></content>
      <categories>
        <category>灵天赐</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>天赐问答5</title>
    <url>/2021/04/18/2115-answer5/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/14/2111-answer1/">天赐问答1: 知行合一, 方为真知.</a></li>
<li><a href="https://draapho.github.io/2021/04/15/2112-answer2/">天赐问答2: 总是拖延, 该怎么办?</a></li>
<li><a href="https://draapho.github.io/2021/04/16/2113-answer3/">天赐问答3: 凡夫一向动, 小乘一向静</a></li>
<li><a href="https://draapho.github.io/2021/04/17/2114-answer4/">天赐问答4: 烦恼名众生, 悟解名菩提</a></li>
<li><a href="https://draapho.github.io/2021/04/18/2115-answer5/">天赐问答5: 如何放下对结果的期待</a></li>
<li><a href="https://draapho.github.io/2021/04/19/2116-answer6/">天赐问答6: 为什么真正的境界不会退转?</a></li>
<li><a href="https://draapho.github.io/2021/04/20/2117-answer7/">天赐问答7: 为什么开悟的似乎都是男人, 女人呢?</a></li>
<li><a href="https://draapho.github.io/2021/04/21/2118-answer8/">天赐问答8: 男女欲望该怎么处理?</a></li>
<li><a href="https://draapho.github.io/2021/04/22/2119-answer9/">天赐问答9: 不完美, 才会独一无二</a></li>
<li><a href="https://draapho.github.io/2021/04/23/2120-answer10/">天赐问答10: 不要辜负你的生命</a></li>
<li><a href="https://draapho.github.io/2021/04/24/2121-answer11/">天赐问答11: 100多年前的马克思主义, 过时了吗?</a></li>
<li><a href="https://draapho.github.io/2021/04/25/2122-believe/">我们到底该信什么，不该信什么？</a></li>
</ul>
<p>以上所有内容, 皆转载自微信公众号: 自愈之光<br>此系列为灵天赐入道开悟后的资料收集.</p>
<hr>
<h1 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h1><p><em><strong>观察和专注当下是指一个东西吗，我之前发现我很难专注当下，头脑里稍不注意就会演起小剧场，但当我意识到自己走神之后，回到眼前，当下，这本身又好像是观察。</strong></em></p>
<p>答：观察与专注当下，效果一样。</p>
<p>常人脑海中思绪纷飞，难得空闲。</p>
<p>可以做个实验，找个空闲的时间，安安静静的坐上十分钟。</p>
<p>不做事，不说话，不玩手机，不看任何东西。</p>
<p>只是对着空无一物的墙壁，安安静静的坐一会。</p>
<p>你会发现，脑海中，时时刻刻都在浮现种种念头。</p>
<p>时时刻刻在鼓动你，让你去做点这个，做点那个。</p>
<p>或是带着你去回忆过去，担忧未来。</p>
<p>似乎，它永远都停不下来，似乎一定要做点什么才可以。</p>
<p>这个躁动不安的，便是人的小我心智。</p>
<p>也是古人所谓的——‘心猿意马’。</p>
<p>平时，人们处在小我心智的掌控下。</p>
<p>如同带上镣铐的囚徒，不停的被驱使，没有半点闲暇。</p>
<p>观察，和专注当下，给你提供了一个珍贵的机会。</p>
<p>观察，让你从大脑永不间断的思维流中，抽身而出，看见思维的流动，以及它们要把你带去的方向。</p>
<p>专注当下，通过做事以至于忘我的程度，让你忘记一切思维流的干扰，只剩下全然而又彻底的存在。</p>
<p>两种方式，都是让你从痛苦之中越狱，从束缚之中解脱的关键。</p>
<p>当你身处两者之中的时间越来越多，你身上的镣铐就越来越困不住你。</p>
<p>你天然的，就会获得对痛苦的免疫力。</p>
<p>因为，生活中的大多数痛苦，都是人的小我心智，为打造的牢笼。</p>
<p>越狱的关键，不是努力奋斗，努力奋斗也是小我心智的一种手段。</p>
<p>让你误以为努力为了监狱而行动，有一天就可以脱离监狱。</p>
<p>越狱的关键，是认识到，你不在牢笼中。</p>
<p>当你认识到，你本不在牢笼中的一瞬间，你就出来了。</p>
<h1 id="问：-1"><a href="#问：-1" class="headerlink" title="问："></a>问：</h1><p><em><strong>在生活中有时候会在不经意间遇到一些问题，可当真正想问的时候却不知道从何出说起，好像那些问题根本没有存在过。有点迷惑。</strong></em></p>
<p>答：因为，你习惯了浅层次的思考，没有深层次思考一切现象本质的习惯。</p>
<p>某些问题冒出来的瞬间，其实是一种灵感，也是一种启发。</p>
<p>但是，由于过于沉浸于人脑的心智认同。</p>
<p>转瞬之间，你因外物对心的触动，产生的珍贵灵感与启发。</p>
<p>一下被你脑海中不间断的思维流，彻底淹没了。</p>
<p>你遇见的这些瞬间，每一个都是能让你顿悟，或者有所启发的奇迹时刻。</p>
<p>但是，处在心智认同中的你，因为没有与你的心共鸣。</p>
<p>便会让这些瞬间，轻易消逝。</p>
<p>没有给你带来任何益处。</p>
<p>不用担心，绝大部分人，在日常生活中，都和你一样。</p>
<p>每一个能抓住这些瞬间的人，都是非凡者。</p>
<p>并非他们天生非凡，不过是因为，他们懂得疑惑心智呈现给他们的假象。</p>
<p>而且，他们还十分善于进入非心智认同的领域，去汲取事实真相。</p>
<h1 id="问：-2"><a href="#问：-2" class="headerlink" title="问："></a>问：</h1><p><em><strong>我是一位面临考研的学生，我的毛病可以这样描述：</strong></em></p>
<p><em><strong>看《与神对话》时，神说：不要怕，怕会吸引你害怕的东西 我：好可怕</strong></em></p>
<p><em><strong>遇到压力，我对自己说：不要着急，欲速则不达 我：完了，我好着急，要“不达”了</strong></em></p>
<p><em><strong>“要接纳自己” 我：“完了，我又没接纳自己了”</strong></em></p>
<p><em><strong>好像一个很努力地要睡着的人，然后越来越精神…..可我就是想好好地睡个觉而已….为什么那么难呢？..明明只要闭上眼睛躺着就是最好的状态了…我怎么就那么害怕自己睡不着呢…或者说，我为什么执着地相信自己非得害怕不可呢…</strong></em></p>
<p><em><strong>当我在当下感知到痛苦时，常常会感觉我无论做什么都是在逃避：向前走，像是要逃避；向后退，像是要逃避；呆在原地，更像是要逃避。所以但凡恐惧的情绪已经出现的状态下，我往往不知道该怎么做，像是“无处可逃”。就比方说，当我感知到考研的压力时，我马上开始复习？对不起，你都没确认自己的目标院校，所谓的复习也不过是你逃避恐惧缓解焦虑的方式之一；我马上去考虑目标院校，对不起，你了解的也不少了，所谓的继续了解也不过是你逃避恐惧的方式之一罢了；那我啥也不干了？对不起，你这是坐以待毙。</strong></em></p>
<p><em><strong>每一种选择只要成为我当下的选择，仿佛都会导向一种悲观的结果；但只要它暂时不是我的选择，那么即使它并不靠谱，我可能也会幻想它会带来一个正向的结果。永远维持着这种求而不得的感觉，这种情况下自暴自弃成为最优解。当我陷入恐惧拼命地想要防御时，我应该怎么办？应该毫无保留地将自己暴露在恐惧中吗？我应该这样做吗？我能这样做吗？</strong></em></p>
<p><em><strong>怎么才能把心放宽，怎么才能不害怕，怎么才能不着急！啊，我害怕这样下去会把自己毁了</strong></em></p>
<p><em><strong>好多地方听过这样一个观点，时间是高我为了体验物质世界创造出的幻觉。还有爱是一切存在的原因，爱即是一切的看法。这些形而上的说法，对我们修行亦或者生活的意义是什么呢？既然一切是最完美的安排，那这些是要去真实体会的真相呢？还是一种对真理的譬喻？</strong></em></p>
<p>答：你现在的状态，属于被小我心智死死困住。</p>
<p>你从外界看来的知识，没有经过实践、感悟与共鸣之前，都不是你的。</p>
<p>只是一种‘貌似懂得’的幻觉。</p>
<p>这种幻觉，会过滤所有你接触到的‘真理知识’。</p>
<p>处于这种自我幻觉中时，你会体验到‘知识的无用’。</p>
<p>事实上，不是你看到的‘真理知识’，真的对你没用。</p>
<p>而是由于自我的遮蔽，你看书时，没能接触到真正的知识。</p>
<p>所有‘真理知识’，必须经历接触、实践、有效、共鸣、信心的阶段，才能真正习得。</p>
<p>不是看几句话，读几本书就可以习得的。</p>
<p>你考研的问题，也是自我对你玩弄把戏。</p>
<p>它会给于你创造一个幻觉。</p>
<p>幻觉基于一些看似合理的认知，你周围的环境，社会的一般氛围。</p>
<p>幻觉让你误以为， 你‘非考研’不可。</p>
<p>不是这样的，你对你的人生，任何时候拥有超乎你想象的可能性。</p>
<p>考研，并非唯一的道路，也不是你不得不走的道路。</p>
<p>自我会利用这种把戏，让你反复的自我折磨，陷入痛苦之中无法自拔。</p>
<p>通过狭隘你对未来的视野，迷惑你真正的选择。</p>
<p>实际上，这种方式，恰恰才让你无法进入真正的考研学习状态。</p>
<p>原因很简单。</p>
<p>因为，你考研并不是你真正发自内心去‘选择’的。</p>
<p>自我会欺骗你，说你你没有任何选择权，你只有去考研。</p>
<p>这个时候，你对‘考研’的认知，也被自我扭曲。</p>
<p>你‘考研’不再是为了成就理想，不再是为了成为人生想成为的那种人，不再是能让你感到兴奋和快乐的事情。</p>
<p>它变成一种恐惧：一种害怕‘失败’，害怕‘未来’一败涂地的恐惧。</p>
<p>就这样，自我成功的把你对未来的选择，对未来的理想，对未来的憧憬。</p>
<p>替换为，对未来的恐惧，对未来的担忧，对未来的无力。</p>
<p>通过迷惑你对自己人生的选择权，自我让你误以为：</p>
<p>你的一切道路，都不是你所选择的。</p>
<p>人，是无法为一条不得不走的道路，发自内心的感到兴奋的。</p>
<p>没有这种兴奋，就不会有真正的动力，去做并非你真正选择的事情。</p>
<p>结果，自然也不可能做好。</p>
<p>你越是焦急、越是紧张，越是害怕失败；</p>
<p>你越是表现糟糕，你越是失控，也越是走向无可避免的绝望。</p>
<p>这一点，正是自我的狡猾之处。</p>
<p>像一个魔法师，让你不知不觉中，陷入它的痛苦把戏。</p>
<p>要识破这些幻觉，考研，就需要明确你考研的初心。</p>
<p>是为了能学习自己热爱的专业？</p>
<p>还是为了享受学习进步的快乐？</p>
<p>还是为了成为科学家，为人类的发展做出贡献……</p>
<p>如果，你能将任何一件你真正的热爱与兴奋，与你的考研挂钩。</p>
<p>当你明白，你是为了自己的兴奋与快乐和享受而考研的，而不是为了你并不真正感兴趣的‘高工资’、‘更好的出路’、‘他人的赞扬’等等因素而考研。</p>
<p>你就会爆发出无穷的动力。</p>
<p>会像上瘾一样的做事情，像是永动机一样，以常人难以想象的方式，毫不努力的持续学习。</p>
<p>如果，考研这件事，无法让你发自内心的感到兴奋。</p>
<p>生活中，你还有其他，更让你感到兴奋的方向。</p>
<p>为什么不把你的时间，投入到正确的事情上呢？</p>
<p>考研既然无法让你感到幸福，过程已经如此痛苦。</p>
<p>为什么，会认为结果，就一定会幸福呢？</p>
<p>努力之后考不上、考上的学校很糟糕、没读到喜欢的专业、三年后没读下来、读下来，却没有之前所预期的好处。</p>
<p>这个时候，你怎么办？</p>
<p>这样，无非是在荒废人生，多走弯路罢了。</p>
<p>人生，要顺应自己的天赋与热爱，去走一条笔直的大道。</p>
<p>这条道路，或许会很难，或许有很多挫折，或许有许多考验。</p>
<p>可是，至少你会走得快乐，走得兴奋，走得圆满。</p>
<p>怀着这种心态，无论你去考研，还是做别的。</p>
<p>没有做不成的事情。</p>
<p>因为，你没有一天，会感到痛苦。</p>
<p>你专注在做事的过程中，成为了最好的自己。</p>
<p>这份心态，将给你的人生注入蓬勃不息的能力源泉。</p>
<p>让你活在自我实现的喜悦之中。</p>
<p>这，才是人生的正确活法。</p>
<h1 id="问：-3"><a href="#问：-3" class="headerlink" title="问："></a>问：</h1><p><em><strong>明心和见性是否可能并行，不是泾渭分明前后顺序的阶段？</strong></em></p>
<p>六祖慧能说过：</p>
<p><strong>心是地，性是王。</strong></p>
<p>心与性，不是两个两个东西，是同一个东西，不过所在的深度不一样。</p>
<p>心是土地。</p>
<p>这片土地，是一个人的认知边界。</p>
<p>你认知世界的一切事物，都在心的这块土地上生长蓬勃。</p>
<p>你有喜欢的音乐，也有讨厌的音乐；</p>
<p>你有喜欢的人事，也有讨厌的人事。</p>
<p>心生种种善恶、好坏、 悲欢等认知，由此而体验到不同的环境。</p>
<p>譬如眼前有半杯水。</p>
<p>有人看了，欣喜道：还有半杯！</p>
<p>有人看了，哀叹道：只剩半杯了。</p>
<p>这，都是心的作用。</p>
<p>半杯水永远只是半杯水，不因为有人欣喜而多一滴，也不因为有人悲伤而少一滴。</p>
<p>半杯水，之所以在不同人眼里，呈现出不同的意味。</p>
<p>是因为不同的人，有不同的心地。</p>
<p>这片国土，不断染着一切进入的事物，让这些东西，成为他们心中的模样。</p>
<p>性是国王。</p>
<p>国王，是掌管规律运行的绝对主宰。</p>
<p>心的用，是感知。</p>
<p>性的用，是存在。</p>
<p>举个例子：</p>
<p>你识别一件事，你喜欢还是不喜欢，这件事对你是好是坏，是心的用。</p>
<p>而无论你多么努力的用思考去下命令，也不能停止心脏的跳动。</p>
<p>心脏的跳动，人体运作的智性，神经细胞以某种规律而形成了意识。</p>
<p>这些，都是性的用。</p>
<p>性生心，心生一切妄想执着。</p>
<p>一般而言，人们都是先认知心，再认知性，这样会比较容易。</p>
<p>毕竟，心就已十分难以认知，就像让一条鱼认知水的存在一样。</p>
<p>而，性更是超乎人的想象层面。</p>
<p>不过，也有少数人。</p>
<p>直接见性，从而知心。</p>
<p>譬如我的引路人，便属于这一种。</p>
<p>原因，很简单。</p>
<p>发大愿，舍己为人。</p>
<p>妄心灭，本性出。</p>
<p>于是，直接越过自我，直下见性。</p>
<p>见性之后，自然明心。</p>
<h1 id="问：-4"><a href="#问：-4" class="headerlink" title="问："></a>问：</h1><p><em><strong>天赐老师，我是一名高三的学生，我想问的是如何才能像你的另一个回答里你的表妹那样“放下对好结果的期待”，这个做法有什么技术层面的实操方法吗？如何才能寻找那些足以改变自己命运的真实欲望，怎么判断什么是自己的真实欲望什么是自己在压力下的应激反应和异想天开?从而不被社会主流观念牵着走?我也想历经千锤百炼做强者，问题是性格软弱身体容量小也沉不住气耐力也不好，可能这就叫根器浅?一直听着学校的教导努力努力，但是我总是坚持不下去，不断地失败不断地自责到最后完全失去了信心，现在我想要换一条路走，我想寻找发掘自己的独特性在保证生计的同时能不被社会主流观点裹挟走出一条自己的路。。。或者这么说，如何让努力更平稳一点而不是一曝十寒，如何构建更稳固的动力系统让动力来源于自身创造的快乐而不是被虚荣和焦虑捆绑?这个真的困绕我好久了啊啊啊啊啊啊！希望老师好好指导我一下。</strong></em></p>
<p>答：努力是一种幻觉，我也曾被努力欺骗过。</p>
<p>努力会告诉你，不必费脑去思考问题的答案，只要去努力就好了。</p>
<p>只要努力， 一切都可以成功。</p>
<p>我不成功， 只是因为我不够努力。</p>
<p>一味的努力，不是努力，只是懒惰，懒于思考。</p>
<p>是自我的幻觉，不断给你带来更多的痛苦。</p>
<p>现实是不一样的。</p>
<p>搬砖的人在努力，也不可能成为世界首富。</p>
<p>绝大部分人再怎么努力，也不可能考上清华、北大。</p>
<p>完全只凭借努力考上清华北大的人，同样会受到冲击。</p>
<p>因为，他们会看到很多完全不努力的人，依然轻松超越他们的努力。</p>
<p>天赋与热爱很重要。</p>
<p>一个不擅长数学，又很讨厌数学的人。</p>
<p>一辈子再怎么努力，也绝不可能成为伟大的数学家。</p>
<p>因为，这人每一次学习数学，都在消耗能量。</p>
<p>人每天的能量有限，很容易被耗光。</p>
<p>哪怕只是一天干八小时，一周干五天，也会感觉仿佛死了一样的难受。</p>
<p>热爱数学的人呢？</p>
<p>这个人可以废寝忘食的学习数学，碰见任何问题都会充满兴奋的寻找答案。</p>
<p>讨厌数学的人，学五天至少要休息两天，可能还不够。</p>
<p>热爱数学的人一天不学数学就浑身难受，从凌晨学习到深夜，也不会感到很疲惫，反而充满了兴趣。</p>
<p>别人眼中的痛苦和工作，在他眼中只是在玩游戏。</p>
<p>很多人玩游戏、做轻松愉快的事，很容易就能废寝忘食，也不会特别疲惫。</p>
<p>这，就是热爱的意义所在。</p>
<p>你现在身处高三，我给你的建议是：</p>
<p>不必着急思考太多深奥的事情，这些不过是你面对学习压力时，无意识的逃避心理。</p>
<p>学会直面压力，坦然的接纳它们。</p>
<p>你的压力来源，主要来自于你自己的贪欲。</p>
<p>你希望能够做得更好，能比周围的人更好，能上一个特别好的学校。</p>
<p>放下这些想法和欲望。</p>
<p>你需要做的，不是比周围人更好。</p>
<p>你需要做的，也不是能力范围内的超常发挥。</p>
<p>你要做的，是正常的付出，正常的学习，正常的玩耍，正常的提高。</p>
<p>在自己的能力范围内，成为最好的自己，就足够了。</p>
<p>不要想着去突破极限。</p>
<p>你不是运动员，没必要自我折磨。</p>
<p>经常突破极限的顶尖运动员，一般都活不长。</p>
<p>退役后也一身伤病，生活质量不高。</p>
<p>顺应你的本性，想玩的就玩，想学的时候就认真学。</p>
<p>不要用玩耍来逃避学习，而是接纳学习，不把学习当成让你痛苦的事。</p>
<p>这样，就会轻松很多。</p>
<p>因为，你放下了那些不必要的欲望。</p>
<p>高考，能考多少就考多少，尽到了能力范围内的付出，就足够了。</p>
<p>每一天的学习，只专注于每一天。</p>
<p>名次和排名，不是用来和别人比，只用来对比昨天的自己。</p>
<p>每一次的考试，只当成一种测试，根据结果调整你的方法就好了。</p>
<p>人生很长。</p>
<p>高考之后，你的人生，也才刚刚开始。</p>
<p>在这个阶段，一定要学会直面挑战，停止折磨自己，停止给自己施压。</p>
<p>高考完，无论成绩如何。</p>
<p>你都会有足够的时间，去自由探索你的热爱。</p>
<p>先把这一年，踏踏实实的经历下来吧。</p>
<p>保持运动，保持一个爱好，不逃避学习。</p>
<p>该学学，该玩玩。</p>
<p>心就会很静，也没什么问题。</p>
<p>不是你玩得越少，学习就会越好的，这是一个幻觉。</p>
<p>大家能利用的时间，其实都差不多。</p>
<p>把你已有的时间充分利用，高效率的学习，比每周节约几小时的娱乐，效果更好。</p>
<p>心智压力没有得到释放，高压状态下，人很容易表现时常。</p>
<p>专心的，接受高考的试炼吧。</p>
<p>这种经历，对你未来的人生，是极有好处的。</p>
<p>没必要自己吓唬自己，放下欲望，好好享受吧。</p>
<p>人生很长。</p>
<p>你有足够的时间，在热爱、兴奋与快乐之中，成为最好的自己。</p>
]]></content>
      <categories>
        <category>灵天赐</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>天赐问答4</title>
    <url>/2021/04/17/2114-answer4/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/14/2111-answer1/">天赐问答1: 知行合一, 方为真知.</a></li>
<li><a href="https://draapho.github.io/2021/04/15/2112-answer2/">天赐问答2: 总是拖延, 该怎么办?</a></li>
<li><a href="https://draapho.github.io/2021/04/16/2113-answer3/">天赐问答3: 凡夫一向动, 小乘一向静</a></li>
<li><a href="https://draapho.github.io/2021/04/17/2114-answer4/">天赐问答4: 烦恼名众生, 悟解名菩提</a></li>
<li><a href="https://draapho.github.io/2021/04/18/2115-answer5/">天赐问答5: 如何放下对结果的期待</a></li>
<li><a href="https://draapho.github.io/2021/04/19/2116-answer6/">天赐问答6: 为什么真正的境界不会退转?</a></li>
<li><a href="https://draapho.github.io/2021/04/20/2117-answer7/">天赐问答7: 为什么开悟的似乎都是男人, 女人呢?</a></li>
<li><a href="https://draapho.github.io/2021/04/21/2118-answer8/">天赐问答8: 男女欲望该怎么处理?</a></li>
<li><a href="https://draapho.github.io/2021/04/22/2119-answer9/">天赐问答9: 不完美, 才会独一无二</a></li>
<li><a href="https://draapho.github.io/2021/04/23/2120-answer10/">天赐问答10: 不要辜负你的生命</a></li>
<li><a href="https://draapho.github.io/2021/04/24/2121-answer11/">天赐问答11: 100多年前的马克思主义, 过时了吗?</a></li>
<li><a href="https://draapho.github.io/2021/04/25/2122-believe/">我们到底该信什么，不该信什么？</a></li>
</ul>
<p>以上所有内容, 皆转载自微信公众号: 自愈之光<br>此系列为灵天赐入道开悟后的资料收集.</p>
<hr>
<h1 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h1><p><em><strong>喝完咖啡/茶我会觉得很清醒，感觉很容易进入临在或专注的状态。请问您怎么看？</strong></em></p>
<p>答：咖啡和茶，有刺激大脑神经的作用。</p>
<p>它们，暂时提升了你的注意力。</p>
<p>所以，比较容易进入专注状态。</p>
<p>适当饮用热茶，有益于健康。</p>
<p>每天食用过多咖啡和茶，易让人产生依赖性。</p>
<p>一般而言，茶比咖啡健康一些，茶利于排尿，也没有咖啡容易产生依赖性。</p>
<p>不过，这类提神饮品，都不应常喝。</p>
<p>有人习惯之后，如果不喝茶和咖啡，就会精神不振。</p>
<p>因为，他们体内的能量亏空。</p>
<p>能量亏空的人，不适合饮用提神类饮品，应该停止喝茶与喝咖啡。</p>
<p>…… (灵天赐提了一款饮料和购买方式. 此处略过, 容易认为在打广告. )</p>
<p>日常要规律作息，规律饮食，每周运动至少两次。</p>
<p>有时间，多去自然里坐坐。</p>
<p>两周不到，体内的能量系统，就会得到恢复。</p>
<p>能量充沛后，就会发现。</p>
<p>你无需咖啡和茶等工具的刺激，也很容易进入临在与专注状态，不易感到疲惫。</p>
<h1 id="问：-1"><a href="#问：-1" class="headerlink" title="问："></a>问：</h1><p><em><strong>您好，我二十二岁，马上毕业，按世俗的眼光就应该找工作挣钱，可我却偶尔有离群隐居，独自修行的想法。我觉得钱，食物，人际关系已经对我没有吸引力了。但我家里还有父母，他们对我有期望。您怎么看呢。</strong></em></p>
<p>答：</p>
<p>离群隐居，不等于修行。</p>
<p>不止你有这种误会，很多人对于修行，也有同样的误会。</p>
<p>倘若只是离开人群，独自居住，便可修行觉悟。</p>
<p>随便一处深山老林，理应到处都是充满智慧的觉悟者。</p>
<p>达摩有云：</p>
<p><strong>“‘烦恼’名众生，悟解名‘菩提’，亦不一不异，只隔其迷悟耳。”</strong></p>
<p>此句意指：</p>
<p>烦恼的时候，便是众生；悟解的时候，便是菩提。</p>
<p>‘菩提’指智慧与觉悟。</p>
<p>烦恼和菩提之间，既不是完全相同的一个，也不是不同的两个。</p>
<p>烦恼和菩提，是一枚硬币的正反两面。</p>
<p>中间，只隔一层迷、悟。</p>
<p>离开人群，离开人世，试图求取智慧。</p>
<p>这种举动的逃避烦恼，害怕你所面对的现实。</p>
<p>达摩还说：</p>
<p><strong>“一切烦恼为如来种子，为因烦恼而得智慧。”</strong></p>
<p>一切烦恼，都是觉悟的种子。</p>
<p>正因为有烦恼，才能得到智慧。</p>
<p>也就是说。</p>
<p>烦恼，是智慧与觉悟的种子。</p>
<p>你逃离烦恼的瞬间，也就逃避了觉悟和智慧。</p>
<p>你说，钱、食物、人际关系对你没有吸引力。</p>
<p>显然，不是的。</p>
<p>你有父母要供养，父母的养育之恩，还未报答。</p>
<p>如何割舍？</p>
<p>修行，先把人做好。</p>
<p>现代网络社会，和古代不一样了。</p>
<p>传承时机、状态，也不一样了。</p>
<p>修行，不是一定要抛妻弃子，人世本就是最好的道场。</p>
<p>因为，这里到处都是烦恼。</p>
<p>这时候逃避现实。</p>
<p>一辈子，也就荒废了。</p>
<p>因为，你避开了对你而言最重要的一堂课。</p>
<p>少了这门课，山洞里打坐入定一辈子。</p>
<p>终究无法求得圆满。</p>
<p>告诉你一个事实，释迦牟尼是有妻子有孩子的。</p>
<p>老子也是有妻子有孩子的。</p>
<p>以后，你老了。</p>
<p>想图清净，随时去找地方隐居。</p>
<p>不过，不是你隐居了，才会有智慧。</p>
<p>而是你直面烦恼，才有机会生发智慧。</p>
<p>正是青春年华。</p>
<p>该把人道圆满，将这个人做好。</p>
<p>寻一位智慧师，依其法门，在家修行勤奋修行即可。</p>
<p>六祖慧能也说：</p>
<p><strong>“若欲修行，在家亦得，不由在寺。”</strong></p>
<p>很多人，和你一样。</p>
<p>总觉得修行，一定要找个深山老林，或者寻个佛寺道观。</p>
<p>其实，现在的佛寺道观里，深山老林，几乎没有真修了。</p>
<p>乐观一点。</p>
<p>大概剩下一只手可数完的人数。</p>
<p>有见地的觉悟者，要么在入世生活。</p>
<p>要么，就图清净，躲在籍籍无名的小破庙或小道观。</p>
<p>就是那种，地图上都不一定有的偏僻之处。</p>
<p>隐世的觉者，在你面前走上十个来回。</p>
<p>你也不可能认得出来。</p>
<p>毕竟，你的眼力。</p>
<p>连我这种入世来讲的，都认不出。</p>
<p>何况是隐世的？</p>
<p>更不可能认得出来。</p>
<p>以你现在的认知，真碰见了，只会对他们充满蔑视。</p>
<p>毕竟，他们和你想象中的高人，完全不一样。</p>
<p>更像平凡人、普通人。</p>
<p>像你身边，随处可见的那种。</p>
<p>就是你现在，特别想远离的——那种‘凡人’。</p>
<p>修行，需要导师的。</p>
<p>完全不依师而觉悟的人，亿万稀有。</p>
<p>这一类人，往往生而知之。</p>
<p>本就不需要学习，更不需像你一样，要跑去深山老林里‘修行’，才会获得智慧。</p>
<p>他们，生来，就有智慧。</p>
<p>你自己也明白，你不是生而知之的类型。</p>
<p>讲个故事：</p>
<p>生而知之者如老子。</p>
<p>十岁时，家里请当地德高望重的商容，给他当老师。</p>
<p>商容时常就老子的问题，问得哑口无言。</p>
<p>仅三年，博学智慧的商容。</p>
<p>便教不下去，主动向老子的父母告辞。</p>
<p>他推荐老子去他师兄那学习。</p>
<p>商容的师兄，是周朝的太学博士，相当于今天清华大学的博士导师。</p>
<p>十三岁，老子便离家，去周朝首都的最高学府，接受博导的教导。</p>
<p>三年后，十六岁的老子，被推荐成为周朝守藏室的官吏。</p>
<p>周朝的守藏室，相当于今天的国家图书馆与国家机密档案馆的集合。</p>
<p>老子看了三年书，以及各种机密文献。</p>
<p>19岁时，他的智慧与声誉开始传遍全国。</p>
<p>你看，你今年22岁。</p>
<p>比老子当时的年纪，还大3岁。</p>
<p>除学校学习以外，看过多少本修行相关的书？</p>
<p>《大学》、《中庸》、《易经》看过吗？</p>
<p>《太上老君说常清静经》、《南华经》、《道德经》读过吗？</p>
<p>《金刚经》、《心经》、《坛经》读过吗？</p>
<p>《四福音书》、《奇迹课程》看过吗？</p>
<p>《苏菲派》、《可兰经》听说过吗？</p>
<p>《与神对话》、《当下的力量》、《bashar系列》、《赛斯资料》，听过吗？</p>
<p>…………</p>
<p>这些最基础的经典读物。</p>
<p>你知道，这些资料的存在吗？</p>
<p>古代圣人所写的经典，看过多少本？</p>
<p>看过的书，能达到老子19岁时的十分之一吗？</p>
<p>看书，还只是修行中最肤浅的部分。</p>
<p>并不是你看了，就能得到真理。</p>
<p>不正确的看，没有修行方法。</p>
<p>看再多的书，也不会有丝毫收获。</p>
<p>没人指点，怎么知道哪本书说的是真理，哪本书里全是猜测？</p>
<p>哪本书里埋了多少坑？</p>
<p>哪本书的作者不知道自己其实写错了？</p>
<p>再和你谈点现实问题：</p>
<p>深山老林，哪来钱买书？谁给你钱来维持生活？</p>
<p>柴米油盐不要钱？</p>
<p>自给自足，有野外生存能力吗？</p>
<p>独自在野外生活过一个月吗？</p>
<p>种田的苦吃得下吗？现实中种过几年田？</p>
<p>会种田吗？顿顿吃相同的饭和菜，能坚持超过半年吗？</p>
<p>说不定，每顿不一定有饭菜，可能只有土豆，吃得消吗？</p>
<p>夏天山里有彻夜不停的蚊虫、随处可遇的毒蛇、取水困难，未必是你想象中的清幽浪漫。</p>
<p>为了生存，忙于种田、挑水、做饭的忙碌生活，有想过吗？</p>
<p>谁给你发许可，允许你在国家的土地上建房屋？</p>
<p>被发现，会被强拆的，知道吗？</p>
<p>老子生而知之，天生早慧，依然勤学苦思，博览群书。</p>
<p>观人世历代沧桑，不断思索感悟天地宇宙真理的奥秘，方才悟道。</p>
<p>释迦牟尼生而知之，29岁舍弃繁华，拜师学习，习种种方法，吃尽各种苦头，苦修6年。</p>
<p>直到七日一食，饿锝前胸贴后背，几乎只剩下骨头。</p>
<p>这时，他放弃苦修。</p>
<p>追随他的弟子，也失望的离他而去。</p>
<p>他接受妇女的羊乳供养，在菩提树下，夜观星空。</p>
<p>终于契合得道，悟得究竟智慧。</p>
<p>他们，都是通过自己的方式，在人世中深思成长，而得觉悟。</p>
<p>并不是通过逃离人世的烦恼，而得智慧。</p>
<p>释迦牟尼若没有牧羊女，给他施舍的羊奶，没有牧羊女所在的人世。</p>
<p>在山里，释迦牟尼就把自己饿死了。</p>
<p>又哪来觉悟与智慧呢？</p>
<p>这些是圣人们白纸黑字留下的记载。</p>
<p>你若觉得，古代记载太遥远，不愿意相信。</p>
<p>和你举一个现实例子：</p>
<p>我两年明心见性，是大学中完成的。</p>
<p>没有跑去什么深山老林，也没有跑去当什么和尚道士。</p>
<p>大二到大三的两年间，引路人对我的指导和修行，完全通过网络完成。</p>
<p>期间，现实里见过他两次。</p>
<p>每次不超过三小时。</p>
<p>见面时，基本是闲聊，没什么特别收获。</p>
<p>每一次真正的顿悟与进步，都是我自己依照引路人的教导。</p>
<p>按照正确的方式，去看书、练习、深思之后，才取得的。</p>
<p>这期间，我完成了大学学业，和其他学生一样一起去打电子游戏，与室友一起聚餐玩耍，平时看小说。</p>
<p>考虑到毕业后的工作，顺便报了一个大学里的UI设计班。</p>
<p>断断续续学了两年，写了170万字的小说。</p>
<p>同时，闲暇还在思考，未来想做什么，家中不时有各种烦恼不停骚扰我。</p>
<p>这些，都没有对我的修行，造成任何影响。</p>
<p>或者说，恰恰是现实中的烦恼和痛苦。</p>
<p>促使我的修行，飞速进步。</p>
<p>现在，改变了糟糕的原生家庭，改变了父母之间的恐怖关系。</p>
<p>家庭圆满，父母和谐，没什么矛盾。</p>
<p>你的父母，你想远离的这些‘凡人’。</p>
<p>究竟影响了，你修行的什么？</p>
<p>真的明白，什么是修行吗？</p>
<p>你觉得。</p>
<p>他们，才是你痛苦的源头吗？</p>
<p>他们，为你的烦恼和痛苦负全责吗？</p>
<p>连入世的修行者，我在这里讲的东西。</p>
<p>都没有正法眼，认得出，看得清。</p>
<p>也没有在日常生活中，真正做到。</p>
<p>深山老林里，谁给你信心？</p>
<p>为什么觉得，通过独处。</p>
<p>无需任何教导，无需向任何智者求学，无需任何学习。</p>
<p>远离人群，入了山林，就从此超越老子、耶稣、释迦牟尼获能得觉悟呢？</p>
<p>真正的隐世高人，从你面前走过去，你也认不出来的。</p>
<p>因为，你什么都没有。</p>
<p>没有智慧，没有诚心，没有觉悟，没有慧眼。</p>
<p>没什么能让高人，认可你是可教之材之处。</p>
<p>高人们，随手给你一个小考验。</p>
<p>你都过不去。</p>
<p>为什么？</p>
<p>因为，你连家庭、父母和现实，这种最简单的考验都过不去。</p>
<p>更何况，隐世高人的考验呢？</p>
<p>修行远比赚钱、读书等世间一切事，更难。</p>
<p>甚至难道，只有见性后。</p>
<p>一个人，才真正有机会，觉醒无师智。</p>
<p>从而能看懂老子、释迦牟尼、耶稣这些圣人留下的话语。</p>
<p>在文字中，发现他们的道路。</p>
<p>自愈之光这个公众号。</p>
<p>存在的时间，也不会太久。</p>
<p>等我把现实的问题处理完，就会关掉。</p>
<p>有这份天大的机缘，无数宝山一样的正法，免费丢在你面前。</p>
<p>不需要你花钱，你依然不珍惜。</p>
<p>跑去山里，瞎折腾什么？</p>
<p>修行，不假外求。</p>
<p>智慧，只能从心内求取。</p>
<p>达摩说过：</p>
<p><strong>自心是佛，即心是佛，心外无佛，佛外无心。</strong></p>
<p>这点都不明白，都不知珍惜。</p>
<p>你，如何修行呢？</p>
<h1 id="问：-2"><a href="#问：-2" class="headerlink" title="问："></a>问：</h1><p><em><strong>想问问您和他人聊天的时候说不说灵性知识。我父母知道我在灵修的道路上，我很要好的两三个也朋友知道，我也劝过我爸妈读，我爸却说《当下的力量》不是他的处世哲学，他不喜欢。他们还对我在修行这件事羞于启齿，比如我说我在冥想，家里有客人的时候他们就会换一个词叫“闭目养神”。</strong></em></p>
<p><em><strong>有时和他人聊天，我也会想说灵性知识，不是想标榜自己特殊，而是想救他人于水火。但也会羞于开口。</strong></em></p>
<p><em><strong>每当我羞于开口的时候，我又会以“拯救自己就是拯救世界”安慰自己。</strong></em></p>
<p><em><strong>请问在传播灵性知识这件事上，我们应该采取什么态度呢？</strong></em></p>
<p>答：</p>
<p>这不是在修行，而是在标榜自我。</p>
<p>这也不是在拯救别人，只是在标榜自己的特殊。</p>
<p>和你讲个故事：</p>
<p>写《当下的力量》的作者，顿悟后。</p>
<p>在公园长凳上傻傻的坐了很久一段时间，什么也没做。</p>
<p>顿悟后，他从未到处抓着，让别人听他聊灵性。</p>
<p>也从未按着别人的头，让别人来听他‘传播’灵性知识。</p>
<p>每天，他只是微笑而又满足的坐在那里。</p>
<p>看起来，什么也不需要的样子。</p>
<p>然后，大家逐渐开始好奇。</p>
<p>为什么公园里的这个流浪汉，好像每天都很开心，很满足？</p>
<p>于是，人们就开始向他提问。</p>
<p>他根据别人的提问，不断的回答……不断的回答。</p>
<p>一转眼，他就变得越来越出名，到处上节目。</p>
<p>然后，他写下《当下的力量》，全球畅销。</p>
<p>这个故事，不知道，是否有让你领悟什么？</p>
<p>修行，从不是让你异于他人，也不是让你高高在上。</p>
<p>而是放下执着，解除烦恼，回归本真，收获解脱。</p>
<p>别人不想听，没必要逼着别人听。</p>
<p>别人不感兴趣，便没必要开口。</p>
<p><strong>人之患，在于好为人师。</strong></p>
<p>像这样做，无非，是内心深处起了分别。</p>
<p>觉得自己是‘灵修者’，和周围的凡人们有了差距。</p>
<p><strong>为什么不向我请教灵性的真谛？</strong></p>
<p><strong>虽然，我也不知道什么是灵性真谛，可我至少看过的书比你们多！</strong></p>
<p><strong>为什么不听我的话？</strong></p>
<p><strong>为什么不按我的想法去做？</strong></p>
<p><strong>我的想法，我的见解，肯定是对的。</strong></p>
<p><strong>你们这些不懂‘灵性知识’的人，为什么看不到我身上满溢而出的灵性光辉？</strong></p>
<p><strong>让我还要刻意在家里来客人时，特别开口提醒客人，‘我在冥想’。</strong></p>
<p><strong>父母还试图误导客人们，万一客人们不了解，我是多么非同寻常而又特别的‘灵修者’，怎么办？</strong></p>
<p>自己读一下，以上这些话。</p>
<p>问问你的内心，这些话语，给你的感觉是什么？</p>
<p>你觉得是那是一种什么感觉，那就是你正在带给周围人的感觉。</p>
<p>按佛家的修行，这种言行属于恭高我慢，与杀人放火是同一个级别的错误，严重程度可以下地狱了。不要觉得太夸张，地狱门前僧道多，也主要是这个原因。</p>
<p>按灵性的修行，你属于陷入自我的牢笼，丧失了对他人无条件的爱与宽容，炫耀自己的知识。</p>
<p>再读一读，《马太福音》的第七章，耶稣的话：</p>
<p><strong>为什么只看见你兄弟眼中有刺，而不知自己眼中有梁木呢？</strong></p>
<p><strong>当你自己眼中有梁木，又怎能对你兄弟说：请容我帮你眼中的刺呢？</strong></p>
<p><strong>你这假冒为善的人！</strong></p>
<p><strong>要先去掉自己眼中的梁木，然后你才能看得清，才能真正去掉你兄弟眼中的刺。</strong></p>
<p>和你说这些，不是批判你。</p>
<p>而是如实告诉你，什么是真相。</p>
<p>修行，不是让你高高在上的资本。</p>
<p>对别人最好的教导，是用行动去成为榜样。</p>
<p>看到活生生的榜样，无需你说什么。</p>
<p>自然会被你吸引，自然会跑来问你。</p>
<p>智慧的光芒，不会被黑暗掩盖。</p>
<p>所以，和别人说话的时候，如何沟通？</p>
<p>就事论事，别人提什么，你就说什么。</p>
<p>既然不感兴趣，何必硬聊？</p>
<p>对方真想知道的时候，不需你的传播，那人自己就会来问。</p>
<p>如果，平时和周围人的聊天，忍不住想扯点灵性、禅宗、修行之类的别人并不感兴趣的话题。</p>
<p>说明，你内心深处感到自卑。</p>
<p>因为，除了这些东西。</p>
<p>你没法通过其他话题，给自己自信。</p>
<p>就像生活里，某些人与不懂英语的人说话时。</p>
<p>喜欢两、三句就夹带几英文单词。</p>
<p>这一类人，一般是内心深处过于自卑。</p>
<p>正因为自卑，才会迫切需要向人炫耀他们不理解的字词，为自己增添自信。</p>
<p>你喜欢这样的人吗？</p>
<p>你想成为这样的吗？</p>
<p>如果不喜欢。</p>
<p>以后，别做做这种傻事了。</p>
<p>什么时候，回首今天的提问，对自己的心态感到发自内心羞愧与羞耻时。</p>
<p>就说明，你进步了。</p>
<p>你真正开始，有‘灵性’了。</p>
<p>学习古人的智慧：</p>
<p><strong>静坐常思己过，闲谈莫论人非。</strong></p>
<p>与君共勉~</p>
<hr>
<p>无论喜欢或不喜欢，点亮或不点亮，关注或不关注。</p>
<p>祝你平安喜乐~</p>
]]></content>
      <categories>
        <category>灵天赐</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>天赐问答8</title>
    <url>/2021/04/21/2118-answer8/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/14/2111-answer1/">天赐问答1: 知行合一, 方为真知.</a></li>
<li><a href="https://draapho.github.io/2021/04/15/2112-answer2/">天赐问答2: 总是拖延, 该怎么办?</a></li>
<li><a href="https://draapho.github.io/2021/04/16/2113-answer3/">天赐问答3: 凡夫一向动, 小乘一向静</a></li>
<li><a href="https://draapho.github.io/2021/04/17/2114-answer4/">天赐问答4: 烦恼名众生, 悟解名菩提</a></li>
<li><a href="https://draapho.github.io/2021/04/18/2115-answer5/">天赐问答5: 如何放下对结果的期待</a></li>
<li><a href="https://draapho.github.io/2021/04/19/2116-answer6/">天赐问答6: 为什么真正的境界不会退转?</a></li>
<li><a href="https://draapho.github.io/2021/04/20/2117-answer7/">天赐问答7: 为什么开悟的似乎都是男人, 女人呢?</a></li>
<li><a href="https://draapho.github.io/2021/04/21/2118-answer8/">天赐问答8: 男女欲望该怎么处理?</a></li>
<li><a href="https://draapho.github.io/2021/04/22/2119-answer9/">天赐问答9: 不完美, 才会独一无二</a></li>
<li><a href="https://draapho.github.io/2021/04/23/2120-answer10/">天赐问答10: 不要辜负你的生命</a></li>
<li><a href="https://draapho.github.io/2021/04/24/2121-answer11/">天赐问答11: 100多年前的马克思主义, 过时了吗?</a></li>
<li><a href="https://draapho.github.io/2021/04/25/2122-believe/">我们到底该信什么，不该信什么？</a></li>
</ul>
<p>以上所有内容, 皆转载自微信公众号: 自愈之光<br>此系列为灵天赐入道开悟后的资料收集.</p>
<hr>
<h1 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h1><p><em><strong>思维有用吗？我倒是很享受全凭直觉的感觉，但这是不是自缚手脚呢？</strong></em></p>
<p>答：思维是一种智性。</p>
<p>有思维，你才能活在这个世界。</p>
<p>完全失去思维，你就会失去对现实的聚焦，无法正常活下去。</p>
<p>举个例子，思维是双腿，感觉是双眼。</p>
<p>任凭双腿按它的驱使硬走，只一门心思想走平坦的道路。</p>
<p>你可能绕了很多原路，也依然无法到达目的地。</p>
<p>如果只依靠感觉，你站在原地望穿秋水，也是无法前进一步的。</p>
<p>更何况，感觉和思维。</p>
<p>对于你当前的认知层次来说，是很难分清的。</p>
<p>有的感觉背后其实是思维作用，有的思维背后其实是感觉作用。</p>
<p>不可一概而论，也不能说思维一定不好，感觉一定很好。</p>
<p>摆脱这种片面与狭隘的思考方式。</p>
<p>你便向着真正的感觉，以及真正的思维，切实迈进了一步。</p>
<h1 id="问：-1"><a href="#问：-1" class="headerlink" title="问："></a>问：</h1><p><em><strong>天赐哥哥你好。</strong></em></p>
<p><em><strong>你最一开始在知乎写回答时提到了，修行需要大决心，大毅力。</strong></em></p>
<p><em><strong>那大决心究竟要多大?与干不成就跳楼自杀的决心比是更强还是更弱呢?</strong></em></p>
<p><em><strong>大毅力又是多大的毅力呢?</strong></em></p>
<p><em><strong>可以类比一些具体发生的事</strong></em></p>
<p><em><strong>来让大家更好理解这两个词吗?</strong></em></p>
<p>答：放弃生命，并非大决心。</p>
<p>人们放弃生命，不是因为这些人什么都放下了。</p>
<p>恰恰是因为，他们生活中有太多放不下。</p>
<p>比如：放不下自我观念、他人看法、世界、未来、概念、认知等等。</p>
<p>因此，他们才会选择放弃生命。</p>
<p>如果，一个人真的什么都可以放得下，什么都可以舍弃得了。</p>
<p>那么，他痛苦所依存的根基，就会奔溃离析。</p>
<p>如果，一个人。</p>
<p>连钱、权、名、利，他人对自己的看法，世俗对自己的看法，亲人对自己的看法，自己对未来的期待，都可一概舍弃并放下了。</p>
<p>这样的人，就永远失去了痛苦的因。</p>
<p>一瞬间，这个人就已从痛苦之中解脱。</p>
<p>没有理由，再去自杀。</p>
<p>决心，不是身处绝望黑暗中，卷缩在某个角落。</p>
<p>闭上双眼，自暴自弃，一咬牙选择逃避。</p>
<p>而是无论多少次被绝望击倒，被痛苦击败，被黑暗吞噬。</p>
<p>依然站起来，继续找寻光明。</p>
<p>这，才是决心。</p>
<p>直面痛苦，直面恐惧，直面绝望，直面惨不忍睹的人生。</p>
<p>这，才是觉悟。</p>
<p>痛苦折磨下，来到高楼上，在肾上腺素的刺激下，脑海中一堆负面定义与想法的疯狂驱使下。</p>
<p>闭上双眼，往下一跳，实在是一件十分简单与轻松的事。</p>
<p>像有的人下棋，生气了便出手砸飞棋子，破坏棋局一样。</p>
<p>这样的人，没有改变自己的决心，也没有舍弃一切的觉悟。</p>
<p>其短暂而又痛苦一生中，终究只是顺从了环境、他人以及自我的狭隘认知。</p>
<p>什么是大毅力？</p>
<p>比如有的人，一出生手里便只有一幅烂牌。</p>
<p>每天睁眼，就要面对各种值得让人绝望，值得让人失望，值得让人听从黑暗的无穷苦难。</p>
<p>在这种没有一丝光亮的生活中，在这种没有希望存在的至暗中。</p>
<p>这人，依然满怀对光明的期盼。</p>
<p>坚定的前行，找寻任何可能。</p>
<p>即便被命运打断手脚，即便被黑暗与痛苦遮蔽双眼，即便毫无缘由的苦难不断降临到身上。</p>
<p>这人虽然会与常人一样痛哭、一样绝望，一样哀嚎与惨叫。</p>
<p>可是，当眼角的血泪干涸。</p>
<p>这人哪怕用牙齿，在地上缓慢拖行。</p>
<p>也依然会喘息着，拼尽一切向着光的方向前行。</p>
<p>所以，修行升起的大决心，究竟有多大？</p>
<p>可以想象一下，一个从小出生在地狱之中，备受折磨的恶鬼。</p>
<p>它从未见过，也从未听闻过地狱以外的存在。</p>
<p>可是，忽有一天，它仰头望向天空。</p>
<p>发誓，要将地狱，转化为天堂。</p>
<p>就在那一刹那。</p>
<p>通向天堂的道路，为它而洞开。</p>
<p>这，便是修行中所谓的——‘愿’。</p>
<p>也即，所谓的——大决心。</p>
<h1 id="问：-2"><a href="#问：-2" class="headerlink" title="问："></a>问：</h1><p><em><strong>天赐您好，我看《当下的力量》时有提到时刻深入内在身体，请问这与时刻观察自己的思想本质是一样的吗？二者需要同时进行吗？</strong></em></p>
<p>答：什么是内在的身体？</p>
<p>什么是观察？</p>
<p>你可以想一下。</p>
<p>既然是存在一种‘观察’，而这种‘观察’平时被你外在的思维所蒙蔽。</p>
<p>那么，这个‘观察’，又来自哪里？</p>
<p>既然，它不是来自于你外在的任何东西。</p>
<p>显然，它只存在于你的内在之中。</p>
<p>维持观察时，人就已经身处‘内在身体’之中。</p>
<p>倘若执着于处于‘内在身体’。</p>
<p>便在意识之中，创造出一个名为‘内在身体’的新概念。</p>
<p>执着于这个概念，就被念头带走了。</p>
<p>从结果上来说，也没有真正处于你的内在身体之中。</p>
<p>以幻入幻，无法出幻。</p>
<h1 id="问：-3"><a href="#问：-3" class="headerlink" title="问："></a>问：</h1><p><em><strong>天赐老师好！后学有关于如何对待男女欲望的问题向您请教。</strong></em></p>
<p><em><strong>请问老师，有家室的在家修行人，男女交合会影响修行吗？如精力和专注力等。在家修行人如何正确对待男女欲望呢？如果要戒除淫欲的话，请问有什么好方法？您在修行过程中，是如何戒掉男女之欲的？ 在修行的哪个阶段就没有淫欲之心了？感恩老师！谢谢！</strong></em></p>
<p>答：首先，男女交合的欲望并不是错误的。</p>
<p>如果男女交合的欲望是错误的，那么人类的存在本身，不就是一个错误吗？</p>
<p>既然，人类存在是一个错误，还修行干什么呢？</p>
<p>错误再怎么修行，也不可能成为正确。</p>
<p>所谓‘淫欲’，是一个需要界定的概念。</p>
<p>太多门外汉，认为男女交合之事=淫欲，认为但凡男女交合都是邪恶的。</p>
<p>基于这个观点，有过妻子的释迦牟尼，显然也是邪恶的。</p>
<p>世上任何一个人，都是邪恶的。</p>
<p>既然都是邪恶的，还有什么必要修行呢？</p>
<p>想一想，为什么明心之后的关卡，叫见性，而不是见道、见佛、见觉呢？</p>
<p>这个‘性’字，就是以男女交合之事为喻。</p>
<p>人们无法理解，也不懂得一字之中的奇迹密意。</p>
<p>现代人类社会，对男女交合这件事上，所施加的扭曲认知。</p>
<p>实在太多，也过于深重。</p>
<p>给你举个例子。</p>
<p>男性即使不交合，依然也会定期排精。</p>
<p>女性即使不交合，也依然会定期排卵。</p>
<p>这与交合与否本身，没有任何关系。</p>
<p>交合是一种生命运动，如此才能让人类繁衍。</p>
<p>它并不邪恶，反而极其神圣。</p>
<p>人的认知，将其罪恶化，邪恶化，贬低化。</p>
<p>正如有的人，无法面对现实，便选择去贬低、诋毁和逃避现实，也是同一个道理。</p>
<p>你明白，真正的戒是什么吗？</p>
<p>很多人只知戒除一切欲望。</p>
<p>却不知，‘戒除一切欲望’的这个欲望本身，才是最需要戒除的。</p>
<p>如此，才是真正的‘无所住’。</p>
<p>分清楚，男女交合这件事本身，是人类繁衍的需要。</p>
<p>不需戒除，也不应戒除。</p>
<p>我问你，为何不问我如何戒除排便、排尿、睡眠、吃饭、喝水、乃至于呼吸呢？</p>
<p>男女交合，也与睡眠、排泄、喝水、吃饭等事相同，是人的生理天性。</p>
<p>违背人类生理天性，便是违背自然，是违背道的意志，是后天的妄想执着。</p>
<p>如果，道不需人类的交合。</p>
<p>人类甚至不会有交合的能力，而是直接成为无性繁殖的哺乳动物。</p>
<p>男女交合能力，在人类身上也只在一定时间内存在。</p>
<p>你现在，无非是因为年轻，才需要去‘戒除’。</p>
<p>事实上，等你到达一定年纪。</p>
<p>无需你去‘戒除’，你自然会永远失去这种生殖能力，无需你的任何干涉。</p>
<p>所以，男女交合之事不需戒除。</p>
<p>淫欲，才需要戒除。</p>
<p>什么叫做淫欲？</p>
<p>比如，你有一个交往对象，或是已经结婚，依然与别的异性进行交合。</p>
<p>你明知这种交合的举动，会伤害其他人。</p>
<p>可你依然控制不住自己，去欺骗、侮辱、伤害他人。</p>
<p>去犯错，以至于犯罪。</p>
<p>这，才是淫欲。</p>
<p>又比如，你的交合欲望，不是周期性出现。</p>
<p>而是天天出现，时刻出现。</p>
<p>任何一名吸引力你的异性，都会让你几乎失去控制。</p>
<p>这也是，淫欲。</p>
<p>淫欲，不是自然欲望的表达，而是一种被认知扭曲的肉体欲望。</p>
<p>你试图通过交合这件事，来逃避人生中的某种痛苦。</p>
<p>因此，选择沉迷于这件事之中。</p>
<p>与一个人沉迷于游戏、喝酒、赌博、暴饮暴食等等行为，没有任何区别。</p>
<p>是为了逃避自己本该面对的现实。</p>
<p>不是交合这件事邪恶，而是你将自己内心的邪恶，投射到男女交合这件事上。</p>
<p>男女交合，阴阳结合，生命诞生。</p>
<p>本是一件无比神圣的事。</p>
<p>本是一个奇迹降临，在生命诞生瞬间，能够一瞥道之宏伟的神圣瞬间。</p>
<p>也是人类的，最后一根救命稻草。</p>
<p>就像，不是戒除烦恼而得智慧；而是因为有烦恼，才有智慧产生的土壤。</p>
<p>毕竟，总不能因为盆里的洗澡水太脏。</p>
<p>就把孩子与洗澡水，一起泼出去吧？</p>
<p>达摩祖师于《血脉论》中有云：</p>
<p><strong>佛不诵经，佛不持戒，佛不犯戒，佛无持犯，亦不造善恶。</strong></p>
<p><strong>若欲觅佛，须是见性。</strong></p>
<p><strong>见性即是佛，若不见性，念佛、诵经、持斋、持戒亦无益处。</strong></p>
<p>所以，佛无持犯，佛无持颂，佛无所住，故见性为佛。</p>
<p>其实，很多东西发展到今天。</p>
<p>早已和最初那位的本意，相去甚远。</p>
<p>和你举个实际例子：</p>
<p>释迦牟尼在世时期，严禁偶像崇拜，严禁烧香、拜泥土偶像、持咒等等，也不认可任何苦行能导向智慧。</p>
<p>当时，全是印度‘婆罗门’盛行的各种宗教崇拜仪式。</p>
<p>苦行包括通过静定而得禅乐，是‘沙门’所盛行的修行方式。</p>
<p>当时的印度的‘沙门’。</p>
<p>即现在‘和尚’的前身，也是释迦牟尼修行期间，拜师学习的派系。</p>
<p>‘沙门’是与‘婆罗门’割裂，独立出的派系，与强调血统的婆罗门强烈对立。</p>
<p>‘沙门’兼收并蓄，舍弃人生中的一切外在、包括父母、亲人等等，做出种种苦行，只为寻求最终的真理、觉悟以及智慧。</p>
<p>释迦牟尼虽是沙门出身。</p>
<p>他连‘沙门’中的很多东西，也有提出反对说法。</p>
<p>更何况，是与‘沙门’对立的‘婆罗门’呢？</p>
<p>那个时期的印度，婆罗门是‘外道’。</p>
<p>是经书中被降服的‘对象’。</p>
<p>而你现在环顾四周，进入任何一间寺庙。</p>
<p>人们首先做的，是什么？</p>
<p>正在拜的，是什么？</p>
<p>高坐殿堂之上的，又是什么？</p>
<p>细思恐极，不是吗？</p>
<p>微笑~</p>
<h1 id="问：-4"><a href="#问：-4" class="headerlink" title="问："></a>问：</h1><p><em><strong>一定要有过痛苦的经历才有觉悟的决心吗？才有觉悟的可能吗？我没有经历过多大的痛苦，每天过得还行，不算快乐，但也没多大烦恼，就是普普通通的，家庭一般，父母也常常有鸡毛蒜皮的矛盾，读书求学虽然不是很优秀，但我也满足了，我时常感恩家庭完整，爷爷奶奶，外公外婆健在，我的家庭虽然不是很富裕，但能让我想吃什么吃什么，我也时常感恩党，感谢党让我们的生活变得这么好。最近我看群里的消息，我发现自己有我慢，对待周围的同学的态度不够友好，不够打开自己的内心，原来我一直认为自己与同学们不一样，我无意识地觉得自己气度不凡，内心上与别人疏远，俗称高冷，因此我也经常感到痛苦，我为什么融入不到他们，他们为什么这么冷落我，为什么我找不到女朋友，原来是我的问题。我打算慢慢解决自己的我慢，打开自己的心扉，发现更多无意识。</strong></em></p>
<p>答：如果你没有被别人冷落过，你就不会觉明白痛苦。</p>
<p>不痛苦，就不会寻求答案。</p>
<p>也不会像现在这样，认识到自己的傲慢，认识到别人不认可自己，不一定是别人的问题。</p>
<p>更可能，是你自己的问题。</p>
<p>你在别人与自己之间，划分出高低优劣的区别。</p>
<p>自认比别人高的你，又因为别人的不认可，而生出痛苦难过。</p>
<p>问题，在于内心深处的自卑。</p>
<p>自卑的人，才会需要别人的认可。</p>
<p>自卑的人，才会试图通过在思想中贬低他人，从而收获自己的优越感。</p>
<p>认识到自己和别人的一样，承认自己和别人的一样。</p>
<p>才是你真正开始，和别人不一样的起点。</p>
<p>因为，无论嘴上怎么说。</p>
<p>实际上，每个人都与你一样。</p>
<p>总在无意识的，认为自己和别人不一样。</p>
<p>觉悟，也是同理。</p>
<p>一切都是相应的。</p>
<p>生命的实相，超过人类的想象。</p>
<p>不必着急去找寻觉悟，先找到生命的意义。</p>
<p>踏踏实实，把人生过好。</p>
<p>就是，最好的修行。</p>
<h1 id="问：-5"><a href="#问：-5" class="headerlink" title="问："></a>问：</h1><p><em><strong>您的引路人是谁？他发大愿心，舍己为人，是一种什么样的状态？我很向往，可以学习吗？</strong></em></p>
<p>答：引路人体制内，身份敏感，不适合在这里提。</p>
<p>当时，他在明心前，练习四念住的阶段。</p>
<p>一段时间后，忽然心中起愿。</p>
<p>认识到自己无比的渺小，觉得自己只需要像天道下的一粒小石子般，默默无闻的去奉献，就已经足够。</p>
<p>具体的愿，我的记忆力一向不好，不太记得了。</p>
<p>总之，起愿之后。</p>
<p>第二天清晨，他便越过明心，直下见性。</p>
<p>说起来，这是一件很奇妙的事。</p>
<p>当人处在极致的痛苦之中，极致的黑暗之中，极致的迷茫之中。</p>
<p>却因为心中善良，因为那份甘愿舍弃一切而寻求答案的无上决心。</p>
<p>一刹那间，全然忘却自己的存在。</p>
<p>自然升起了，回向他人的愿望。</p>
<p>也是那一刹那。</p>
<p>道便将这人，深深拥入怀中。</p>
<p>引领着他，不可避免的，走向觉悟。</p>
<p>正所谓，感天动地。</p>
<p>真实不虚。</p>
<p>愿，是无法向他人学习的。</p>
<p>每个人都有独一无二的愿，无需强求自己，去走他人的道路。</p>
<p>你学不来，也学不会。</p>
<p>某些人学菩萨学佛乱发宏愿，是没有意义的。</p>
<p>愿不是这样的发的，愿也不是别人能给你或教给你的。</p>
<p>愿需要时机，需要一个多次轮转的灵魂。</p>
<p>从灵魂深处，自然生发而出。</p>
<p>容不得一丝虚假，容不得一丝不真。</p>
<p>所以，不必强求。</p>
<p>没到时机，过好眼前，就已足够。</p>
<p>如果，你天生对物质世界的一切，没有任何强烈的愿望。</p>
<p>对于物质成功、成为人上人、明星、伟人等等，都感到无聊。</p>
<p>说明，你的灵魂已来到恰当的时机。</p>
<p>去深思，你生命的意义，到底是什么？</p>
<p>去找到这个问题的答案。</p>
<p>真正找到时。</p>
<p>愿，自然会出现的。</p>
<hr>
<p>关注公众号‘自愈之光’，加入交流群。</p>
<p>即可向我免费提问。</p>
]]></content>
      <categories>
        <category>灵天赐</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>天赐问答10</title>
    <url>/2021/04/23/2120-answer10/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/14/2111-answer1/">天赐问答1: 知行合一, 方为真知.</a></li>
<li><a href="https://draapho.github.io/2021/04/15/2112-answer2/">天赐问答2: 总是拖延, 该怎么办?</a></li>
<li><a href="https://draapho.github.io/2021/04/16/2113-answer3/">天赐问答3: 凡夫一向动, 小乘一向静</a></li>
<li><a href="https://draapho.github.io/2021/04/17/2114-answer4/">天赐问答4: 烦恼名众生, 悟解名菩提</a></li>
<li><a href="https://draapho.github.io/2021/04/18/2115-answer5/">天赐问答5: 如何放下对结果的期待</a></li>
<li><a href="https://draapho.github.io/2021/04/19/2116-answer6/">天赐问答6: 为什么真正的境界不会退转?</a></li>
<li><a href="https://draapho.github.io/2021/04/20/2117-answer7/">天赐问答7: 为什么开悟的似乎都是男人, 女人呢?</a></li>
<li><a href="https://draapho.github.io/2021/04/21/2118-answer8/">天赐问答8: 男女欲望该怎么处理?</a></li>
<li><a href="https://draapho.github.io/2021/04/22/2119-answer9/">天赐问答9: 不完美, 才会独一无二</a></li>
<li><a href="https://draapho.github.io/2021/04/23/2120-answer10/">天赐问答10: 不要辜负你的生命</a></li>
<li><a href="https://draapho.github.io/2021/04/24/2121-answer11/">天赐问答11: 100多年前的马克思主义, 过时了吗?</a></li>
<li><a href="https://draapho.github.io/2021/04/25/2122-believe/">我们到底该信什么，不该信什么？</a></li>
</ul>
<p>以上所有内容, 皆转载自微信公众号: 自愈之光<br>此系列为灵天赐入道开悟后的资料收集.</p>
<hr>
<h1 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h1><p><em><strong>天赐哥哥，我是一名医学生，在做实验时我们会对实验动物做很多残忍的事情，我感到有些不适。但是很多人都对此习以为常，让我怀疑是我太矫情了。并且我无法看清楚自己的内心，我不知道我感到不舒服，是不是因为我内心深处怕自己做不好实验所以想逃避，是不是因为我想给自己立一个善良的人设等等。总之，我的内心很冲突，我不知道该怎么对待自己的感受，怎么做出正确的行为。请天赐哥哥教我。</strong></em></p>
<p>答：回溯自己的内心，问一问自己，当初为什么选择成为医学生？</p>
<p>如果，不明白自己选择背后的动机，选择背后的意义。</p>
<p>你就会，被眼前的情景所困。</p>
<p>医学生需要做动物实验，没什么问题。</p>
<p>毕竟，野生动物在野外被食肉动物捕杀，最后被一口口的活活咬死，也是一种残忍。</p>
<p>而这样的残忍，也比不上小鸡生下来便就被切掉鸡喙，放入转身都困难的养殖集中营里，每日投食各种激素与毒物，缩短一大半的生长周期后，再断绝其生育权，使其在牢房中整日产蛋，或将其屠宰，让它们终其一生见不到真正的阳光。</p>
<p>这样的残忍，也远比不上将熊或是鹅关在牢中，用特殊手段催肥鹅肝或是熊胆，最后将其取出，再任由其自生自灭。</p>
<p>这样的残忍，也比不上向自然界中疯狂投毒排污，向海洋之中投放各类难以降解的塑料产品，让动物幼崽还未出生便胎死腹中，让各种植物与动物大面积的种族灭绝。</p>
<p>处于拜物主义统治下的人类社会，不懂得如何与动物、植物以及自然界形成良好的共生关系。</p>
<p>继续这样下去，无非是周围的生态不断恶化，最终失去生态支撑的人类，走向灭亡而已。</p>
<p>比如，目前的蔓延全球的病毒，也只是因为过多的野生动物被大批量的种族灭绝。</p>
<p>失去寄宿体的病毒，为了继续生存下去，开始自行进化突变，以寻找新的寄宿生命。</p>
<p>曾经，人们面对各种动物，每天在以多少的数量被种族灭绝的新闻时，似乎觉得就算生态奔溃应该也是多少年以后的事情。</p>
<p>是后代要操心的事，与自己无关。</p>
<p>直到被病毒开始突变，被困在家中没法出门，上街也要时时刻刻戴口罩时，才开始明白，自己与自然界，真是一个不可分割的整体。</p>
<p>你知道吗？</p>
<p>有的原始社会中，原始人能与被他们猎食的动物之间，保持良好沟通关系，彼此和谐共存。</p>
<p>为什么，被吃掉的动物，能与吃他们的人类，保持良好的意识沟通呢？</p>
<p>生命的奥秘，远超人类的狭隘想象。</p>
<p>回归你的初心，想想，你为什么而学医。</p>
<p>看似眼前少杀了几个动物，可你的日常生活中，因你的直接行为、间接行为、无意识行为而死得更惨的无数大大小小的生命，你甚至都不知道。</p>
<p>减少对塑料的使用，少点外卖，支持那些生态、环保、可持续发展的企业的产品，购买那些真正为动物生存环境而考虑的产品，淘汰那些动物集中营的劣质激素类肉制品。</p>
<p>动物和自然，会感谢你的。</p>
<p>一个个点滴的细微举动，对地球上动物们所带来的救赎意义，远比拯救几只专门实验用培养动物所带来的影响，要大得多。</p>
<p>因为，你所拯救的不止是地球和未来，也在拯救自己的健康和未来。</p>
<h1 id="问：-1"><a href="#问：-1" class="headerlink" title="问："></a>问：</h1><p><em><strong>天赐您好，我想问爱情的本质是什么，为什么爱情总让人获得短暂幸福，又带来痛苦，在爱情中，如何更好的修行，如何更好的在这段关系中成就自我，而不是迷失自我，真正的爱一个人，那是一种怎么样的状态，如何去做到发自内心的真正的爱一个人呢？</strong></em></p>
<p>答：爱情关系中，你一开始的出发点，就是这段关系的最终结局。</p>
<p>如果，你走向爱情的原因，是因为你渴望别人爱你；</p>
<p>那么，最终你会因为别人无法以你所期待的强度和方式来爱你，而不幸告终。</p>
<p>如果，你走向爱情的原因，是因为渴望逃离孤独的感觉；</p>
<p>那么，你最终会因为别人无法以你所期待的强度和方式来爱你，而不幸告终。</p>
<p>如果，你走向爱情的原因，是因为渴望别人能真正了解你；</p>
<p>那么，你最终会因为别人无法以你期待的强度和方式来了解你，而不幸告终。</p>
<p>争吵、争执、愤怒、委屈、误解等等情况，都是因为进入爱情的关系的双方，对彼此有过高的期望。</p>
<p>即使自己嘴上不说，可无意识中依然是这样表达的。</p>
<p>走向婚姻的爱情，也会因为同样的原因而不圆满。</p>
<p>丈夫或是妻子去找第三者，或是分歧冷战离婚等等，都是基于同样的原因。</p>
<p>彼此都对他人有了过高的期待，同时自己也没能满足对方的期待，对方也没能满足自己的期待。</p>
<p>真正圆满的爱情关系，是一种这样的形式呢？</p>
<p>即：</p>
<p>在无条件成为真实自己的基础上，无条件的爱对方；如果双方之中有任何一方能做到这一点，这段关系就能维持下去。</p>
<p>如果双方都能做到这一点，就是世人羡慕的神仙伴侣了。</p>
<p>没有隐瞒、没有欺骗、没有误导，只有对彼此真实无条件的接纳，已经对彼此无条件的支持。</p>
<p>无条件的爱，便代表没有‘预期‘，也代表没有‘要求’。</p>
<p>你并不期望对方活成你所希望的样子，对方也不期望你活成她所期望的样子。</p>
<p>双方都是不求回报的付出，这就是高层次进化的意识，才能达成的人类关系。</p>
<p>这样的关系，是任何关系的最高实现形式；</p>
<p>无论这些关系是爱人关系、亲人关系、朋友关系，只要能做到这个程度，能将这份无条件的爱表达出来，就是这种关系的最高表现形式了。</p>
<p>无论性别、无论年龄、无论何种关系的形式，都能成为人类关系中最美妙的表现形式，彼此间不会产生任何问题与误解。</p>
<h1 id="问：-2"><a href="#问：-2" class="headerlink" title="问："></a>问：</h1><p><em><strong>天赐您好，关于信念—思想—情绪的反应链接，遇到的事物和情景境遇，自动进入信念根据信念系统生成感受；感受进入思想不断回荡，思想经过思维逻辑结构判断生成情绪；情绪又在思想的内心自言自语的小剧场中，不断产生回音自我增殖加强</strong></em></p>
<p><em><strong>自从观察到这一反应的结构，在整个不由自主的反应中，我非常多次试图改变重塑整个信念系统，但每次都只能在最后的内心自言自语的小剧场，不断回音加强的阶段介入，阻止情绪彻底失控，即使深入到思维逻辑这一层，明白这次整个逻辑的运转过程，也只能在这一次中阻断整个反应的后续的自我加强，不过绝大部分时候情绪仍然会自我回音增生；当我想要重修这些思维逻辑判断的时候，发现逻辑是一种既定的程序，是不断被产生的产物，想从这里解决问题，就像是在一个永恒的秋季扫落叶，树上永远在产生新的枯叶，永远扫不完</strong></em></p>
<p><em><strong>当我想要更深入，从信念系统入手，从影响烈度更低和永恒秋季着手打断整个循环，很快发现绝大多数信念，是童年幼年时期的经历体验直接的具现化，剩下的信念，也大多是基于这些经历体验具现化的信念影响下的 经历体验再度具现化的产物</strong></em></p>
<p><em><strong>灰暗的体验占据了大多数，整个自动反应运转了这么多年，挤压积累下的情绪已经碰不得了，试图触动这部分的信念，还没触及到信念，情绪的能量先在体内暴动，整个身体虽然没有任何外力作用，却僵住不能动</strong></em></p>
<p><em><strong>这部分信念系统究竟要如何触及改变？</strong></em></p>
<p>答：因为，方式错了。</p>
<p>道家讲“清净无为”，佛家讲“戒定慧”。</p>
<p>本质上，因为你站在‘错误世界’的国土之上，那么你做什么都是错误的，你试图修建任何东西，都只是为这片‘错误世界’添砖加瓦。</p>
<p>所以，怎么办呢？怎么改变呢？</p>
<p>很简单，什么都不做，就可以了。</p>
<p>有所求，便会希翼；</p>
<p>有希翼，便会期待；</p>
<p>有期待，便会失望；</p>
<p>有失望，便会痛苦。</p>
<p>这些，就是将你困住的根源。</p>
<p>一棵树，秋天落叶缤纷，你一直扫，叶一直落。</p>
<p>怎么办呢？</p>
<p>默默看着树叶往下飘落。</p>
<p>明白，早晚有一天，叶子会落光的。</p>
<p>再多的叶子，终究会在深冬时节，脱落完毕。</p>
<p>那时候，就能打扫干净了。</p>
<p>人的意识，也是同理。</p>
<p>若你的心树上的烦恼叶，还未到时节。</p>
<p>那么，无论你怎样打扫，也是毫无意义的。</p>
<p>所以，才要练习观察。</p>
<p>你越试图做点什么，越是在给树上增加名为‘烦恼’的叶子。</p>
<p>停下来，静静的看着，不需要更多了。</p>
<p>如果，你学会不要干涉它们，只是如实的观察它们。</p>
<p>就会逐渐发现。</p>
<p>你，不是它们。</p>
<p>落叶也好，树木也罢；打扫也好，记忆也罢。</p>
<p>一切，都是你信以为真的幻觉。</p>
<p>你在幻觉之中打扫，当然永远不会有任何作用。</p>
<p>认出幻觉的瞬间，你就出来了。</p>
<p>你，无法看见你所是的。</p>
<p>你，永远只能看见你所不是的。</p>
<p>对于过去，直面，并且观察；</p>
<p>对于未来，直面，并且观察；</p>
<p>对于当下，直面，并且观察。</p>
<p>不需要更多了，就这样，就足够了。</p>
<p>总觉得不够，总觉得要做点什么才可以，总觉得要‘努力’折腾才可以。</p>
<p>这些，都是妄想。</p>
<h1 id="问：-3"><a href="#问：-3" class="headerlink" title="问："></a>问：</h1><p><em><strong>赐大哥，有一个问题困扰我十几年了，就是容易想入非非，总是幻想自己很厉害，但从初中开始就开始幻想别人如何伤害我，即使很痛苦，也觉得很爽，越想越带劲，想陷入这种幻想中。很难控制，我这是什么问题。</strong></em></p>
<p><em><strong>我记得第一次用这种痛苦惩罚自己就是很小的时候父母吵架的时候。</strong></em></p>
<p><em><strong>上次你说这是童年问题。</strong></em></p>
<p><em><strong>我小时候的话一直很胆小，很害羞，虽然成绩还好，但处理事情的能力真的很弱。当然也有自己自信的地方。</strong></em></p>
<p><em><strong>如果是童年问题，我该怎么顺着这个方向去解决自己的问题。</strong></em></p>
<p>答：这个问题，和上一个问题是一样的。</p>
<p>直面，观察它们。</p>
<p>对你个人，建议你可以选择去不断回忆每一次童年的痛苦，去与记忆中的那个孩子待在一起。</p>
<p>安慰、安抚、鼓励，告诉那个孩子，没有关系，都不是你的错。</p>
<p>告诉那个孩子，没有关系，一切都可以原谅。</p>
<p>告诉那个孩子，没有关系，一切都会变得更好。</p>
<p>与其待在一起，将那些沉积的情绪，全部变成眼泪释放出来。</p>
<p>抱住自己，安慰自己，鼓励自己。</p>
<p>告诉自己，自己值得世上的一切美好，不需要任何惩罚。</p>
<p>这样，就足够了。</p>
<h1 id="问：-4"><a href="#问：-4" class="headerlink" title="问："></a>问：</h1><p><em><strong>天赐老师我想知道怎么才能清心寡欲，圣人说过食色性也，但我还在读书感觉这些东西非常干扰我的心绪，再加上内心积累的一些负面回忆时不时跳出来阻拦自己，每天觉得就像生活在垃圾场里一样！我就想在保证生存的前提下彻底灭绝欲望像梭罗那样过清心寡欲的生活，非常厌恶人间！</strong></em></p>
<p>答：欲望没什么糟糕的，欲望让你活在这个世界，使你体验七情六欲、喜怒哀乐。</p>
<p>就像你肚子饿了，就想吃东西；</p>
<p>口渴了，就想喝水。</p>
<p>这些东西并不邪恶，也不污秽；</p>
<p>真正邪恶与污秽的，是你的心，你的自我。</p>
<p>你的自我，带上有色眼镜来看待一切，以欲望的名义来逃避过去，逃避不愿面对的痛苦。</p>
<p>你逃避痛苦的瞬间，也就逃避了自己的成长。</p>
<p>并不是你像梭罗那样生活了，就能清心寡欲；</p>
<p>而是你清心寡欲了，才能做到像梭罗那样生活。</p>
<p>你的认知完全基于外界得来的信息，又自以为绝对正确。</p>
<p>然后，将这些东西视为绝对真理，并以此来推理、判断、认知整个外部世界。</p>
<p>这就是你烦恼的升起处，建立在你不自知的错误认知上。</p>
<p>又怎能，收获内心的和谐与宁静？</p>
<p>直面欲望，直面回忆，直面过去；</p>
<p>宽容自己，接纳自己，原谅自己。</p>
<p>然后，你才有资格改变自己。</p>
<p>改变自己，真是世界上最难的事了。</p>
<p>人，贵在自知，贵在自省。</p>
<p>人生路还长，慢慢往前走吧。</p>
<p>生活、生命、真相，和你想象的，认知的，截然不同。</p>
<h1 id="问：-5"><a href="#问：-5" class="headerlink" title="问："></a>问：</h1><p><em><strong>天赐哥哥，我想请教你一个问题，当俩个选择在眼前时，怎样知道自己做的选择是否正确，是那种很纠结的问题，也许选择错了一辈子也就那样了，如果对了就是好事。应该这样才能知道自己到底是想要那个，如何选择？</strong></em></p>
<p>答：跟随你的内心，而不是跟随你的恐惧。</p>
<p>除非你正站在楼顶边缘，正在做一道名为‘跳下去，还是不跳下去的’二选一选择题。</p>
<p>否则，不存在你说的，一辈子也就那样的情况。</p>
<p>只要你还活着一天，你就有一天的权利再做一次选择。</p>
<p>很多时候，你持续一种不变的生活，也只是因为每天都做出了同样的选择而已。</p>
<p>生命是无穷的可能性，不要活在自己的认知和头脑里。</p>
<p>每时每刻，你都在自己做出新的选择。</p>
<p>你永远不会明白，某件事真的对你好，还是对你不好；</p>
<p>有些不好的事发生在你的生命里，反而给你带来了最大的成长；</p>
<p>有些极好的事发生在你的生命里，反而给你带来了最坏的阻碍。</p>
<p>你永远不会知道的，你唯一能做的，就是放下所有恐惧。</p>
<p>跟随你内心的真实感受，选择你真正想要的。</p>
<p>只有这样，无论未来面对什么，你都不会为自己今天的选择而后悔。</p>
<p>你所想要的，永远不是最高最完美的人生，而是最好最多成长的人生。</p>
<h1 id="问：-6"><a href="#问：-6" class="headerlink" title="问："></a>问：</h1><p><em><strong>有的时候遇到一些问题，脑子里会自动出现一个声音“播放”您或者其他书里面出现过的话来指出我的问题，比如说这周又一次拖延作业，就想起上次您聊拖延症时候的内容；看着室友在玩手机不写作业脑中总是有种优越感/不满感，然后那个声音和我说“你是不是想借此凸显出自己多看了点东西就很高贵”但我自己却很难说是否有什么变化。这难道也是一种“我正处于教导之中”的错觉吗？</strong></em></p>
<p>答：这种声音，是自我的把戏。</p>
<p>自我批斗、自我批判、批判他人、批判外界。</p>
<p>唯一的目的，是将你的注意力，从当下移开。</p>
<p>记住，无论何时，无论何物；</p>
<p>你所能看见的，便已不再是你了。</p>
<p>活在当下，意味着：</p>
<p>你只有当下，除此以外，别无一物。</p>
<h1 id="问：-7"><a href="#问：-7" class="headerlink" title="问："></a>问：</h1><p><em><strong>本人住宿生，尤其是在周日晚上回宿舍的路上时候会格外想起家里人对自己的好，周中也时不时会想到“这次回去要对家里人好一点”“看看能不能解决家里的一些矛盾”，结果一回家脑子里反而基本全是手机电脑，没心思写作业，在饭桌上不顾家人反对一直在玩；家里人的话爱理不理，甚至还会产生争执。我是不是问题很大？怎么摆脱这种困境？</strong></em></p>
<p>答：先观察到自己，玩游戏的时候，观察自己为什么这么执着于玩游戏；</p>
<p>和家人争执的时候，观察到自己正在争执；</p>
<p>不想写作业的时候，观察到自己不想写作业。</p>
<p>深入的，就像一个第三者一样，如实客观的观察自己，像个陌生人一样观察自己每天的举动；</p>
<p>随着观察的深入，你会越来越察觉自己一举一动之下的荒诞以及不受控制。</p>
<p>喜欢游戏，一般是因为积累的压力没有得到宣泄，玩游戏是宣泄你压力，维持你的心理健康。</p>
<p>心理健康仅次于身体健康，学习的重要性，远比不上心理健康重要。</p>
<p>你自己可以看看新闻报道，或者听听周围的人，或者问问有经验的心理咨询师。</p>
<p>一个学生，如果心理健康出现严重问题，别说考好考坏了。</p>
<p>你书可能都没法继续读下去了，直接中途辍学。</p>
<p>同时，宣泄压力也并不是只有电脑游戏一条路径，可以考虑每周增加一次固定的运动娱乐。</p>
<p>学习，充分利用平时的时间，好好学习就可以了。</p>
<p>周六周日既然是放假，就好好休息，好好玩一下。</p>
<p>保持这种不松不紧的作息，放假也不变。</p>
<p>你的考试成绩，一般不会差的。</p>
<p>学习好坏，还贪玩不贪玩关系不大。</p>
<p>学习好坏，主要是看你学习的动机，学习的方法，学习的效率；</p>
<p>学会有意识的思考，而非停留在非对即错的二元领域去狭隘的思考问题。</p>
<p>是不是考清华北大的天赋，你自己也很清楚，没必要强求。</p>
<p>每个人的天赋，是不一样的。</p>
<p>比如，如果经过切身尝试，你清楚明白自己并没有成为世界短跑冠军的天赋；</p>
<p>那你再怎么努力，除了平添伤痛以外。</p>
<p>没有任何意义，也不会创造任何价值。</p>
<p>及时找到你的热爱与天赋，对你人生的长远意义。</p>
<p>远比读书时期的自我折磨，要重要得多。</p>
<h1 id="问：-8"><a href="#问：-8" class="headerlink" title="问："></a>问：</h1><p><em><strong>请问您的小说还更新吗？如果更的话可以给个大概时间吗？</strong></em></p>
<p>答：最近在重写和攒稿，最迟5月底之前，会看到的。</p>
<h1 id="问：-9"><a href="#问：-9" class="headerlink" title="问："></a>问：</h1><p><em><strong>天赐您好，我有时候帮助别人觉得很累，一累的时候就会产生想放弃的想法，我想知道天赐兄在明心见性前帮助别人的时候，会不会也会产生这种想法，是怎么样坚持下去的呢？</strong></em></p>
<p>答：助人是最难的事情，也是最需要智慧的。</p>
<p>智慧不足，很多问题你看不透，你也想不明白，同样你也帮不到别人。</p>
<p>不必强求完美甚至正确，只要问心无愧就好了。</p>
<p>事实上，助人本质上是帮助自己；</p>
<p>你通过无条件利益他人这件事，来提升自己的品格以至于灵魂能量。</p>
<p>越是长久善良不求回报的人。</p>
<p>生活中的运气会越好，心灵承受能力也越强大。</p>
<p>帮助别人，不要带着别人‘听你的’期待。</p>
<p>你只是表达自己，别人听不听都没有关系，做好自己就足够了。</p>
<p>之所以会累，是因为你期待自己能‘救’别人，你期待别人能完全‘听从’你的话语，这些都是痛苦的起处。</p>
<p>事实上，你没有智慧能看得出别人真正的需要，也没有智慧能够给予别人真正的需要，甚至连别人是不是真的需要，你其实也不能确定。</p>
<p>所以，放下你的期待；</p>
<p>帮助别人的意义，只在于成为你自己；</p>
<p>重要的是过程，而不是结果。</p>
<h1 id="问：-10"><a href="#问：-10" class="headerlink" title="问："></a>问：</h1><p><em><strong>天赐你好，我有很多奇怪的问题想问你，我最近陷入思维里很难走出来，首先是关于拉普拉斯妖，这个世界是否是纯物质的，物质遵循一定的运动规律，所以我们的过去未来其实早就已经注定好了呢？另一个问题是“我”究竟是什么，我只是一个寄生在某一个肉体上的意识么，这个世界只能通过我的感官呈现在我的眼前，“我”为什么是我，我存在的意义又是啥呢，偶然听说佛家开悟类似人格解体，难道开悟其实也只是一种脑内运动吗？很迷茫，求指导，不知道自己为何i以这种方式存在，也不知道该做什么，有一种对万物无所谓的逃避状态。</strong></em></p>
<p>答：因为你这些东西，都是外界看来的，别处听来的，你信以为真的东西。</p>
<p>你没有自己的东西。</p>
<p>用虚假的东西，推理虚假的东西，得出虚假的结论，进入自以为的满足。</p>
<p>这些，是不真实的思辨。</p>
<p>没有去体会绿树的芬芳，没有体会鸟儿的鸣叫，没有体会汗水侵透周身的疲惫与屹立顶峰，视野开阔，一览众山小的透彻</p>
<p>没有体会到生命的愉悦，没有体会到生命的鲜活，沉浸在认知之中，玩一种名为思辨的游戏。</p>
<p>真理，不是这样被认知的；</p>
<p>思辨的终点，是毫无意义的呓语，而非智慧与觉悟。</p>
<p>不明白什么是真实，连自己活在自以为是的虚假之中也不知道，当然活得像个行尸走肉。</p>
<p>因为，你辜负了生命，没有活出真实。</p>
<p>这样的状态，不建议学习任何理论，不建议接触任何哲学，不建议学习任何思维方式。</p>
<p>建议，多去看几部好电影，去生活里多做一些能让你感动和流泪的事情。</p>
<p>推荐电影：</p>
<p>《肖生克的救赎》、《心灵奇旅》</p>
<h1 id="问：-11"><a href="#问：-11" class="headerlink" title="问："></a>问：</h1><p><em><strong>如果当时被念头卷走了，事后再去回忆当时的心念，重新感受一下自己到底内心发生了什么，这样可以不可以？这样算不算没有活在当下？另外，我最近还使用的心法是心向内转，不假外求。日常思考我从别人身上看到的缺点、自己体会到的受伤感怎样体现了我自己的思想挂碍，这些挂碍在自己处世行为上是以怎样的形式体现出来，坚持认为自己看到他人的不足其实都是来自自己内心。反过来推己及人，我既然相信自己有纯净圆满的心，相信众生都有，所以他人的一切行为都可以理解和包容。最初用这个方法是通过一种感应或是体会。有时候再用则动用了思维理智，所以虽然时有收获，但是感觉心力有所损耗。然后我刚刚发现这似乎是第二阶段见性的向善法。不知道越过明心阶段使用这个方法是否不妥。</strong></em></p>
<p>答：你不可能回到过去，你永远只会在当下创造一种名为过去的体验，然后在里面体验‘过去’。</p>
<p>这样的‘过去’，不是真正的过去。</p>
<p>你沉浸在其中时，不仅错过了过去的‘当下’，也错过了现在的‘当下’。</p>
<p>明心到见性的方法，是消融自我。</p>
<p>以上你所说的方式，是在自我领域范畴内的妄作。</p>
<p>不存在第一阶段和第二阶段之说，第二阶段的修行在不可思议的范畴，身处自我之中的人，没有经历是完全想象不到的。</p>
<p>不必再去胡乱创造各种相，在里面钻来钻去了。</p>
<p>这些，都在助长自我。</p>
<p>踏踏实实的，练习观察；</p>
<p>除此以外，没有别的捷径可走。</p>
<p>你现在做的这些，是南辕北辙；</p>
<p>和你举个最简单的例子，你说，他人的一切行为，都可以理解与包容；</p>
<p>你真的明白，什么是理解和包容吗？</p>
<p>一个人，突然上来抢你钱包，然后顺手捅了你一刀，这一瞬，你能理解包容吗？</p>
<p>上司突然对你一顿臭骂，错在对方，而不在你，这一瞬，你能理解包容吗？</p>
<p>一个持刀歹徒，突然伤害了你的家人，面对满地尸体，这一瞬，你能理解包容吗？</p>
<p>你，真的能理解吗？</p>
<p>你，真的能包容吗？</p>
<p>不是这样的，不是你想象的这样，修行不是你想象的那样，智慧也不是。</p>
<p>所以，才叫做‘不可思议’。</p>
]]></content>
      <categories>
        <category>灵天赐</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>天赐问答11</title>
    <url>/2021/04/24/2121-answer11/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/14/2111-answer1/">天赐问答1: 知行合一, 方为真知.</a></li>
<li><a href="https://draapho.github.io/2021/04/15/2112-answer2/">天赐问答2: 总是拖延, 该怎么办?</a></li>
<li><a href="https://draapho.github.io/2021/04/16/2113-answer3/">天赐问答3: 凡夫一向动, 小乘一向静</a></li>
<li><a href="https://draapho.github.io/2021/04/17/2114-answer4/">天赐问答4: 烦恼名众生, 悟解名菩提</a></li>
<li><a href="https://draapho.github.io/2021/04/18/2115-answer5/">天赐问答5: 如何放下对结果的期待</a></li>
<li><a href="https://draapho.github.io/2021/04/19/2116-answer6/">天赐问答6: 为什么真正的境界不会退转?</a></li>
<li><a href="https://draapho.github.io/2021/04/20/2117-answer7/">天赐问答7: 为什么开悟的似乎都是男人, 女人呢?</a></li>
<li><a href="https://draapho.github.io/2021/04/21/2118-answer8/">天赐问答8: 男女欲望该怎么处理?</a></li>
<li><a href="https://draapho.github.io/2021/04/22/2119-answer9/">天赐问答9: 不完美, 才会独一无二</a></li>
<li><a href="https://draapho.github.io/2021/04/23/2120-answer10/">天赐问答10: 不要辜负你的生命</a></li>
<li><a href="https://draapho.github.io/2021/04/24/2121-answer11/">天赐问答11: 100多年前的马克思主义, 过时了吗?</a></li>
<li><a href="https://draapho.github.io/2021/04/25/2122-believe/">我们到底该信什么，不该信什么？</a></li>
</ul>
<p>以上所有内容, 皆转载自微信公众号: 自愈之光<br>此系列为灵天赐入道开悟后的资料收集.</p>
<hr>
<h1 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h1><p><em><strong>天赐你好，我想问如何找到自己的热爱呢，跟着当下的最高兴奋走，可是该怎么分辨一个想法是最高兴奋，还是所谓小我的欲望呢？关于找自己的热爱，职业规划老师讲回忆自己做的废寝忘食的很有成就感的事。我只能想到以前自己完成一项作业后发现过了好长时间的例子，但这种并不用哪件特定的事情，专心完成一件事都会有这样的成就感。我好像从小就没什么特别兴趣爱好，没有特别喜欢的明星啊娱乐运动啊。比如打球、游戏、看剧看动漫这种，平时也会做，但是长时间不做也没什么，不会像同学有空了就很想打个球或很了解动漫等等。明年就要找工作了，可是自己都不知道想做什么，没有目标，学的专业也谈不上喜不喜欢，干这行可以不干也行，我觉得试试其他的也挺好。有时候会因为这个有点愁，但也知道愁没有用，要做好当下手头的事，可是时间又真的很快，这样似乎又陷入了自我对未来的恐惧了，害怕生活的不好。但其实不去想这些的时候，自己玩耍或学习也会有很投入、开心的感觉。的想问问这种状态该如何做呢？</strong></em></p>
<p>答：兴奋就是兴奋，不是别的什么。</p>
<p>你因为太多的思虑，以至于扭曲了对现实的如实认知。</p>
<p>举个例子：</p>
<p>某天下课后，摆在你面前的有4个选择。</p>
<p>和朋友一起出去聚餐，回宿舍上网看资料，去图书馆学习看书，去网吧和舍友一起打游戏。</p>
<p>这些选择之中，只需要选择相对于其他选项，最让你兴奋的那一个就好了，哪怕只是一丁点，也坚定的选那个。</p>
<p>不要批判自己的兴奋，比如不要因为自己此刻的兴奋是去打游戏或聚餐，就觉得不好，强迫自己去图书馆学习看书。</p>
<p>你现在的阶段，不需过于在意是不是小我，因为你分辨不出来的。</p>
<p>只需要在生活中，尽可能的活得更真实就好了。</p>
<p>你现在的这些困惑，是由于你活得不真实。</p>
<p>没有留意生活中的各种微小信号，无动于衷的停留在原地。</p>
<p>直到开始面临现实的压力时，才开始慌张起来。</p>
<p>你没有明白兴奋法则的运作规律。</p>
<p>它是一种极其有效的运作法则，不必用思辨去干扰。</p>
<p>再举个例子：</p>
<p>比如，看似去网吧玩游戏是不好的，但可能正因为今天选择去网吧玩游戏，尽兴之后忽然对游戏的兴趣迅速衰减，之后就更喜欢去做其他事了；</p>
<p>又或者在玩游戏的时候，不小心看到某个视频，那个视频激起了你的强烈兴趣，让你一下找到了自己生命中真正想做的事情。</p>
<p>又或者，因为一起玩游戏，有个平时关系一般的舍友感情加深，忽然告诉你他们正在做一个很有趣的项目，问你要不要一起来做，结果你也刚好感兴趣。</p>
<p>比如，去图书馆看书学习看似是好的，但你本想玩游戏，强行抑制之后，第二天没控制住结果去网吧玩了个通宵；之后又继续被相同的选择反复困扰。</p>
<p>而在图书馆看书学习时，心也静不下来，十分毛躁，结果一晚上什么都没学到。</p>
<p>内心愧疚，做事情心情不好，然后碰见更多糟糕事；又或者，只错过了之前我提到的那些的机会，也足够致命了。</p>
<p>当然，我只是随便举例。</p>
<p>生命的可能性是无穷的，未来的可能性也是远超你的想象。</p>
<p>不要以一种你已完全知晓未来会如何演进的态度，去做任何事。</p>
<p>因为，你会发现很多事，都事与愿违。</p>
<p>必须要做到如实接纳自己内心当下的真实，跟随自己内心当下的真实，把心完全打开。</p>
<p>勇敢的去做，勇敢的去体验。</p>
<p>兴奋从不是一条笔直大道，让你直达人生最终的答案。</p>
<p>兴奋像道路上一个个的指示灯塔，不断将你引领到截然不同的方向，直到到达终点之前，你永远不知道前方等待你的是什么。</p>
<p>打开你的思维，去除旧有的观念，活出你的真实。</p>
<p>很多问题，不需要问，自己就会明白答案。</p>
<h1 id="问：-1"><a href="#问：-1" class="headerlink" title="问："></a>问：</h1><p><em><strong>天赐哥，我高中时喜欢一个女孩，但是我那时自卑恐惧，不敢面对自己的喜欢。想要远离，又忍不住自我感动，不时给她发一些奇奇怪怪的话。现在我们的关系很尴尬，又身处不同的大学，交集很少。</strong></em></p>
<p><em><strong>我觉得她的内心与我类似，也受到自卑与恐惧的困扰，我想要帮助她，我该怎么做才能让她更开心呢？</strong></em></p>
<p>答：自认为是想拯救别人。</p>
<p>其实，你没有自己所想的那么高尚。</p>
<p>你只是，想拯救曾经的自己。</p>
<p>不要将自己的意志，凌驾于他人之上。</p>
<p>学会去如实面对，诚实与他人相处。</p>
<p>你不能欺骗自己的感受，如果你对别人有什么感受。</p>
<p>不要坐在原地，试图让别人来理解你，或故布迷宫，让别人猜测你的真实想法。</p>
<p>勇敢的表达自己，同时，也允许别人做自己。</p>
<p>真诚的话语，往往充满了打动心的伟力。</p>
<p>以“为他人好”为名义，实则暗中自我抬高的话语，只会招致别人的抗拒以及对抗。</p>
<p>对别人最好的帮助，就是让自己成为活的榜样。</p>
<p>时时刻刻，做最真实的自己。</p>
<p>有时候，看似会遭遇打击。</p>
<p>出乎你意料的是，往往是这些打击，才能让你飞速进步，更快抵达人生的幸福以及圆满。</p>
<p>很多时候，你会发现。</p>
<p>如果你勇敢地向别人表达真实，你所得到的反应，往往出乎你的意料。</p>
<p>唯独用真实，才能看到真实。</p>
<p>如果用虚假，也只会看见虚假。</p>
<p>直面自己，是获得勇气的第一步。</p>
<p>先拯救你自己吧。</p>
<h1 id="问：-2"><a href="#问：-2" class="headerlink" title="问："></a>问：</h1><p><em><strong>我为什么会对自己的性别产生迷惑？</strong></em></p>
<p>答：人很多时候，总将不是问题的问题，视作问题；</p>
<p>然后，对那些更重要的问题，选择视而不见。</p>
<p>一般而言，无论生理性别如何，每个人体内都会有两种性别能量。</p>
<p>即男性能量与女性能量，这是一种意识上的区分，与生理性别关系不大。</p>
<p>每一位真正的意识大师，无论是他们，或是她们，都完成了一个十分基础课程。</p>
<p>即——体内男性能量与女性能量的平衡。</p>
<p>之所以会对性别产生疑惑，说明你体内的男性能量与女性能量出现失衡。</p>
<p>这种失衡方向，与你的生理性别，恰好相反。</p>
<p>这种情况下，能量失衡才会对你造成困扰。</p>
<p>比如，你生理上是一名男性，可体内的女性能量过强，完全压住了你的男性能量；</p>
<p>又或者，你是一名女性，可体内的男性能量过强，完全压住了你的女性能量。</p>
<p>这些，才是你困惑的起源。</p>
<p>正常情况下，性别能量不会失衡到这种程度，会失衡到这种程度。</p>
<p>说明你的认知与意识，无意识增强了这种失衡。</p>
<p>一般而言，而你的成长经历中，有的人会为了逃避某些现实压力。</p>
<p>而对另一种生理性别，寄予美好的幻想，基于不了解而产生的奇妙幻想。</p>
<p>幻想，有另一种性别状态，能让你过得比这种存在状态更好。</p>
<p>又或是，你天生更喜欢另一种性别的存在状态，下意识讨厌自己现在的性别存在状态。</p>
<p>后者的存在极为稀少，大部分人都是前者。</p>
<p>倘若追溯记忆，人们总会发现，是某些后天经历，以及他们不停强化认知所带来误解，让他们误以为，自己天生更喜欢另一种性别。</p>
<p>天生的性别失衡，涉及到一些隐秘，不适合公开讲，便略过不提。</p>
<p>但是，无论前者还是后者，尝试有意识的增强体内较弱那一方的性别能量。</p>
<p>同时，有意识探索体内较强那一方的性别能量，尝试面对与坦然接纳，都是极其有益的。</p>
<p>对那些对另一种性别怀抱美好幻想的人来说，应有意识的深刻了解另一种性别缺陷、痛苦、难处等负面信息。</p>
<p>比如，一位渴望变成女性的男性，应与一位渴望变成男性的女性做一些真诚的分享和交流。</p>
<p>对双方来说，会是一种十分有益的成长。</p>
<p>这些，都有助于个人抵达体内男性能量与女性能量的平衡点。</p>
<p>很多人不明白，在更高层面来说。</p>
<p>生理性别，是每个人出生前就已接纳的选择，而非上天给他们强塞的安排。</p>
<p>如今的科技，也未达到能真正转换性别的程度。</p>
<p>因此，不建议任何个体，去做生理上的转变手术。</p>
<p>这种转变，以极大的痛苦为代价，百害而无一利。</p>
<p>不要为了逃避一些现实的小痛苦，而去选择某种更加无法承受的大痛苦。</p>
<p>相当于从火坑里跳出，又一头钻入火海。</p>
<p>尝试接纳自己的生理性别，当你的体内性别能量，终于抵达平衡的瞬间。</p>
<p>你会从此放下对性别的纠结，选择去拥抱和探索广阔无垠的人生。</p>
<p>性别，往往只和恋爱以及社会身份相关。</p>
<p>这些，无非是物质层一些微不足道的事件。</p>
<p>在心灵内在层次，有一个更广阔的世界以及不可思议的成长之路，正在等待你的足迹。</p>
<h1 id="问：-3"><a href="#问：-3" class="headerlink" title="问："></a>问：</h1><p><em><strong>请教天赐：如果个人算命看出命中带有不可避免的灾祸，是不是生死看淡，将命运交付上天就完事了？可以纵情于享乐吗？</strong></em></p>
<p>答：请阅读，<strong>《了凡四训》</strong>。</p>
<p>问问自己，享乐是人生的终极意义吗？</p>
<p>你纵情享乐的时候，真的就达到精神巅峰，别的东西再也不需要了吗？</p>
<p>如果，一个人真的享尽五欲之好，可以无穷无尽的享受下去。</p>
<p>这个人其实很容易厌倦，并因此而陷入某种精神迷茫以及空虚中。</p>
<p>你自己想想，小时候渴望不已的零食，只希望自己每天都能卖一大堆零食从早吃到晚，就是最大的幸福。</p>
<p>长大后，有钱想吃什么零食就可以买什么零食，也没有人管自己吃多少了。</p>
<p>你看，又有多少人，依然像小时候那么疯狂的爱吃零食？</p>
<p>依然像小时候一样，怎么吃都不会厌倦？</p>
<p>所以，问题错了。</p>
<p>错误的问题，不会带来正确的答案。</p>
<p>生命的意义不是享乐。</p>
<p>所以，当然不是纵情享乐就好了。</p>
<p>假如生命的意义，只在于纵情享乐。</p>
<p>为什么有的人中了巨奖，得到一辈子花不完的钱，过了一段时间奢华无比的人生后，反而选择自杀？</p>
<p>自己深思。</p>
<p>五欲的追求是无止境的，五欲能带来的满足，终究是有限的。</p>
<p>真正的快乐，被洗脑的常人，根本想象不到。</p>
<p>比如，生来只有痛苦的众生，真的会痛苦吗？</p>
<p>不会，他们反而以苦为乐。</p>
<p>毕竟，他们从没有一天感受过：</p>
<p>什么，是真正的快乐？</p>
<h1 id="问：-4"><a href="#问：-4" class="headerlink" title="问："></a>问：</h1><p><em><strong>入道（觉醒）的人都知道时间并不存在，那么还有所谓自由意志吗？可以通过个人选择体验自己的时间线吗？</strong></em></p>
<p>答：你现在，就存在于自己所选择的时间线上。</p>
<p>每时每刻，都处于你自己选择的时间之中。</p>
<p>好了，这个问题回答完毕。</p>
<p>你懂了吗？</p>
<p>不会的，你不会理解，也不会懂的。</p>
<p>就像告诉你，E=mc²。</p>
<p>你觉得，这是什么？</p>
<p>无聊的字母和数字，又有什么意义？</p>
<p>像电磁感应现象，第一次被发现的时候，做实验展示给大家。</p>
<p>谁能想到，它将缔造未来几百年的人类社会。</p>
<p>整个现代人类社会根基——电力，就建立在几百年前，这样一个小小的线圈实验上。</p>
<p>人脑想象，以及所能认知的范畴，极其狭隘。</p>
<p>不要试图拿着一个算盘，试图计算一些尖端计算机几千万年也无法运算出来的问题。</p>
<p>因为，答案本身，就超出你的认知之外。</p>
<p>什么时候，你真正认知到了。</p>
<p>你才能提这个问题，我也才能和你讨论。</p>
<h1 id="问：-5"><a href="#问：-5" class="headerlink" title="问："></a>问：</h1><p><em><strong>你说自己坚定相信马列主义，但是毕竟是100年前的思想了，当时十分先进，可放到如今仍然完全适用吗？你相信的道就是造物主本身（神圣本源）吗？</strong></em></p>
<p>答：释迦牟尼，2500年前的思想；</p>
<p>老子，2500年前的思想；</p>
<p>耶稣，2000年前的思想；</p>
<p>庄子，2300年前的思想；</p>
<p>孔子，2500年前的思想；</p>
<p>又比如，《易经》，4000年前的思想。</p>
<p>莱布尼兹很早便从中学习，而受到启发，进而表发二进制算法的论文。</p>
<p>可以说，没有莱布尼兹，真正意义上第一台二进制计算机的诞生，不知要延后多少年。</p>
<p>现代计算机，也正是基于二进制算法而诞生。</p>
<p>未来，即使实现真正的人工智能，其最早的基础，也依然源于最初的二进制算法。</p>
<p>所以，马克思主义。</p>
<p>是马克思提出的一个猜想，也是他用一生所探索的方向。</p>
<p>马克思的创建这个思想的本意，是为了拯救人们被压榨的痛苦。</p>
<p>未来，会给人类社会带来真正绝望的。</p>
<p>不再是生产力的落后，而是未来人类社会中，整个生产力体系分配的不公。</p>
<p>随着科技的提升，个体的反抗能力将越来越微不足道。</p>
<p>而乌托邦的实现，不是依靠绝对的公平。</p>
<p>而是赋予每个人，尽情发挥天赋并实现它们的平台和机会。</p>
<p>人类社会就像一块巨大的拼图，尽管每个人类模块的形状都不一样。</p>
<p>可拼接在一起，就会彼此和谐的构成整个人类社会，最大潜力的完美蓝图。</p>
<p>因此，必须处理掉这种分配不公带来的人性压抑。</p>
<p>人类社会的未来，才不会因为可笑的战争，而摧毁掉自己稚嫩的文明。</p>
<p>这是一种极其伟大的愿心。</p>
<p>马克思一生穷困潦倒，生的六个儿女中，也只活下来三个女儿。</p>
<p>他也依然在坚持，在战斗。</p>
<p>马克思，有他自身的思维局限性。</p>
<p>马克思主义，也还是一个胚胎。</p>
<p>远远没有成为一个婴儿，真正诞生来到这个世界。</p>
<p>所以，乍看之下，他的很多东西似乎很乱。</p>
<p>这里一点，那里一点，这里一块，那里一块。</p>
<p>只是因为，胚胎正在试图发育手脚、器官、皮肤等等各种结构。</p>
<p>作为一个蕴含未来的思想。</p>
<p>它还没有真正的，从这个世上真正诞生。</p>
<p>马克思用他的生命、智慧以及直觉，留下了这个胚胎。</p>
<p>他隐隐感觉到了，这个胚胎长大成年后的样子。</p>
<p>他满怀期待，离开世间。</p>
<p>后来的人，没有理解其中的深意。</p>
<p>事实上，当前人类社会，所有指引现实的哲学思想中。</p>
<p>唯独只有马克思主义，才是整个人类社会，步入更高层次文明的唯一希望。</p>
<p>苏联的斯大林主义，不过是对马克思主义的扭曲，以及粗暴的曲解。</p>
<p>马克思主义的内涵，及其宏伟的前景蓝图。</p>
<p>当代人类，也只是隐约有所察觉，并没有真正的认知。</p>
<p>未来，等我将家里的债务处理完毕后。</p>
<p>我要做的下一件事，便是去发育马克思留下的胚胎，让它成为一个真正的婴儿，诞生在这个世界。</p>
<p>做完这件事，便是回报了人类社会对我的抚育之恩。</p>
<p>也是为什么，我是一名禅修者，同时也是一名坚定的马克思主义信奉者。</p>
]]></content>
      <categories>
        <category>灵天赐</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</title>
    <url>/2019/07/25/1909-TCM_science/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
<li><a href="https://draapho.github.io/2021/03/05/2107-tuibeitu1/">万年歌, 马前课, 梅花诗, 推背图 (上)</a></li>
<li><a href="https://draapho.github.io/2021/03/18/2108-tuibeitu2/">万年歌, 马前课, 梅花诗, 推背图 (下)</a></li>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/26/2123-caseofsatori/">见性者体验收集</a></li>
</ul>
<p><em><strong>转载自 <a href="http://bbs.tianya.cn/post-free-5088705-1.shtml">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></strong></em><br><em><strong>转载自 <a href="http://blog.sina.com.cn/s/blog_7edcb9a10102vjtm.html">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（七）连载</a></strong></em></p>
<hr>
<h1 id="好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（一）连载"><a href="#好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（一）连载" class="headerlink" title="好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（一）连载"></a>好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（一）连载</h1><p>按：正确地认识科学，是正确认识中医的第一步。</p>
<p>人是观念的动物，一旦观念僵化，就容易陷入偏执。其实科学与中医，看似是一个小话题，却实实在在检验每个人的见识和心胸。对于中医，相信绝大多数的人并不真的了解或者入门，哪怕是中医粉。但是对于科学，我们却都感觉至少这个名词很熟悉、很亲切。毕竟我们都上过高中、大学，都受过十八世纪以来西方现代科学观念的普及与熏陶，其实，这一点上大家基本一样。但是为什么有的人就能够暂且抛开这些自己熟悉的体系、观念，认真倾听讨论的另一方在说什么、如何解释；而有的人却急吼吼骂着别人文傻举起大棒？仿佛这样一“科普”自己先天就具有了与众不同明显的先进性。<br>没有人可以生而知之，同样也没有人的胸怀可以永远狭隘，因为它不过来自于视野与认识世界的角度。只是领域与视角的改变，你就会发现一个全新的世界，甚至重新建立新的世界观、科学观。这非常像潜水，哪怕是马尔代夫休闲式的浮潜——在你的头没入海水之前，你根本不知道、无法想象，在你脚踩的珊瑚石那里、在你周围翻腾的海浪下面，竟是那么一个五彩斑斓、游鱼遍布的奇异世界。对于潜水，你戴好装备、下到水里都依然不能领略，何况是在岸上。<br>是的，同样的道理，在你的身体里面、在你活生生的身体里，也有那样一个世界，一个中医的世界、中医的视角。往内看，向鲜活的身体里面感觉，它甚至是一个随时与你的心灵互为因果、相互联系、密不可分的世界。<br>怎么才能向内看？怎么才是往内感觉？这可能反而是现代人不熟悉、不好把捉的事情。因为我们太不熟悉那个视角了，自打降生以来，我们就被感官吸引，不断地向外探寻、求取。我们所熟悉、被灌输的西方科学理念，也是完全外向型指向、特长于细分的表象研究的。我们却一直迷失着那个“能够去感知外部世界的内在的源头”——一直丧失着对内在这个“能觉”之心的关注。另一方面，我们也一直被教导要思辨、思维，建立来自头脑的逻辑理性体系。却往往忽略以致最后关闭、丧失了直接用这直观的“能觉”之心去感知世界的通道。可世界的的确确分明具有着这另外一个视角，东方的视角（西方最伟大的科学家，诸如爱因斯坦、尼古拉·特斯拉都一再地谈及）。中国与印度都有这样的视角。只不过，中国在养生与医疗上发现并建立了相对更完善的体系。<br>怎么才能向内看？怎么才是往内感觉？这很有趣，充满哲学与宗教性意味，但显然，这是另一个话题。我们得一点点才能引导到对于方法的讨论。<br>因为仅仅是听到这样的提法，对于一些人来说也许已经是对于其固化观念的“冒犯”。所以，最后你会感觉这甚至是一个关于“勇气”的话题——相关于一个人有没有做好“经过这次完整的阅读旅程，某种僵化过时的科学观会土崩瓦解”的准备。<br>是的，这，最终，注定会通过“中医话题”演变成一个心灵的冒险！一个对“偏执之病根——自我”的挑战！<br>也正因于此，它升华为一个邀请，更深藏一种祝福！</p>
<p>如是，暂时放下旧有观念，重新全方位审视你心目中的科学观——正确地认识科学，是正确认识中医的第一步。<br>我们不妨从讨论科学开始，看看我们的“科学观念”是不是就早已被人动了手脚，植入了某种伪劣的病毒。<br>既然想要辨析清楚，就需要从最基础的地方讨论。当我们实打实地，按着逻辑一步步推理过去，从科学的“概念、定义、范畴、特征、方法、在人类生存中的位置、属性、真精神乃至未来”开始厘清，并且对中医重新审视，以真正科学精神的角度审视，建立起新的正确认识。这样，到了后面专门辨析的时候，只要稍作勾提与揭露，所有谬论与曲解自会在正确认知面前土崩瓦解。任何“外行无知式”的说辞或者“流氓胡搅式”的诡辩，都会不攻自破。<br>另外一点需要率先澄清的是，事实上，无论笔者将要讲到什么新颖的说法、新奇的理论它都是基于尊重客观事实这个大前提的。如果在我以及很多人的生命经历与所见闻的直接经验中，中医是完全无效的、是延续了几千年数以千万记的、纯粹的骗子集团，那这些说法就都成了包庇而不负责任的言论，那就不止是道德谴责了，请举报绳之以法。<br>需要同时再次郑重强调的是，无论对中医理论的身、心体验还是临床医疗实践，无论从药理还是病理，笔者都有一定相应切身的实证。真理不在书本的知识上，真相在你亲身的实践与体验中——这，是我敢于写作这些文章的最大前提。</p>
<p>是的，我们必须先说科学，再解中医，先耐心看清科学以及科学精神的实质，甚至搞清科学与哲学、宗教乃至艺术等的关系，了解它在人类生存生活中的层面与位置，才能正式地引入中医，看它处于什么样的位置和高度，进而再最后讨论中医到底是不是科学？中医究竟有多大价值？<br>为了正确地认识科学，我们将着重阐述这些命题——<br>科学到底是什么？<br>科学在不断发展中<br>科学不是万能的<br>科学的位置<br>科学没有代言人<br>什么才是真正的科学精神<br>……</p>
<p>部分前期目录下：<br>第一章：科学到底是什么？<br>引言——从《批评中医》的“混淆”到科学概念的混乱</p>
<p>1，西方科学的发展过程<br>2，科学的定义<br>3，“科学”一词的由来<br>4，科学的分类<br>5，从经典的科学方法看——中华文明独特的数理逻辑与整体观的科学理念</p>
<h1 id="好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（二）连载"><a href="#好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（二）连载" class="headerlink" title="好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（二）连载"></a>好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（二）连载</h1><p>在过去关于中医的网络辩论中，经常会看到一些回复中值得商榷的“科学观”。说实在的，正是一些空喊口号不认真求实的做法刺激了笔者这么个较真的人。于是，我认真去查找资料、还原历史、还原定义，就从科学的最本真朴素的地方开始辨析——</p>
<h2 id="先行公布接下来一些内容的目录："><a href="#先行公布接下来一些内容的目录：" class="headerlink" title="先行公布接下来一些内容的目录："></a>先行公布接下来一些内容的目录：</h2><p>  第一章：科学到底是什么？<br>  引言——从《批评中医》的混淆到科学概念的混乱<br>  （1）《批评中医》曲解爱因斯坦以偷换概念，混淆对科学的正确认知。<br>  （2）《批评中医》篡改李约瑟原话以否定中国科学史、否定中医<br>  （3）爱因斯坦与李约瑟共通的科学史观<br>  正文：<br>  1，西方科学的发展过程<br>  2，科学的定义<br>  3，“科学”一词的由来<br>  4，科学的分类<br>  5，从经典的科学方法看——中华文明独特的数理逻辑与整体观的科学理念<br>  6，“中华文明密码”河图洛书中的数字震撼</p>
<p>  屡经大量水军来骂的“战斗”，真不想触及方舟子《批评中医》这个公认的“雷区”，可是当我们真要严肃正式地讨论“中医的科学问题”，你还就无法回避，因为如果细心观察会发现，很多人关于科学与中医的错误观念都源出于此，几乎所有后来的洗脑文本都仿照这个写就。那么好吧，既然绕不开，我们就单刀直入，看看这种科普在“普”什么？只是分析其开头区区三百字，三篇下来，相信每一个诚实的科普人也会触目惊心——</p>
<p>  引言——从《批评中医》的“混淆”到科学概念的混乱</p>
<h2 id="（1）《批评中医》曲解爱因斯坦以偷换概念，混淆对科学的正确认知。"><a href="#（1）《批评中医》曲解爱因斯坦以偷换概念，混淆对科学的正确认知。" class="headerlink" title="（1）《批评中医》曲解爱因斯坦以偷换概念，混淆对科学的正确认知。"></a>（1）《批评中医》曲解爱因斯坦以偷换概念，混淆对科学的正确认知。</h2><p>  在公开反对中医的书籍中最著名的一本是《批评中医》，很多“中医黑”的论调都是以这个为蓝本的。而此书作者方舟子先生为了批判中医也确实可以说是字里行间煞费苦心，从每一句话、从第一句话开始就有让人意想不到的“神来之笔”——</p>
<p>  此书开篇《中医学不是科学》的第一句话，为混淆科学的概念以彻底否定中医，方氏就先假意主打一个“现代科学”的概念——<br>  “现代科学的源头来自古希腊的自然哲学，是在欧洲文艺复兴时期诞生、发展起来，然后向全世界传播的。”</p>
<p>  这句话完全正确，没有任何问题，但方氏接下来一句却迅速切换、直接把“现代科学”偷换概念成“科学”一词——<br>  “古代中国也有灿烂的文明，某些技术发明甚至长期领先西方，但是为什么科学没有在中国诞生呢？”</p>
<p>  而如果严格承接两句上下文意，本来分明应该是——为什么“现代科学”没有在中国诞生？<br>  他却落脚在了——为什么“科学”没有在中国诞生？</p>
<p>  看到这里，也许读者您会问——难道“科学”不是就特指“现代科学”吗？<br>  当然不是！看完这一章就会真相大白——这是一个一直被“有意无意”混淆的概念。<br>  就如这里，两句文意一交接间，已经神不知鬼不觉完成切换，混淆了“科学”与“现代科学”的概念。<br>  作为资深的所谓科普作家，对于科学的真正含义与渊源不可能不知道，故意偷换与混淆只有一种解释——泼脏水，为后面否定“中医是科学”埋下伏笔。</p>
<p>  且看《批评中医》接下来的原文，我们继续分析，请读者诸君明辨——<br>  “伟大的物理学家爱因斯坦在一封信中回答说：西方科学的发展是以两个伟大的成就为基础的：希腊哲学家（在欧几里得几何学中）发明了形式逻辑体系，以及（在文艺复兴时期）发现通过系统的实验有可能找出因果关系。”</p>
<p>  在这段话里，方氏拉大旗作虎皮，假意引述爱因斯坦的话，实际上却在随后的引申中瞒天过海故意曲解文意，还是像上面似的，把爱因斯坦原意中“西方科学的发展”直接在自己接下来的结论中篡改成了“科学的起源”，请看他书中的原话——<br>  “也就是说，爱因斯坦认为‘科学的起源’是个不平常的事件，因此不必对‘古代中国没有出现科学’而惊讶。”</p>
<blockquote>
<p>（附爱因斯坦原文：“The development of Western science has been based on two great achievements, the invention of the formal system (in Euclidieam geometry) by the Gree philosophers and the discovery of the possibility of finding out causal relationships by systematic experiment (at the renaissance ) in my opinion one need not be astonished that the Chinese sages did not make these steps. The astonishing thing is that these discoveries were made at all”</p>
</blockquote>
<p>  而这显然与爱因斯坦的原意严重不符——<br>  爱因斯坦的语意着重在“发展”，指的是——原有科学大发展，然后“现代科学的诞生”是不平常的；<br>  方舟子则将其篡改成“科学的起源”——意味着“整个科学的诞生”都是在西方的那两个背景下。<br>  而这所有的篡改与偷换概念，都是为了那最后一句服务的——“中国古代没有出现科学”。</p>
<p>  如此，他只要假借爱因斯坦的权威之口让读者产生“整个科学都是爱因斯坦那时才出现”的幻觉，就可以将中医“黑”在科学出现之前，于是，便可“顺理成章”推出他文章中后面两句话——<br>  “中医作为中国古代的文化的一部分，其诞生的时间远在科学之前。”<br>  “既然中医理论体系远在人类有科学之前就已确立，那么中医学不是科学，本是很自然的事。”</p>
<p>  可是爱因斯坦的原意显然不是这样。按照逻辑线，正确的说法也本应该是——<br>  “中医作为中国古代文化的一部分，其诞生的时间远在‘现代科学’之前。”<br>  “既然中医理论体系远在人类有‘现代科学’之前就已确立，那么中医学不是‘现代科学’，本是很自然的事。”</p>
<p>  也就是说，当我们证明了科学和现代科学是两个完全不同，不能混淆的概念，那些话的推论只能是中医学不是“现代科学”，而不能置换成中医学不是“科学”。<br>  后面读者了解了正确的科学史就会知道本有“古代科学”，甚至本应细分为“西方古代科学”与“中国（东方）古代科学”，中医本是中国古代科学的璀璨明珠。因此，这是绝不能混淆的概念，这也正是诽谤、抹黑中医与捍卫、正名中医的关键所在，是论证中医科学性所必须厘清的第一事实。<br>  那这么明目张胆的偷换与篡改到底为了什么目的呢？昭然若揭——就是要将中医先一棍子打成不科学、归为不科学，好为《批评中医》后面的种种外行谬论做张本。这意味着假如中医不科学了，就可以“以科学的名义”对它任意毁谤、肆意侮辱。<br>  而令人震惊的是这种偷换概念以及其他的诡辩手法在这本书中比比皆是。以至于在对《批评中医》的审阅批驳中笔者每每感叹，其实真不能怪读者心思不够细腻，实在是其“偷”得“水平高超”。这有如“就怕贼惦记”，当一个这样的“高手”就是存心要给你找毛病、栽赃、构陷，不明真相的大众被忽悠几乎就是板上钉钉的事情……</p>
<h1 id="好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（三）连载"><a href="#好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（三）连载" class="headerlink" title="好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（三）连载"></a>好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（三）连载</h1><p>引言——从《批评中医》的“混淆”到科学概念的混乱</p>
<p>（1）“《批评中医》曲解爱因斯坦以偷换概念，混淆对科学的正确认知”——见上一次连载。下面继续后文：</p>
<h2 id="（2）《批评中医》篡改李约瑟原话以否定中国科学史、否定中医"><a href="#（2）《批评中医》篡改李约瑟原话以否定中国科学史、否定中医" class="headerlink" title="（2）《批评中医》篡改李约瑟原话以否定中国科学史、否定中医"></a>（2）《批评中医》篡改李约瑟原话以否定中国科学史、否定中医</h2><p>  有意思的是，关于《批评中医》“偷换概念、曲解爱因斯坦，混淆科学认知”的文章曾经发在网上（转发上千，搜索以前微博可见），结果遭到了方舟子拥趸的强烈反弹。很多人根本不认真看文章，更没有勇气面对方篡改文意与偷换概念这些事实。只是一味地对笔者冷嘲热讽，这真的使人切身地体会到了这两句话的分量——</p>
<p>  你无法叫醒一个装睡的人！你也无法叫醒一个不愿醒来的人！</p>
<p>  好吧，我也只好再次奉上方先生在这一段接下来继续的公然篡改，以给我上面的分析做出完全的印证，使它彻底成为铁证——</p>
<p>  还记得方舟子一上来把“现代科学”偷换概念成“科学”一词的这句话吗——“古代中国也有灿烂的文明，某些技术发明甚至长期领先西方，但是为什么科学没有在中国诞生呢？”</p>
<p>  我当时分析说——就在这里他别有用心地故意混淆“科学”与“现代科学”的概念：</p>
<p>  其实应该是——为什么“现代科学”没有在中国诞生？</p>
<p>  他却落脚在了——为什么“科学”没有在中国诞生？</p>
<p>  在这里，这句话在《批评中医》中整段的原话是这样的——“古代中国也有灿烂的文明，某些技术发明甚至长期领先西方，但是为什么科学没有在中国诞生呢？这个问题是英国科技史学家李约瑟提出的，被称为‘李约瑟问题’”</p>
<p>  当时，我本着充分的信任，以为方氏引述“李约瑟的原话”总该是没问题的，就忽略了，还以为李约瑟先生也是个老糊涂，怎么会说出这种话来。可是在后续的写作中，当我为了搞清科学定义而老老实实去查阅李约瑟原话时，我又一次震惊了，看到这样的中文资料——</p>
<p>  李约瑟在《东西方的科学与社会》这篇文章一开始就说：“大约在1938年，我开始酝酿写一部系统的、客观的、权威性的专著，以论述中国文化的科学史、科学思想史、技术史及医学史。当时我注意到的重要问题是：为什么‘近代科学’只在欧洲文明中发展，而未在中国（或印度）文明中成长？”</p>
<p>  看，李约瑟不仅明确说了中国文化有“科学史、科学思想史、技术史及医学史”，原话设问更是直接问的——“为什么‘近代科学’（亦即‘现代科学’）只在欧洲文明中发展，而未在中国（或印度）文明中成长？”</p>
<p>  这段资料中翻译的‘近代科学’一词与上一节我们根据逻辑推论的“现代科学”如出一辙。更有说服力的，整个文意也与爱因斯坦说的完全一致。真可谓英雄所见略同。</p>
<p>  为谨慎起见，再进一步就此检阅一些资讯，更是“铁证如山”——</p>
<p>  看到李约瑟介绍中国古代的科技成就最知名的著作是《中国科学技术史》，英文：Science and Civilisation in China , 直译的话就是：中国的科学和文明。</p>
<p>  显然介绍的是中国古代的科学与技术——科学古已有之。</p>
<p>  怎么方先生居然篡改出了“为什么科学没有在中国诞生”是所谓的“李约瑟问题”？</p>
<p>  再顺着线索，细查原文，实际上，相关“李约瑟问题”的两处原文表达如下：</p>
<blockquote>
<p>So the question he asked was this: “Why, given china’s amazing technological achievements, did the Chinese fail to develop modern science ?”<br>  译文：于是，他提出一个问题：“为什么中国取得如此令人惊叹的技术成就，却没有诞生出现代科学？”<br>Why did modern science develop in Europe when China seemed so much better placed to achieve it. This is called the Needham question .<br>  译文：为什么当时中国似乎处于取得这一成就更加有利的位置，而现代科学却在欧洲（而不是在中国）诞生？这个问题被称为“李约瑟问题”。</p>
</blockquote>
<p>  请列位看官注意，清清楚楚、明明白白，“李约瑟问题”是——“为什么‘现代科学’没有在中国诞生？</p>
<p>  而不是——方舟子光天化日下的“造假”——“为什么‘科学’没有在中国诞生？”</p>
<p>  与我们上一节的推论也完全相同——科学与现代科学是两个完全不同的概念。混淆者要么出于无知，要么别有用心！试问这位曾经以“打假”而甚嚣尘上的“科普工作者”属于哪一种？</p>
<h2 id="（3）爱因斯坦与李约瑟共通的科学史观"><a href="#（3）爱因斯坦与李约瑟共通的科学史观" class="headerlink" title="（3）爱因斯坦与李约瑟共通的科学史观"></a>（3）爱因斯坦与李约瑟共通的科学史观</h2><p>  那么，为了彻底反衬出方舟子的篡改，也为了下面对科学发展史的介绍更明晰，我们按爱因斯坦与李约瑟的原意梳理出一个清晰思路——</p>
<p>  爱因斯坦认为（古已有之的）“科学”，得以在文艺复兴时期获得极大的发展，乃至最终催生出了观念和实践都大大跃进的“现代科学”。而这种发展源于两个伟大的成就——古希腊时期的“形式逻辑”与文艺复兴时期的“系统实验”这两个基础。这就明确地显示出他的科学史观是承认在西方“现代科学”之前实际上“科学”早已存在，即存在“古代科学”，比如说“古希腊欧几里得几何学”及其“形式逻辑”。</p>
<p>  李约瑟则基于对中国古文明与西方现代科学的高度认识，更进一步，肯定并提出了“中国古代科学”——抑或说古代“东方科学”的概念。并进而藉此提出著名的“李约瑟问题”——为什么真正意义上的“现代科学”没有在中国——这个十七世纪前“科学”本来很发达的国度产生？</p>
<p>  综上可见，爱因斯坦与李约瑟在“科学”与“现代科学”这涉及整个科学概念与科学史观的问题上认识相同。与实际的科学发展史也完全相符。</p>
<p>  而方氏则既故意偷换、曲解、混淆了爱氏关于科学认知的概念，更对李约瑟的话直接篡改。</p>
<p>  是的，尽管爱因斯坦与李约瑟是顶级的科学家和博古通今的学者，对科学的理解有着超乎常人的深刻，也完全符合科学史的实际。但是，任何人，不止方先生，也依然都有权对此保留看法。不过，假如一个人不认同他们的观点却故意篡改、曲解他们的原意，然后还要借用他们的名声做大旗忽悠公众，就不知道应该归纳为一种什么行径了？对于诚信、对于科学精神又是一种什么态度呢？</p>
<p>  爱因斯坦和李约瑟虽然早已过世，可无数双活人的眼睛注视着！</p>
<p>  对爱恩斯坦、李约瑟的歪曲与造假，更是对他们声誉的公然玷污与践踏！而这么做无非是想借他们之口，以证明“古代中国没有科学”，进而把中医污蔑为“伪科学”！<br>  证据确凿，文理俱在。作为一个一度博取大众信任的“打假英雄”如此这般，如果不是亲眼所见，白纸黑字，笔者真不敢也不愿相信。</p>
<h1 id="好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（四）连载——科学的准确定义"><a href="#好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（四）连载——科学的准确定义" class="headerlink" title="好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（四）连载——科学的准确定义"></a>好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（四）连载——科学的准确定义</h1><h2 id="1，西方科学的发展过程"><a href="#1，西方科学的发展过程" class="headerlink" title="1，西方科学的发展过程"></a>1，西方科学的发展过程</h2><p>  也正是那些对于“科学”与“现代科学”概念上“有意无意”的混淆，以及对于中国古代科学观念与成就的不了解，造成人们大量观念上的含混错乱，最终导致对中医科学性的困惑。这一章将追本溯源，厘清概念、廓清认识。</p>
<p>  我们的探讨方式是先以西方概念的科学为对象，看看它发展的过程，再回看“科学的概念”，以及它最初传入中国时的原意。接着探讨“科学的分类”，这样从理念上就可以确定中医属不属于科学。</p>
<p>  之后，我们再从科学的特征和方法论上一点点鉴别。</p>
<p>  而中医到底是不是科学？它在科学中的位置如何？又是否高超？也自会随之明了。</p>
<p>  下面先从西方科学的发展史开始，看看正统西方科学概念经历的三个阶段：</p>
<p>  第一阶段是古希腊时期。</p>
<p>  第二阶段是文艺复兴时期。</p>
<p>  第三阶段是工业革命时期。</p>
<p>  公认的工业革命到现在为止又分为三次。</p>
<p>  整个的具体过程是这样的——</p>
<p>  古希腊的科学原是指分科研究的知识，与被称作哲学的综合性知识相对。</p>
<p>  到了十六世纪，波澜壮阔的文艺复兴运动让人们打破了宗教枷锁对人性的束缚，高举“科学”这个概念和“人文”这个理念做大旗，使科学不仅成为了当时一种批判神学的精神武器，更成为一种认识世界的崭新观念。</p>
<p>  由此渐渐引发了第一次工业革命。</p>
<p>  而第二次工业革命，也称第二次科技革命，出现于十九世纪七十年代到二十世纪初，是以电力的广泛应用、新的交通工具、新的通讯手段的发明等等为标志的。</p>
<p>  第三次工业、科技革命，也就是当下的信息革命，肇始于二十世纪四五十年代至九十年代。是以原子能、航空航天、计算机为代表，还包括分子生物学、互联网络等新突破。</p>
<p>  介绍这些，是为了——</p>
<p>  理清西方科学的发展脉络，严格地更正那些关于科学发展的错误认识，从而再次确认我们第一步的推论——</p>
<p>  在十六世纪科学获得一次突飞猛进并且这个概念被着重提出来做大旗之前，世界上、东西方，都早有科学，只不过这个名词没有被高举出来而已。并不存在类似前文方舟子那种以混淆概念形成的“时间点”判定的以下谬论——</p>
<p>  “既然中医理论体系远在人类有科学之前就已确立，那么中医学不是科学，本是很自然的事。”</p>
<p>  当然以上推演的是西方科学的进程，至于中医学是不是科学，我们还需继续往下分析。</p>
<h2 id="2，科学的定义"><a href="#2，科学的定义" class="headerlink" title="2，科学的定义"></a>2，科学的定义</h2><p>  判断中医学是不是科学，首先就需要了解“科学”的定义。</p>
<p>  请看权威的大辞典们怎么诠释——</p>
<p>  《辞海》1999年版：“科学：运用范畴、定理、定律等思维形式反映现实世界各种现象的本质的规律的知识体系。”</p>
<p>  法国《百科全书》:“科学首先不同于常识，科学通过分类，以寻求事物之中的条理。此外，科学通过揭示支配事物的规律，以求说明事物。”</p>
<p>  前苏联《大百科全书》:“科学是人类活动的一个范畴，它的职能是总结关于客观世界的知识，并使之系统化。‘科学’这个概念本身不仅包括获得新知识的活动，而且还包括这个活动的结果。”</p>
<p>  《现代科学技术概论》:“可以简单地说，科学是如实反映客观事物固有规律的系统知识。”</p>
<p>  也就是，如果概括地说——科学：是反映自然、社会、思维等现实世界各种现象本质及其客观规律的分科知识体系。（综合现代汉语词典与辞海的说法）</p>
<p>  ——这是它确定的标识。</p>
<p>  而当我们按着严格的科学定义去观照，看看中国古代有没有科学呢？</p>
<p>  显而易见，按着这样的概念轮廓，纵观中国古代科学以及依托科学之下的技术发展史，我们的祖先取得了斐然可观的成就，在天文、数学、农学及制造业等许多方面有过无数发现、创造和发明，那绝不仅仅只是享誉世界的四大发明，也绝不仅仅只是耳熟能详的《周髀算经》、《九章算术》或者众所周知的地震仪、圆周率、大明历……</p>
<p>  可见那些别有用心者为了诋毁中医，不惜混淆概念，既否定祖国的“科学史、科学思想史”（李约瑟语），还否定了古希腊的科学文明。这完全不符合科学定义与科学发展的历史事实。当然他们如此拙劣的所有目的，都是想通过“时间点”的诡辩最终否定中国的“古医学史”（李约瑟的提法）、“古医学”——也就是中医。</p>
<p>  将来，我们会知道中国传统文化中真正令人叹为观止、为我们这个民族的繁衍生息、为未来之人类文明进程作出巨大贡献的科学，恰恰是——中医。这一点后面会全面论证。</p>
<p>  而方舟子在《中医不是科学》一文中，之所以一直吞吞吐吐打马虎眼，不承认以上那些针对科学准确的定义标识，甚至还要故意找理由否认这些公认的说法，就是因为一旦按正规的定义审视，首先就得至少承认中医在科学定义的范畴内，它显然符合“反映人生命、疾病、身心一定的客观规律之分科知识体系”这个定义，所以李约瑟才把它划分为古医学来研究。退一步讲，即使它有不完善的地方，可同时总结了大量生命规律性的法则，任何人也不能一棍子打死说它就不是科学、它就不是研究人生命及其疗愈的分科知识体系。而即使是现代医学、现代科学，何尝不是在日日进步、时时完善中？为何厚此薄彼？是崇洋媚外双重标准还是其他什么居心？</p>
<p>  至此，应该说，是在“时间点”之外，从“定义”这个角度，对方舟子“中医不是科学”之错误论调的第二次完爆。</p>
<p>  不过，且慢，为了把这个说法证明得无可辩驳，让胡搅蛮缠者也理屈词穷，笔者做了大量严谨的案头工作。我们下面可以看看科学一词最初翻译过来时的演变过程，甚至我们可以温习一下自己母文化“科学”两字的具体意思，以充分证明此种说法。</p>
<h1 id="找不到（五）和（六）"><a href="#找不到（五）和（六）" class="headerlink" title="找不到（五）和（六）"></a>找不到（五）和（六）</h1><h1 id="好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（七）连载——从经典的科学方法看中华文明独特的数理逻辑与整体观的科学理念"><a href="#好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（七）连载——从经典的科学方法看中华文明独特的数理逻辑与整体观的科学理念" class="headerlink" title="好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（七）连载——从经典的科学方法看中华文明独特的数理逻辑与整体观的科学理念"></a>好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（七）连载——从经典的科学方法看中华文明独特的数理逻辑与整体观的科学理念</h1><p>  中国古代文明的辉煌与一些科技的进步程度是超乎想象的。当我写下这样的话，一定还是会有不少朋友嗤之以鼻，以为我不过是民族虚荣心膨胀的妄自尊大，没关系，您看下去就知道了。</p>
<p>  很多人并不真正了解我们祖先的殊胜成就，更不了解我们的璀璨文明。只是在近二百年西强东弱的格局里，在西方经济强势挟带的西方文明里迷失了，迷失久了太不自信，甚至卑躬曲膝 、崇洋媚外，反而做了打压自己文化传统的旗手。</p>
<p>  记得有一次参观湖南长沙的博物馆，看到马王堆一号墓出土的素纱禅衣，薄如蝉翼、轻若虹霓。衣长160厘米，袖通长195厘米，重量却仅仅48克。经测算原料的纤度为10.2旦尼尔，即900米的纤维重1克，现在生产的高级丝织物还有14旦尼尔，高超的缫丝技术让人惊叹不已，讲解员介绍说目前现有的复制技术也很难做到这么轻。原来看到白居易《缭绫》中的诗句：“应似天台山上明月前，四十五尺瀑布泉，中有文章又奇绝，地铺白烟花簇霜”，以为对“缭绫”月光般飘渺空灵、如水般晶莹剔透的描写不过是诗人过分的艺术夸张，真的看到了精美奇绝“轻纱薄如空”、“举之若无”的素纱禅衣，才知是自己没见识，人家并非凭空想象，完全据实而来。</p>
<p>  对古文明的认知何尝不是如此！</p>
<p>  要说的还有那些丝织品上花纹图案所表现出的高雅的审美意识，让你看过之后一定会慨叹现代国人的粗鄙与陋俗，相比之下就是没文化呀！汉唐风韵乃至高古时那么素朴、典雅而高贵的审美情趣，几乎已经在这个文化断代、文化荒漠的中国荡然无存！</p>
<p>  令人震撼的当然不仅仅是这点“科技含量”，尽管它也已高超得令世人叹服。下面要介绍的才是要让人真正瞠目结舌的例证，当然，我会让这份震撼一直贯穿这本书，甚至延续到未来的作品。现在，就先开个头儿吧——</p>
<p>A,经典的两大科学方法和中国特有的伟大“推演法”</p>
<p>  经典的所谓科学方法有两大类，就是归纳法和演绎法（又称推演法）。一直有一种观点说中国传统文化的建立只有归纳法，而没有推演法，更有甚者认为没有数学。那应该让孤陋寡闻者查一下朱世杰的《四元玉鉴》，看看他以及其承袭的中国古代“天元术”在解决多元高次方程组问题上比欧洲早了几百年。有人又会惊讶了。不过，这跟下面要介绍的内容比还根本就不算什么：</p>
<p>  中医经典《黄帝内经》之《素问-上古天真论》明确指出：“上古之人，其知‘道’者，法于阴阳，和于术数。”——它说上古真正知“道”、得“道”的人，肯定会懂得把握、熟练运用并相和于阴阳与术数。</p>
<p>  其实，术数所表述的显然就是推演的一面，显然就是中国传统理念中逻辑的一面。谈到推演和逻辑就必须联系数学，术数就是关于数学的学问。《四库全书总目》在谈到术数的定义时，有下面一段文字： “物生有象，象生有数，乘除推阐，务究造化之源者，是为数学。”虽然，这并不是现代西方意义上的数理逻辑系统。但是，显然，它属于推演的部分却是不能否定的，这是中国独特的数理逻辑体系。下面就是验证这一说法的伟大例证——</p>
<p>  被称作第三次科技革命重要标志之一的计算机，大家知道它发明与应用的运算模式是二进制的吧？那么，这作用非凡的二进制又是谁最先发明的呢？</p>
<p>  莱布尼兹是一位卓越的数学天才， 1671年，当他还只有25岁时，便发明了世界上第一台能进行加减乘除运算的计算机。1684年，他又与牛顿几乎同时各自完成了微积分的研究。</p>
<p>  “世界上没有两片完全相同的树叶”也是他的名言。西方数学史认为，二进制就是这位被誉为十七世纪亚里士多德的德国数理哲学大师首创的。可是这只不过是当时西方人的孤陋寡闻。</p>
<p>  有可信的资料表明莱布尼茨的二进制受到了中国《易经》八卦图的启发。（具体举证详见上海人民出版社出版，胡阳、李长铎著作《莱布尼茨——二进制与伏羲八卦图考》）</p>
<p>  当然，也有一种说法是莱布尼茨先发明了二进制才看到八卦图——</p>
<p>  莱布尼兹从他的传教士朋友“布维”寄给他的拉丁文译本《易经》中，读到了八卦的组成结构，惊奇地发现其中“阴爻”（- -）和“阳爻”（—）的排列方式与他曾冥思苦想的二进制基本素数（0）（1）排列如出一辙，其进位制就是二进制，并认为这是世界上数学进制中最先进的。（见下图，阴爻是0，阳爻是1）</p>
<p>  <img src="https://draapho.github.io/images/1909/YinYong.jpg" alt="YinYong.jpg"></p>
<p>  2015年6月11日 另一个可能引起莱布尼茨对八卦的兴趣的人是坦泽尔（Wilhelm Ernst Tentzel），他当时是图灵根大公爵硬币珍藏室的领导，也是莱布尼茨的好友之一。在他主管的这个硬币珍藏中有一枚印有八卦符号的硬币。</p>
<p>  也就是说，综合大量考据论证，从时间点上来看，“莱布尼茨先发明了二进制才看到八卦图”的说法不太可信，他显然在发明之前的很多年间里就曾经还有很多渠道可以见识到八卦图。</p>
<p>  不过，综上可见，无论哪种说法，应该承认，莱布尼兹是欧洲最早发现二进制的数学家。但就世界范围来看，二进制式的推演法及其发明权在中国，并且整整较之提前了至少两千年左右——这却是铁的客观事实。</p>
<p>  至于阴阳与八卦更深的奥义，西方人更是到现在也无法梦见。后面的文章还会结合图二与莱布尼茨在二进制上的“神秘发现”继续拆解。震撼才刚开始。</p>
<p>（八卦是我国古代的一套象征意义的符号，古人用它来从根源与整体性上把握、诠释天地万物的生成。其符号结构的素材唯有两种，即阳爻和阴爻。这两种素材互相搭配，以三个为一组，便产生出八种符号结构。这八种符号结构就叫做八卦。它们的具体名称是乾、坤、震、艮、离、坎、兑、巽。）</p>
<p>B,中国高明的数理科学——一个“阴阳”已涵容“归纳”与“推演”两大科学法则</p>
<p>  在莱布尼茨眼中，八卦就是他的二进制的中国翻版。他感到这个来自古老中国文化的符号系统与他的二进制之间的关系实在太明显了，因此他不禁在惊叹中断言：二进制乃是具有世界普遍性的、最完美的逻辑语言。</p>
<p>  是的，正如他说——逻辑语言——二进制的推演是阳爻和阴爻，其实就是“阴阳”的演化。这本身就是“推演法”，亦即“演绎法”。在《易经》中更是通过一套“阴与阳”简易又精深的推演系统来阐明甚至预测万物的运作规律。只不过是别说西方人，就是当下的国人也早已对这套系统中那些独有的隐喻符号（诸如天干地支）完全陌生了。</p>
<p>  再看另一方面的“归纳法”——《黄帝内经》说：“阴阳者，天地之道也，万物之纲纪，变化之父母，生杀之本始，神明之府也。”</p>
<p>  这里将天地万物，将一切事物的更生演变、生杀转化都归结到“阴阳”里，都以“阴阳”的视角作出最终的完美解释与指引。无论是《黄帝内经》还是《易经》，对这种“阴阳的转换、归化与统合”规律都有实际的阐明抑或操演，就“归纳法”的角度而言，天下还有比这更完美的吗？深奥难测、晦涩难懂是一回事，孤陋寡闻或者掩耳盗铃地予以否定又是另一回事！事实上，在高深玄妙的“中国古代科学”面前我们更应该多怀敬畏之心去钻研、去亲近。</p>
<p>  综上所述，一个“阴阳”已涵容“归纳”与“推演”两大法则，穷通万法，统观世界。请问，还有比这更高明的数理与科学理念吗？只不过这独特的东方科学式的数理逻辑模式，是与常人被西式理念灌输后熟知的、对“数理逻辑及科学方法”早已僵化的观念不同罢了。</p>
<p>  这正是东、西方科学理念、思维模式、研究方法等等完全不同，属于不同体系的明证之一。而越来越多的证据表明，东方式的、中国特有的科学理念不仅只是补充，而且越来越发现它在整体观、系统论上的前瞻性，为科学的未来指示着方向。我们又怎么能以西方一时的经济、文化强势而彻底地抛弃自家的珍宝呢？</p>
<p>  对于传统文化，诋毁者只是由于对自己文化基因的陌生与隔膜，不明白蕴于其中的浅显道理与深邃奥妙而已呀。</p>
<p>  一个“阴阳”，在传统文化的体系中太重要了，相关中医，《黄帝内经》也一样叮嘱要“察色按脉，先别阴阳”。就是说中医的诊断与治疗，首先就是先要辨清病人“阴阳”的属性。否则“阳病”用成了“阴药”或者“阴病”用成了“阳药”，就成了庸医误人。</p>
<p>  可以说，要想真正进入传统这门学问，要想理解中国人、中国文化高深的“意识”与“理念”，就一定要把握好对“阴阳”的认识，这是总根子。</p>
<p>  从上可见，中国的数学是配合中国文化的数学，中国的科学、医学理念是源出于中国文化根源的理念、东方科学的理念。知道了这一点不但不会妄自菲薄，更会高山仰止于我们文化的独特魅力。就像“十七世纪的亚里士多德”莱布尼茨一样，听听他那时在《中国近况》一书的绪论中，怎么评论当时的中国文明吧——</p>
<p>  1，“全人类最伟大的文化和最发达的文明仿佛今天汇集在我们大陆的两端，即汇集在欧洲和位于地球另一端的东方的欧洲——中国。”</p>
<p>  2，“中国这一文明古国与欧洲相比，面积相当，但人口数量则已超过” （在古代，人口就意味着强盛的标志。有一个问题很有趣味也很有启发性——又是什么使得中国古代的人口大大兴盛于世界列国，难道是从人类始祖之时这块土地就人多？显然不是。除了人文、政经等等因素，毫无疑问，传统中医也起着至关重要的作用。）</p>
<p>  3，“在日常生活以及经验地应付自然的技能方面，我们是不分伯仲的。我们双方各自都具备通过相互交流使对方受益的技能。在思考的缜密和理性的思辨方面，显然我们要略胜一筹，但在时间哲学，即在生活与人类实际方面的伦理以及治国学说方面，我们实在是相形见绌了。”</p>
<p>  （其实就这都反映着他一些对东方文明根源的不了解，东方的“理性”就像东方的“科学”一样，它真的不存在或者比西方的差吗？东方的意识与思维模式比西式的差吗？其实，就当时的国力来讲，已经给了他答案。）</p>
<p>  并且请不要忽略，莱布尼茨的时代已经是到了清朝康熙年间，中国已即将从顶点走向衰落，中国的古老文明已经经过几次血洗与阉割以及千百年大量的误读与曲解。只不过它植根于民族血液中本真的生命力太过强大与包容，总能通过碰撞、融合，重新焕发新的生机。</p>
<p>  就像当下，经历了近百年西方各个方面的洗礼，如今的中国国力却再次崛起蒸蒸日上，文化上真正的复兴也指日可待。</p>
<p>C,中华文明的整体性观念为科学的未来指明了方向<br>  介绍这些不仅是证明《易经》了不起的数理学，更是为了说明中华文明从本已来的独特性——它完全区别于“西方式科学”的“科学理念”，甚至是“思维模式”。如果你探究它更深的意蕴，你将知道从某种层面上它理念与意识的高度几千年了还在等待西方的成长，这不稀奇，因为从一开始它就是从人类意识的根源与巅峰出来的东西。<strong>它是熟透了的文明。</strong></p>
<p>  是的，世界是一个整体，关于世界的认知也应该是一个整体。应该有西式的“分科之学”。但由于人认知的局限性与片面性，更应该有整体性的视角——那就是中国古代科学推崇的“整体观”，它是“整体”、“根源”性的“通学”。提纲挈领、把握根本，仰观天文，俯察地理，中知人事，是古人的追求。</p>
<p>  以西式的观念面对世界，可产生分科研究的西方科学。而“整体”必然包容“部分”，以整体观的视角去钻研解决，当然也能产生“中国式通学”——包容各种分科之学的东方科学。中国古代先进的科技就是明证。</p>
<p>  只不过它们都是在传统文化独特的理念下衍生、打着中国独特烙印的分科学问；只不过东方式视角的整体性、根源性更为高瞻远瞩而直彻根源罢了。</p>
<p>  中医就更是这种文明与东方式科学理念的实践反映与高度结晶。它的“整体观”、“人与自然的一体性”、“与时消息、因人而异的辨症论治”、“阴阳平衡”等等观念无不闪烁着最根源的东方智慧。</p>
<p>  事实上，现今的西方科学，整体性是潮流之一，也已发展了宇宙学、地球系统科学等一些综合性科学、系统性科学、复杂性科学，至于新兴的各种交叉科学更是雨后春笋般快速成长。可见，不论是分科的，还是交叉的、综合的和整体的，只要它们确系属于各自客观规律的反映，都应归属于科学的总范畴之内。反映客观规律的知识体系，不能仅限于分科的，我们又怎么能将反映综合性、整体性、根源性客观规律的知识，排斥在科学之外呢？</p>
<p>  真正的科学又怎么会独属“西”有，甚至又怎么能分立“东”“西”呢？</p>
<hr>
<p><em><strong>转载自 <a href="http://bbs.tianya.cn/post-free-5088705-1.shtml">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></strong></em><br><em><strong>转载自 <a href="http://blog.sina.com.cn/s/blog_7edcb9a10102vjtm.html">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题（七）连载</a></strong></em></p>
<hr>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>  我无意参与中西医之争, 一来我对中西医都不熟悉, 二来领教过中医黑的蛮不讲理(劝架的身份, 只是说了一句中医并非一无是处, 直接炸了), 实在不想自讨没趣.<br>  中医是否科学, 本来就没必要争论的一件事情. 科学的概念晚于中医, 即便证明了中医不科学又怎么样? 其实是思维里面有后面的逻辑链: 不科学就是迷信, 迷信就是错的.<br>  这整条逻辑链可以攻击的地方太多了, 包括但不限于, 科学是什么? 科学等于正确吗? 不科学等同于错吗?<br>  科学是个好东西, 科学要求的逻辑思维, 敢于自我否定和突破, 不断改变看问题的视角, 才让科学体系一路狂奔发展至今. 如今的科学发展又似乎进了一个死胡同, 难道不应该突破思维束缚, 换一个全新的角度来看看世界吗?<br>  西方哲学体系是往外看, 把事物静态的看, 拆分的看, 往小里看. 印度哲学体系是向内看. 中国文明是整体性的看, 大小无二. 换个视角看看吧, 换个心态而已, 不会要命的.<br>  在 <a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a> 里, 我也粗陋的谈了谈自己对科学的看法.</p>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>解构&lt;让子弹飞&gt;</title>
    <url>/2020/04/15/2003-letthebulletsfly/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
<li><a href="https://draapho.github.io/2021/03/05/2107-tuibeitu1/">万年歌, 马前课, 梅花诗, 推背图 (上)</a></li>
<li><a href="https://draapho.github.io/2021/03/18/2108-tuibeitu2/">万年歌, 马前课, 梅花诗, 推背图 (下)</a></li>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/26/2123-caseofsatori/">见性者体验收集</a></li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>政治, 是世间最肮脏的东西之一, 因为这里没有任何底线和约束, 是人性博弈最彻底的地方.<br>近期恶补政治斗争哲学, 对精英阶层的为人处事方式有了些许的了解和总结.</p>
<p>史书, 四大名著以及西方名著等, 都是因为蕴含着不变的人性, 才最终穿越千百年, 流传至今.<br>只是, 太过浩渺, 而且基本都包着一层层外壳… 无力去一一阅读, 分析, 总结, 解构.</p>
<p>觅得一短小精悍的&lt;让子弹飞&gt;, 关键人物区区十数人, 通过高度的脸谱化和符号化, 竟能将人性二字揭露如此彻底, 深感佩服.<br>因此近日反复观看研究此影视, 略有心得, 以作总结.</p>
<p>其目的是将观察到的现象, 像软件设计模式一样, 加以归纳总结, 便于日后当做工具一样来使用和分析.<br>这样, 再回过头去阅读名著, 必然更快更容易的进入深层次的理解.</p>
<p>建议先看几遍&lt;让子弹飞&gt;, 熟悉人物关系. 然后查看 <em><strong>参考资料</strong></em> 内容. 最后再看本篇的解构.</p>
<h1 id="鹅城稳态势力"><a href="#鹅城稳态势力" class="headerlink" title="鹅城稳态势力"></a>鹅城稳态势力</h1><p><img src="https://draapho.github.io/images/2003/diagram1.png" alt="鹅城稳态势力"></p>
<p>势力简介:</p>
<ul>
<li>刘督统: 鹅城势力的上级, 依靠黄四郎和城南两大家族对鹅城敛财.<ul>
<li>郭旅长: 刘督统的枪杆子, 其骑兵对鹅城有绝对性优势.</li>
</ul>
</li>
<li>黄四郎: 鹅城一霸, 一家独大. 性格: 贪得无厌, 一毛不拔.<ul>
<li>胡万胡千胡百: 宠臣+心腹.</li>
<li>黛玉晴雯: 女色, 用于试探.</li>
<li>钻石: 钱财, 用于试探. 黄四郎非常在意, 一定会取回来.</li>
<li>花姐: 妓女. 间谍情报工作.</li>
<li>武智冲: 团练教头, 城内打手.</li>
<li>假麻子: 土匪, 听命于黄四郎. 城外枪杆子.</li>
</ul>
</li>
<li>城南二大家族: 鹅城势力参与者, 抱团抗衡黄四郎. 穿着华丽.<ul>
<li>打手: 做拐卖壮丁的恶事, 少不了欺男霸女的打手.</li>
</ul>
</li>
<li>流水的县长: 51任县长, 只有5任选择为民说话被斩首. 其余被收下当狗.<ul>
<li>宣传工作: 明面上归县长管, 暗里少不了黄四郎诸多干预.</li>
</ul>
</li>
<li>鹅城百姓: 中产和无产.<ul>
<li>卖凉粉的: 有衣服穿, 无权中产代表.</li>
<li>敲鼓鸣冤的: 衣无所有, 底层代表.</li>
</ul>
</li>
</ul>
<h2 id="小密圈模式"><a href="#小密圈模式" class="headerlink" title="小密圈模式"></a>小密圈模式</h2><ul>
<li>特点:<ul>
<li>小: 小范围的组织, 参与的人越少越好.</li>
<li>密: 属于桌底下的交易, 只能秘密进行, 不能公之于众.</li>
<li>圈: 形成利益共同体, 由’我’变为了’我们’. 非圈内人难以进入.</li>
</ul>
</li>
<li>案例分析:<ul>
<li>黄四郎, 城南家族, 当狗的县长<ul>
<li>潜规则: 县长上任, 得巧立名目, 拉拢豪绅, 缴税捐款. 得钱之后, 豪绅的钱如数奉还, 百姓的钱三七分成.</li>
<li>要点: 作为来者和弱势的县长, 自我定位必须清晰, 要让自己有利用价值.</li>
<li>县长: 脏活累活全干, 恶名全背, 得的钱还只能是小份, 跪着把钱给挣了.</li>
</ul>
</li>
<li>刘督统, 黄四郎, 城南两大家族.<ul>
<li>刘督统: 堂堂督统, 挣的钱必须是干净的.</li>
<li>黄四郎: 在鹅城势力最强, 所以贩卖烟土, 利润大风险小, 替刘督统挣钱. 自己得小钱</li>
<li>城南家族: 在鹅城势力较弱, 所以拐卖壮丁, 利润较小风险较大, 替刘督统挣钱. 自己得小钱.</li>
</ul>
</li>
<li>马邦德, 县长夫人, 汤师爷<ul>
<li>三者本是一个比较牢固的利益共同体. 对外目的一致: 赚钱!</li>
<li>县长夫人出钱, 得自由身. 鸡变凤凰, 跻身上层社会.</li>
<li>马县长, 无本买卖, 能文能武, 跪着捞钱.</li>
<li>汤师爷, 汤师爷和县长夫人在火车上有打情骂俏. 故三者内在关系微妙, 师爷县长位置互换也不是不可能.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="白手套模式"><a href="#白手套模式" class="headerlink" title="白手套模式"></a>白手套模式</h2><ul>
<li>特点:<ul>
<li>公开的宣传: 道德法治, 民主自由, 公平公正.</li>
<li>背后的操作: 利益交换, 巧取豪夺, 设置门槛.</li>
<li>矛盾之处: 婊子立牌坊.</li>
<li>解决办法: 别人当婊子, 自己与婊子形成小密圈, 然后立牌坊.</li>
<li>白手套: 干脏活又不想弄脏自己的白手, 需要一手套来干活. 替主子当婊子背锅的就是白手套, 有主动的, 也有被动的. 需要时带着, 不需要时扔掉.</li>
</ul>
</li>
<li>案例分析:<ul>
<li>黄四郎, 城南家族, 当狗的县长.<ul>
<li>白手套: 当狗的县长. 脏事做完, 主动跑路.</li>
<li>立牌坊: 黄四郎, 城南家族</li>
<li>黄四郎和城南家族由于长居鹅城, 百姓中的名声还是要顾及一点的, 恶事不宜做的太频太过.</li>
<li>买官的县长目的是赚钱, 赚一笔就走. 恶事做尽, 被骂王八蛋, 禽兽, 畜生, 寄生虫又如何?</li>
</ul>
</li>
<li>中国史书, 官吏民.<ul>
<li>官: 父母官, 满口仁义道德, 百姓疾苦. 人性使然, 大多贪权好财.</li>
<li>吏: 酷吏. 心狠手辣, 巧立名目, 盘剥百姓. 事实上官吏密不可分, 官的灰色收入即来源于吏.</li>
<li>民: 兴, 百姓苦; 亡,百姓苦. 盼着青天大老爷来整治酷吏, 就是个极小概率事件.</li>
<li>吏是官的白手套. 用时可得财, 丢时可得名. 屡试不爽.</li>
</ul>
</li>
<li>弱势民选政府.<ul>
<li>资本财阀: 赚取超额利润. 实际掌握着钱袋子, 笔杆子甚至枪杆子.</li>
<li>民选政府: 代表人民, 处理财阀问题, 则被斩首. 若与财阀合作, 则收下当狗, 做白手套.</li>
<li>选民: 似乎有选举权, 但什么也改变不了. 不满情绪被发泄到自己选出的领导人身上.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="搞平衡模式"><a href="#搞平衡模式" class="headerlink" title="搞平衡模式"></a>搞平衡模式</h2><ul>
<li>特点:<ul>
<li>精髓: 让势均力敌的两方实力相互斗争, 自己或稳坐钓鱼台, 或从中渔利.</li>
<li>上级管理下级的必用手段. 保证屁股下凳子的安全.</li>
<li>弱者在诸多强者中生存壮大的必要技能. 让自己成为关键的第三方, 两边收好处壮大自己.</li>
<li>用者不计其数, 贯穿古今中外.</li>
</ul>
</li>
<li>案例分析:<ul>
<li>刘督统, 黄四郎, 城南两大家族.<ul>
<li>上级管理下级的模式.</li>
<li>刘督统是上级, 黄四郎和城南家族分别负责两块赚钱的业务.</li>
<li>支持城南两大家族抱团, 和黄四郎搞平衡. 避免黄四郎一家独大, 野心膨胀, 威胁自己的位子.</li>
</ul>
</li>
<li>中国史书, 皇帝和重臣.<ul>
<li>毛太祖, 蒋公, 清孝庄文皇后, 明嘉靖, 明太祖, 宋太祖, 唐太宗, 汉光武帝, 汉高祖.</li>
<li>反面例子: 三家分晋中的智家</li>
</ul>
</li>
<li>国际案例<ul>
<li>英国, 欧洲搅屎棍, 离岸平衡.</li>
<li>美国, 大号版的英国. 离岸平衡.</li>
<li>新中国, 利用美苏互斗, 最终两边得利. 从棋子玩成了玩家.</li>
<li>新加坡, 大国平衡外交. (说实话, 体量太小, 风险极大)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="投机者模式"><a href="#投机者模式" class="headerlink" title="投机者模式"></a>投机者模式</h2><ul>
<li>特点:<ul>
<li>不以破坏现有稳定结构为前提, 最大化自身收益.</li>
<li>通常利用信息不对称来为自己牟利.</li>
<li>不是长久之计, 其他人早晚会有所察觉.</li>
<li>空手套白狼就是投机者模式的一种.</li>
</ul>
</li>
<li>案例分析:<ul>
<li>黄四郎安排假麻子打劫自己的货.<ul>
<li>鸿门宴上, 黄四郎说: ‘我的货十回有八回被张麻子劫走了’</li>
<li>被劫的货就又回到了黄四郎自己手上, 不用大头给刘督统了.</li>
</ul>
</li>
<li>花姐.<ul>
<li>花姐的位置大致等于信息中转站. 如果胆大心细, 可操作空间不小. 相当于多面间谍.</li>
<li>此情况下, 花姐的最好出路就是县长夫人, 与县长形成利益共同体, 到时候远走高飞.</li>
</ul>
</li>
<li>鹅城平衡被张牧之打破之后, 马邦德就是一个超级投机者.<ul>
<li>两边下注, 都是恩人. 只想捞点钱走人.</li>
<li>结果惨了点, 赔了夫人又折兵. 张牧之计划中,县长夫人用来被暗杀掉. 马邦德自己被黄四郎炸死.</li>
</ul>
</li>
<li>平西王吴三桂<ul>
<li>云南剿匪, 剿匪不剿净. 用来保命并争取更多利益.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="鹅城平衡打破"><a href="#鹅城平衡打破" class="headerlink" title="鹅城平衡打破"></a>鹅城平衡打破</h1><p><img src="https://draapho.github.io/images/2003/diagram2.png" alt="鹅城平衡打破"></p>
<h2 id="势力简介"><a href="#势力简介" class="headerlink" title="势力简介:"></a>势力简介:</h2><ul>
<li>被争取对象<ul>
<li>刘督统: 看戏模式.<ul>
<li>黄四郎的烟土被劫次数和频率过高, 刘督统必然有所察觉.</li>
<li>即然有人与黄四郎互斗, 何不坐山观虎斗, 以待渔翁之利.</li>
<li>所以胡百去请郭旅长的骑兵, 说是三天之后到, 到了第四天也没见到个影子. (万民伞倒了三次, 所以砍头那天是第四天.)</li>
</ul>
</li>
<li>城南家族: 搞平衡模式.<ul>
<li>作为鹅城的关键第三方势力, 两强相斗, 利益最大化的策略就是搞平衡, 坐等双方反复拉拢和收买.</li>
<li>首先, 县长张牧之通过宣传帮城南两大家族洗白了, 把拐卖壮丁这个屎盆子扣到了黄四郎身上.</li>
<li>银子铺满地, 枪和子弹铺满地两个场景, 给的特写都是城南家族打麻将. 张牧之的重点拉拢对象就是城南家族.</li>
<li>除了给银子, 给枪给子弹, 还给了他们更高的位子. 结尾处有大光头向县长要两把椅子的特写, 暗喻非常明显.</li>
</ul>
</li>
<li>鹅城百姓: 乌合之众, 谁赢帮谁.<ul>
<li>鹅城百姓并没有到饿死人的地步, 革命造反动力不足. 只有在明确看到黄四郎被砍头后, 无风险的去分赃.</li>
<li>这是张牧之的理想主义造成的. 无风险高收益的事情, 轮不到百姓. 高风险高收益是张牧之手下的期望, 低风险高收益是城南家族的期望.</li>
<li>在张牧之勾起百姓反叛之心, 骑马三圈拉人时, 路边门店只有西式的马, 灯, 挂牌随风而动, 而中式的’茶’,’和廣’则纹丝不动.</li>
<li>此细节暗喻西方民众会更积极主动的响应革命. 而中国百姓忍耐力超强, 更安于现状, 苟且偷生. (受的的威胁更深更久, 有更强的斯德哥尔摩效应.)</li>
<li>拿钱拿枪打碉楼三个晚上, 万民伞倒了三次, 说明百姓自己开始行动了, 而不是仅仅心理上期盼着青天老爷.</li>
<li>卖凉粉的: 孙守义. 做小生意的鹅城中产, 多半是为了稳定经营投靠黄四郎势力. 因为卷进了高层内斗, 被当做了棋子.</li>
<li>鸣冤的: 敲冤鼓敲了两次, 第一次计杀小六做帮凶, 第二次自己老婆被强暴. 想投靠黄四郎势力捞好处, 也不掂量掂量自己有什么利用价值.</li>
</ul>
</li>
</ul>
</li>
<li>黄四郎家族<ul>
<li>黄四郎: 贪得无厌, 一毛不拔, 任人唯亲.<ul>
<li>其贪婪自大的性格所致, 树敌过多, 这是他被张牧之扳倒的根本原因!</li>
<li>否则, 刘督统会来救他. 已决心跟马邦德走的老三老四老五不会又铁了心又跟着张牧之革黄四郎的命.</li>
</ul>
</li>
<li>胡万: 男宠, 心腹. 能力有限, 智商一般.<ul>
<li>黄老爷对计杀老六后供出自己非常不满! 并间接提醒, 事情可以做的更漂亮, 等凉粉消化差不多了再用计!</li>
<li>因为是男宠, 假死后被复用. ‘杀鸡取卵’, 无法领会卵是什么. 暗杀失败后, 天真的相信张麻子会放他回去.</li>
<li>花姐已搞定胡万, 估计黄四郎的机密从他嘴里能知道不少</li>
<li>证据: 黄四郎和胡千调侃花姐别当小凤仙时, 胡万略有不悦, 没有附和该话题.</li>
</ul>
</li>
<li>胡千: 心腹, 马屁高手.</li>
<li>胡百: 心腹, 心狠手辣.</li>
<li>黛玉晴雯和钻石: 代表女色和钱财, 用于试探.<ul>
<li>鸿门宴上, 汤师爷(马邦德)被试探了个干干净净: 爱钱并好色! 可以’收下当狗’.</li>
<li>鸿门宴上, 张牧之滴水不进, 深不可测, 所以黄四郎在’请客’之后, 必然选择’斩首’.</li>
</ul>
</li>
<li>武智冲: 团练教头, 城内打手.<ul>
<li>虽然不太会拍马屁, 行为上表现为小人和墙头草, 但实际能力和脑子都比胡万强.</li>
<li>被张牧之打屁股立威信时, 说的是武举人而不是黄四郎. 至少没有亲口说后台是黄四郎!</li>
<li>计杀老六时. 激的到位, 溜的及时.</li>
<li>但这样一个人, 因为不是亲信, 黄四郎在他假死后, 再也没有用过. 导致武智冲对黄四郎怀恨在心.</li>
</ul>
</li>
<li>假麻子: 土匪, 听命于黄四郎. 城外枪杆子.<ul>
<li>这条线是黄四郎的绝密, 因而用的是虚线. 因为一旦被刘督统察觉, 黄四郎就死定了.</li>
<li>面见假麻子时, 只有黄四郎和假麻子两个人, 连胡千都不在!</li>
</ul>
</li>
</ul>
</li>
<li>张牧之势力<ul>
<li>张牧之: 内方外圆. 里子, 理想主义者; 表面, 现实主义者. 有初心, 也始终不忘初心.<ul>
<li>‘公平, 公平, 还是他妈的公平’; ‘站起来, 不准跪’;</li>
<li>拉拢一切可拉拢的力量, 所以操作中, 向恶霸城南家族, 大骗子马邦德做了大量的利益交换和妥协.</li>
</ul>
</li>
<li>老六: 热血青年. 讲对错, 认死理. 大部分人都是这么过来的, 也有一辈子陷在里面的.</li>
<li>老二: 和老三基情满满, 但和老三不是一路人. 不贪钱, 不好<strong>女</strong>色, 一心跟着大哥张牧之.</li>
<li>老三: 有野心, 有能力. 现实主义者. 主要是为了自身利益, 财,色,权; 其实也代表跟着打江山的下属们的期望.</li>
<li>老四和老五: 现实主义者, 但没有野心. 虽然也想着财, 但如果没有老三拉拢, 不会背叛大哥.</li>
<li>老七: 有自己原则, 能辨是非的人. 虽然也爱财, 但不会背叛大哥, 不会与老三同流合污.</li>
<li>宣传工作: 估计是用大棒加胡萝卜的方法, 把鹅城的宣传工作完全把控住了. 主要用来制造舆论优势, 动员鹅城百姓.</li>
</ul>
</li>
<li>马邦德势力<ul>
<li>马邦德: 唯利是图, 赚钱最重要. 所以他为了自保和赚钱, 能把两个仇人说成恩人, 双面下注, 游刃有余, 个人利益最大化!<ul>
<li>最终的计划是, 出卖张牧之, 从黄四郎那里捞足好处, 远走高飞.</li>
<li>马邦德和花姐, 黄四郎用了小密圈模式, 在黄四郎和张牧之之间用了投机者模式.</li>
</ul>
</li>
<li>花姐: 花姐是为了自己的多面间谍. 她对张牧之有爱慕之情, 对黄四郎隐忍配合, 与马邦德, 老三等最终形成联盟.<ul>
<li>此联盟以花姐为联络中心, 联合了马邦德, 老三, 老四老五. 目标是带着钱跑路, 在其它地方当上层阶级.</li>
<li>有一个箭头是指向黄四郎的下属们的, 意味着花姐可以通过这批人刺探到黄四郎的机密消息.</li>
<li>花姐已搞定胡万, 估计黄四郎的机密从他嘴里能知道不少.</li>
<li>证据: 黄四郎和胡千调侃花姐别当小凤仙时, 胡万略有不悦, 没有附和该话题.</li>
<li>假黄四郎高概率也被搞定了. 证据, 轻而易举的看身体区分真假黄四郎.</li>
</ul>
</li>
<li>陕西老婆: 马邦德的后路. 猜测马邦德在赚足喝饱之后, 会回到陕西老婆那里安度余生.<ul>
<li>核心理由: 马邦德一伙出卖张牧之, 假剿匪, 真跑路时, 他把最贵重的钻石给了陕西老婆.</li>
</ul>
</li>
<li>县长夫人: 花姐是成功了的县长夫人. 县长夫人的过去就是花姐.</li>
<li>钻石: 小密圈模式的代表. 每一次钻石的易手, 代表着两种势力之间的利益交换和结盟.</li>
</ul>
</li>
</ul>
<h2 id="计谋和心态"><a href="#计谋和心态" class="headerlink" title="计谋和心态."></a>计谋和心态.</h2><ul>
<li>县长上任<ul>
<li>张牧之七人: 赚钱捞一笔. 张牧之想赚了钱让老六留洋.<ul>
<li>以假乱真, 枪杀假麻子, 宣传工作做一波. 收买人心.</li>
<li>老二老三, 同组镜头, 因为两人是基友.</li>
<li>老四老五, 同组镜头, 两人性格目标相近.</li>
<li>老六, 张牧之重点培养对象, 接班人.</li>
<li>老七, 有独立判断和想法的一个人.</li>
<li>看似铁板一块的张牧之集团, 在一开始就做了内部划分.</li>
</ul>
</li>
<li>马邦德: 见机行事, 捞钱第一. 或帮黄四郎干掉张牧之, 当真县长跪着挣钱; 或配合张麻子赚鹅城豪族的钱.</li>
<li>黄四郎: ‘礼帽, 礼貌’, 被张牧之霸气外露顶了回去.<ul>
<li>二八开是打发不了的, 要’和他耍耍’. 以防万一, 精心准备替身.</li>
</ul>
</li>
<li>花姐: 对张牧之有爱慕之情. 临危不惧, 身手了得, 被黄四郎选中当间谍. 还特意警告: ‘你不要变成小凤仙哦’.</li>
<li>县长夫人: 帮马邦德买县官, 一心想脱离原有身份, 当县长夫人.<ul>
<li>生存之道, 利用男人的好色, 打探各个势力之间以及内部的利益冲突, 矛盾和裂缝, 择机获利.</li>
<li>故县长夫人会和真汤师爷打情骂俏, 会勾引张牧之.</li>
<li>县长夫人的生存之道, 就是花姐的生存之道.</li>
</ul>
</li>
</ul>
</li>
<li>计杀老六<ul>
<li>黄四郎: 以其人之道, 还治其人之身. 县长打武举人的杀威棒打好, 要给大家公平, 那就用你的人要公平!<ul>
<li>黄四郎的期望: 识相的, 就自己收拾包袱走人. 认怂的, 就跪下当狗.</li>
<li>等到的结果是: 即不识相, 也不认怂; 还要报仇, 要杀人诛心.</li>
</ul>
</li>
<li>百姓的态度, 就是人性. 对错不重要, 要的是有趣和热闹.</li>
<li>老六墓前, 对各人心态做了一次细致的描述.</li>
<li>老七: 老二让老七带话. 说明平时两人关系较好, 共同语言应该是都比较钦佩仰慕老大.</li>
<li>老三: 老二老三不愧是基友, 老三一眼看穿老二不是喝醉了, 而是生气了, 生老大的气!<ul>
<li>老三此时也很生气, 想拼命报仇. 关键一句: ‘姓汤的不是个好玩意!’</li>
</ul>
</li>
<li>老四老五: 没啥特别的地方, 说的话都是一样的.</li>
<li>张牧之: 目标从赚钱变为了报仇, 而且是要把黄四郎的根给拔了!<ul>
<li>从此刻起, 真正成为鹅城势力搅局者. 必然会破坏原鹅城势力的平衡态.</li>
</ul>
</li>
<li>马邦德: ‘不能拼命啊!拼命还怎么赚钱!’. 想继续当投机者, 赚钱最重要.</li>
</ul>
</li>
<li>鸿门宴<ul>
<li>黄四郎: 鸿门宴是黄四郎的第一步, 即’请客’. 目的是试探虚实, 看人下菜.<ul>
<li>死人试胆量如何, 黛玉晴雯看是否好女色, 讨论分赃验是否贪钱.</li>
<li>张牧之胆量过人, 不好色不为钱, 水米不进, 执意接腿, 唯有 ‘斩首’ 一条道.</li>
<li>马邦德漏个底朝天, 此人不足为患, 可以 ‘收下当狗’.</li>
</ul>
</li>
<li>马邦德: 借用张牧之的威慑, 从黄四郎这里多捞点, 赚钱重要.<ul>
<li>时刻不忘把话题引到捞钱的问题上 .</li>
<li>因而张牧之拒绝分180万的钱, 执意接腿时, 非常不悦.</li>
<li>当黄四郎同意五五对半分时, 立马笑逐颜开. 估计心底暗自佩服张牧之装傻博弈的水平.</li>
<li>‘美女不要, 钱你也不要, 你要什么啊?’. 马邦德彻底看不懂张牧之了.</li>
</ul>
</li>
<li>张牧之: 原本是为了血拼斩首而来的. 最终决定智斗.<ul>
<li>一场鸿门宴, 张牧之看到了黑幕, 理解了官场规则.</li>
<li>在明白这种规则后, 他决定要放得下并玩得起, 用官场规则智斗巧斗, 代替搏命的武斗.</li>
<li>他绝决的表现出不为钱不为色, 处处顶的黄四郎难受不已, 就已料到黄四郎必起杀心.</li>
</ul>
</li>
</ul>
</li>
<li>葬礼绑票<ul>
<li>张牧之: 放得下心慈手软, 仁义道德. 玩得起阴谋诡计, 不择手段.<ul>
<li>充分试探马邦德后, 知道他在意县长夫人和捞钱. 很可能脱离自己的控制.</li>
<li>料定黄四郎要除掉自己, 睡到马邦德身边时, 就准备按计牺牲县长夫人了.</li>
<li>时刻不忘拉拢马邦德: ‘我不能酒后欺负一个寡妇’. 夫人惨死于黄四郎, 更可让马邦德死心塌地跟着自己.</li>
<li>这一计, 是直接安排到葬礼绑票那一步的. 便可拿钱撕票, 大仇得报.</li>
</ul>
</li>
<li>马邦德: 这一局, 他被玩的团团转, 黄四郎和张牧之的计谋都没有看破. 赔了夫人又折兵.<ul>
<li>他是真在意县长夫人, 一度想枪杀了黄四郎. 但还是忍住了, 估计想起 ‘拼命还怎么赚钱’ 这句话.</li>
</ul>
</li>
<li>黄四郎: 棋高一着, 用了替身. 好不得意!</li>
<li>老三: 当老大的野心初现, 带着九筒出场.</li>
</ul>
</li>
<li>发银子给穷人<ul>
<li>拿到城南两大家族的赎金后, 由于张牧之的目标不再是挣钱, 而是死磕黄四郎. 但手下们依旧以挣钱为目标. 内部裂痕自此开始!</li>
<li>老七正式挑起话题: 钱到手了, 是不是可以走了. 老三老四老五的反应都是一致的.</li>
<li>张牧之说’不走’, 是老三开口质疑的: ‘两大家族的钱不算钱啊?’. 老四老五看向老三. 老二始终看着老大.</li>
<li>张牧之说要的是黄四郎的钱后, 老三眨眨眼, 若有所思, 老四老五抓耳挠腮. 老二老七始终看着老大.</li>
<li>张牧之说’人不走, 钱也都不要了, 发出去’. 老三一脸无奈, 老四老五窃窃私语, 老七回头看老四老五. 老二始终看着老大.</li>
<li>内部阵营分裂: 老大和老二目标一致, 马邦德和老三老四老五目标一致, 老七落单.<ul>
<li>老大: 要当青天大老爷, 收拾黄四郎, 拿黄四郎的钱, 给老六和夫人报仇. 老二紧随老大.</li>
<li>老三和马邦德: 要钱即可. 对老大很不满. 老四老五, 要钱即可, 对老大有点想法.</li>
<li>老七: 要钱, 但也没对老大的决定有意见.</li>
</ul>
</li>
<li>发银子那段, 说明老三和老二, 已经是花姐那里的常客.</li>
<li>绑花姐回来那段, 马邦德应该还没有和花姐勾搭上, 不然以他的性格, 不会说要杀了花姐. 花姐知道了县长就是张麻子, 但始终没有告诉黄四郎.</li>
<li>发银子给穷人, 收买人心. 被黄四郎一招 ‘以彼之道还施彼身’ 破解. 不过无妨, 百姓并不知道县长就是麻匪, 砸的只是麻匪的名声, 麻匪需要名声?</li>
<li>黄四郎对县长身份起疑, 但不知道县长就是张麻子, (即认为县长是假扮麻匪发钱). 觉得不像个买官的县长.</li>
</ul>
</li>
<li>陕西老婆和八岁小孩<ul>
<li>马邦德心里有鬼. 实际是和花姐勾搭上了. 形成小密圈, 在暗中交易.</li>
<li>张牧之的怀疑被陕西老婆和八岁小孩化解了, 认为马邦德因此表现异常, 没有深究.</li>
<li>个人倾向陕西老婆是马邦德走马上任鹅城之前就安排了一个日期前来取钱, 而不是临时安排用来骗钻石的(张牧之会因此给钻石根本就无法预判).</li>
<li>马邦德上任的就是鹅城县长, 所以事先安排陕西老婆来鹅城是可能的. 后面出城剿匪和张牧之说的康城县长是黄四郎给的. 牢记马邦德是个大骗子, 满口谎言..</li>
</ul>
</li>
<li>人肉自行车<ul>
<li>此时, 钻石已经在花姐手里, 说明花姐和马邦德的小密圈同盟正式成立.</li>
<li>黄四郎撞见人肉自行车后, 最终依靠花姐献上钻石化解. 黄四郎只知道钻石在张牧之那里, 所以见到钻石就知道花姐打入了张牧之集团内部, 可以继续利用花姐, 搞内部分化.</li>
<li>说花姐快成小凤仙了, 是因为: 花姐没有第一时间告知打入内部和钻石的事, 说明花姐并不安分, 另有计划. 相当于警告和威慑花姐.</li>
<li>老二无心提到了 ‘大哥说了, 留着他是要弄他的钱’, 说者无意, 听者有心, 花姐就知道可以尝试拉拢老二老三. 想必老三在花姐这里谈了不少理想和倒了诸多苦水.</li>
<li>老二始终忠心于老大, 拉拢失败; 老三与花姐一拍即合, 成为新的’县长和县长夫人’联盟; 片尾上海浦东的对话就是花姐和老三, 就是县长和县长夫人!</li>
</ul>
</li>
<li>城内麻匪火拼<ul>
<li>黄四郎试探马邦德, ‘你至少有三句话要说’.<ul>
<li>黄四郎是想让马邦德跪下当狗, 期望的三句话: 1.县长是谁. 2.替身在哪 3.马首是瞻. 马邦德依照张牧之的交代, 拖延时间.</li>
<li>第一句: ‘我不该拿你的钻石送人’. 说明花姐告诉了马邦德她用钻石保了老二和老三. 对黄四郎而言这是一条无用的信息.</li>
<li>二三两句, 都是过去的事了, 对黄四郎而言没有任何意义. 政治斗争, 最忌讳的是计较沉没成本, 最正确的是计算当下和未来的利害.</li>
</ul>
</li>
<li>张牧之把黄四郎的计策算的死死的. 因为他知道黄四郎的手段和目的: 扮麻匪(故技重施), 杀县长(除之后快).</li>
<li>张牧之扳回一局, 让黄四郎不得不答应出钱剿匪. 但内部早已危机四伏.</li>
<li>‘什么叫惊喜’, 参考历史’什么是联合舰队’. 表达的是极度的不满和不信任(用在这里并不是太契合), 顺带是对马邦德的警告, 必须选边站, 站中间有你受的.</li>
<li>‘汤师爷是我的至爱…’, 配合那抚摸肩膀的动作, 这是讽刺黄四郎搞胡万这个男宠.</li>
</ul>
</li>
<li>出城剿匪之前<ul>
<li>三股势力此处正式成型:<ul>
<li>张牧之为核心; 老二, 老七跟着. 杀黄四郎, 替老六和夫人报仇.</li>
<li>马邦德, 花姐, 老三为核心; 老四, 老五跟着. 挣钱重要, 不想再搏命了.</li>
<li>黄四郎, 要你们所有人的命, 还我钻石和银子, 顺带赚一把两大家族的钱!</li>
</ul>
</li>
<li>老六墓前, 马邦德知道了如下重要信息: 安排老二去青石岭做接应, 张牧之执意和黄四郎拼命, 县长就是张麻子.<ul>
<li>分析一下马邦德根据’人埋在哪儿 事儿就出在哪儿’这句话, 判断出县长真是张麻子的理由.</li>
<li>马邦德之前始终没办法确定张牧之是假扮麻子还是真麻子. 所以他的推理只能基于: 黄四郎一伙假麻子, 张牧之一伙假麻子, 还有一伙劫黄四郎烟土的真麻子.</li>
<li>在存在另一方真麻子的情况下, 张牧之扮麻匪发银子, 发生火并的时间和地点都是无法提前安排的, 因为潜在的火并对象有两个, 黄四郎一伙的假麻子和真麻子.</li>
<li>而张牧之敢于提前安排火并的时间和地点, 说明张牧之就是张麻子, 他知道对手只有黄四郎一伙的假麻子.</li>
</ul>
</li>
<li>‘事儿办了九成了, 算七成吧’. 除了拿钱出城, 剩下的事是要致黄四郎于死地. 张牧之已有计划, 但后面被偷袭和内讧弄乱了.<ul>
<li>本来的计划是装模做样出城剿匪, 凯旋回城后给黄四郎扣勾结麻匪, 鱼肉百姓的屎盆子. 然后以青天老爷的身份杀黄四郎替身, 完美实现’杀人诛心’. 所以让花姐在城内看管替身.</li>
</ul>
</li>
<li>假麻子单独面见黄四郎, 讨论埋地雷的事情. 假麻子是黄四郎的绝密, 所以连胡千都不在.<ul>
<li>地雷不是给张牧之准备的, 偷袭用来干掉张牧之一伙, 地雷用来炸马邦德老三一伙, 好取回钻石和钱财.</li>
</ul>
</li>
<li>花姐加入麻匪一段, 老三一手安排的. 目的是带着花姐一起走.<ul>
<li>此时老三, 花姐和马邦德已经结成同盟, 一直看马邦德不顺眼的老三, 这里再也没有冲过马邦德.</li>
<li>这里, 老三应该还自己拉拢了老四老五(老四老五不知道老三, 花姐, 马邦德的关系). 拉拢老七失败, 导致后来被打黑枪.</li>
</ul>
</li>
<li>黄四郎核对鹅县委任状, 名字是马邦德, 画像是那个师爷的. 当面对质时, 黄四郎开始执行计划, 和马邦德做了大量交易.<ul>
<li>花姐始终没有将县长就是张麻子的事情告诉黄四郎. 所以黄四郎到这里才确定张牧之是假县长.</li>
<li>黄四郎: ‘果然他不姓马’, 他指的是假县长张牧之. 计上心头, 可以更轻松的从内部瓦解张牧之和马邦德, 故曰’更加悠然’</li>
<li>支退张牧之后, 黄四郎用三个县的委任状拉拢马邦德. 而马邦德死前, 兜里有五张委任状.</li>
<li>说明马邦德用更多的信息换来了额外的两张委任状, 正式与黄四郎结盟, 黄四郎赠与钻石.</li>
<li>五张委任状中, 包括他自己想要的康城委任状. (日期只念到八年八月, 说明不是二十八日鹅城那张).</li>
<li>透露给黄四郎的重要信息包括: 老二已经去青石岭接应了, 张牧之就是张麻子, 老三老四老五是自己人, 我愿意和你合作赚钱.</li>
<li>不确定有没有透露黄四郎替身的事情, 因为替身是马邦德老三他们的底牌, 交出去分分钟被黄四郎弄死.</li>
<li>如果马邦德说了, 必定通知花姐带着替身逃跑. 如果没说, 花姐也要按照老三的安排出城会合, 拿钱跑路.</li>
</ul>
</li>
</ul>
</li>
<li>出城剿匪遭遇假麻子埋伏<ul>
<li>张牧之看出了老三脑后有反骨, 这次行动剥夺了老三的指挥权, 交给了老五.</li>
<li>看到老二惨死后, 老三特别特别的伤心. 因为他知道, 老二的死, 有他的一份; 他和马邦德是同伙, 而马邦德投诚于黄四郎. 他后悔了.</li>
<li>老七被打黑枪后, 马邦德继续执行原计划, 吹哨子吹出’大哥死了’, 以动摇军心. 吹哨子的方法, 是老三教给他的.</li>
<li>老三此时又活跃起来, 当起了老四老五的带头人. 让老五去确认老大死活, 好进一步确认后续计划. 如果老大死了, 他是不会替二哥报仇的.</li>
<li>马邦德完全能听懂吹哨的含义, ‘假麻子抓到了’, 老七眨眼解读时, 马邦德没有盯着老七等翻译, 眼珠子在转来转去动脑筋, 他怕和黄四郎同盟的事露馅.</li>
<li>陕西老婆应该是马邦德的后路. 所以他会把最贵重的钻石交给陕西老婆, 让娘俩先撤.</li>
<li>知道老婆孩子死了后, 是真伤心, 也是真借机跑路! 想拿着钱, 尽快逃离这个是非之地.</li>
<li>五把万民伞, 说明假麻子存在已久. 主要任务就是帮黄四郎假劫烟土, 真杀青天.</li>
<li>‘山西确实是在东边’, 没看出太多内涵. 有人(见参考资料)推测出鹅城是四川省金鹅镇.</li>
<li>马邦德临死前想说的两档子事:<ul>
<li>1.老二是我出卖害死的, 这是最愧对张牧之的事, 要排第一, 但这条信息对张牧之后续行动没有任何帮助. 所以要先说第二条.</li>
<li>2.花姐是卧底, 要当心花姐和老三. 这才是对张牧之后续行动最重要的信息, 内部出问题了!</li>
</ul>
</li>
<li>马邦德的惨死, 进一步刺激了老三, 知道黄四郎没有任何诚信, 不可与之合作. 老二一死, 师爷一炸, 把老三推回到了张牧之一边.</li>
</ul>
</li>
<li>回城扳倒黄四郎<ul>
<li>张牧之再次回城时, 黄四郎此时才直接称之为’这个张麻子, 杀了假麻子, 得了钱不逃命’. 说明马邦德告知了县长是张麻子, 而非花姐.</li>
<li>张牧之首先搞定了宣传工作(大棒加胡萝卜即可), 把拐卖壮丁这个屎盆子也扣到了黄四郎身上. 孤立黄四郎, 拉拢城南二大家族和百姓.</li>
<li>当着老三的面, 先散了全部的银子. 赚钱走人一直是老三的最终目的, 等于把老三的底牌打个精光, 让他不得不回来和张牧之一起死磕黄四郎, 好再赚点回来.</li>
<li>然后才放心的支走老三, 让其去找回花姐和替身.</li>
<li>拿了钱, 又被黄四郎收回. 得而复失, 怕里有怒. 这是让百姓用贪婪去克服恐惧. 然后发枪, 给百姓助威壮胆. 这都属于明面上的舆论战.</li>
<li>背后的交易是, 拉拢城南二大家族, 帮忙打黄四郎. 将大头的银子和枪弹给了城南二家族, 还答应给他们更高的位子. 结尾处有大光头向县长要两把椅子的特写, 暗喻非常明显.</li>
<li>城南二大家族也是精的很, 从张牧之黄四郎两头吃饱喝足后, 等两头消耗差不多了(张牧之打光了所有子弹, 那少爷判断出’至少得死一个’), 再出击, 稳坐胜利一方.</li>
<li>张牧之和老四老五老七骑马三圈拉人时, 路边门店只有西式的马, 灯, 挂牌随风而动, 而中式的’茶’,’和廣’则纹丝不动. 中国老百姓确实更能忍, 不到活不下去, 不会大规模造反.</li>
<li>胡百去请郭旅长骑兵, 说是三天之后到. 实际是过了三个晚上, 百姓都抢完了黄家财物, 也没见到一个官兵. 刘督统在看戏.</li>
<li>三个晚上, 万民伞倒了三次, 说明百姓自己开始行动了, 而不是仅仅心理上期盼着青天老爷.</li>
<li>当众砍了假黄四郎后, 胜负就定了. 因为人们的恐惧被砍掉了, 剩下的全是愤怒和贪婪带来的勇气.</li>
<li>武智冲之流, 历来都有, 屡见不鲜. 由于他们有利用价值, 对新的统治阶级又言听计从, 所以多半可以继续当酷吏. 影片中, 武智冲被黄四郎开枪打死了.</li>
<li>老七告诉了张牧之花姐和老三他们的事情. ‘老二啊老二’, 叹息只有老二忠于自己, 却因为花姐老三他们白白牺牲了.</li>
<li>由于当大哥的张牧之过于理想主义, 不符合底下兄弟的愿望, 所以这个集团必然从内部分裂. 能代表大多数人愿望的老三成为了领头人黄四郎, 花姐成为了县长夫人.</li>
<li>张牧之 ‘没有你, 对我很重要’ 的一厢情愿, 是无法实现的. 屠龙勇士, 或自己或后代, 必成恶龙!</li>
<li>张牧之骑白马, 追火车. 恶龙不会灭, 同样屠龙勇士也会再次出现. 社会就这样命运般的轮回着.</li>
</ul>
</li>
<li>钻石的易手<ul>
<li>鸿门宴, 黄四郎送于张牧之, 以示明面上的结盟之意.</li>
<li>张牧之装醉, 掉下钻石用于试探马邦德, 马邦德捡起.</li>
<li>马邦德卧室, 被张牧之取回. 并寄放在老三那里.</li>
<li>张牧之将钻石给了马邦德的陕西老婆, 让她去赎人.</li>
<li>暗线: 马邦德从陕西老婆拿了钻石. 然后送给花姐, 正式结盟, 形成利益共同体.</li>
<li>人肉自行车时, 黄四郎撞见老三老二. 花姐将钻石交给黄四郎, 表示已打入敌方内部, 化解一场危机.</li>
<li>暗线: 黄四郎核对鹅县委任状, 支走张牧之后, 与马邦德走小密圈模式, 将钻石赠与马邦德以示结盟.</li>
<li>暗线: 马邦德将钻石给了陕西老婆, 让其先撤离这个是非之地.</li>
<li>钻石是黄四郎的最爱, 一定会关照假麻子钻石的事. 因此假麻子劫了陕西老婆, 取得钻石.</li>
</ul>
</li>
</ul>
<h2 id="立威信模式"><a href="#立威信模式" class="headerlink" title="立威信模式"></a>立威信模式</h2><ul>
<li>特点:<ul>
<li>做一些常人觉得不合常规的事情, 譬如花大代价做无用功, 冒高风险得负收益的事情.</li>
<li>以此打破众人的思维惯性, 表明自己不破不立的决心, 试图引导成新的习惯.</li>
<li>花大代价做无用功, 实则一本万利, 毫无风险. 但效果有限, 只能在普通百姓中取得些许威望.</li>
<li>冒高风险得负收益, 这才是最凶险的一关, 很容易前功尽弃. 过了此关, 才能威慑住真正的对手.</li>
</ul>
</li>
<li>案例分析:<ul>
<li>张牧之上任三把火. 城口杀麻匪, 砍藤放冤鼓, 县衙棒打武智冲.<ul>
<li>制造舆论, 拉拢百姓, 树敌恶霸, 摆明立场.</li>
<li>可惜之前已有五任青天老爷被杀, 所以老百姓并不期待什么. 立威失败.</li>
</ul>
</li>
<li>商鞅变法, 最关键的两处: 徙木立信, 王子犯法与庶民同罪.<ul>
<li>徙木立信. 花大代价做无用功, 是在普通百姓中树立了一言九鼎的威信.</li>
<li>王子犯法与庶民同罪, 将太子老师刺字割鼻. 从此改革畅通无阻, 在达官显贵中树立了威信.</li>
<li>高风险负收益: 对手鼓动太子犯法, 商鞅进退两难. 进, 罚太子得罪皇上. 退, 改革失败身败名裂.</li>
<li>商鞅最后以太子年幼, 过错在于两个老师, 避免得罪皇上, 得以继续改革. 但最终还是因得罪太子被害.</li>
</ul>
</li>
<li>千金马骨. 看似亏本买卖, 实则用五百金做了广告, 省去了大量的人力成本和时间成本.</li>
<li>杀鸡儆猴. 穰苴斩庄贾以徇三军. 以斩杀权贵的方式以示军法严明, 树立了威信.<ul>
<li>高风险负收益: 是猴眼中的高风险. 权贵们一般作威作福惯了, 思维惯性是得罪不起, 不然自身会有破财甚至杀身的风险.</li>
<li>高风险高收益: 是立威信者眼中的高风险. 理论上, 在广为人知的前提下, 风险越大, 成功后树立起的威信就越大, 后续阻力就越小.</li>
</ul>
</li>
<li>汉攻大宛之战, 又称汗血马之战.<ul>
<li>初看是汉武帝为了汗血宝马/天马, 不惜代价的发动了两次战争, 艰难取胜. 似乎是高风险低收益的事情.</li>
<li>实则大宛是鸡, 西域诸国是猴. 这是汉武帝联合西域诸国攻击匈奴整个大战略中, 最重要的一环. 武力证明威信!</li>
<li>大汉此战必须取胜, 否则在西域诸国前期的宣传和投入全部白费, 西域各国将全面倒向匈奴, 大汉对匈奴将被动的转攻为守.</li>
<li>汗血宝马, 在这场战争中根本不值一提. 真正的高收益是: 挖了匈奴的大后方, 变为了自己的左方侧翼.</li>
<li>大宛之战第二次战争途中, 屠城灭轮台国也属杀鸡儆猴, 以示不配合的后果.</li>
</ul>
</li>
<li>失败案例: 蒋经国上海反腐.<ul>
<li>蒋经国是真反腐. 可惜大老板自己的老爹不给力, 非壮士断不了腕.</li>
<li>反腐不了了之后, 贪腐必然更加肆无忌惮. 会加速国民党的经济崩溃.</li>
<li>失败后, 不但前期反腐威信尽失, 还将自己家族贪腐不堪公众化了.</li>
<li>个人认为, 蒋介石在那个节点搞反腐不是时候. 如果成功了, 权贵们便会与中共暗通款曲. 怎么算都是风险大于收益.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="搅局者模式"><a href="#搅局者模式" class="headerlink" title="搅局者模式"></a>搅局者模式</h2><ul>
<li>特点:<ul>
<li>搅局者, 体制的病毒, 潜在的破坏者, 背锅侠.</li>
<li>在和平年代, 搅局者大多承担了极高的风险, 却只有极低的收益. 动乱年代, 则是高风险高收益.</li>
<li>要么是务实的理想主义者, 要么是被利用的天真者. 否则一定会从搅局者演变为投机者, 最终被体制化.</li>
<li>不太计较个人得失, 有为了自己的理想或执念, 坚持到底的信念.</li>
<li>目标必须明确, 这样第三方势力才能预测其行为, 放心的或坐壁上观, 或暗地里拉一把.</li>
<li>补充说明: ‘忍耐’是政治和投资的入门级要求. 局者, 大势也! 逆势而动, 不得好死! 向死而生, 英雄豪杰!</li>
</ul>
</li>
<li>案例分析:<ul>
<li>张牧之. 务实的理想主义者.<ul>
<li>为了理想, 和黄四郎死磕. 惨胜后, 自己的理想也只是昙花一现.</li>
<li>内方外圆, 会利用任何规则, 像现实做必要的妥协, 不择手段.</li>
<li>因为始终盯着黄四郎, 而变弱的黄四郎对刘督统, 城南家族都有好处, 所以他们乐的壁上观虎斗.</li>
</ul>
</li>
<li>毛太祖. 务实的理想主义者.<ul>
<li>从国共对立到国共合作, 能把被扣上的搅局者之锅给甩了!</li>
<li>美苏相斗, 能让棋子蹦出棋盘, 自己找个凳子当玩家! 这局搅的让做局者都想不到.</li>
<li>政治的泰斗级玩家. 放在当代史, 功过三七. 酝酿千年后, 一代雄主.</li>
</ul>
</li>
<li>孙悟空. 被利用的天真者.<ul>
<li>具体分析见参考资料 <em><strong>顾子明闲扯西游记</strong></em>.</li>
</ul>
</li>
<li>海瑞. 被利用的天真者.<ul>
<li>毋庸置疑, 他是一个理想主义者. 但本质上他是一个天真者, 始终没整明白自己为何能高升.</li>
<li>得罪了一大帮人, 却步步高升. 那是因为他有利用价值, 始终有高位参与者在用他下棋.</li>
<li>对高位者而言, 自己在幕后, 海瑞无帮无派, 在前冲锋背锅, 还绝对不会泄密. 无风险高收益, 这么好用的白手套, 哪里去找!</li>
</ul>
</li>
<li>德国.<ul>
<li>在国家经济发展受限之后, 主动充当了世界秩序的搅局者. 引发了二次世界大战.</li>
<li>德国当背锅侠, 引发世界大战后, 混乱就是大家共同的阶梯了.</li>
<li>后起之秀的美国大搞双边投机, 吃饱喝足后, 一次登陆二颗蘑菇, 顺利取代英国, 荣登世界一极.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="趋炎附势者"><a href="#趋炎附势者" class="headerlink" title="趋炎附势者"></a>趋炎附势者</h2><ul>
<li>特点:<ul>
<li>倒向权贵, 想捞点好处, 人之常情.</li>
<li>但最好先想清楚自己能为权贵做什么, 然后再想能捞到多少好处.</li>
<li>政治有风险, 接触需谨慎.</li>
</ul>
</li>
<li>案例分析:<ul>
<li>卖凉粉的. 孙守义, 鹅城中产, 诬陷老六案帮凶.<ul>
<li>其实我挺同情和理解这个人的, 孙守义走的每一步都符合他当时的最佳选择, 但毫无办法的走成了死局.</li>
<li>作为鹅城有衣穿但没权的中产阶级, 讨好本土势力求个良好的经营环境不过分吧?</li>
<li>得罪了武智冲, 根据以往的县长断案, 试图忍耐, 将大事化了, 以保护家庭和小本买卖, 不过分吧?</li>
<li>被逼陷害老六, 作为一个普通人, 还有点钱, 贪生怕死, 不得不合作, 人之常情吧?</li>
<li>被枪指着脑袋, 横竖一死的情况下, 为了家人的安全出卖自己的良心, 有办法谈对错吗?</li>
<li>孙守义, 就这样, 走向了死局. 只是因为他被加入到了政治斗争之中!</li>
</ul>
</li>
<li>鸣冤的. 衣无所有者, 老婆被胡百好透.<ul>
<li>陷害老六的时候, 敲冤鼓的就是这个人. 如果此人是主动的当这个帮凶, 那他的脑子不太好使…</li>
<li>撑死给权贵当个跑腿的, 家里还藏有娇妻. 这狗当的, 必然是赔了夫人又折兵.</li>
</ul>
</li>
<li>女医淳于衍. 卷入宫斗, 毒害许皇后.<ul>
<li>淳于衍求见霍光老婆霍显, 想为丈夫求个官; 霍显要求其帮个忙, 她爽快答应了.</li>
<li>自此, 淳于衍就走上了绝路, 没有任何的回转余地. 因为这个忙是: 毒杀皇后!</li>
<li>不从, 立刻死. 从, 昧着良心以后死. 好死不如赖活着, 她选择了从.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>书籍<ul>
<li>&lt;自私的基因&gt;</li>
<li>&lt;万历十五年&gt;</li>
<li>&lt;资治通鉴&gt;</li>
<li>四大名著. 等等流传百年以上的书籍.</li>
</ul>
</li>
<li>顾子明<ul>
<li><a href="https://freewechat.com/a/MzI5MTY1NDY4OQ==/2247483654/1">深度解读|姜文《让子弹飞》</a></li>
<li><a href="http://www.360doc.com/content/19/0924/14/55082197_862925957.shtml">顾子明|让子弹飞新篇章</a></li>
<li><a href="https://ressrc.com/2019/11/15/gu-ziming-idles-the-journey-to-the-west-1/">顾子明闲扯西游记（一） | 顾子明</a></li>
<li><a href="https://ressrc.com/2019/11/18/gu-ziming-idles-the-journey-to-the-west-2/">顾子明闲扯西游记（二） | 顾子明</a></li>
<li><a href="https://ressrc.com/2019/11/19/gu-ziming-idles-the-journey-to-the-west-3/">顾子明闲扯西游记（三） | 顾子明</a></li>
<li><a href="https://ressrc.com/category/jianwen/guziming/">RESSRC 政事堂 顾子明</a></li>
<li><a href="https://www.wuxiareview.com/category/gzmdzst/">武侠评论 顾子明</a></li>
</ul>
</li>
<li>其它<ul>
<li><a href="https://www.bilibili.com/read/cv1779181/">《让子弹飞》小析——人物篇 一</a></li>
<li><a href="https://www.bilibili.com/read/cv1810695/">《让子弹飞》小析——人物篇 二</a></li>
<li><a href="https://www.bilibili.com/read/cv1972748/">《让子弹飞》小析——人物篇 三</a></li>
<li><a href="https://zhuanlan.zhihu.com/xyj-cao">西游记释疑 - 曹不空</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32672726">重复博弈策略：做好人，还是做坏人？</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>万年歌, 马前课, 梅花诗, 推背图 (上)</title>
    <url>/2021/03/05/2107-tuibeitu1/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
<li><a href="https://draapho.github.io/2021/03/05/2107-tuibeitu1/">万年歌, 马前课, 梅花诗, 推背图 (上)</a></li>
<li><a href="https://draapho.github.io/2021/03/18/2108-tuibeitu2/">万年歌, 马前课, 梅花诗, 推背图 (下)</a></li>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/26/2123-caseofsatori/">见性者体验收集</a></li>
</ul>
<p><em><strong>转载自 <a href="https://www.youtube.com/c/%E5%A4%A7%E9%87%91%E4%BA%BA/videos">大金人 - YouTube</a></strong></em>, 略有删改.</p>
<hr>
<h1 id="推背图之考证"><a href="#推背图之考证" class="headerlink" title="推背图之考证"></a>推背图之考证</h1><ul>
<li>视频资料:<ul>
<li><a href="https://www.youtube.com/watch?v=igWxd6ZThdw">推背圖之考證閒談 第一集(1/3)</a></li>
<li><a href="https://www.youtube.com/watch?v=tFy3kjqcMks">推背圖之考證閒談 第二集(2/3)</a></li>
<li><a href="https://www.youtube.com/watch?v=EcS-9bIhiVc">推背圖考證與閒談 第三集(3/3)</a></li>
</ul>
</li>
<li>推背图有非常多的版本流传于世, 研究最多的是金批本推背图. 这里也都是基于金批本推背图进行研究的</li>
<li>推背图三个字, 最早出现在唐代武则天时期的《大云经疏》.<ul>
<li>其敦煌本抄本有内容如下:<br><code>按《推背图》曰: 大蓄八月，圣明运翔。止戈昌，女主立正起唐唐。佞人去朝龙来防，化清四海，整齐八方。</code></li>
<li>《大云经疏》有明显的政治目的. 暗示武则天称帝是天命所归.</li>
</ul>
</li>
<li>《鸡肋编》, 北宋庄绰著.<ul>
<li>提及范仲淹的儿子范纯仁, 被诬告见过《推背图》而有反意. 宋神宗则说:”此书人皆有之, 不足坐也”.</li>
<li>说明《推背图》在那个时期很流行.</li>
</ul>
</li>
<li>《桯史》, 南宋岳柯(岳飞之孙)著  内有一篇 &lt;艺祖禁谶书&gt;.<ul>
<li>现存史料里, 首次提到了《推背图》的作者为唐李淳风.</li>
<li>记载了赵匡胤以推代禁. 让人弄乱次序和内容, 编出上百个版本的《推背图》, 然后秘密流入民间. 真假难辨, 大幅降低《推背图》预言的可信性.</li>
</ul>
</li>
<li>大金人认为《推背图》的作者不是李淳风, 而是托名之作.<ul>
<li>理由是《旧唐书》200卷,《新唐书》225卷, 多有提及李淳风和袁天罡的著作, 但从未提及过《推背图》.</li>
<li>二四十史中的宋史, 是元朝编撰的. 志第一百五十九·艺文五. 出现了《推背图》一书, 无作者.</li>
</ul>
</li>
<li>纵横杂志(1985.2) &lt;李玉琴: 我的皇娘生活&gt;, 李玉琴是溥仪于1943年, 纳的第三位妾.<ul>
<li>提及了溥仪相信《推背图》的预言, 说日本从东边来, 到了鸡年(1945年)就要完蛋了.</li>
</ul>
</li>
<li><strong>1915年, 《中国预言七种》出版, 内涵金批本《推背图》</strong><ul>
<li>因而1915年至今的内容, 是可以用来验证《推背图》的准确性的. 当前, 43象进行中.</li>
<li>这些语言, 只有在要应验的时代很接近的时候, 或是事情已经发生了, 才会让你看出来. 而不会让你很早之前就看出来.</li>
<li>何海鸣, 于《求幸福斋随笔》中提到了自己对新出版的金圣叹《推背图》看法的改变过程, 在解《推背图》过程中, 感叹推背图真是极妙啊. 但当时(1915年)只能分析出中国的威胁会来自日本, 以及日本会受到教训, 解不出更多了.</li>
<li>时光飞逝, 到2020年, 39,40,41,42,43几乎都已经神奇地应验了或正在进行中.</li>
<li>《中国预言七种》, 中华民国四年五月初版. 印刷所:进步书局, 发行所:文明书局和中华书局, 编者:清溪散人.</li>
<li><strong>清溪散人才是关键人物, 七种预言在这本书里面一次出现. 其它六种预言找不到证据与资料来说明何时出现, 如何流传. 因而, 用最严格的逻辑来审视, 1915年之前的内容, 都可以不算应验, 要重点考察的是此年之后的应验情况. 因而, 大金人只重视39象及之后的内容. 39象之前的内容, 当成故事看就好.</strong></li>
<li>《周吕望著乾坤万年歌》, 有四页.</li>
<li>《蜀汉诸葛丞相马前课》, 有七页.</li>
<li>《推背图》. 袁天罡李淳风著, 金圣叹批注, 都是假托古人之名, 不需要相信.</li>
<li>《李淳风藏头诗》, 共八页.</li>
<li>《宋邵康节梅花诗》, 有三页.</li>
<li>《刘伯温烧饼歌》, 六页.</li>
<li>《黄檗禅师诗》, 两页.</li>
<li>最后一页, 署名为1867年的Maeon的一篇英文. 大概讲了一下获得这些预言的奇特过程. (黑人问号脸)</li>
</ul>
</li>
<li>1915年出版的《中国预言七种》, 是目前已知最早的金批本推背图.<ul>
<li>《清稗类钞》, 晚清遗老 徐珂编撰. 1916年由商务印书馆首版, 分48册. 其中的方伎类介绍了乾坤万年歌, 马前课和推背图的部分内容, 和金批本一模一样.</li>
<li>合理推测, 是徐珂在最后时刻看到了《中国预言七种》, 然后将其收入进《清稗类钞》, 而且只收录和清朝有关的内容. 因而无法作为互相印证的证据.</li>
</ul>
</li>
<li>1938年,《中国二千年之预言》 华夏哲理阐微社出版, 著作者:刘伯温等, 批评(批注评论)者:金圣叹.<ul>
<li>出版年份是民国二十七年, 1938年, 第四版. 注意, 是第四版.</li>
<li>和《中国预言七种》是大同小异. 但多了一篇新预言, 名为《最近发现之刘伯温预言》, 即《金陵塔碑文》</li>
<li>后面主要是在解读《金陵塔碑文》, 对此略过. 见 维基百科 <a href="https://zh.wikipedia.org/wiki/%E9%87%91%E9%99%B5%E5%A1%94%E7%A2%91%E6%96%87">金陵塔碑文</a>, 网传版本”金陵塔, 金陵塔”可查的最早时间是2003年6月15日.</li>
</ul>
</li>
<li>1947年7月第一版, 《中国预言八种》 蒋维乔题, 出版者兼补注者: 海宁朱肖琴, 发行所: 上海广益书局.<ul>
<li>其中七种预言, 都是和《中国预言七种》是一样的.</li>
<li>多出了一种《明刘伯温金陵塔藏碑》, 做了注解, 并介绍了此文的身世之谜.</li>
<li>朱肖琴也对金批本《推背图》做了注解, 对刚刚经历过的三十九象, 注解颇多, 感触极深.</li>
<li>朱肖琴从四十象开始, 注解就是空的. 没有经历过, 很难合理的解出来.</li>
</ul>
</li>
<li>《推背图》考证结果:<ul>
<li>《推背图》肯定不是唐袁天罡李淳风所撰, 属于托名之举.</li>
<li>《推背图》可能在宋朝之初已在民间流传, 但随后版本杂乱不一, 不可考.</li>
<li>金批本《推背图》最早出现的时间是: 1915年出版的《中国预言之七种》一书中.</li>
<li>若以托名金圣叹的批注者算起, 预测准确率可以从三十三象算起. 可惜, 此假设不可考.</li>
<li>以最严格的角度来要求, 验证《推背图》预测准确率, 只能看39象及之后的内容.</li>
</ul>
</li>
<li>《中国预言七种》考证结果:<ul>
<li>《中国预言七种》所收录内容, 文体和风格迥异多样. 同一人所出的可能性较小, 收录的可能性较大.<ul>
<li>其意义为: 若是收录, 则预言之间大概率是弱相关的, 可以用来做相互印证之用.</li>
</ul>
</li>
<li>七种预言的作者, 都是托名之举, 勿要当真.</li>
<li><strong>托名之举的铁证, 在开篇《乾坤萬年歌》就明示了. 写的是汉严光注, 但里面的注解明确写出了西晋东晋, 隋唐五代, 一路写到宋元明清. 直到清代才停止注解!</strong></li>
<li>让人不得不浮想联翩, 这篇《乾坤萬年歌》的真正注解, 甚至真正的作者, 就是清溪散人你自己吧?</li>
<li>唯有《推背图》历史上可考, 但作者和批注者都是托名之举. 金批本《推背图》真实的作者和创作时间, 不可考…</li>
</ul>
</li>
</ul>
<h1 id="解读万年歌"><a href="#解读万年歌" class="headerlink" title="解读万年歌"></a>解读万年歌</h1><ul>
<li>资料:<ul>
<li><a href="https://www.youtube.com/watch?v=sI_mBWxoBTY">乾坤萬年歌(上集)</a></li>
<li><a href="https://www.youtube.com/watch?v=TCugoQRAZ0k">乾坤萬年歌(下集)</a></li>
<li>维基文库 <a href="https://zh.m.wikisource.org/zh-hans/%E4%B9%BE%E5%9D%A4%E8%90%AC%E5%B9%B4%E6%AD%8C">乾坤万年歌</a></li>
</ul>
</li>
<li><strong>一兀为君八十载。</strong><ul>
<li>一兀 = 元. 为君八十载: 元朝八十九年, 传十任皇帝.</li>
<li>元朝皇帝在位时间短, 更换频繁. 十载到底算一共十个皇帝, 还是传十任共十一个皇帝, 没有定数. 采用<a href="https://zh.wikipedia.org/wiki/%E5%85%83%E6%9C%9D">维基百科 元朝</a>的记录, 是十一位皇帝.</li>
<li>从汉文化立场看, 要从南宋彻底灭亡的1279年算起, 1279-1368年, 共89年.</li>
<li>这种计算方法在明朝末年, 还会看到一次, 所以是具有一致性的.</li>
</ul>
</li>
<li><strong>淮南忽见红光起。</strong><ul>
<li>元末红巾军起义, 爆发于颍州. 此句依靠地点和名称锁定历史事件.</li>
</ul>
</li>
<li><strong>八只牛来力量大。日月同行照天下。土猴一兀自消除。四海衣冠新彩画。</strong><ul>
<li>八牛 = 朱. 日月 = 明. 1368年是戊申年, 戊为土, 猴年 = 土猴. 一兀消除 = 元朝灭亡</li>
<li>此句依靠姓名, 朝代, 年份锁定历史事件.</li>
</ul>
</li>
<li><strong>三百年来事不顺。虎头带土何须问。</strong><ul>
<li>明朝, 公认为1368-1644的276年. 但1644是崇祯上吊死亡, 南明政权一直持续到1662年. 这样算是294年, 约合三百年. 其算法和”一兀为君八十载”保持一致, 都是基于汉文化本位的.</li>
<li>虎头带土, 寅虎戊土. 戊寅年为1638年, 是一个大灾大乱之年, 内有李自成再度崛起, 外有清兵三路南下. 另一层意会之意为: 大明大而不强, 诸事不顺, 徒有老虎之气象, 实际却灰头土脸.</li>
</ul>
</li>
<li><strong>十八孩儿跳出来。苍生方得苏危困。</strong><ul>
<li>十八孩儿 = 十八子 = 李 = 李自成. 跳 = 古同”逃”. 李自成兵败逃出北京, 最终身亡. 依靠姓名, 关键动作锁定历史事件.</li>
<li>苍生方得苏危困. 李自成兵败后, 清朝大局已定. 百姓摆脱了持续的战乱之苦, 不用当”菜人”和”想肉”了. 缓解了危和困.</li>
</ul>
</li>
<li><strong>相继春秋二百馀。五湖云扰又风颠。</strong><ul>
<li>按照之前的算法, 清朝年代应该是1662-1912年, 共250年. 相继春秋二百余, 怎么算都符合.</li>
<li>随后, 中国持续纷乱, 中外各种势力争逐, 有内战也有外战, 内外交困. 云绕为纷扰之事, 风颠为战乱之事.</li>
<li>注意 “汉朝严光注” 的注解, 一直写到了这里才结束! 注解为: “二百余年指清朝, 自此以后, 事尚未来, 尚待明解”. 这符合《中国预言七种》的出版时间. 1915年之后, 于作者而言, 就是未来之事了.</li>
<li>在这往后的内容, 才能用来验证《周吕望著乾坤万年歌》预测准确性.</li>
</ul>
</li>
<li><strong>人丁口取江南地。京国重新又一迁。</strong><ul>
<li>人 = 介. 丁口 = 石. 蒋介石. 江南地 = 江南. 1927年蒋介石国民革命军攻克南京, 成立南京国民政府. (此解硬凑迹象明显, 差强人意.)</li>
<li>另一解: 人丁口 = 何. 指的是东路军总指挥何应钦. (一般而言, 此人地位不足以用来精确定位.)</li>
<li>重新又一迁. 表明首都/政权迁了两次.<ul>
<li>北洋政府(北京) 重新 国民政府(南京) 第一迁.</li>
<li>国民政府(南京) 重新 中华民国(台湾) 又一迁.</li>
<li>国民政府(南京) 重新 中华人民共和国(北京) 又一迁.</li>
</ul>
</li>
<li>两个又一迁, 同时进行. 对应后面的两分疆界.</li>
</ul>
</li>
<li><strong>两分疆界各保守。更得相安一百九。</strong><ul>
<li>1949年后, PRC和ROC, 两岸局势. 保守和相安, 意味着相互之间不会有大战, 总体是和平稳定的.</li>
<li>从 “更得相安一百九” 开始, 就是未来事件了, 而且是有机会亲证的.</li>
</ul>
</li>
<li><em><strong>此后的解读是彻底的解谜和猜测, 请勿迷信!!!</strong></em></li>
<li><strong>更得相安一百九。那时走出草田来。手执金龙步玉阶。</strong><ul>
<li>可能预判的只有时间了. 名称等其它信息是无从下手的, 只有发生之后才可能正确匹配.</li>
<li>“走出草田来”, 可能是一个名字, 如”苗”, “黄”, 或走字底相关的字. 都有可能, 事前乱猜没意义.</li>
<li>重点是 “一百九”, “那时”, “金龙”.<ul>
<li>金=庚辛, 龙=辰. 金龙 = 庚辰年 = 2060年 或 2120年. 取较近的2060年.</li>
<li>“那时”, 根据上下文解, 就是”相安一百九”之后. 因而一百九之后的年份必须小于2060年.</li>
<li>“一百九”. 基于1949年, 两分疆界开始算起. 两种解法可小于2060年:<ul>
<li>“两分”+”一百九” = 190/2 = 95. 1949+95 = 2044年.</li>
<li>一百九 = 109. 1949+109 = 2058年</li>
</ul>
</li>
</ul>
</li>
<li>事件猜测. 2044年或2058年左右, 两岸结束相安状态. 2060年开始, 成立新政权, 形式变好.</li>
</ul>
</li>
<li><strong>那时走出草田来。手执金龙步玉阶。清平海内中华定。南北同归一统排。谁知不许乾坤久。一百年来天上口。</strong><ul>
<li>事件猜测: 2060年或2120年, 成立新政权. 统一过程为”平定”,”南北同归一统排”; 政权持续时间是”不许久”, “一百年”.</li>
<li>由于需要”平定”, 分了”南北”. 说明金龙年之前是不平定的, 分裂的状态.</li>
<li>由于是”清平海内”, 台湾自古不被中央核心政权划归为”海内”, “南北”也都是基于中国大陆的南北.</li>
<li>“排”意为一个接一个. 也暗示分裂出的主体不止两个, 是多个分散的主体, 依次排列, 形成统一. 一个”归”字, 也体现了非暴力性, 暗含心悦诚服, 主动投靠之意.</li>
<li>综上, 讲述的不会是大陆政权统一台湾政权. 更可能是大陆政权衰落, 已处于割据状态. 只有这样, 统一过程才可能”清平海内”, “南北同归”, “排”. 整个”一统”过程是相对平稳的, 非武力的”中华定”. 政权形式大概率是联邦制, 这样地方割据势力能保留相当大自主权的, 才可能”排”着队”同归”, 符合人性.</li>
<li>政权持续时间: 100年. 2060+100 = 2160年, 生变. 与”天上口”有关, 很可能是”吴”字.</li>
</ul>
</li>
<li>后略……直接分析《万年歌》中万年二字的由来.</li>
<li><strong>行仁行义立乾坤。子子孙孙三十世。我今只算万年终。再复循环理无穷。</strong><ul>
<li>基于金龙的2060年, 把后面出现的年数全部加起来, 再算上”子子孙孙三十世” = (30*30) = 900年</li>
<li>100+290+200+250+200+200+(30*30) = 2140. 因而万年歌往后的预测时间是两千年以上.</li>
<li>反推之, 万年歌开始的时间点是7000多年前, 也就是公元前5000多年. 大概对应的是三皇五帝时期.</li>
<li>这样, 结构上也是工整的. 以第三句”三皇五帝已相承”起算, 以倒数第三句”子子孙孙三十世”结束. 共一万年.</li>
</ul>
</li>
</ul>
<h1 id="解读马前课"><a href="#解读马前课" class="headerlink" title="解读马前课"></a>解读马前课</h1><ul>
<li>视频资料:<ul>
<li><a href="https://www.youtube.com/watch?v=UVfQNyq-jio">馬前課(上集)</a></li>
<li><a href="https://www.youtube.com/watch?v=2uBLWX9Yzko">馬前課(中集)</a></li>
<li><a href="https://www.youtube.com/watch?v=h-b_DNn9_EY">馬前課(下集)</a></li>
<li>维基文库 <a href="https://zh.m.wikisource.org/wiki/%E9%A6%AC%E5%89%8D%E8%AA%B2">馬前課</a></li>
</ul>
</li>
<li>简介<ul>
<li>首次出现于1915年的《中国预言七种》, 因而1915年之后的内容是确定性的预言性质, 至今为止, 全部应验.</li>
<li>总共十四课, 内容简短, 段段分明. 按顺序地, 一课讲述一个朝代或政权.</li>
<li>每课都由六爻卦象, 十六字短诗组成. 后附守元和尚的解释</li>
<li>作者<code>蜀汉诸葛丞相</code>和解注者<code>白鹤山守元</code>, 大概率是托名之举.</li>
</ul>
</li>
<li>第一课: <strong>無力回天 鞠躬盡瘁  陰居陽拂 八千女鬼</strong>  卦象:頤<ul>
<li>“鞠躬尽瘁” = 诸葛亮; “八千女鬼” = “魏”. 三国时期, 蜀败而魏胜.</li>
</ul>
</li>
<li>第二课: <strong>火上有火 光燭中土  稱名不正 江東有虎</strong>  卦象:離<ul>
<li>“火上有火” = 炎; “稱名不正” = 篡夺曹魏; 司马炎篡夺曹魏建立西晋. “江東有虎” = 建都于江东的东晋.</li>
</ul>
</li>
<li>第三课: <strong>擾擾中原 山河無主  二三其位 羊終馬始</strong>  卦象:剝<ul>
<li>五胡十六国乱世. “羊終馬始” = 始于晋朝的司”马”家, 终于杨(谐音”羊”)坚建立隋朝.</li>
<li><strong>注: 马前课出现了谐音用法, 不等于其它预言也能乱用谐音! 每个预言都有自身的规范, 需要用已经发生的事件去挖掘出这些规范, 方可应用到后面的预言中.</strong></li>
</ul>
</li>
<li>第四课: <strong>十八男兒 起於太原  動則得解 日月麗天</strong>  卦象:解<ul>
<li>十八男儿 = 十八子 = 李. 李氏于太原起兵, 方可得解脱困, 建立大唐盛世.</li>
</ul>
</li>
<li>第五课: <strong>五十年中 其數有八  小人道長 生靈荼毒</strong>  卦象:否<ul>
<li>五代十国大乱. 从907年朱温称帝到960年赵匡胤黄袍加身, 共53年. 有八个姓氏的人当上皇帝, 皆为短命王朝.</li>
</ul>
</li>
<li>第六课: <strong>惟天生水 順天應人  剛中柔外 土乃生金</strong>  卦象:兌<ul>
<li>宋朝. “剛中柔外” 指政治上, 对内部百姓采用镇压政策, 对外敌打不过, 用怀柔政策. “金”为金国. 属土的金朝 克 属水的宋朝.</li>
<li>《推背图》第十六象有: “天一生水  順天應人”, 只有一字之差.<ul>
<li>抄袭? 碰巧? 同一个作者?</li>
</ul>
</li>
</ul>
</li>
<li>第七课: <strong>一元复始 以刚处中  五五相传 尔西我东</strong>  卦象:井<ul>
<li>元朝, 以武力治天下, 传十代, 分为四大汗国.</li>
<li>《推背图》第二十五象有: “子子孙孙五五宜”, 再一处类似的写法.</li>
</ul>
</li>
<li>第八课: <strong>日月麗天 其色若赤  綿綿延延 凡十六葉</strong>  卦象:益<ul>
<li>日月 = 明, 赤色 = 朱. 朱元璋建立明朝, 共十六位皇帝.</li>
<li>《推背图》第四十四象有: “日月麗天”. 一模一样, 语出易经, 不稀罕.</li>
<li>《推背图》第二十七象有: “其色曰赤”. 用词为什么几乎一样? 也都是讲的明朝.</li>
</ul>
</li>
<li>第九课: <strong>水月有主 古月為君  十傳絕統 相敬若賓</strong>  卦象:晋<ul>
<li>水月有主 = 清. 古月=胡, 胡人为君. 十传=传了十任, 加上开国皇帝皇太极, 共十一任.</li>
<li>绝统. 统可以有多解. 结束于年号”宣统”; 清朝结束”统治”; 家天下的”传统”, 王朝模式终结.</li>
<li>相敬若宾. 相对于之前的皇帝, 国民政府对清朝王室成员非常地优待. 与过往不同, 值得一提.</li>
</ul>
</li>
<li>第十课: <strong>豕後牛前 千人一口  五二倒置 朋來無咎</strong>  卦象:蹇<ul>
<li>豕後牛前 = 1912年鼠年, 清帝退位, 共和政府成立, 中华民国元年.</li>
<li>千人一口 = 和, 特别强调了全新的政治制度为: 共和制.</li>
<li>五二倒置 = 25. 基于豕後牛前的1912, 加上25为1937年, 中日战争爆发.</li>
<li>朋来无咎 = 和美英苏结盟, 最终抗战胜利, 国家得保成为战胜国之一.<ul>
<li>蹇卦第五爻爻辞为 <code>大蹇朋来</code>, 因而朋来取字爻辞.</li>
</ul>
</li>
<li>卦象为蹇. 蹇 = 寒足, 在寒冷之地前行. 易经的解为: 踏步难行, 艰辛万苦, 进退维谷, 容忍待时. 蹇卦的九五就是大蹇朋来!<br>在朋友帮助下走出困境.</li>
</ul>
</li>
<li>第十一课: <strong>四門乍辟 突如其來  晨雞一聲 其道大衰</strong>  卦象:離<ul>
<li>四门乍辟. 出处和典故:<ul>
<li>&lt;史记 五帝本记&gt;: <code>宾于四门, 四门穆穆, 诸侯远方宾客皆敬</code></li>
<li>其实来自于更远古的 &lt;尚书 舜典&gt;: <code>宾于四门, 四门穆穆</code> 以及 <code>询于四岳, 辟四门, 明四目, 达四聪</code>.</li>
<li><code>辟四门</code> 就被后世多有引用: 如&lt;汉书 梅福传&gt;; &lt;后汉书 曹世叔妻&gt;; 唐代孙逖 <code>方巡五年狩，更辟四门聪</code>等.</li>
<li><code>辟四门</code> 就是 <code>四门乍辟</code> 的出处了. <strong>这里的<code>四门</code>特指<code>明堂四方的门</code></strong></li>
</ul>
</li>
<li>什么是<code>明堂</code><ul>
<li>明堂是天子举行朝会与祭祀的地方. 整体建筑风格为内圆外方.</li>
<li>俯视看名堂, 其图形就和孔方兄类似. 可参考 <a href="https://jbh.17qq.com/article/hhbhhogfz.html">明堂复原图</a></li>
</ul>
</li>
<li>明堂四门乍辟 = 共 = 共产党, 共和国<br><img src="https://draapho.github.io/images/2107/gong.png" alt="gong.png"><ul>
<li>解法不唯一, 欢迎其它更好的,更合理的解读.</li>
</ul>
</li>
<li>突如其来.<ul>
<li>解释一, 字面理解. 即势头很猛, PRC快速击溃ROC, 占领中国大陆建立新中国.</li>
<li>解释二, 配合离卦来解. 离卦爻辞内就含有<code>突如其来</code><ul>
<li>同卦相叠, 离上离下, 离为火.</li>
<li>&lt;易经&gt;对离卦的解: 外观极盛一切顺利, 但可能为假象虚象. 双火之烈, 如烈日中天; 双火之燃, 内部已有损. 劝告为凡事宜守之, 勿太急进. (正是当前国强民弱, 国进民退之象)</li>
<li>离卦第四爻爻辞为 <code>九四, 突如其来如, 焚如, 死如, 弃如</code>. 描述的是火势突然, 让人反应不及, 熊熊燃烧, 吞没一切.</li>
<li>另一种解释, 来自<a href="https://www.eee-learning.com/book/neweee30">易學網</a>. <code>突如其来如, 焚如</code>是形容九四气焰嚣张, 有如烈火, 直扑六五而去, 六五为柔弱之君王. 因而讲的的是造反逼宫. 对应于毛之勇猛, 蒋之柔弱.</li>
<li>进一步理解的话, 突如其来指的不但是建国的过程, 也暗示着结束的过程. 来时凶猛, 去时突然.</li>
</ul>
</li>
<li>解释二明显是更合理的. 原因是第十课里,<code>朋来无咎</code>就使用了卦象里的爻辞, 这里很可能继续采用了这种方法.<ul>
<li>马前课之前一个离卦在第二课, 讲的是司马炎篡夺曹魏建立西晋.</li>
</ul>
</li>
</ul>
</li>
<li>因而, <code>四門乍辟 突如其來</code> 讲的是中华人民共和国建国.</li>
</ul>
</li>
<li><em><strong>此后的解读是彻底的解谜和猜测, 请勿迷信!!!</strong></em><ul>
<li>晨鸡一声. 基本就是一个时间定位点. 两种解法.<ul>
<li>字面含义: 鸡年: 2029, 2041, 2053年.</li>
<li><code>辰</code>通<code>晨</code>, 讲的是辰年: 2024, 2036, 2048年.</li>
</ul>
</li>
<li>其道大衰. 暗示之前非常强盛, 才有可能大衰. 并非灭亡, 而是大大地衰落了.</li>
</ul>
</li>
<li>第十二课: <strong>拯患救難 是唯聖人  陽復而治 晦極生明</strong>  卦象: 大過<ul>
<li>这一课比较特别, 看上去没有什么明显的定位信息, 全都是直白的事件描述.</li>
<li>拯患救难 是唯圣人. 出圣人, 救民于患难.</li>
<li>阳复而治 晦极生明. 大衰至极后, 开始阳复生明, 大治.</li>
<li><code>明</code>是个潜在的定位点. 与此对应的是《推背图》第四十四象谶曰: <code>日月丽天</code>, 同样是个<code>明</code>字.</li>
</ul>
</li>
<li>第十三课: <strong>賢不遺野 天下一家  無名無德 光耀中華</strong>  卦象: 大畜<ul>
<li>天下大同. 与此对应的是《推背图》第五十九象.</li>
<li>看起来是跳跃了很多年代, 应该是很久很久以后的事情吧.</li>
</ul>
</li>
<li>第十四课: <strong>占得此課 易數乃終  前古後今 其道無窮</strong>  卦象: 未濟<ul>
<li>与此对应的是《推背图》第六十象.</li>
<li>世道兴衰, 无穷无尽.</li>
</ul>
</li>
<li>回看, 守元和尚在第九课处的解: <code>水月有主清也, 古月胡也... 老僧生于嘉靖十年, 今年八十有六, 过此以后不敢妄议.</code><ul>
<li>明朝嘉靖十年为1532年 + 86 = 1618年, 即万历46年, 为明朝末期</li>
<li>1618年, 努尔哈赤建立后金政权, 正式起兵反明. 此时国号是<code>金</code>, 不是<code>清</code>. 还要再过18年, 于1636年皇太极才改国号为<code>大清</code></li>
<li>虽说水月有主解出清字不难, 守元和尚毕竟说的极其顺口且肯定, 故有此一疑. 守元和尚也很可能是托名之举.</li>
<li>结合最后的<code>八六老僧白鹤山守元志</code>, 倾向于认为是清朝末年民国初期的一位神秘作者所出, 他籍由诸葛孔明的名号, 加上占卜法马前课(小六壬)的名号, 再加上白鹤山僧守元的名号组合架构, 编辑出版而来.</li>
<li>作者借由守元的解, 在文末直接指明了文章的结构是 <code>一课指一朝</code>, 并叹到<code>天道循环, 明者自明, 昧者自昧</code>.</li>
<li>托名的目的: 自己大隐, 书籍能迅速出名, 广为流传.</li>
</ul>
</li>
</ul>
<h1 id="解读梅花诗"><a href="#解读梅花诗" class="headerlink" title="解读梅花诗"></a>解读梅花诗</h1><ul>
<li>视频资料:<ul>
<li><a href="https://www.youtube.com/watch?v=lwr4X1mWONE">梅花詩(上集)</a></li>
<li><a href="https://www.youtube.com/watch?v=urgRyA9OYTM">梅花詩(中集)</a></li>
<li><a href="https://www.youtube.com/watch?v=MJdZFChHXyw">梅花詩(下集)</a></li>
<li>维基文库 <a href="https://zh.m.wikisource.org/zh-hans/%E6%A2%85%E8%8A%B1%E8%A9%A9">梅花诗</a></li>
</ul>
</li>
<li>简介<ul>
<li>首次出现于1915年的《中国预言七种》, 因而1915年之后的内容是确定性的预言性质, 至今为止, 全部应验.</li>
<li>作者 <code>宋邵康节先生</code> 应是托名之举. 邵康节即北宋五子之一的邵雍, 是承先启后的易学超级大师. 最有名的著作是《皇极经世》.《梅花易数》和《铁板神数》也相传是邵雍所著. 因为著名, 才可能被托名.</li>
<li>共有史章, 每章七言四句二十八字, 没有搭配易卦. 文字比较浅显.</li>
<li>书中的圆括号内是注解内容, 注解者为《中国预言七种》的编者, 清溪散人.</li>
</ul>
</li>
<li>其一 <strong>荡荡天门万古开，几人归去几人来。山河虽好非完璧，不信黄金是祸胎。</strong><ul>
<li>讲的是北宋.</li>
<li>山河虽好非完璧: 指的是北宋一百六十七年, 一直没能拿下燕云十六州.</li>
<li>不信黄金是祸胎: 指出了金朝才是真正的威胁, 但北宋一开始在联金灭辽. 最终有了靖康之耻, 北宋被金所灭.</li>
</ul>
</li>
<li>其二 <strong>湖山一梦事全非，再见云龙向北飞。三百年来终一日，长天碧水叹弥弥。</strong><ul>
<li>讲的是南宋.</li>
<li>湖山一梦事全非. 南宋以临安(今浙江杭州)为都城. 相比于北宋: 湖光山色, 繁华逍遥, 偏安一隅, 醉生梦死, 人事全非.</li>
<li>再见云龙向北飞. 此句关键是一个再字.<ul>
<li>北宋时, 金国南下掳走了徽钦二帝. 可谓双龙北去.</li>
<li>南宋灭亡前, 1276年, 元军兵临临安城下, 谢太后求和不成, 带着5岁的宋恭帝投降. 然后, 宋恭帝被忽必烈封为瀛国公, 让他搬家北上.</li>
<li>再见云龙向北飞, 整句讲的就是宋恭帝投降北上的故事.</li>
</ul>
</li>
<li>三百年来终一日, 长天碧水叹弥弥. 宋朝国祚三百一十九年, 以陆秀夫背幼主赵昺投海自尽. 这个终一日, 就是面对长天碧水, 叹弥弥.</li>
<li>过度解读: 南宋最后三个皇帝赵显, 赵昰, 赵昺都有个日字. 宋朝终于一日.</li>
</ul>
</li>
<li>其三 <strong>天地相乘数一原，忽逢甲子又兴元。年华二八乾坤改，看尽残花总不言。</strong><ul>
<li>天地相乘数一原. 指天干地支又一个轮回开始了. 即甲子年.</li>
<li>忽逢甲子又兴元. 明示了甲子年, 元朝兴起.<ul>
<li>忽必烈于1271年(辛未年)改大蒙古国国号为大元, 这一年不是甲子年. 但说的是<code>兴元</code>, 而不是<code>建元</code></li>
<li>七年前的1264年是甲子年, 是忽必烈最为关键的一年. 蒙古国争夺大汗之位的内战结束了. 忽必烈在1264年9月7日发布《至元改元诏》为至元元年. 是为<code>甲子兴元</code></li>
</ul>
</li>
<li>年华二八乾坤改, 看尽残花总不言. 二八=两个八. 元朝持续八十八年后, 改朝换代, 残花乱世, 不堪言, 不堪言.</li>
</ul>
</li>
<li>其四 <strong>毕竟英雄起布衣，朱门不是旧黄畿。飞来燕子寻常事，开到李花春已非。</strong><ul>
<li>描述明朝的大白话.</li>
<li>英雄起布衣. 朱元璋出身低微. 旧黄畿,</li>
<li>朱门不是旧黄畿. 点明了朱姓. 元朝的黄畿是大都(今北京), 朱元璋奠都于今天的南京, 因而<code>不是旧黄畿</code>.</li>
<li>飞来燕子寻常事. 燕王朱棣成为明成祖永乐皇帝.</li>
<li>开到李花春已非. 定位于李自成, 灭明.</li>
</ul>
</li>
<li>其五 <strong>胡儿骑马走长安，开辟中原海境宽。洪水乍平洪水起，清光宜向汉中看。</strong><ul>
<li>讲的是清朝. 大金人的解法和清溪散人的注解有所不同.</li>
<li>胡儿骑马走长安. 指清兵入关. 此句没有疑义.</li>
<li>开辟中原海境宽.<ul>
<li>清溪散人注解为<code>夷人通商</code>; 这样解, 讲的就是清朝后期的事. 而且从汉本位立场来理解<code>海境宽</code>是被海上来的夷人通商, 是无法合理解释<code>开辟中原</code>四个字的.</li>
<li>大金人认为此句的立场是从骑马胡儿, 清军入关的角度来写的. 讲的是满蒙征服者入主中原, 占领了整个沿海区域, 建立清朝. 只有这样理解, 才讲的通<code>开辟中原</code>. 时间上也紧接着清兵入关, 讲的是清兵占领汉文明全境.</li>
</ul>
</li>
<li>洪水乍平洪水起<ul>
<li>清溪散人注解为:洪秀全+黎元洪.</li>
<li>大金人认为: 战乱如同洪水一般, 一波未平一波又起. 洪秀全太平天国只是多波冲击的起点. 列举如下:<ul>
<li>1851-1864, 太平天国</li>
<li>1851-1868, 捻军捻乱</li>
<li>1856-1860, 英法联军</li>
<li>1864-1877, 新疆回变</li>
<li>1894-1895, 甲午战争</li>
<li>1899-1901, 拳匪义和团</li>
<li>1900, 八国联军</li>
</ul>
</li>
</ul>
</li>
<li>清光宜向汉中看<ul>
<li>清溪散人注解为:辛亥八月武昌起义.</li>
<li>大金人认为, 武昌起义是其六<code>漫天一白汉江秋</code>写的事情. 而且汉中不太可能指武汉武昌地区, 古文写汉中, 那就是汉中地区, 指的是四川陕西交界处的一块区域, 大致相当于如今的汉中市地区. 综上结论就是: 这一句讲的不是武昌起义!</li>
<li>随着<code>洪水乍平洪水起</code>的一波波叛乱, 最后八国联军攻陷北京. 此时光绪皇帝和慈禧太后逃亡西安避难去了. <code>清光</code>指的就是清光绪帝, 然后从北京向汉中看, 西安就在这条直线的终点附近.</li>
<li>故大金人的解, <code>清光宜向汉中看</code>指的是光绪慈禧, 出逃西安这个事件. 这是清末大溃败的一个最高潮. 而这里不直接写长安(今西安), 很可能是因为第一句里<code>胡儿骑马走长安</code>就把长安用掉了. 因而写的是从京城往汉中看去, 往西南方向逃.<br><img src="https://draapho.github.io/images/2107/hanzhong.png" alt="hanzhong.png"></li>
<li>这一句只有这样解才最合理, 若解为武昌起义, 不但汉中的用法不符合习惯用法, 而且和后面一章重复. 结构上无美感又无意义的重复, 不符合惜字如金的古文习惯.</li>
</ul>
</li>
</ul>
</li>
<li>其六 <strong>漫天一白汉江秋，憔悴黄花总带愁。吉曜半升箕斗隐，金乌起灭海山头。</strong><ul>
<li>讲的是中华民国. 此章之后, 开始真正考验《梅花诗》预言的准确率.</li>
<li>漫天一白汉江秋.<ul>
<li>庚辛属金, 其所属颜色是白色, 金色或银灰色. 因而, <code>白</code>字暗示了这一年的天干是庚或辛. 正巧, 1911年起的辛亥革命, 天干是辛.</li>
<li>漫天一白有其典故, 出自唐朝李贺的《致酒行》有<code>雄鸡一声天下白</code>. 这里可以比喻成晦去明至, 延续千年的集权帝制就此结束. 未来充满了新的希望.</li>
<li>武昌武汉就是在长江, 十月十日是秋天, 推翻满清的是汉人. 这些都浓缩在<code>汉江秋</code>三个字里了.</li>
<li>整句讲的就是1911年10曰10日的武昌起义为开端, 爆发辛亥革命.</li>
</ul>
</li>
<li>憔悴黄花总带愁.<ul>
<li>清溪散人的注解点出了<code>黄兴</code></li>
<li>同时也点出了黄花岗七十二烈士的著名革命事件.</li>
<li>还点出了中华民国成立后的特质: 内忧外患. 故而总是憔悴并带着忧愁.</li>
</ul>
</li>
<li>说到花, 梅花诗里提到了各种花. 归纳如下:<ul>
<li>其三(元): <code>看尽残花总不言</code></li>
<li>其四(明): <code>开到李花春已非</code></li>
<li>其六(民国): <code>憔悴黄花总带愁</code></li>
<li>其九(未来): <code>一院梨花春有主</code></li>
<li>其十(未来): <code>数点梅花天地春</code></li>
</ul>
</li>
<li>吉曜半升箕斗隐<ul>
<li>曜就是日光, 光芒. 指的就是民国的青天白日旗.</li>
<li>吉曜半升. 虽是吉曜, 美中不足, 只能半升.</li>
<li>特别说明一下. 1915年此书出版时, 中华民国的国旗时五色旗, 直到1928年才启用了青天白日旗. 因而这句对应的是1928年以后的事请.</li>
<li>箕斗隐. 是一个双关语.<ul>
<li>第一层, 箕和斗, 讲的是古代天上的星星的.</li>
<li>箕斗隐非常形象地说明了很多星星就躲在半升的晴天白日之后. 五角星就是中国共产党的标志. 暗喻了共产党对国民党的渗透和潜在威胁.</li>
<li>第二层, 这么多星宿, 为何特用箕斗?</li>
<li>箕斗语出《诗经 小雅 大东》: <code>维南有箕 不可以簸扬 维北有斗 不可以挹酒浆</code>; 《魏书 卷六六 李崇传》: <code>何异兔丝燕麦，南箕北斗哉!</code> 此典故多用于比喻徒有虚名的人或事物.</li>
<li>好一个徒有虚名, 正是对中华民国的真实写照! 当时的国民政府只是名义上的大一统政府, 本质上是军阀割据, 是为有名无实.<br><img src="https://draapho.github.io/images/2107/jidou.png" alt="星宿图.png"></li>
</ul>
</li>
</ul>
</li>
<li>金乌起灭海山头<ul>
<li>金乌, 太阳的别名. 此处指日本.</li>
<li>日本崛起, 跨海侵华, 最终失败.</li>
</ul>
</li>
</ul>
</li>
<li>其七 <strong>云雾苍茫各一天，可怜西北起烽烟。东来暴客西来盗，还有胡儿在眼前。</strong><ul>
<li>讲的是中华人民共和国.</li>
<li>云雾苍茫各一天.<ul>
<li>抗日战争结束后, 国共内战四年. 国民党败逃台湾, 两岸隔海相望, 各有一片天地.</li>
<li>云雾苍茫直接点明了不会是划江而治, 而是海峡两岸. 是一种云里雾里, 看不真切的感觉.</li>
</ul>
</li>
<li>可怜西北起烽烟。东来暴客西来盗，还有胡儿在眼前。<ul>
<li>讲的是中共建国初期, 总体环境很不好, 内忧外患.</li>
<li>可怜西北起烽烟. <code>可怜</code>二字就只能是处于弱势的新疆了. 新疆暴乱闹独立问题.</li>
<li>东来暴客西来盗. 东边的朝鲜战争, 西边的中印自卫反击战. <code>暴客</code>指的是韩国有请美国前来帮忙, <code>盗</code>字描述了印度的蚕食策略, 用词精妙.</li>
<li>还有胡儿在眼前. 胡儿, 中原文明对于北方民族的习惯性称呼. 中苏交恶.</li>
</ul>
</li>
<li>另一种看法认为, 后三句不但讲了建国初期已经发生的事情, 未来的衰落过程中还会再发生一次.</li>
</ul>
</li>
<li><em><strong>此后的解读是彻底的解谜和猜测, 请勿迷信!!!</strong></em></li>
<li>其八 <strong>如棋世事局初残，共济和衷却大难。豹死犹留皮一袭，最佳秋色在长安。</strong><ul>
<li>大概率讲的是中华人民共和国的衰落过程. 将中华人民共和国分七八两章来讲, 没有问题.</li>
<li>这种结构篇首就出现过. 第一章讲了北宋, 第二章讲了南宋. 但宋朝是一整个连续的朝代.</li>
<li>如棋世事局初残，共济和衷却大难.<ul>
<li>共济和衷: 大概率, 就是指中华人民共和国.</li>
<li>局初残. 盛极而转衰. 能挖的潜力, 能调用的资源不多了, 没有那么多棋子和韭菜了.</li>
<li>共济和衷却大难. 共济和衷, 很可能是一种政治号召和措施, 希望的目的是共克难关, 导致的结果是形式急转直下, 大难临头.</li>
</ul>
</li>
<li>豹死犹留皮一袭.<ul>
<li>经此一难, 对全国进行中央集权的实力是没有了, 是为<code>豹死</code></li>
<li>本质上缩小为一个地方政权, 但名义上的全国统一和国号还在, 是为<code>犹留皮一袭</code></li>
</ul>
</li>
<li>最佳秋色在长安.<ul>
<li>点明了有实际控制力的区域仅限于<code>长安</code>. 长安可泛指政治中心, 也可特指西安.</li>
<li>结合《推背图》的<code>称王只合在秦州</code>, 倾向于特指西安. 势力范围局限在有红色传统的陕甘宁地区.</li>
</ul>
</li>
</ul>
</li>
<li>其九 <strong>火龙蛰起燕门秋，原璧应难赵氏收。一院梨花春有主，连宵风雨不须愁。</strong><ul>
<li>火龙蛰起燕门秋.<ul>
<li>蛰起. 就是<code>起蛰</code>. 指的是惊起蛰伏的虫或兽. 比喻隐逸的贤才出为世用.</li>
<li>火龙. 自然会按照年份来推测. 火为丙或丁, 龙为辰. 对应丙辰年, 2036年或2096年.</li>
<li>燕门. 如果按地点来解, 可能指历史上的燕门郡, 为赵武灵王所设, 在今山西代县西北.</li>
<li>猜测: 此句点明了某时某地会出一个圣人, 来解决第八章的残局.</li>
</ul>
</li>
<li>原璧应难赵氏收.<ul>
<li>明显出自典故, 完璧归赵. 这里是说, 原璧归不了赵了.</li>
<li>有个比较有意思的对应, 网络用语<code>赵家人</code>, 在这里倒也非常地契合.</li>
<li>解析一: 中共大难之后, 国家政权回不到中央集权制了.</li>
<li>解析二: 和氏璧, 通常被引申为中原主要政权. 对中华人民共和国而言, 原璧就是之前的中华民国, 现偏安于台湾. 这样解的话就是: 台湾不是被中共(赵氏)收回去的.</li>
</ul>
</li>
<li>一院梨花春有主.<ul>
<li>这里确定是<code>梨花</code>而不是网络上流传的<code>奇花</code>.</li>
<li>有散落的许多梨花, 共处一院, 共有一主. 如果是政治制度, 大致是联邦制.</li>
</ul>
</li>
<li>连宵风雨不须愁.<ul>
<li>虽说还会有所波折, 但总体上不用担心和忧愁.</li>
</ul>
</li>
</ul>
</li>
<li>其十 <strong>数点梅花天地春，欲将剥复问前因。寰中自有承平日，四海为家孰主宾。</strong><ul>
<li>做了一个总结和结尾. 强调了世事循环往复. 天下大同之日, 自会到来.</li>
<li>欲将剥复问前因. 剥卦为阴盛阳衰, 复卦为阴极而阳复. 因而<code>剥复</code>用来形容盛衰, 消长, 循环往复.</li>
<li>寰中自有承平日. 天下承平, 世界大同这么一天自然是有的, 急是急不来的.</li>
<li>四海为家孰主宾. 即无名无德, 无尔无我, 天下一家, 治臻大化.</li>
</ul>
</li>
</ul>
<hr>
<p><em><strong>转载自 <a href="https://www.youtube.com/c/%E5%A4%A7%E9%87%91%E4%BA%BA/videos">大金人 - YouTube</a></strong></em>, 略有删改.</p>
<p>未完待续, 接 <a href="https://draapho.github.io/2021/03/18/2108-tuibeitu2/">万年歌, 马前课, 梅花诗, 推背图 (下)</a></p>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>天赐问答7</title>
    <url>/2021/04/20/2117-answer7/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/14/2111-answer1/">天赐问答1: 知行合一, 方为真知.</a></li>
<li><a href="https://draapho.github.io/2021/04/15/2112-answer2/">天赐问答2: 总是拖延, 该怎么办?</a></li>
<li><a href="https://draapho.github.io/2021/04/16/2113-answer3/">天赐问答3: 凡夫一向动, 小乘一向静</a></li>
<li><a href="https://draapho.github.io/2021/04/17/2114-answer4/">天赐问答4: 烦恼名众生, 悟解名菩提</a></li>
<li><a href="https://draapho.github.io/2021/04/18/2115-answer5/">天赐问答5: 如何放下对结果的期待</a></li>
<li><a href="https://draapho.github.io/2021/04/19/2116-answer6/">天赐问答6: 为什么真正的境界不会退转?</a></li>
<li><a href="https://draapho.github.io/2021/04/20/2117-answer7/">天赐问答7: 为什么开悟的似乎都是男人, 女人呢?</a></li>
<li><a href="https://draapho.github.io/2021/04/21/2118-answer8/">天赐问答8: 男女欲望该怎么处理?</a></li>
<li><a href="https://draapho.github.io/2021/04/22/2119-answer9/">天赐问答9: 不完美, 才会独一无二</a></li>
<li><a href="https://draapho.github.io/2021/04/23/2120-answer10/">天赐问答10: 不要辜负你的生命</a></li>
<li><a href="https://draapho.github.io/2021/04/24/2121-answer11/">天赐问答11: 100多年前的马克思主义, 过时了吗?</a></li>
<li><a href="https://draapho.github.io/2021/04/25/2122-believe/">我们到底该信什么，不该信什么？</a></li>
</ul>
<p>以上所有内容, 皆转载自微信公众号: 自愈之光<br>此系列为灵天赐入道开悟后的资料收集.</p>
<hr>
<h1 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h1><p><em><strong>天赐老师您好! 关注您在知乎上的回答有一年多时间了，也一直关注您和吴光磊老师的微信公众号，从中学习了很多东西! 很荣幸有这样的机会向您直接提问。自己是一位非常自律和理性的人，自律到自己能够独立完成的事情，基本上都可以，从基本上不锻炼，到1年内跑完全马，从体重超重严重，到两年内基本上每个月匀速降低体重一斤，两年体重下降25斤，学习工作生活上，也基本上如此。但是这样自律和理性的一个坏处是，我其实并没有想清楚甚至根本没有想过自己真正想做什么，自己内心深处的真正召唤是什么，而是需要做什么，什么利益最大化就去做什么，什么有助于自己长期生活质量提高就做什么。但是这样就像您在第二次问答中提到过的，我越来越意识到我错过的，可能远远大于自己最初想象的。我可能已经失去了把内在闪光具现化到现实的机会。目前自己已经工作很多年，整个生活已经相对固化，按照世俗观点，还算过的不错，自己当然还是继续在拼命的努力工作和生活，但是现在的自己，和还在大学时候，和刚刚毕业时候完全不同。不可能再去对人生做出很大改变，像我这样的情况，您觉得还有没有可能找到自己真正有极大热情的人生方向，还有没有可能响应生命对自己的召唤? 如果可能，应该怎么去寻找? 谢谢天赐老师! 感恩!</strong></em></p>
<p>答：很多人和你一样，容易陷入某个误区。</p>
<p>认为，在某个地方，存在一种更好的生活状态。</p>
<p>为了到达那种生活状态，你必须舍弃当下，才能进入那个状态中。</p>
<p>其实，这是一种错误的思考。</p>
<p>对你自己寻找到人生的最高价值，是一种极大的阻碍。</p>
<p>举一个例子，你减肥，并不是只靠自律与努力做到的。</p>
<p>你不喜欢当前的‘肥胖’的状态，于是你热爱减肥，为了减肥而学习和研究各种事情。</p>
<p>一直持续下去，便自然而然的减肥成功。</p>
<p>只是依靠自虐式的‘自律’和‘努力’，来压抑欲望。</p>
<p>你的减肥，肯定是不会成功的。</p>
<p>最多，只是短暂的成功。</p>
<p>你的成功，主要来自于你转变了自己过去的认知模式，从而对当前的存在状态，产生了一种强烈的出离心。</p>
<p>你发自内心的，再也不喜欢肥胖的状态。</p>
<p>这，就是决心。</p>
<p>你减肥，显然也见过很多减肥失败，减肥半途而废的。</p>
<p>虽然，每一个人嘴上都在说同样的事情，都说他们不喜欢肥胖。</p>
<p>事实上，只有真正下定决心，真正对当前生活状态有了出离心，真正开始从头到尾完全改变自己的人，才会是减肥成功的少数。</p>
<p>而你，显然并不如你自己认为的那么自律和理性。</p>
<p>你想想，如果你真是‘极其自律’和‘理性’的人，你甚至都不会允许自己的体重超标的。</p>
<p>你不仅超标了，还经历了一个从肥胖到廋下来的过程。</p>
<p>这个过程与你所取得结果，本是一种对生活的热爱所驱动，而不仅仅只是所谓的‘自律’。</p>
<p>你热爱一种更健康的生活方式，热爱一种更美好的存在状态。</p>
<p>于是，你真正下定决心去做，自然也就做到了。</p>
<p>找寻自己的热爱，不是一定要放弃你当前的什么。</p>
<p>那是一种执着。</p>
<p>若你真的放弃了对你当前生活支撑的工作，或者别的什么。</p>
<p>你就会对你的热爱，开始抱有期待。</p>
<p>你会迫切期待你的热爱，必须向你马上展现出效果。</p>
<p>或者，至少向你展现出，和你所放弃的东西同等程度的回报。</p>
<p>这些都是强求，这种心急的状态，会为你关闭那扇无限可能性的大门。</p>
<p>因为，原本出乎你意料的未来，因为你太执着于你所想象的错误方式，而无法来到你身边。</p>
<p>建议，可以先在生活中。</p>
<p>试着找到你的热爱，并开始给你的热爱一些时间，慢慢的，长久的，不求回报的去做它。</p>
<p>一点一点的，一天一天的，一年一年的，带着享受做下去。</p>
<p>耐心做下去，再看看你的热爱，看看它最后会给你带来些什么。</p>
<p>结果，往往超乎你的想象。</p>
<p>不过，前提是你要给它机会，让它有机会来改变你的生活。</p>
<p>生活中，从不存在改变太晚一说。</p>
<p>只要你一天活在这个世上，你就有一天的时间可以去改变自己。</p>
<p>比如，你说自己的状态，很难对人生有一个重大的改变。</p>
<p>这些，都是你的大脑想象，是你畏惧改变而对自己使用的说辞。</p>
<p>我给你举个例子：</p>
<p>你对自己当前的生活满意吗？喜欢吗？接纳吗？</p>
<p>如果，明天你突然得了一种癌症。</p>
<p>医生很遗憾的告诉你，你最多只能再活一星期了。</p>
<p>接下来，人生中的最后一星期，你打算怎么过？</p>
<p>会选择以当前的生活方式，继续下去吗？</p>
<p>你喜欢这样的生活方式吗？</p>
<p>如果，医生告诉你，你最多只能再活一个月，半年，一年，十年，……五十年呢？</p>
<p>如果，你开始试着以这种态度，来看待你的人生。</p>
<p>你会突然发现，无论什么时候，你选择改变都不晚。</p>
<p>只要你还活着一天，你就拥有一天的可能性。</p>
<p>你现在这种状态，无非是没有去认真的思考过死亡。</p>
<p>你看，事实上，你也并不如你想象的那样理性。</p>
<p>如果你真的理性，就不会无意识的避开思考死亡。</p>
<p>因为，死亡将会击穿你所有自以为的‘自律’、‘努力’、‘奋斗’和一切你所认为重要的事物。</p>
<p>在死亡面前，你唯一能做的，只有臣服。</p>
<p>如果，你能时常思考一下死亡。</p>
<p>你对于人生到底该怎样活，就会变得更加通透。</p>
<p>毕竟，你现在的这种思考方式。</p>
<p>完全建立在无视死亡，死亡不会降临在你身上，你无意识认为自己可以一直活到寿命极限的基础上。</p>
<p>你的困惑，也是如此。</p>
<h1 id="问：-1"><a href="#问：-1" class="headerlink" title="问："></a>问：</h1><p><em><strong>强迫症（和念头对抗），焦虑症的原理及应对办法 。</strong></em></p>
<p>答：</p>
<p>强迫症的原理：认为自己是绝对正确的，无法接纳那些他们所无法掌控的事物。</p>
<p>强迫症的应对：时常反思，深刻认识到自己的错误。</p>
<p>补充说明：试图和念头对抗，不是强迫症</p>
<p>焦虑症的原理：总希望事情像自己所期待的那样发展，又担心不像自己所期待的那样发展，于是不停的焦虑各种可能，害怕各种不是自己所期待的结果到来。</p>
<p>焦虑症的对应：接纳命运的无常，接纳人生的无常，接纳一切不完美，接纳所有的错误，接纳这个不圆满的自己。</p>
<p>最后，无论焦虑症，还是强迫症，本质上都来源于以前的心灵创伤，是内心在哭泣，所以才会表现出对某些行为的强迫，以及对各种事情的焦虑。</p>
<p>如果只关注于当前所面对的问题，就会治标不治本，毫无效果。</p>
<p>必须回溯过去，找到他们自己所不愿面对的过往，将那些过往去逐一面对，逐一释放，逐一谅解。</p>
<p>一旦过去被释放，那些潜藏内心深处的情绪，也会被一同释放。</p>
<p>真正做到这一点的人，会不停的哭。</p>
<p>哭完后，由于积压的负面情绪，得到释放。</p>
<p>无论强迫症还是焦虑症，会有立竿见影的好转效果。</p>
<p>不过，这只是一定时期内的好转，要完全根治，需要完全转变原本的每一种错误思维方式。</p>
<h1 id="问：-2"><a href="#问：-2" class="headerlink" title="问："></a>问：</h1><p><em><strong>请问观察，我举两个例子，请您判断一下。</strong></em></p>
<p><em><strong>我在骑车，脑子里在胡思乱想，没一会就骑到地方了，对刚才的路程一片茫然。</strong></em></p>
<p><em><strong>我在骑车，脑子里在胡思乱想，但是知道自己在胡思乱想，只是感觉自己在胡思乱想，没一会骑到地方了。</strong></em></p>
<p><em><strong>看见一些事物，心里起了一些情绪，只是静静的感受这些情绪。</strong></em></p>
<p><em><strong>我有一次在观察时听到了一声鸟叫，声音像钻进心里一样，是否这就是观察。</strong></em></p>
<p><em><strong>请问您这四个哪个是观察。我感觉有时观察有点太简单了，还是它本来就这么简单，是我自己想多了。我觉得您说的观察应该是指感受，我不知道理解的对不对。有时感觉无法从观察迅速转入做事模式，即有时在应该做事时也在不自觉的观察，感觉有点干扰。</strong></em></p>
<p>答：以你说的举例，观察就是：</p>
<p>我知道“我在骑自行车”，我知道“我在胡思乱想”，我知道“自己刚才好像有些迷茫”，我知道“自己似乎不知道什么才是正确的观察”。</p>
<p>这些都是观察，你觉知的一刹那，观察就开始了。</p>
<p>你纠结于对错的时候，观察就已经丢失了。</p>
<p>如果你突然意识到，自己刚才正在纠结对错，观察便又回来了。</p>
<h1 id="问：-3"><a href="#问：-3" class="headerlink" title="问："></a>问：</h1><p><em><strong>有些人在观察时出现了人格解体的症状，请问这种状况出现原因及解决。</strong></em></p>
<p>答：这个问题，要定义什么是人格。</p>
<p>事实上，人们所谓的人格。</p>
<p>本就是一个不断接受外界信息输入，再综合自己的身体特质，从而形成的一种不稳定结合体。</p>
<p>你的每一个观念，每一个对错的想法，都是家人、社会、集体向你灌输的。</p>
<p>你在这种信息之中，形成了一种‘自我感’，并开始认同于这个自我身份。</p>
<p>为了维护这个自我，而去和别人辩论、争吵。</p>
<p>有人甚至会因为别人一些小小的冒犯，而感到极其强烈的情感，继而选择犯罪杀人等等。</p>
<p>如果，将人比喻为一台电脑。</p>
<p>那么，自我就是安装的软件，这个软件让你误以为它就是电脑本身。</p>
<p>一旦产生这个误解，就会误以为自我是不能改变的，也不应试图改变。</p>
<p>因为，你如果试图去改变自我。</p>
<p>会影响到电脑的正常运行，就会破坏电脑的硬件结构。</p>
<p>其实，以上全都是自我的欺骗。</p>
<p>自我不会影响到电脑的运行，无论你将其多少次改变和重装，都没有问题。</p>
<p>真正产生问题的，是你给电脑装入了错误的自我。</p>
<p>比如，小婴儿出生来到人世，十分安详平和。</p>
<p>吃饱睡，睡饱了吃。</p>
<p>身体没有不舒服，就没有太大的烦恼。</p>
<p>为什么，随着成长。</p>
<p>明明也是一样有吃有睡，有人继续保持乐观，能轻易面对别人无法面对的痛苦。</p>
<p>有人却越来越烦恼，以至于失去继续活下去的认知能力？</p>
<p>无非，都是内置了不同的软件罢了。</p>
<p>所以，为什么常说要成长，要改变自己，要转变自己。</p>
<p>因为，你一旦开始去做。</p>
<p>自我，就会千方百计的阻止一个人改变自己。</p>
<p>毕竟，对于一款软件来说，你通过代码层将其完全改变。</p>
<p>于把一款游戏完全变成另一款游戏，对于这个软件本身来说，无异于死亡。</p>
<p>于是，自我会开始欺骗。</p>
<p>说它是无法改变的，改变了会出现无法想象的大麻烦。</p>
<p>其实不是的，恰恰是因为它的作用，才会让主机运行过热，以至于烧坏CPU。</p>
<p>观察，是将你从‘自我’之中抽离。</p>
<p>在这之前，你由于陷入自我的景象之中，而深深的无法自拔。</p>
<p>你就像播放恐怖电影时，电影院中的观众。</p>
<p>你看到主角毫无所知，一步步的逼近危险，忍不住要尖叫，几乎把自己吓晕过去。</p>
<p>观察，就是让你转移一下注意力。</p>
<p>让你意识到。</p>
<p>啊，眼前是银幕，这里是电影院。</p>
<p>我在看电影，我不是电影里的人，我也不是电影里的那个主角。</p>
<p>这种行为，是极其有力的。</p>
<p>因为抽离，你开始能认知到底层的真实。</p>
<p>人每天睡觉，人格每晚都在解体。</p>
<p>醒来时，人格也在重组。</p>
<p>只是因为变化微小，一时半会认识不到而已。</p>
<p>这就是为什么，二十年前的你，和现在的你，绝不会是同一个人格。</p>
<p>至于你说的这种情况，需要具体问题具体分析。</p>
<p>一般，观察不会导致任何心理问题发生。</p>
<p>错误的观察，最多让人胡思乱想，生活得更费力一点而已。</p>
<p>就像练习健身操，不可能把手脚跳断。</p>
<p>最多，只是肌肉和韧带拉伤。</p>
<p>有人非说因为自己练习健身操，结果手脚被砍断了。</p>
<p>这个时候，这个人要好好反思一下自己。</p>
<p>想想他到底做了什么，才会在跳健身操的时候，把自己的手脚都砍断了。</p>
<p>其实，真正会影响生活的，一向都是自我。</p>
<p>比如，被自我欺骗，从而生气、愤怒、被情绪带动做傻事，或进入自我营造的幻觉之中，误以为自己‘无情’、‘超脱’、‘高高在上’等等。</p>
<p>这些，真正的观察，都可轻易破解。</p>
<p>在起情绪的瞬间，你觉知到 ‘情绪’。</p>
<p>这一刹那，你便不是情绪。</p>
<p>如果你是情绪，你就不可能觉知得到情绪。</p>
<p>既然，意识中出现了客体，那么必定有一个潜藏的主体。</p>
<p>又比如，感到和这个世界的‘不真实’，以及所有存在的‘虚妄’。</p>
<p>觉察到这个‘不真实’和‘虚妄’的瞬间，你便从中出来了。</p>
<p>你会认识到，这些‘不真实’和‘虚妄’，本身也是念头。</p>
<p>既然是念头，就也是一种幻觉。</p>
<p>你能看见它们，显然你就不是它们。</p>
<p>如果你是它们，你就一定看不见它们。</p>
<p>就好像一个人没有镜子，没有反射物，他就看不到自己的脸。</p>
<p>正因为不是你，所以你才能看见它们。</p>
<p>你说的因为观察，而进入某种生活烦恼的状态。</p>
<p>不是因为观察，而是这个人被自我的念头带走了。</p>
<p>被什么念头带走了？</p>
<p>被‘我在观察’、‘一切不真实’等等念头所带走，并进入了这些念头所营造的幻觉之中。</p>
<p>而察觉不到，他以上正在浮现的感受，全是念头。</p>
<p>这种类型的人，有很多。</p>
<p>各种精神病的早期，往往都由于执着于某个念头。</p>
<p>无论如何，也无法释怀和放手。</p>
<p>结果就被念头所困，听不见他人的话语，再也不愿出来。</p>
<p>所以，你会看到。</p>
<p>精神病的一个普遍表现，就是从不会觉得自己是错的。</p>
<p>哪怕嘴上认错，心里也一定不会认错。</p>
<p>他们坚信自己一定是对的，是绝对无疑的正确。</p>
<p>都是别人的问题。</p>
<p>有这种思维方式的人，一旦遇见突发压力或者人生巨变，一下就很容易转变为精神病。</p>
<p>可以说，本身就已经精神病的预备役了。</p>
<p>有这种思考方式的人，应提高警惕，学会时常反省自己。</p>
<h1 id="问：-4"><a href="#问：-4" class="headerlink" title="问："></a>问：</h1><p><em><strong>原因和结果是真的有关联还是人们的经验结果？感谢您的回答。</strong></em></p>
<p>答：你这个问题比较宽泛，我也宽泛一点回答。</p>
<p>这要看在哪个层面，人的认知总是非对即错的二元领域。</p>
<p>无法明白，其实还有——非对非错、即对即错、非非对非错、非即对即错。</p>
<p>在一般层面，原因当然与结果有关，比如你吃饭的果，是你饥饿的因。</p>
<p>你改变人生的果，是因为你不喜欢当下自己的因。</p>
<p>这些，都是简单直接的因果关系。</p>
<p>而在人生层面，原因和结果开始出现变动， 比如你能成为爱因斯坦，肯定不仅仅是努力，还有基因、头脑、性格、天赋、家庭环境等因素的综合作用。</p>
<p>你生活里很多事情，显然不是你的因能决定的。</p>
<p>比如，有人天生富贵不知道钱的意义，有人生来就没有条件走出穷困大山；</p>
<p>有人生来好手好脚，有人生来缺胳膊少腿。</p>
<p>有人出生和平国度，有人出生在战乱国家。</p>
<p>这种程度上的不一样，你不能说是别人不努力的因，才是他们这种出生的果。</p>
<p>而在更高层面上，因和果又是绝对关联了。</p>
<p>不过，这个更高层面的因果，人类的语言无法描述，描述了也会导致误解。</p>
<p>不太适合写在公众号文章里。</p>
<p>在此，略过不提。</p>
<h1 id="问：-5"><a href="#问：-5" class="headerlink" title="问："></a>问：</h1><p><em><strong>为什么开悟的人好像都是男人，女人呢？</strong></em></p>
<p>答：你问我之前，我没有想过这个问题。</p>
<p>刚才，我回忆了一下。</p>
<p>我所接触过的寥寥几位真修，以及我所推荐书的作者中。</p>
<p>的确，没有女性。</p>
<p>释迦牟尼、老子、达摩，全都是男性。</p>
<p>不过，我不觉得女性无法开悟。</p>
<p>修行完全是精神层面的成长，与这个物质躯体是什么组成形式，是毫无关联的。</p>
<p>不过，女性开悟者为何如此罕见？</p>
<p>原因，主要是三个方面：</p>
<p>第一个方面，社会原因。</p>
<p>当前，人类是男权主义社会。</p>
<p>男人在享受男权社会福利的同时，也承担了过重的社会责任。</p>
<p>因此，男人在其成长过程中，相对而言，会被社会要求要变得更加独立。</p>
<p>这种独立的心态，对于修行而言，是十分有益的。</p>
<p>同时，男权社会人们对女性孩童在思想上，灌输了种种负面的道德观，降低了女性的思维独立性，培养了女性的依赖性思考。</p>
<p>比如：</p>
<p>女人要为别人打扮得漂漂亮亮，男人只需体现内在价值。</p>
<p>女人可以不费力去嫁个好男人，男人一定要完全靠自己。</p>
<p>这些，是男权社会对女性灌输的刻板观念。</p>
<p>孩童时代，大家都是一张白纸。</p>
<p>一旦被社会染上颜色，就很难从这种思维方式中脱离。</p>
<p>不要忘记，女性能和男性一样平等工作，获得完全相同的月薪，得到别人相同的尊重。</p>
<p>也就是这几十年内， 社会主义兴起后的事。</p>
<p>人类社会，对孩子的思想灌输。</p>
<p>对女性思想所产生的影响，是十分巨大的。</p>
<p>第二个方面，是生理因素。</p>
<p>女性修行者，想进行精神成长，受到的干扰与束缚因素很多。</p>
<p>比如，每月一次的痛苦，比如比男性更容易受到细菌感染等等。</p>
<p>女人的身体机能，也天生弱于男性。</p>
<p>通过锻炼能能达到的极限，同样弱于男性。</p>
<p>这些，是生理条件对于女性的限制。</p>
<p>由于这些条件限制，让女性的思维方式。</p>
<p>更易倾向于依赖，而非独立自主。</p>
<p>加上社会的灌输，更加重了这种倾向，增加了女性修行的难度。</p>
<p>第三个方面，是精神因素。</p>
<p>女性在生活中，有很多东西放不下。</p>
<p>是之前社会和生理特征的影响，导致这种倾向。</p>
<p>比如，女性在日常生活中，通常不介意向别人展现出一种‘弱者姿态’。</p>
<p>大部分女性，遇见问题时。</p>
<p>下意识就去找朋友倾述，宣泄情感，抱怨生活等等。</p>
<p>加上每月一次的痛苦打磨，这些让女性获得了，远超男性的精神抗压能力。</p>
<p>你们会发现，通常闷声不响的男性，会突然某一天从楼上跳下。</p>
<p>许多每天都说，自己痛苦得想死的女性。</p>
<p>却能一直坚强的，活下来。</p>
<p>不过，女性也因此而丧失了很多独处的思考时间。</p>
<p>错失了许多宝贵的精神成长机会。</p>
<p>女性生育孩子后。</p>
<p>孩子会变成肉体的延伸，是她们身上掉下来的一块肉。</p>
<p>那位母亲，能轻易在心中放下她的孩子？</p>
<p>当然，放下不是物理意义上的去舍弃，而是一种精神上的放下。</p>
<p>不会将孩子当做自己宇宙的中心。</p>
<p>这一点，男性会比女性更容易做到。</p>
<p>毕竟，孩子是女人身上掉下来的肉，不是男人身上掉下来的。</p>
<p>三方面的综合因素。</p>
<p>导致女性踏上觉悟之路后，修行的难度，远超男性。</p>
<p>说了这么多缺点。</p>
<p>那么，女性，难道无法觉悟吗？</p>
<p>不是的，别忘记我说的。</p>
<p>人类社会，近几千年来，一直是男权社会。</p>
<p>女性开悟者一定有，女圣人虽然极少，肯定也有。</p>
<p>问题在于，她们被当时社会允许著书立说，传播思想吗？</p>
<p>家人允许她们在年轻时，就自由自在的出门远游吗？</p>
<p>她们在古代出门远游，所面对的危险，又是男性的几倍？</p>
<p>有多少男性弟子，愿意追随她们学习？</p>
<p>还愿意自发宣扬，他们的导师，是一位女性，而不担心被别人看不起？</p>
<p>又有多少陌生人，一听见这位‘圣人’是个女性，便立即看低对方的学说，没有进一步了解的想法？</p>
<p>由于以上种种歧视，导致女性著作，难以流传下来。</p>
<p>显然，不是因为女性中无法出现开悟者，或出现大圣人。</p>
<p>而是古代男权社会，大环境不允许女圣人著书立说。</p>
<p>古代，名扬天下的女性不少。</p>
<p>你回忆一下，除去诗歌这一类‘玩物‘。</p>
<p>女性的著作，有多少流传到今天，让你耳熟能详？</p>
<p>能记起的，又有几本？</p>
<p>如此对照，即可知晓原因。</p>
<p>并非女性不能开悟，而是女性修行者，在古代面临的种种困难，要远高于男性。</p>
<p>外加大环境的压抑，导致女性觉悟者，似乎从未耳闻。</p>
<p>女性修行，全是缺点吗？</p>
<p>不是的，这是一种错误的思维方式。</p>
<p>世间万物，有舍有得。</p>
<p>有了痛苦，才会有觉悟的机会；没有痛苦，连觉悟的机会都没有。</p>
<p>女性也是一样的。</p>
<p>正因女性在生理上，先天承受了男性所没有承受的痛苦。</p>
<p>所以，女性的抗压能力、抗抑郁能力、抗负面能力，都远超男性。</p>
<p>从平均寿命上来说，女性相较于男性，至少也能多活五年以上。</p>
<p>这些，都是由痛苦而得到的恩赐。</p>
<p>其次，在这些痛苦的打磨下，女性也因此而变得更具备精神成长的潜力。</p>
<p>比如，关注灵性成长、精神觉醒、修行的人之中。</p>
<p>女性数量，通常多于男性。</p>
<p>她们对于这些知识，更敏感，更有感应，更容易信任、更愿意去付出。</p>
<p>不像很多男性，通常要经历一个思维上的反复辩论，以及试图攻击传授者的过程。</p>
<p>这一点，对修行而言，是十分难能可贵的。</p>
<p>男人，更倾向于听从于思辨，而非感觉。</p>
<p>可修行，却必须完全跟着感觉走。</p>
<p>这一点，对许多男性而言，是一条几乎跨不过去的天堑。</p>
<p>女人喜欢跟随感觉，更容易听从于内在的召唤，也因此更容易走上觉悟之路。</p>
<p>这就是为什么，我时常遇见修行上更真诚的，一般是女性求道者较多。</p>
<p>不过，我很少看到女性修行者，能升起助人的大决心。</p>
<p>可能因为，她们受到的社会束缚太多。</p>
<p>她们过于关注自我、关注家庭、关注外在、关注异性。</p>
<p>比如，情感方面。</p>
<p>女性容易产生依赖，易误以为只有爱情，才是人生的全部。</p>
<p>唯有找到真爱，才是人生中最重要的事情。</p>
<p>不过，正因为干扰和束缚很多。</p>
<p>如果，女性能下大决心。</p>
<p>修行之路，走起来就会非常快，非常迅速。</p>
<p>给你讲一个故事。</p>
<p>古印度，释迦牟尼一开始，不愿意女子随他出家学习。</p>
<p>他自己一直在说，众生平等。</p>
<p>为什么，他又不愿女子向他学习？</p>
<p>即使，这位请求的女子，是亲手将他养育长大的姨母，反复哀求了他三次。</p>
<p>释迦牟尼依然选择拒绝。</p>
<p>最后，他姨母带着很多女子，光着脚走十几天路，一路吃尽苦头，沿途乞讨来找到他， 释迦牟尼还是不允许。</p>
<p>最终，在弟子阿难们的劝说下。</p>
<p>他选择接受养母，允许他的姨母带女弟子，随他学习。</p>
<p>当时，他的弟子阿难就说。</p>
<p>世尊，我曾经问你时，你不是说过，女子也一样能成就最高的智慧圣果吗？</p>
<p>释迦牟尼回答，是的，我说过，女子当然可以成就最高的智慧圣果。</p>
<p>然后，他向弟子说，不接纳女子的原因。</p>
<p>因为，会让佛法更早的灭亡。</p>
<p>原因，很简单。</p>
<p>印度女子的地位，比中国女人在那时的地位，低上很多。</p>
<p>允许女子学佛，对于佛法在印度的传播，会产生极大的负面影响。</p>
<p>印度的种姓制度，直到今天都依然存在。</p>
<p>那一刻，他便已预见到，佛法将在印度早早的走向灭亡。</p>
<p>现在，印度已经几乎没有佛法了。</p>
<p>时至今日，来到所谓的文明社会。</p>
<p>印度女人今天的地位，人们也是有目共睹。</p>
<p>当时，释迦牟尼同样不允许奴隶出家。</p>
<p>为什么？</p>
<p>因为，他不能跟当时的国王对着干，需要遵循国主对奴隶的规定。</p>
<p>所以，并非释迦牟尼歧视女性。</p>
<p>而是当时的时代社会的大背景，对性别产生压抑。</p>
<p>如果，我们身处女权社会，男性也将受到同等程度的压抑。</p>
<p>因此，觉悟是不分男女的，修行也是不分男女的。</p>
<p>对大道的认知，也一样不分男女。</p>
<p>不过，为什么我目前所见过的，见性之后的修行者中。</p>
<p>还没有遇到过任何一位女性。</p>
<p>显然，是样本太小的缘故。</p>
<p>女性修行的难度更大，也更低调。</p>
<p>相较男性修行者，出现得更少，很正常。</p>
<p>比例上，应该比10:1还小很多。</p>
<p>修行本来就已经极难了，我到目前为止，现实生活中真正见过的见性者，也不过区区四人，其中还算上一位隐在破庙里的老和尚。</p>
<p>算上网络上，虽然没见过，可看别人的文章与交流，可知对方是否见性，这样的算上也不过三人。</p>
<p>共计，也只有七位见性者。</p>
<p>网上，曾见过一个女性明心者，没人教。</p>
<p>她在网上发帖，分享当时的状态。</p>
<p>觉得十分神奇，还误以为自己已经开悟了。</p>
<p>当时，我还没明心。</p>
<p>引路人带我去围观的帖子。</p>
<p>并告诉我，那个女生的状态，正是明心的表现。</p>
<p>如今，我见过有境界的真修，连十人都没到。</p>
<p>以十比一的比例来说，我没见过女性的见性者。</p>
<p>很正常。</p>
<p>网上，见过一个偶然触碰到见性边缘的女性灵修者。</p>
<p>距离见性，只差临门一脚。</p>
<p>有过一次见性的巅峰体验。</p>
<p>可惜，没有正确的指引，已被自我带偏。</p>
<p>认为自己从此开悟，要去普度众生，所有人都应该向她学习。</p>
<p>步入邪路，终生止步于妄想的境界中。</p>
<p>劝过几句，对方不听。</p>
<p>也就算了。</p>
<p>修行，有一步很基础的功夫。</p>
<p>是要达成自己体内男女能量的平衡。</p>
<p>男性，需要有意识的增强体内女性能量柔软的那部分，变得细腻柔软。</p>
<p>女性，需要有意识的增强体内男性能量果敢的那部分，变得独立无畏。</p>
<p>体内男女能量平衡，才能收获一个平衡的能量状态。</p>
<p>这是修行的基础。</p>
<p>当然，也有情况不同的，比如：</p>
<p>某些体内男性能量过于充沛的女性，也需要学习女性能量。</p>
<p>某些体内女性能量过于充沛的男性，也需要学习男性能量。</p>
<p>一般而言，男性需向女性学习温柔与细腻，女性需向男性学习无畏与勇猛。</p>
<p>如果，连体内的性别能量，都无法平衡的话。</p>
<p>觉悟，是无法得到的。</p>
<p>—–有感而发—-</p>
<p>我在知乎上，说自己开悟。</p>
<p>其实，本无悟可开。</p>
<p>修行从不是得到，修行是一步一步的舍去。</p>
<p>舍无可舍，悟无可悟，是名开悟。</p>
<p>用开悟的名相，也只是为了方便叙述。</p>
<p>我在文章中，也将开悟与得道，做了一个定义上的区分。</p>
<p>就是为了避免各位，着‘开悟’的相。</p>
<p>开悟，指达成人的内在精神圆满。</p>
<p>对于人生，对于生活，对于未来，对于修行，不再抱有任何不笃定的疑问。</p>
<p>不再有任何修行问题，需要去问原来的导师。</p>
<p>觉醒了无师智，自己就可以教导自己，继续往下走了，不再需要任何指引。</p>
<p>无论是看经书，还是看古代圣人的经典，都能轻易看懂。</p>
<p>仿佛圣人正在自己面前，对自己耳提面命一般。</p>
<p>很多人对开悟有误解，误以为‘开悟’之后，一定要‘普度众生’。</p>
<p>不是这样的，这些都是自我的领域。</p>
<p>内在圆满之后，其实就没有要救人，要助人的需求。</p>
<p>因为，已经善良到极致了。</p>
<p>不是这样善良到极致，将别人当成自己的人，是无法入道的。</p>
<p>表现出来，好像开悟者每天都在试图在助人。</p>
<p>其实，是别人一直在追着他问而已。</p>
<p>自己，没有被助人这事所束缚。</p>
<p>从入道到得道的这个阶段，是逐渐湮灭心中的人我、众生之别。</p>
<p>当没有分别的时刻，悟与不悟也没有区别。</p>
<p>更没有，刻意帮助的必要了。</p>
<p>每个人，都有最好的缘法。</p>
<p>不必强求，顺其自然就好。</p>
<p>包括我在‘自愈之光’公众号，写这些文章和回答大家的提问。</p>
<p>主要动机，不是为了助人。</p>
<p>助人已成为我的本能，我不需要刻意去助人。</p>
<p>主要动机，是帮家里还挺大一笔债。</p>
<p>所以，未来会多写一些知乎回答，再开通直播，在视频里讲一些东西。</p>
<p>其实，我对出名毫无兴趣。</p>
<p>可不用这种方式，老天不允许我还清家中债务。</p>
<p>所以，只能当下担当。</p>
<p>站出来，当个导师。</p>
<p>把该我做的事情，做完。</p>
<p>引路人从不抛头露面。</p>
<p>光磊老师，也是为了推广中医，疗愈人们的身体才站出来开直播，传承中医。</p>
<p>我的愿，不需要我站出来抛头露面。</p>
<p>等家中的债务还清之后，差不多得道了。</p>
<p>那时，会留下一本书。</p>
<p>然后，从网络上隐没。</p>
<p>以一种更不显眼的方式，更不为人知的方式。</p>
<p>默默助人。</p>
<p>也是为什么。</p>
<p>我始终只用笔名，从不用真名的原因。</p>
<p>大家对于修行，不要太强求了。</p>
<p>能得到多少就是多少，能改变自己的生活多少，就是多少。</p>
<p>不要为解除烦恼而修行，结果创造出更多烦恼。</p>
<p>微笑~</p>
<p>之后，因为时间安排。</p>
<p>公众号会改为一周两篇天赐问答，不再两天一篇。</p>
<p>内容上，也会多答几个提问。</p>
]]></content>
      <categories>
        <category>灵天赐</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动之网卡驱动</title>
    <url>/2018/02/06/1813-drv-net/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/22/1809-drv-blk/">驱动之块设备-框架</a></li>
<li><a href="https://draapho.github.io/2018/01/24/1810-drv-nand1/">驱动之NAND Flash框架</a></li>
<li><a href="https://draapho.github.io/2018/01/25/1811-drv-nand2/">驱动之NAND Flash源码</a></li>
<li><a href="https://draapho.github.io/2018/01/26/1812-drv-nor/">驱动之NOR Flash</a></li>
<li><a href="https://draapho.github.io/2018/02/06/1813-drv-net/">驱动之网卡驱动</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="虚拟网卡源码"><a href="#虚拟网卡源码" class="headerlink" title="虚拟网卡源码"></a>虚拟网卡源码</h1><p>网络驱动的实现很复杂, Linux内核都帮我们做掉了, 对用户端直接进行socket编程即可.<br>而具体到硬件, 网卡驱动十分简单. 与网络驱动通过二个函数和一个变量.</p>
<ul>
<li>网卡发送函数: <code>hard_start_xmit</code></li>
<li>网卡接收函数: <code>netif_rx</code></li>
<li>数据: <code>sk_buff</code></li>
</ul>
<p>网卡驱动的基本步骤:</p>
<ol>
<li>分配一个 <code>net_device</code> 结构体: <code>alloc_netdev</code></li>
<li>设置: 实现发送 <code>hard_start_xmit</code>, 接收 <code>netif_rx</code>, 以及其它设置</li>
<li>发送函数注意使用 <code>netif_stop_queue</code> <code>dev_kfree_skb_irq</code> <code>netif_wake_queue</code></li>
<li>注册: <code>register_netdev</code>.</li>
</ol>
<h2 id="vnet-c"><a href="#vnet-c" class="headerlink" title="vnet.c"></a>vnet.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考 drivers\net\cs89x0.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/etherdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bitops.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/system.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">vnet_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参考LDD3, 虚构一个ping应答包</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">emulator_rx_packet</span><span class="params">(struct sk_buff *skb, struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *type;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ih</span>;</span></span><br><span class="line">    __be32 *saddr, *daddr, tmp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   tmp_dev_addr[ETH_ALEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">ethhdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">rx_skb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从硬件读出/保存数据</span></span><br><span class="line">    ethhdr = (struct ethhdr *)skb-&gt;data;                        <span class="comment">// 对调源/目的的mac地址</span></span><br><span class="line">    <span class="built_in">memcpy</span>(tmp_dev_addr, ethhdr-&gt;h_dest, ETH_ALEN);</span><br><span class="line">    <span class="built_in">memcpy</span>(ethhdr-&gt;h_dest, ethhdr-&gt;h_source, ETH_ALEN);</span><br><span class="line">    <span class="built_in">memcpy</span>(ethhdr-&gt;h_source, tmp_dev_addr, ETH_ALEN);</span><br><span class="line"></span><br><span class="line">    ih = (struct iphdr *)(skb-&gt;data + <span class="keyword">sizeof</span>(struct ethhdr));   <span class="comment">// 对调源/目的的ip地址</span></span><br><span class="line">    saddr = &amp;ih-&gt;saddr;</span><br><span class="line">    daddr = &amp;ih-&gt;daddr;</span><br><span class="line">    tmp = *saddr;</span><br><span class="line">    *saddr = *daddr;</span><br><span class="line">    *daddr = tmp;</span><br><span class="line">    <span class="comment">//((u8 *)saddr)[2] ^= 1; /* change the third octet (class C) */</span></span><br><span class="line">    <span class="comment">//((u8 *)daddr)[2] ^= 1;</span></span><br><span class="line"></span><br><span class="line">    type = skb-&gt;data + <span class="keyword">sizeof</span>(struct ethhdr) + <span class="keyword">sizeof</span>(struct iphdr);</span><br><span class="line">    <span class="comment">// printk(&quot;tx package type = %02x\n&quot;, *type);</span></span><br><span class="line">    *type = <span class="number">0</span>;                                  <span class="comment">// 修改类型, 原来0x8表示ping, 0表示reply</span></span><br><span class="line">    ih-&gt;check = <span class="number">0</span>;                              <span class="comment">// rebuild the checksum (ip needs it)</span></span><br><span class="line">    ih-&gt;check = ip_fast_csum((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)ih,ih-&gt;ihl);</span><br><span class="line"></span><br><span class="line">    rx_skb = dev_alloc_skb(skb-&gt;len + <span class="number">2</span>);       <span class="comment">// 构造一个sk_buff</span></span><br><span class="line">    skb_reserve(rx_skb, <span class="number">2</span>);                     <span class="comment">// align IP on 16B boundary</span></span><br><span class="line">    <span class="built_in">memcpy</span>(skb_put(rx_skb, skb-&gt;len), skb-&gt;data, skb-&gt;len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write metadata, and then pass to the receive level */</span></span><br><span class="line">    rx_skb-&gt;dev = dev;</span><br><span class="line">    rx_skb-&gt;protocol = eth_type_trans(rx_skb, dev);</span><br><span class="line">    rx_skb-&gt;ip_summed = CHECKSUM_UNNECESSARY; <span class="comment">/* don&#x27;t check it */</span></span><br><span class="line">    dev-&gt;stats.rx_packets++;</span><br><span class="line">    dev-&gt;stats.rx_bytes += skb-&gt;len;</span><br><span class="line"></span><br><span class="line">    netif_rx(rx_skb);                           <span class="comment">// 提交sk_buff</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vnet_send_packet</span><span class="params">(struct sk_buff *skb, struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    printk(<span class="string">&quot;virt_net_send_packet cnt = %d\n&quot;</span>, ++cnt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对于真实的网卡, 把skb里的数据通过网卡发送出去 */</span></span><br><span class="line">    netif_stop_queue(dev);                      <span class="comment">// 停止该网卡的队列</span></span><br><span class="line">    <span class="comment">/* 实际网卡的话, 把skb的数据写入网卡 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用发送的数据虚构应答数据, 所以放这里了</span></span><br><span class="line"><span class="comment">     * 实际网卡应该是用中断实现数据接收和 netif_rx 上报的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    emulator_rx_packet(skb, dev);</span><br><span class="line">    dev-&gt;stats.tx_packets++;                    <span class="comment">// 更新统计信息</span></span><br><span class="line">    dev-&gt;stats.tx_bytes += skb-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断里的话, 需要使用 dev_kfree_skb_irq</span></span><br><span class="line">    dev_kfree_skb (skb);                        <span class="comment">// 释放skb.</span></span><br><span class="line">    netif_wake_queue(dev);                      <span class="comment">// 数据全部发送出去后,唤醒网卡的队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vnet_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 1. 分配一个net_device结构体 */</span></span><br><span class="line">    vnet_dev = alloc_netdev(<span class="number">0</span>, <span class="string">&quot;vnet%d&quot;</span>, ether_setup);</span><br><span class="line">    <span class="comment">// 也可用 alloc_etherdev 指定了网卡名称为 eth%d</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 设置 */</span></span><br><span class="line">    vnet_dev-&gt;hard_start_xmit = vnet_send_packet;   <span class="comment">// 指定发送函数</span></span><br><span class="line">    vnet_dev-&gt;dev_addr[<span class="number">0</span>] = <span class="number">0x08</span>;                   <span class="comment">// 设置MAC地址</span></span><br><span class="line">    vnet_dev-&gt;dev_addr[<span class="number">1</span>] = <span class="number">0x89</span>;</span><br><span class="line">    vnet_dev-&gt;dev_addr[<span class="number">2</span>] = <span class="number">0x89</span>;</span><br><span class="line">    vnet_dev-&gt;dev_addr[<span class="number">3</span>] = <span class="number">0x89</span>;</span><br><span class="line">    vnet_dev-&gt;dev_addr[<span class="number">4</span>] = <span class="number">0x89</span>;</span><br><span class="line">    vnet_dev-&gt;dev_addr[<span class="number">5</span>] = <span class="number">0x11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置下面两项才能ping通</span></span><br><span class="line">    vnet_dev-&gt;flags    |= IFF_NOARP;</span><br><span class="line">    vnet_dev-&gt;features |= NETIF_F_NO_CSUM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 注册 */</span></span><br><span class="line">    register_netdev(vnet_dev);</span><br><span class="line">    <span class="comment">// 不建议直接使用 register_netdevice.</span></span><br><span class="line">    <span class="comment">// register_netdev 是 register_netdevice 的加锁版.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vnet_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unregister_netdev(vnet_dev);</span><br><span class="line">    free_netdev(vnet_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(vnet_init);</span><br><span class="line">module_exit(vnet_exit);</span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m       := vnet.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/net/             # net驱动目录</span></span><br><span class="line">$ make modules                                  <span class="comment"># 生成vnet.ko</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/net/             # net驱动目录, nfs</span></span><br><span class="line">$ insmod vnet.ko                                <span class="comment"># 加载驱动</span></span><br><span class="line"></span><br><span class="line">$ ifconfig vnet0 3.3.3.3                        <span class="comment"># 设置ip</span></span><br><span class="line">$ ifconfig                                      <span class="comment"># 查看网卡信息</span></span><br><span class="line">eth0      ......</span><br><span class="line">vnet0     Link encap:Ethernet  HWaddr 08:89:89:89:89:11             <span class="comment"># mac地址</span></span><br><span class="line">          inet addr:3.3.3.3  Bcast:3.255.255.255  Mask:255.0.0.0    <span class="comment"># ip地址相关</span></span><br><span class="line">          UP BROADCAST RUNNING NOARP MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">$ ping 3.3.3.3                                  <span class="comment"># ping自己</span></span><br><span class="line">PING 3.3.3.3 (3.3.3.3): 56 data bytes</span><br><span class="line"><span class="comment"># 这里没有应答, 应该是没有设置lo回环的关系.</span></span><br><span class="line"><span class="comment"># 可以知道 ping 自己不会调用到底层的网卡驱动</span></span><br><span class="line">$ ping 3.3.3.4                                  <span class="comment"># ping其它网段</span></span><br><span class="line">PING 3.3.3.4 (3.3.3.4): 56 data bytes</span><br><span class="line">virt_net_send_packet cnt = 1                    <span class="comment"># 代码里的发送计数</span></span><br><span class="line">64 bytes from 3.3.3.4: seq=0 ttl=64 time=0.856 ms</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">$ ifconfig                                      <span class="comment"># 查看网卡信息</span></span><br><span class="line"><span class="comment"># 可以查看 RX packets, TX packets, RX bytes, TX bytes</span></span><br></pre></td></tr></table></figure>


<h1 id="移植网卡驱动"><a href="#移植网卡驱动" class="headerlink" title="移植网卡驱动"></a>移植网卡驱动</h1><p>在实际选用网卡时, 网卡厂商都会提供linux驱动.<br>只需要在此基础上, 针对自己的板子, 部分修改即可.<br>网卡对于s3c2440而言, 其物理接口用的是 <code>MEMORY CONTROLLER</code><br>主要的注意点如下:</p>
<ul>
<li>网卡位宽: 8/16, 实际用的16位宽</li>
<li>片选使用了 <code>nGCS4</code>, 对应基地址为 <code>0x20000000</code></li>
<li>DM9000C 的<code>CMD</code>接的是<code>LADDR2</code>, 因此读指令时, LADDR2要置位.</li>
<li>收发数据时, 中断引脚的设置.</li>
<li>初始化时, S3C2440端相关的寄存器设置.</li>
<li>复位应交 <code>nRESET</code>, 如果需要软件对网卡进行硬件复位, 则需要自己实现.</li>
<li>其它引脚如 <code>LANACK</code> <code>LANLINK</code>, 可知接到led上的, 无需关心.</li>
</ul>
<h2 id="dm9dev9000c-c"><a href="#dm9dev9000c-c" class="headerlink" title="dm9dev9000c.c"></a>dm9dev9000c.c</h2><p>下面, 基于 DM9000C 的厂家驱动, 针对 jz2440 开发板进行修改.<br>修改的地方全部会打上标记 <code>===== for jz2440 ===== </code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  dm9ks.c: Version 2.08 2007/02/12</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        A Davicom DM9000/DM9010 ISA NIC fast Ethernet driver for Linux.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    This program is free software; you can redistribute it and/or</span></span><br><span class="line"><span class="comment">    modify it under the terms of the GNU General Public License</span></span><br><span class="line"><span class="comment">    as published by the Free Software Foundation; either version 2</span></span><br><span class="line"><span class="comment">    of the License, or (at your option) any later version.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    This program is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment">    GNU General Public License for more details.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  (C)Copyright 1997-2007 DAVICOM Semiconductor,Inc. All Rights Reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">V2.00 Spenser - 01/10/2005</span></span><br><span class="line"><span class="comment">            - Modification for PXA270 MAINSTONE.</span></span><br><span class="line"><span class="comment">            - Modified dmfe_tx_done().</span></span><br><span class="line"><span class="comment">            - Add dmfe_timeout().</span></span><br><span class="line"><span class="comment">V2.01   10/07/2005  -Modified dmfe_timer()</span></span><br><span class="line"><span class="comment">            -Dected network speed 10/100M</span></span><br><span class="line"><span class="comment">V2.02   10/12/2005  -Use link change to chage db-&gt;Speed</span></span><br><span class="line"><span class="comment">            -dmfe_open() wait for Link OK</span></span><br><span class="line"><span class="comment">V2.03   11/22/2005  -Power-off and Power-on PHY in dmfe_init_dm9000()</span></span><br><span class="line"><span class="comment">            -support IOL</span></span><br><span class="line"><span class="comment">V2.04   12/13/2005  -delay 1.6s between power-on and power-off in</span></span><br><span class="line"><span class="comment">             dmfe_init_dm9000()</span></span><br><span class="line"><span class="comment">            -set LED mode 1 in dmfe_init_dm9000()</span></span><br><span class="line"><span class="comment">            -add data bus driving capability in dmfe_init_dm9000()</span></span><br><span class="line"><span class="comment">             (optional)</span></span><br><span class="line"><span class="comment">10/3/2006   -Add DM8606 read/write function by MDC and MDIO</span></span><br><span class="line"><span class="comment">V2.06   01/03/2007  -CONT_RX_PKT_CNT=0xFFFF</span></span><br><span class="line"><span class="comment">            -modify dmfe_tx_done function</span></span><br><span class="line"><span class="comment">            -check RX FIFO pointer</span></span><br><span class="line"><span class="comment">            -if using physical address, re-define I/O function</span></span><br><span class="line"><span class="comment">            -add db-&gt;cont_rx_pkt_cnt=0 at the front of dmfe_packet_receive()</span></span><br><span class="line"><span class="comment">V2.08   02/12/2007  -module parameter macro</span></span><br><span class="line"><span class="comment">            2.4  MODULE_PARM</span></span><br><span class="line"><span class="comment">            2.6  module_param</span></span><br><span class="line"><span class="comment">            -remove #include &lt;linux/config&gt;</span></span><br><span class="line"><span class="comment">            -fix dmfe_interrupt for kernel 2.6.20</span></span><br><span class="line"><span class="comment">V2.09 05/24/2007    -support ethtool and mii-tool</span></span><br><span class="line"><span class="comment">05/30/2007  -fix the driver bug when ifconfig eth0 (-)promisc and (-)allmulti.</span></span><br><span class="line"><span class="comment">06/05/2007  -fix dm9000b issue(ex. 10M TX idle=65mA, 10M harmonic)</span></span><br><span class="line"><span class="comment">            -add flow control function (option)</span></span><br><span class="line"><span class="comment">10/01/2007  -Add #include &lt;asm/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">            -Modyfy dmfe_do_ioctl for kernel 2.6.7</span></span><br><span class="line"><span class="comment">11/23/2007  -Add TDBUG to check TX FIFO pointer shift</span></span><br><span class="line"><span class="comment">            - Remove check_rx_ready()</span></span><br><span class="line"><span class="comment">        - Add #define CHECKSUM to modify CHECKSUM function</span></span><br><span class="line"><span class="comment">12/20/2007  -Modify TX timeout routine(+)check TCR&amp;0x01</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define CHECKSUM</span></span><br><span class="line"><span class="comment">//#define TDBUG     /* check TX FIFO pointer */</span></span><br><span class="line"><span class="comment">//#define RDBUG   /* check RX FIFO pointer */</span></span><br><span class="line"><span class="comment">//#define DM8606</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_NAME    <span class="meta-string">&quot;dm9KS&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_VERSION <span class="meta-string">&quot;2.09&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_RELDATE <span class="meta-string">&quot;2007-11-22&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MODVERSIONS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/modversions.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;linux/config.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/etherdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/dma.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/crc32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mii.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ethtool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_MAINSTONE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/hardware.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== for jz2440 =====</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch-s3c2410/regs-mem.h&gt;</span></span></span><br><span class="line"><span class="comment">// ===== end =====</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Board/System/Debug information/definition ---------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_ID        0x90000A46</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9010_ID       0x90100A46</span></span><br><span class="line"><span class="comment">/*-------register name-----------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_NCR       0x00    <span class="comment">/* Network control Reg.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_NSR       0x01    <span class="comment">/* Network Status Reg.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_TCR       0x02    <span class="comment">/* TX control Reg.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_RXCR      0x05    <span class="comment">/* RX control Reg.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_BPTR      0x08</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_FCTR      0x09</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_FCR           0x0a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_EPCR      0x0b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_EPAR      0x0c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_EPDRL     0x0d</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_EPDRH     0x0e</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_GPR           0x1f    <span class="comment">/* General purpose register */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_CHIPR     0x2c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_TCR2      0x2d</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_SMCR      0x2f    <span class="comment">/* Special Mode Control Reg.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_ETXCSR    0x30    <span class="comment">/* Early Transmit control/status Reg.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_TCCR      0x31    <span class="comment">/* Checksum cntrol Reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_RCSR      0x32    <span class="comment">/* Receive Checksum status Reg.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_BUSCR     0x38</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MRCMDX    0xf0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MRCMD     0xf2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MDRAL     0xf4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MDRAH     0xf5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MWCMD     0xf8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MDWAL     0xfa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MDWAH     0xfb</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_TXPLL     0xfc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_TXPLH     0xfd</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_ISR           0xfe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_IMR           0xff</span></span><br><span class="line"><span class="comment">/*---------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_REG05     0x30    <span class="comment">/* SKIP_CRC/SKIP_LONG */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_REGFF     0xA3    <span class="comment">/* IMR */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_DISINTR   0x80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_PHY           0x40    <span class="comment">/* PHY address 0x01 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_PKT_RDY       0x01    <span class="comment">/* Packet ready to receive */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Added for PXA of MAINSTONE */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_MAINSTONE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/mainstone.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MIN_IO        (MST_ETH_PHYS + 0x300)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MAX_IO            (MST_ETH_PHYS + 0x370)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9K_IRQ        MAINSTONE_IRQ(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MIN_IO        0x300</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MAX_IO        0x370</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_IRQ       3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_VID_L     0x28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_VID_H     0x29</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_PID_L     0x2A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_PID_H     0x2B</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_RX_INTR       0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_TX_INTR       0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_LINK_INTR     0x20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_DWORD_MODE    1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_BYTE_MODE     2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_WORD_MODE     0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE            1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE           0</span></span><br><span class="line"><span class="comment">/* Number of continuous Rx packets */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONT_RX_PKT_CNT     0xFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DMFE_TIMER_WUT  jiffies+(HZ*5)  <span class="comment">/* timer wakeup time : 5 second */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DM9KS_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DMFE_DBUG(dbug_now, msg, vaule)\</span></span><br><span class="line"><span class="keyword">if</span> (dmfe_debug||dbug_now) printk(KERN_ERR <span class="string">&quot;dmfe: %s %x\n&quot;</span>, msg, vaule)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DMFE_DBUG(dbug_now, msg, vaule)\</span></span><br><span class="line"><span class="keyword">if</span> (dbug_now) printk(KERN_ERR <span class="string">&quot;dmfe: %s %x\n&quot;</span>, msg, vaule)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_ARCH_MAINSTONE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RX_DESC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u8 rxbyte;</span><br><span class="line">    u8 status;</span><br><span class="line">    u16 length;</span><br><span class="line">&#125;RX_DESC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    u8 buf[<span class="number">4</span>];</span><br><span class="line">    RX_DESC desc;</span><br><span class="line">&#125; <span class="keyword">rx_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_ARCH_MAINSTONE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DM9KS_PHY_mode</span> &#123;</span></span><br><span class="line">    DM9KS_10MHD   = <span class="number">0</span>,</span><br><span class="line">    DM9KS_100MHD  = <span class="number">1</span>,</span><br><span class="line">    DM9KS_10MFD   = <span class="number">4</span>,</span><br><span class="line">    DM9KS_100MFD  = <span class="number">5</span>,</span><br><span class="line">    DM9KS_AUTO    = <span class="number">8</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Structure/enum declaration ------------------------------- */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">board_info</span> &#123;</span></span><br><span class="line">    u32 io_addr;<span class="comment">/* Register I/O base address */</span></span><br><span class="line">    u32 io_data;<span class="comment">/* Data I/O address */</span></span><br><span class="line">    u8 op_mode;<span class="comment">/* PHY operation mode */</span></span><br><span class="line">    u8 io_mode;<span class="comment">/* 0:word, 2:byte */</span></span><br><span class="line">    u8 Speed;   <span class="comment">/* current speed */</span></span><br><span class="line">    u8 chip_revision;</span><br><span class="line">    <span class="keyword">int</span> rx_csum;<span class="comment">/* 0:disable, 1:enable */</span></span><br><span class="line"></span><br><span class="line">    u32 reset_counter;<span class="comment">/* counter: RESET */</span></span><br><span class="line">    u32 reset_tx_timeout;<span class="comment">/* RESET caused by TX Timeout */</span></span><br><span class="line">    <span class="keyword">int</span> tx_pkt_cnt;</span><br><span class="line">    <span class="keyword">int</span> cont_rx_pkt_cnt;<span class="comment">/* current number of continuos rx packets  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device_stats</span> <span class="title">stats</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> srom[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mii_if_info</span> <span class="title">mii</span>;</span></span><br><span class="line">&#125; <span class="keyword">board_info_t</span>;</span><br><span class="line"><span class="comment">/* Global variable declaration ----------------------------- */</span></span><br><span class="line"><span class="comment">/*static int dmfe_debug = 0;*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> * <span class="title">dmfe_dev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ethtool_ops</span> <span class="title">dmfe_ethtool_ops</span>;</span></span><br><span class="line"><span class="comment">/* For module input parameter */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> mode       = DM9KS_AUTO;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> media_mode = DM9KS_AUTO;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>  irq        = DM9KS_IRQ;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> iobase     = DM9KS_MIN_IO;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0  <span class="comment">// use physical address; Not virtual address</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> outb</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> outb</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> outw</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> outw</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> outl</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> outl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> inb</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> inb</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> inw</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> inw</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> inl</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> inl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outb</span><span class="params">(u8 reg, u32 ioaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*(<span class="keyword">volatile</span> u8 *)(ioaddr)) = reg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outw</span><span class="params">(u16 reg, u32 ioaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*(<span class="keyword">volatile</span> u16 *)(ioaddr)) = reg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outl</span><span class="params">(u32 reg, u32 ioaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*(<span class="keyword">volatile</span> u32 *)(ioaddr)) = reg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">u8 <span class="title">inb</span><span class="params">(u32 ioaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">volatile</span> u8 *)(ioaddr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">u16 <span class="title">inw</span><span class="params">(u32 ioaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">volatile</span> u16 *)(ioaddr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">u32 <span class="title">inl</span><span class="params">(u32 ioaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">volatile</span> u32 *)(ioaddr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* function declaration ------------------------------------- */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dmfe_probe1</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_open</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_start_xmit</span><span class="params">(struct sk_buff *, struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_tx_done</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_packet_receive</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_stop</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> struct net_device_stats * <span class="title">dmfe_get_stats</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_do_ioctl</span><span class="params">(struct net_device *, struct ifreq *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_interrupt</span><span class="params">(<span class="keyword">int</span> , <span class="keyword">void</span> *, struct pt_regs *)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,19)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">dmfe_interrupt</span><span class="params">(<span class="keyword">int</span> , <span class="keyword">void</span> *, struct pt_regs *)</span></span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">dmfe_interrupt</span><span class="params">(<span class="keyword">int</span> , <span class="keyword">void</span> *)</span></span>;<span class="comment">/* for kernel 2.6.20 */</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_timer</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_init_dm9000</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">cal_CRC</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, u8)</span></span>;</span><br><span class="line"><span class="function">u8 <span class="title">ior</span><span class="params">(<span class="keyword">board_info_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iow</span><span class="params">(<span class="keyword">board_info_t</span> *, <span class="keyword">int</span>, u8)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> u16 <span class="title">phy_read</span><span class="params">(<span class="keyword">board_info_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">phy_write</span><span class="params">(<span class="keyword">board_info_t</span> *, <span class="keyword">int</span>, u16)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> u16 <span class="title">read_srom_word</span><span class="params">(<span class="keyword">board_info_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dm9000_hash_table</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_timeout</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_reset</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mdio_read</span><span class="params">(struct net_device *, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mdio_write</span><span class="params">(struct net_device *, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_get_drvinfo</span><span class="params">(struct net_device *, struct ethtool_drvinfo *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_get_settings</span><span class="params">(struct net_device *, struct ethtool_cmd *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_set_settings</span><span class="params">(struct net_device *, struct ethtool_cmd *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">dmfe_get_link</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_nway_reset</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">dmfe_get_rx_csum</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">dmfe_get_tx_csum</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_set_rx_csum</span><span class="params">(struct net_device *, <span class="keyword">uint32_t</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_set_tx_csum</span><span class="params">(struct net_device *, <span class="keyword">uint32_t</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DM8606</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dm8606.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DECLARE_TASKLET(dmfe_tx_tasklet,dmfe_tx_done,0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* DM9000 network baord routine ---------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Search DM9000 board, allocate space and register it</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct net_device * __init <span class="title">dmfe_probe</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_probe()&quot;</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)</span></span><br><span class="line">    dev = init_etherdev(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(struct board_info));</span><br><span class="line">    <span class="comment">//ether_setup(dev);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    dev= alloc_etherdev(<span class="keyword">sizeof</span>(struct board_info));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!dev)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">        SET_MODULE_OWNER(dev);</span><br><span class="line">    err = dmfe_probe1(dev);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,0)</span></span><br><span class="line">    err = register_netdev(dev);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> out1;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> dev;</span><br><span class="line">out1:</span><br><span class="line">    release_region(dev-&gt;base_addr,<span class="number">2</span>);</span><br><span class="line">out:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)</span></span><br><span class="line">    kfree(dev);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    free_netdev(dev);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">dmfe_probe1</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">board_info</span> *<span class="title">db</span>;</span>    <span class="comment">/* Point a board information structure */</span></span><br><span class="line">    u32 id_val;</span><br><span class="line">    u16 i, dm9000_found = FALSE;</span><br><span class="line">    u8 MAC_addr[<span class="number">6</span>]=&#123;<span class="number">0x00</span>,<span class="number">0x60</span>,<span class="number">0x6E</span>,<span class="number">0x33</span>,<span class="number">0x44</span>,<span class="number">0x55</span>&#125;;</span><br><span class="line">    u8 HasEEPROM=<span class="number">0</span>,chip_info;</span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_probe1()&quot;</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search All DM9000 serial NIC */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * ===== for jz2440 =====</span></span><br><span class="line"><span class="comment">         * 这里详细说明一下 iobase</span></span><br><span class="line"><span class="comment">         * 片选为 nGCS4, 所以 iobase=0x20000000</span></span><br><span class="line"><span class="comment">         * outb 的时候, LADDR2=0</span></span><br><span class="line"><span class="comment">         * inb(iobase + 4), 相当于 inb(0x20000004),</span></span><br><span class="line"><span class="comment">         * 本质就是让 LADDR2=1, 读指令.</span></span><br><span class="line"><span class="comment">         * ===== end =====</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        outb(DM9KS_VID_L, iobase);</span><br><span class="line">        id_val = inb(iobase + <span class="number">4</span>);</span><br><span class="line">        outb(DM9KS_VID_H, iobase);</span><br><span class="line">        id_val |= inb(iobase + <span class="number">4</span>) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">        outb(DM9KS_PID_L, iobase);</span><br><span class="line">        id_val |= inb(iobase + <span class="number">4</span>) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">        outb(DM9KS_PID_H, iobase);</span><br><span class="line">        id_val |= inb(iobase + <span class="number">4</span>) &lt;&lt; <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id_val == DM9KS_ID || id_val == DM9010_ID) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Request IO from system */</span></span><br><span class="line">            <span class="keyword">if</span>(!request_region(iobase, <span class="number">2</span>, dev-&gt;name))</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">            printk(KERN_ERR<span class="string">&quot;&lt;DM9KS&gt; I/O: %x, VID: %x \n&quot;</span>,iobase, id_val);</span><br><span class="line">            dm9000_found = TRUE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Allocated board information structure */</span></span><br><span class="line">            <span class="built_in">memset</span>(dev-&gt;priv, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct board_info));</span><br><span class="line">            db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">            dmfe_dev    = dev;</span><br><span class="line">            db-&gt;io_addr  = iobase;</span><br><span class="line">            db-&gt;io_data = iobase + <span class="number">4</span>;</span><br><span class="line">            db-&gt;chip_revision = ior(db, DM9KS_CHIPR);</span><br><span class="line"></span><br><span class="line">            chip_info = ior(db,<span class="number">0x43</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取消型号检测, 硬件和给的驱动不匹配, 但能用. ===== for jz2440 =====</span></span><br><span class="line">            <span class="comment">// if((db-&gt;chip_revision!=0x1A) || ((chip_info&amp;(1&lt;&lt;5))!=0) || ((chip_info&amp;(1&lt;&lt;2))!=1)) return -ENODEV;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* driver system function */</span></span><br><span class="line">            dev-&gt;base_addr      = iobase;</span><br><span class="line">            dev-&gt;irq        = irq;</span><br><span class="line">            dev-&gt;open       = &amp;dmfe_open;</span><br><span class="line">            dev-&gt;hard_start_xmit    = &amp;dmfe_start_xmit;</span><br><span class="line">            dev-&gt;watchdog_timeo = <span class="number">5</span>*HZ;</span><br><span class="line">            dev-&gt;tx_timeout     = dmfe_timeout;</span><br><span class="line">            dev-&gt;stop       = &amp;dmfe_stop;</span><br><span class="line">            dev-&gt;get_stats      = &amp;dmfe_get_stats;</span><br><span class="line">            dev-&gt;set_multicast_list = &amp;dm9000_hash_table;</span><br><span class="line">            dev-&gt;do_ioctl       = &amp;dmfe_do_ioctl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,28)</span></span><br><span class="line">            dev-&gt;ethtool_ops = &amp;dmfe_ethtool_ops;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CHECKSUM</span></span><br><span class="line">            <span class="comment">//dev-&gt;features |=  NETIF_F_IP_CSUM;</span></span><br><span class="line">            dev-&gt;features |=  NETIF_F_IP_CSUM|NETIF_F_SG;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            db-&gt;mii.dev = dev;</span><br><span class="line">            db-&gt;mii.mdio_read = mdio_read;</span><br><span class="line">            db-&gt;mii.mdio_write = mdio_write;</span><br><span class="line">            db-&gt;mii.phy_id = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,20)</span></span><br><span class="line">            db-&gt;mii.phy_id_mask = <span class="number">0x1F</span>;</span><br><span class="line">            db-&gt;mii.reg_num_mask = <span class="number">0x1F</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="comment">//db-&gt;msg_enable =(debug == 0 ? DMFE_DEF_MSG_ENABLE : ((1 &lt;&lt; debug) - 1));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Read SROM content */</span></span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">64</span>; i++)</span><br><span class="line">                ((u16 *)db-&gt;srom)[i] = read_srom_word(db, i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Get the PID and VID from EEPROM to check */</span></span><br><span class="line">            id_val = (((u16 *)db-&gt;srom)[<span class="number">4</span>])|(((u16 *)db-&gt;srom)[<span class="number">5</span>]&lt;&lt;<span class="number">16</span>);</span><br><span class="line">            printk(<span class="string">&quot;id_val=%x\n&quot;</span>, id_val);</span><br><span class="line">            <span class="keyword">if</span> (id_val == DM9KS_ID || id_val == DM9010_ID)</span><br><span class="line">                HasEEPROM =<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Set Node Address */</span></span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (HasEEPROM) <span class="comment">/* use EEPROM */</span></span><br><span class="line">                    dev-&gt;dev_addr[i] = db-&gt;srom[i];</span><br><span class="line">                <span class="keyword">else</span>    <span class="comment">/* No EEPROM */</span></span><br><span class="line">                    dev-&gt;dev_addr[i] = MAC_addr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//end of if()</span></span><br><span class="line">        iobase += <span class="number">0x10</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(!dm9000_found &amp;&amp; iobase &lt;= DM9KS_MAX_IO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dm9000_found ? <span class="number">0</span>:-ENODEV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Open the interface.</span></span><br><span class="line"><span class="comment">  The interface is opened whenever &quot;ifconfig&quot; actives it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_open</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    u8 reg_nsr;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_open&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0表示不触发, 重新设置为上升沿触发中断.  ===== for jz2440 =====</span></span><br><span class="line">    <span class="keyword">if</span> (request_irq(dev-&gt;irq,&amp;dmfe_interrupt,IRQF_TRIGGER_RISING,dev-&gt;name,dev))</span><br><span class="line">    <span class="comment">// if (request_irq(dev-&gt;irq,&amp;dmfe_interrupt,0,dev-&gt;name,dev))</span></span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initilize DM910X board */</span></span><br><span class="line">    dmfe_init_dm9000(dev);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DM8606</span></span><br><span class="line">    <span class="comment">// control DM8606</span></span><br><span class="line">    printk(<span class="string">&quot;[8606]reg0=0x%04x\n&quot;</span>,dm8606_read(db,<span class="number">0</span>));</span><br><span class="line">    printk(<span class="string">&quot;[8606]reg1=0x%04x\n&quot;</span>,dm8606_read(db,<span class="number">0x1</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Init driver variable */</span></span><br><span class="line">    db-&gt;reset_counter   = <span class="number">0</span>;</span><br><span class="line">    db-&gt;reset_tx_timeout    = <span class="number">0</span>;</span><br><span class="line">    db-&gt;cont_rx_pkt_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check link state and media speed */</span></span><br><span class="line">    db-&gt;Speed =<span class="number">10</span>;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        reg_nsr = ior(db,DM9KS_NSR);</span><br><span class="line">        <span class="keyword">if</span>(reg_nsr &amp; <span class="number">0x40</span>) <span class="comment">/* link OK!! */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* wait for detected Speed */</span></span><br><span class="line">            mdelay(<span class="number">200</span>);</span><br><span class="line">            reg_nsr = ior(db,DM9KS_NSR);</span><br><span class="line">            <span class="keyword">if</span>(reg_nsr &amp; <span class="number">0x80</span>)</span><br><span class="line">                db-&gt;Speed =<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                db-&gt;Speed =<span class="number">100</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        mdelay(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span>(i&lt;<span class="number">3000</span>); <span class="comment">/* wait 3 second  */</span></span><br><span class="line">    <span class="comment">//printk(&quot;i=%d  Speed=%d\n&quot;,i,db-&gt;Speed);</span></span><br><span class="line">    <span class="comment">/* set and active a timer process */</span></span><br><span class="line">    init_timer(&amp;db-&gt;timer);</span><br><span class="line">    db-&gt;timer.expires   = DMFE_TIMER_WUT;</span><br><span class="line">    db-&gt;timer.data      = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)dev;</span><br><span class="line">    db-&gt;timer.function  = &amp;dmfe_timer;</span><br><span class="line">    add_timer(&amp;db-&gt;timer);  <span class="comment">//Move to DM9000 initiallization was finished.</span></span><br><span class="line"></span><br><span class="line">    netif_start_queue(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set PHY operationg mode</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_PHY_mode</span><span class="params">(<span class="keyword">board_info_t</span> *db)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DM8606</span></span><br><span class="line">    u16 phy_reg0 = <span class="number">0x1000</span>;<span class="comment">/* Auto-negotiation*/</span></span><br><span class="line">    u16 phy_reg4 = <span class="number">0x01e1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !(db-&gt;op_mode &amp; DM9KS_AUTO) ) <span class="comment">// op_mode didn&#x27;t auto sense */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(db-&gt;op_mode) &#123;</span><br><span class="line">            <span class="keyword">case</span> DM9KS_10MHD:  phy_reg4 = <span class="number">0x21</span>;</span><br><span class="line">                                       phy_reg0 = <span class="number">0x1000</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DM9KS_10MFD:  phy_reg4 = <span class="number">0x41</span>;</span><br><span class="line">                       phy_reg0 = <span class="number">0x1100</span>;</span><br><span class="line">                                       <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DM9KS_100MHD: phy_reg4 = <span class="number">0x81</span>;</span><br><span class="line">                       phy_reg0 = <span class="number">0x3000</span>;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DM9KS_100MFD: phy_reg4 = <span class="number">0x101</span>;</span><br><span class="line">                       phy_reg0 = <span class="number">0x3100</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="comment">// end of switch</span></span><br><span class="line">    &#125; <span class="comment">// end of if</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FLOW_CONTROL</span></span><br><span class="line">    phy_write(db, <span class="number">4</span>, phy_reg4|(<span class="number">1</span>&lt;&lt;<span class="number">10</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    phy_write(db, <span class="number">4</span>, phy_reg4);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//end of FLOW_CONTROL</span></span></span><br><span class="line">    phy_write(db, <span class="number">0</span>, phy_reg0|<span class="number">0x200</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/* Fiber mode */</span></span><br><span class="line">    phy_write(db, <span class="number">16</span>, <span class="number">0x4014</span>);</span><br><span class="line">    phy_write(db, <span class="number">0</span>, <span class="number">0x2100</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//end of DM8606</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (db-&gt;chip_revision == <span class="number">0x1A</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//set 10M TX idle =65mA (TX 100% utility is 160mA)</span></span><br><span class="line">        phy_write(db,<span class="number">20</span>, phy_read(db,<span class="number">20</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">11</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//:fix harmonic</span></span><br><span class="line">        <span class="comment">//For short code:</span></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 0000h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x0000</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA00h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa00</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 0017h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x0017</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA17h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa17</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 002Fh</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x002f</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA2Fh</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa2f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 0037h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x0037</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA37h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa37</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 0040h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x0040</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA40h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa40</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//For long code:</span></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 0050h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x0050</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA50h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa50</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 006Bh</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x006b</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA6Bh</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa6b</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 007Dh</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x007d</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA7Dh</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa7d</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 008Dh</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x008d</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA8Dh</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa8d</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 009Ch</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x009c</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA9Ch</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa9c</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 00A3h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x00a3</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AAA3h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaaa3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 00B1h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x00b1</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AAB1h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaab1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 00C0h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x00c0</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AAC0h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaac0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 00D2h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x00d2</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AAD2h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaad2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 00E0h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x00e0</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AAE0h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaae0</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 0000h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x0000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Initilize dm9000 board</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_init_dm9000</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_init_dm9000()&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    spin_lock_init(&amp;db-&gt;lock);</span><br><span class="line"></span><br><span class="line">    iow(db, DM9KS_GPR, <span class="number">0</span>);  <span class="comment">/* GPR (reg_1Fh)bit GPIO0=0 pre-activate PHY */</span></span><br><span class="line">    mdelay(<span class="number">20</span>);     <span class="comment">/* wait for PHY power-on ready */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do a software reset and wait 20us */</span></span><br><span class="line">    iow(db, DM9KS_NCR, <span class="number">3</span>);</span><br><span class="line">    udelay(<span class="number">20</span>);     <span class="comment">/* wait 20us at least for software reset ok */</span></span><br><span class="line">    iow(db, DM9KS_NCR, <span class="number">3</span>);  <span class="comment">/* NCR (reg_00h) bit[0] RST=1 &amp; Loopback=1, reset on */</span></span><br><span class="line">    udelay(<span class="number">20</span>);     <span class="comment">/* wait 20us at least for software reset ok */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I/O mode */</span></span><br><span class="line">    db-&gt;io_mode = ior(db, DM9KS_ISR) &gt;&gt; <span class="number">6</span>; <span class="comment">/* ISR bit7:6 keeps I/O mode */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set PHY */</span></span><br><span class="line">    db-&gt;op_mode = media_mode;</span><br><span class="line">    set_PHY_mode(db);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Program operating register */</span></span><br><span class="line">    iow(db, DM9KS_NCR, <span class="number">0</span>);</span><br><span class="line">    iow(db, DM9KS_TCR, <span class="number">0</span>);      <span class="comment">/* TX Polling clear */</span></span><br><span class="line">    iow(db, DM9KS_BPTR, <span class="number">0x3f</span>);  <span class="comment">/* Less 3kb, 600us */</span></span><br><span class="line">    iow(db, DM9KS_SMCR, <span class="number">0</span>);     <span class="comment">/* Special Mode */</span></span><br><span class="line">    iow(db, DM9KS_NSR, <span class="number">0x2c</span>);   <span class="comment">/* clear TX status */</span></span><br><span class="line">    iow(db, DM9KS_ISR, <span class="number">0x0f</span>);   <span class="comment">/* Clear interrupt status */</span></span><br><span class="line">    iow(db, DM9KS_TCR2, <span class="number">0x80</span>);  <span class="comment">/* Set LED mode 1 */</span></span><br><span class="line">    <span class="keyword">if</span> (db-&gt;chip_revision == <span class="number">0x1A</span>)&#123;</span><br><span class="line">        <span class="comment">/* Data bus current driving/sinking capability  */</span></span><br><span class="line">        iow(db, DM9KS_BUSCR, <span class="number">0x01</span>); <span class="comment">/* default: 2mA */</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FLOW_CONTROL</span></span><br><span class="line">    iow(db, DM9KS_BPTR, <span class="number">0x37</span>);</span><br><span class="line">    iow(db, DM9KS_FCTR, <span class="number">0x38</span>);</span><br><span class="line">    iow(db, DM9KS_FCR, <span class="number">0x29</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DM8606</span></span><br><span class="line">    iow(db,<span class="number">0x34</span>,<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;features &amp; NETIF_F_HW_CSUM)&#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;DM9KS:enable TX checksum\n&quot;</span>);</span><br><span class="line">        iow(db, DM9KS_TCCR, <span class="number">0x07</span>);  <span class="comment">/* TX UDP/TCP/IP checksum enable */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (db-&gt;rx_csum)&#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;DM9KS:enable RX checksum\n&quot;</span>);</span><br><span class="line">        iow(db, DM9KS_RCSR, <span class="number">0x02</span>);  <span class="comment">/* RX checksum enable */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ETRANS</span></span><br><span class="line">    <span class="comment">/*If TX loading is heavy, the driver can try to anbel &quot;early transmit&quot;.</span></span><br><span class="line"><span class="comment">    The programmer can tune the &quot;Early Transmit Threshold&quot; to get</span></span><br><span class="line"><span class="comment">    the optimization. (DM9KS_ETXCSR.[1-0])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Side Effect: It will happen &quot;Transmit under-run&quot;. When TX under-run</span></span><br><span class="line"><span class="comment">    always happens, the programmer can increase the value of &quot;Early</span></span><br><span class="line"><span class="comment">    Transmit Threshold&quot;. */</span></span><br><span class="line">    iow(db, DM9KS_ETXCSR, <span class="number">0x83</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set address filter table */</span></span><br><span class="line">    dm9000_hash_table(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Activate DM9000/DM9010 */</span></span><br><span class="line">    iow(db, DM9KS_IMR, DM9KS_REGFF); <span class="comment">/* Enable TX/RX interrupt mask */</span></span><br><span class="line">    iow(db, DM9KS_RXCR, DM9KS_REG05 | <span class="number">1</span>);   <span class="comment">/* RX enable */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Init Driver variable */</span></span><br><span class="line">    db-&gt;tx_pkt_cnt      = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    netif_carrier_on(dev);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Hardware start transmission.</span></span><br><span class="line"><span class="comment">  Send a packet to media from the upper layer.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_start_xmit</span><span class="params">(struct sk_buff *skb, struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="keyword">char</span> * data_ptr;</span><br><span class="line">    <span class="keyword">int</span> i, tmplen;</span><br><span class="line">    u16 MDWAH, MDWAL;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> TDBUG <span class="comment">/* check TX FIFO pointer */</span></span></span><br><span class="line">            u16 MDWAH1, MDWAL1;</span><br><span class="line">            u16 tx_ptr;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_start_xmit&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (db-&gt;chip_revision != <span class="number">0x1A</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(db-&gt;Speed == <span class="number">10</span>)</span><br><span class="line">            &#123;<span class="keyword">if</span> (db-&gt;tx_pkt_cnt &gt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            &#123;<span class="keyword">if</span> (db-&gt;tx_pkt_cnt &gt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (db-&gt;tx_pkt_cnt &gt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* packet counting */</span></span><br><span class="line">    db-&gt;tx_pkt_cnt++;</span><br><span class="line"></span><br><span class="line">    db-&gt;stats.tx_packets++;</span><br><span class="line">    db-&gt;stats.tx_bytes+=skb-&gt;len;</span><br><span class="line">    <span class="keyword">if</span> (db-&gt;chip_revision != <span class="number">0x1A</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (db-&gt;Speed == <span class="number">10</span>)</span><br><span class="line">            &#123;<span class="keyword">if</span> (db-&gt;tx_pkt_cnt &gt;= <span class="number">1</span>) netif_stop_queue(dev);&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            &#123;<span class="keyword">if</span> (db-&gt;tx_pkt_cnt &gt;= <span class="number">2</span>) netif_stop_queue(dev);&#125;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (db-&gt;tx_pkt_cnt &gt;= <span class="number">2</span>) netif_stop_queue(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Disable all interrupt */</span></span><br><span class="line">    iow(db, DM9KS_IMR, DM9KS_DISINTR);</span><br><span class="line"></span><br><span class="line">    MDWAH = ior(db,DM9KS_MDWAH);</span><br><span class="line">    MDWAL = ior(db,DM9KS_MDWAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set TX length to reg. 0xfc &amp; 0xfd */</span></span><br><span class="line">    iow(db, DM9KS_TXPLL, (skb-&gt;len &amp; <span class="number">0xff</span>));</span><br><span class="line">    iow(db, DM9KS_TXPLH, (skb-&gt;len &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Move data to TX SRAM */</span></span><br><span class="line">    data_ptr = (<span class="keyword">char</span> *)skb-&gt;data;</span><br><span class="line"></span><br><span class="line">    outb(DM9KS_MWCMD, db-&gt;io_addr); <span class="comment">// Write data into SRAM trigger</span></span><br><span class="line">    <span class="keyword">switch</span>(db-&gt;io_mode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> DM9KS_BYTE_MODE:</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; skb-&gt;len; i++)</span><br><span class="line">                outb((data_ptr[i] &amp; <span class="number">0xff</span>), db-&gt;io_data);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DM9KS_WORD_MODE:</span><br><span class="line">            tmplen = (skb-&gt;len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmplen; i++)</span><br><span class="line">        outw(((u16 *)data_ptr)[i], db-&gt;io_data);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DM9KS_DWORD_MODE:</span><br><span class="line">      tmplen = (skb-&gt;len + <span class="number">3</span>) / <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; tmplen; i++)</span><br><span class="line">                outl(((u32 *)data_ptr)[i], db-&gt;io_data);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ETRANS</span></span><br><span class="line">    <span class="comment">/* Issue TX polling command */</span></span><br><span class="line">    iow(db, DM9KS_TCR, <span class="number">0x1</span>); <span class="comment">/* Cleared after TX complete*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> TDBUG <span class="comment">/* check TX FIFO pointer */</span></span></span><br><span class="line">            MDWAH1 = ior(db,DM9KS_MDWAH);</span><br><span class="line">            MDWAL1 = ior(db,DM9KS_MDWAL);</span><br><span class="line">            tx_ptr = (MDWAH&lt;&lt;<span class="number">8</span>)|MDWAL;</span><br><span class="line">            <span class="keyword">switch</span> (db-&gt;io_mode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_BYTE_MODE:</span><br><span class="line">                    tx_ptr += skb-&gt;len;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_WORD_MODE:</span><br><span class="line">                    tx_ptr += ((skb-&gt;len + <span class="number">1</span>) / <span class="number">2</span>)*<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_DWORD_MODE:</span><br><span class="line">                    tx_ptr += ((skb-&gt;len+<span class="number">3</span>)/<span class="number">4</span>)*<span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tx_ptr &gt; <span class="number">0x0bff</span>)</span><br><span class="line">                    tx_ptr -= <span class="number">0x0c00</span>;</span><br><span class="line">            <span class="keyword">if</span> (tx_ptr != ((MDWAH1&lt;&lt;<span class="number">8</span>)|MDWAL1))</span><br><span class="line">                    printk(<span class="string">&quot;[dm9ks:TX FIFO ERROR\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Saved the time stamp */</span></span><br><span class="line">    dev-&gt;trans_start = jiffies;</span><br><span class="line">    db-&gt;cont_rx_pkt_cnt =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free this SKB */</span></span><br><span class="line">    dev_kfree_skb(skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Re-enable interrupt */</span></span><br><span class="line">    iow(db, DM9KS_IMR, DM9KS_REGFF);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Stop the interface.</span></span><br><span class="line"><span class="comment">  The interface is stopped when it is brought.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_stop</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_stop&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* deleted timer */</span></span><br><span class="line">    del_timer(&amp;db-&gt;timer);</span><br><span class="line"></span><br><span class="line">    netif_stop_queue(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free interrupt */</span></span><br><span class="line">    free_irq(dev-&gt;irq, dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* RESET devie */</span></span><br><span class="line">    phy_write(db, <span class="number">0x00</span>, <span class="number">0x8000</span>);    <span class="comment">/* PHY RESET */</span></span><br><span class="line">    <span class="comment">//iow(db, DM9KS_GPR, 0x01);     /* Power-Down PHY */</span></span><br><span class="line">    iow(db, DM9KS_IMR, DM9KS_DISINTR);  <span class="comment">/* Disable all interrupt */</span></span><br><span class="line">    iow(db, DM9KS_RXCR, <span class="number">0x00</span>);  <span class="comment">/* Disable RX */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dump Statistic counter */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FALSE</span></span><br><span class="line">    printk(<span class="string">&quot;\nRX FIFO OVERFLOW %lx\n&quot;</span>, db-&gt;stats.rx_fifo_errors);</span><br><span class="line">    printk(<span class="string">&quot;RX CRC %lx\n&quot;</span>, db-&gt;stats.rx_crc_errors);</span><br><span class="line">    printk(<span class="string">&quot;RX LEN Err %lx\n&quot;</span>, db-&gt;stats.rx_length_errors);</span><br><span class="line">    printk(<span class="string">&quot;RESET %x\n&quot;</span>, db-&gt;reset_counter);</span><br><span class="line">    printk(<span class="string">&quot;RESET: TX Timeout %x\n&quot;</span>, db-&gt;reset_tx_timeout);</span><br><span class="line">    printk(<span class="string">&quot;g_TX_nsr %x\n&quot;</span>, g_TX_nsr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_tx_done</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> dmfe_dev;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="keyword">int</span>  nsr;</span><br><span class="line"></span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_tx_done()&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    nsr = ior(db, DM9KS_NSR);</span><br><span class="line">    <span class="keyword">if</span> (nsr &amp; <span class="number">0x0c</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nsr &amp; <span class="number">0x04</span>) db-&gt;tx_pkt_cnt--;</span><br><span class="line">        <span class="keyword">if</span>(nsr &amp; <span class="number">0x08</span>) db-&gt;tx_pkt_cnt--;</span><br><span class="line">        <span class="keyword">if</span>(db-&gt;tx_pkt_cnt &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printk(KERN_DEBUG <span class="string">&quot;DM9KS:tx_pkt_cnt ERROR!!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(ior(db,DM9KS_TCR) &amp; <span class="number">0x1</span>)&#123;&#125;</span><br><span class="line">            db-&gt;tx_pkt_cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(ior(db,DM9KS_TCR) &amp; <span class="number">0x1</span>)&#123;&#125;</span><br><span class="line">        db-&gt;tx_pkt_cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    netif_wake_queue(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  DM9000 insterrupt handler</span></span><br><span class="line"><span class="comment">  receive the packet to upper layer, free the transmitted packet</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_interrupt</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">else</span></span></span></span><br><span class="line"><span class="function">    <span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,19)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">dmfe_interrupt</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function">    <span class="meta">#<span class="meta-keyword">else</span></span></span></span><br><span class="line"><span class="function">    <span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">dmfe_interrupt</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span> <span class="comment">/* for kernel 2.6.20*/</span></span></span><br><span class="line"><span class="function">    <span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> dev_id;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db;</span><br><span class="line">    <span class="keyword">int</span> int_status,i;</span><br><span class="line">    u8 reg_save;</span><br><span class="line"></span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_interrupt()&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A real interrupt coming */</span></span><br><span class="line">    db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    spin_lock(&amp;db-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save previous register address */</span></span><br><span class="line">    reg_save = inb(db-&gt;io_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Disable all interrupt */</span></span><br><span class="line">    iow(db, DM9KS_IMR, DM9KS_DISINTR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Got DM9000/DM9010 interrupt status */</span></span><br><span class="line">    int_status = ior(db, DM9KS_ISR);        <span class="comment">/* Got ISR */</span></span><br><span class="line">    iow(db, DM9KS_ISR, int_status);     <span class="comment">/* Clear ISR status */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Link status change */</span></span><br><span class="line">    <span class="keyword">if</span> (int_status &amp; DM9KS_LINK_INTR)</span><br><span class="line">    &#123;</span><br><span class="line">        netif_stop_queue(dev);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">500</span>; i++) <span class="comment">/*wait link OK, waiting time =0.5s */</span></span><br><span class="line">        &#123;</span><br><span class="line">            phy_read(db,<span class="number">0x1</span>);</span><br><span class="line">            <span class="keyword">if</span>(phy_read(db,<span class="number">0x1</span>) &amp; <span class="number">0x4</span>) <span class="comment">/*Link OK*/</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* wait for detected Speed */</span></span><br><span class="line">                <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">200</span>;i++)</span><br><span class="line">                    udelay(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">/* set media speed */</span></span><br><span class="line">                <span class="keyword">if</span>(phy_read(db,<span class="number">0</span>)&amp;<span class="number">0x2000</span>) db-&gt;Speed =<span class="number">100</span>;</span><br><span class="line">                <span class="keyword">else</span> db-&gt;Speed =<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            udelay(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        netif_wake_queue(dev);</span><br><span class="line">        <span class="comment">//printk(&quot;[INTR]i=%d speed=%d\n&quot;,i, (int)(db-&gt;Speed));</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Received the coming packet */</span></span><br><span class="line">    <span class="keyword">if</span> (int_status &amp; DM9KS_RX_INTR)</span><br><span class="line">        dmfe_packet_receive(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Trnasmit Interrupt check */</span></span><br><span class="line">    <span class="keyword">if</span> (int_status &amp; DM9KS_TX_INTR)</span><br><span class="line">        dmfe_tx_done(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (db-&gt;cont_rx_pkt_cnt&gt;=CONT_RX_PKT_CNT)</span><br><span class="line">    &#123;</span><br><span class="line">        iow(db, DM9KS_IMR, <span class="number">0xa2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Re-enable interrupt mask */</span></span><br><span class="line">        iow(db, DM9KS_IMR, DM9KS_REGFF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore previous register address */</span></span><br><span class="line">    outb(reg_save, db-&gt;io_addr);</span><br><span class="line"></span><br><span class="line">    spin_unlock(&amp;db-&gt;lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,0)</span></span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Get statistics from driver.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct net_device_stats * <span class="title">dmfe_get_stats</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_get_stats&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> &amp;db-&gt;stats;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Process the ethtool ioctl command</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_ethtool_ioctl</span><span class="params">(struct net_device *dev, <span class="keyword">void</span> *useraddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//struct dmfe_board_info *db = dev-&gt;priv;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ethtool_drvinfo</span> <span class="title">info</span> =</span> &#123; ETHTOOL_GDRVINFO &#125;;</span><br><span class="line">    u32 ethcmd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;ethcmd, useraddr, <span class="keyword">sizeof</span>(ethcmd)))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ethcmd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> ETHTOOL_GDRVINFO:</span><br><span class="line">            <span class="built_in">strcpy</span>(info.driver, DRV_NAME);</span><br><span class="line">            <span class="built_in">strcpy</span>(info.version, DRV_VERSION);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sprintf</span>(info.bus_info, <span class="string">&quot;ISA 0x%lx %d&quot;</span>,dev-&gt;base_addr, dev-&gt;irq);</span><br><span class="line">            <span class="keyword">if</span> (copy_to_user(useraddr, &amp;info, <span class="keyword">sizeof</span>(info)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Process the upper socket ioctl command</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_do_ioctl</span><span class="params">(struct net_device *dev, struct ifreq *ifr, <span class="keyword">int</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,7) <span class="comment">/* for kernel 2.6.7 */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mii_ioctl_data</span> *<span class="title">data</span>=</span>(struct mii_ioctl_data *)&amp;ifr-&gt;ifr_data;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> rc=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_do_ioctl()&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!netif_running(dev))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmd == SIOCETHTOOL)</span><br><span class="line">        rc = dmfe_ethtool_ioctl(dev, (<span class="keyword">void</span> *) ifr-&gt;ifr_data);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        spin_lock_irq(&amp;db-&gt;lock);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,7) <span class="comment">/* for kernel 2.6.7 */</span></span></span><br><span class="line">            rc = generic_mii_ioctl(&amp;db-&gt;mii, data, cmd, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            rc = generic_mii_ioctl(&amp;db-&gt;mii, if_mii(ifr), cmd, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        spin_unlock_irq(&amp;db-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Our watchdog timed out. Called by the networking layer */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_timeout</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_TX_timeout()&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    printk(<span class="string">&quot;TX time-out -- dmfe_timeout().\n&quot;</span>);</span><br><span class="line">    db-&gt;reset_tx_timeout++;</span><br><span class="line">    db-&gt;stats.tx_errors++;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FALSE</span></span><br><span class="line">    printk(<span class="string">&quot;TX packet count = %d\n&quot;</span>, db-&gt;tx_pkt_cnt);</span><br><span class="line">    printk(<span class="string">&quot;TX timeout = %d\n&quot;</span>, db-&gt;reset_tx_timeout);</span><br><span class="line">    printk(<span class="string">&quot;22H=0x%02x  23H=0x%02x\n&quot;</span>,ior(db,<span class="number">0x22</span>),ior(db,<span class="number">0x23</span>));</span><br><span class="line">    printk(<span class="string">&quot;faH=0x%02x  fbH=0x%02x\n&quot;</span>,ior(db,<span class="number">0xfa</span>),ior(db,<span class="number">0xfb</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((i++&lt;<span class="number">100</span>)&amp;&amp;(ior(db,DM9KS_TCR) &amp; <span class="number">0x01</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        udelay(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            db-&gt;tx_pkt_cnt = <span class="number">0</span>;</span><br><span class="line">            netif_wake_queue(dev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">            dmfe_reset(dev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_reset</span><span class="params">(struct net_device * dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    u8 reg_save;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">/* Save previous register address */</span></span><br><span class="line">    reg_save = inb(db-&gt;io_addr);</span><br><span class="line"></span><br><span class="line">    netif_stop_queue(dev);</span><br><span class="line">    db-&gt;reset_counter++;</span><br><span class="line">    dmfe_init_dm9000(dev);</span><br><span class="line"></span><br><span class="line">    db-&gt;Speed =<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) <span class="comment">/*wait link OK, waiting time=1 second */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(phy_read(db,<span class="number">0x1</span>) &amp; <span class="number">0x4</span>) <span class="comment">/*Link OK*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(phy_read(db,<span class="number">0</span>)&amp;<span class="number">0x2000</span>) db-&gt;Speed =<span class="number">100</span>;</span><br><span class="line">            <span class="keyword">else</span> db-&gt;Speed =<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        udelay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    netif_wake_queue(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore previous register address */</span></span><br><span class="line">    outb(reg_save, db-&gt;io_addr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  A periodic timer routine</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_timer</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> * <span class="title">dev</span> =</span> (struct net_device *)data;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_timer()&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (db-&gt;cont_rx_pkt_cnt&gt;=CONT_RX_PKT_CNT)</span><br><span class="line">    &#123;</span><br><span class="line">        db-&gt;cont_rx_pkt_cnt=<span class="number">0</span>;</span><br><span class="line">        iow(db, DM9KS_IMR, DM9KS_REGFF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Set timer again */</span></span><br><span class="line">    db-&gt;timer.expires = DMFE_TIMER_WUT;</span><br><span class="line">    add_timer(&amp;db-&gt;timer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Received a packet and pass to upper layer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_packet_receive</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">    u8 rxbyte;</span><br><span class="line">    u16 i, GoodPacket, tmplen = <span class="number">0</span>, MDRAH, MDRAL;</span><br><span class="line">    u32 tmpdata;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rx_t</span> rx;</span><br><span class="line"></span><br><span class="line">    u16 * ptr = (u16*)&amp;rx;</span><br><span class="line">    u8* rdptr;</span><br><span class="line"></span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_packet_receive()&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    db-&gt;cont_rx_pkt_cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/*store the value of Memory Data Read address register*/</span></span><br><span class="line">        MDRAH=ior(db, DM9KS_MDRAH);</span><br><span class="line">        MDRAL=ior(db, DM9KS_MDRAL);</span><br><span class="line"></span><br><span class="line">        ior(db, DM9KS_MRCMDX);      <span class="comment">/* Dummy read */</span></span><br><span class="line">        rxbyte = inb(db-&gt;io_data);  <span class="comment">/* Got most updated data */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CHECKSUM</span></span><br><span class="line">        <span class="keyword">if</span> (rxbyte&amp;<span class="number">0x2</span>)         <span class="comment">/* check RX byte */</span></span><br><span class="line">        &#123;</span><br><span class="line">      printk(<span class="string">&quot;dm9ks: abnormal!\n&quot;</span>);</span><br><span class="line">            dmfe_reset(dev);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(rxbyte&amp;<span class="number">0x1</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> (rxbyte==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rxbyte&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">      printk(<span class="string">&quot;dm9ks: Rxbyte error!\n&quot;</span>);</span><br><span class="line">          dmfe_reset(dev);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* A packet ready now  &amp; Get status/length */</span></span><br><span class="line">        GoodPacket = TRUE;</span><br><span class="line">        outb(DM9KS_MRCMD, db-&gt;io_addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read packet status &amp; length */</span></span><br><span class="line">        <span class="keyword">switch</span> (db-&gt;io_mode)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">case</span> DM9KS_BYTE_MODE:</span><br><span class="line">                    *ptr = inb(db-&gt;io_data) +</span><br><span class="line">                               (inb(db-&gt;io_data) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">                    *(ptr+<span class="number">1</span>) = inb(db-&gt;io_data) +</span><br><span class="line">                        (inb(db-&gt;io_data) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> DM9KS_WORD_MODE:</span><br><span class="line">                    *ptr = inw(db-&gt;io_data);</span><br><span class="line">                    *(ptr+<span class="number">1</span>)    = inw(db-&gt;io_data);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> DM9KS_DWORD_MODE:</span><br><span class="line">                    tmpdata  = inl(db-&gt;io_data);</span><br><span class="line">                    *ptr = tmpdata;</span><br><span class="line">                    *(ptr+<span class="number">1</span>)    = tmpdata &gt;&gt; <span class="number">16</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Packet status check */</span></span><br><span class="line">        <span class="keyword">if</span> (rx.desc.status &amp; <span class="number">0xbf</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GoodPacket = FALSE;</span><br><span class="line">            <span class="keyword">if</span> (rx.desc.status &amp; <span class="number">0x01</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                db-&gt;stats.rx_fifo_errors++;</span><br><span class="line">                printk(KERN_INFO<span class="string">&quot;&lt;RX FIFO error&gt;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rx.desc.status &amp; <span class="number">0x02</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                db-&gt;stats.rx_crc_errors++;</span><br><span class="line">                printk(KERN_INFO<span class="string">&quot;&lt;RX CRC error&gt;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rx.desc.status &amp; <span class="number">0x80</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                db-&gt;stats.rx_length_errors++;</span><br><span class="line">                printk(KERN_INFO<span class="string">&quot;&lt;RX Length error&gt;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rx.desc.status &amp; <span class="number">0x08</span>)</span><br><span class="line">                printk(KERN_INFO<span class="string">&quot;&lt;Physical Layer error&gt;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!GoodPacket)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// drop this packet!!!</span></span><br><span class="line">            <span class="keyword">switch</span> (db-&gt;io_mode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_BYTE_MODE:</span><br><span class="line">                    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;rx.desc.length; i++)</span><br><span class="line">                        inb(db-&gt;io_data);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_WORD_MODE:</span><br><span class="line">                    tmplen = (rx.desc.length + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmplen; i++)</span><br><span class="line">                        inw(db-&gt;io_data);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_DWORD_MODE:</span><br><span class="line">                    tmplen = (rx.desc.length + <span class="number">3</span>) / <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmplen; i++)</span><br><span class="line">                        inl(db-&gt;io_data);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">/*next the packet*/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        skb = dev_alloc_skb(rx.desc.length+<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (skb == <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            printk(KERN_INFO <span class="string">&quot;%s: Memory squeeze.\n&quot;</span>, dev-&gt;name);</span><br><span class="line">            <span class="comment">/*re-load the value into Memory data read address register*/</span></span><br><span class="line">            iow(db,DM9KS_MDRAH,MDRAH);</span><br><span class="line">            iow(db,DM9KS_MDRAL,MDRAL);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Move data from DM9000 */</span></span><br><span class="line">            skb-&gt;dev = dev;</span><br><span class="line">            skb_reserve(skb, <span class="number">2</span>);</span><br><span class="line">            rdptr = (u8*)skb_put(skb, rx.desc.length - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Read received packet from RX SARM */</span></span><br><span class="line">            <span class="keyword">switch</span> (db-&gt;io_mode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_BYTE_MODE:</span><br><span class="line">                    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;rx.desc.length; i++)</span><br><span class="line">                        rdptr[i]=inb(db-&gt;io_data);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_WORD_MODE:</span><br><span class="line">                    tmplen = (rx.desc.length + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmplen; i++)</span><br><span class="line">                        ((u16 *)rdptr)[i] = inw(db-&gt;io_data);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_DWORD_MODE:</span><br><span class="line">                    tmplen = (rx.desc.length + <span class="number">3</span>) / <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmplen; i++)</span><br><span class="line">                        ((u32 *)rdptr)[i] = inl(db-&gt;io_data);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Pass to upper layer */</span></span><br><span class="line">            skb-&gt;protocol = eth_type_trans(skb,dev);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CHECKSUM</span></span><br><span class="line">        <span class="keyword">if</span>((rxbyte&amp;<span class="number">0xe0</span>)==<span class="number">0</span>)    <span class="comment">/* receive packet no checksum fail */</span></span><br><span class="line">                skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            netif_rx(skb);</span><br><span class="line">            dev-&gt;last_rx=jiffies;</span><br><span class="line">            db-&gt;stats.rx_packets++;</span><br><span class="line">            db-&gt;stats.rx_bytes += rx.desc.length;</span><br><span class="line">            db-&gt;cont_rx_pkt_cnt++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RDBG <span class="comment">/* check RX FIFO pointer */</span></span></span><br><span class="line">            u16 MDRAH1, MDRAL1;</span><br><span class="line">            u16 tmp_ptr;</span><br><span class="line">            MDRAH1 = ior(db,DM9KS_MDRAH);</span><br><span class="line">            MDRAL1 = ior(db,DM9KS_MDRAL);</span><br><span class="line">            tmp_ptr = (MDRAH&lt;&lt;<span class="number">8</span>)|MDRAL;</span><br><span class="line">            <span class="keyword">switch</span> (db-&gt;io_mode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_BYTE_MODE:</span><br><span class="line">                    tmp_ptr += rx.desc.length+<span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_WORD_MODE:</span><br><span class="line">                    tmp_ptr += ((rx.desc.length+<span class="number">1</span>)/<span class="number">2</span>)*<span class="number">2</span>+<span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_DWORD_MODE:</span><br><span class="line">                    tmp_ptr += ((rx.desc.length+<span class="number">3</span>)/<span class="number">4</span>)*<span class="number">4</span>+<span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmp_ptr &gt;=<span class="number">0x4000</span>)</span><br><span class="line">                tmp_ptr = (tmp_ptr - <span class="number">0x4000</span>) + <span class="number">0xc00</span>;</span><br><span class="line">            <span class="keyword">if</span> (tmp_ptr != ((MDRAH1&lt;&lt;<span class="number">8</span>)|MDRAL1))</span><br><span class="line">                printk(<span class="string">&quot;[dm9ks:RX FIFO ERROR\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (db-&gt;cont_rx_pkt_cnt&gt;=CONT_RX_PKT_CNT)</span><br><span class="line">            &#123;</span><br><span class="line">                dmfe_tx_done(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">while</span>((rxbyte &amp; <span class="number">0x01</span>) == DM9KS_PKT_RDY);</span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;[END]dmfe_packet_receive()&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Read a word data from SROM</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u16 <span class="title">read_srom_word</span><span class="params">(<span class="keyword">board_info_t</span> *db, <span class="keyword">int</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iow(db, DM9KS_EPAR, offset);</span><br><span class="line">    iow(db, DM9KS_EPCR, <span class="number">0x4</span>);</span><br><span class="line">    <span class="keyword">while</span>(ior(db, DM9KS_EPCR)&amp;<span class="number">0x1</span>); <span class="comment">/* Wait read complete */</span></span><br><span class="line">    iow(db, DM9KS_EPCR, <span class="number">0x0</span>);</span><br><span class="line">    <span class="keyword">return</span> (ior(db, DM9KS_EPDRL) + (ior(db, DM9KS_EPDRH) &lt;&lt; <span class="number">8</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Set DM9000/DM9010 multicast address</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dm9000_hash_table</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_mc_list</span> *<span class="title">mcptr</span> =</span> dev-&gt;mc_list;</span><br><span class="line">    <span class="keyword">int</span> mc_cnt = dev-&gt;mc_count;</span><br><span class="line">    u32 hash_val;</span><br><span class="line">    u16 i, oft, hash_table[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dm9000_hash_table()&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable promiscuous mode */</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;flags &amp; IFF_PROMISC)&#123;</span><br><span class="line">        <span class="comment">//printk(KERN_INFO &quot;DM9KS:enable promiscuous mode\n&quot;);</span></span><br><span class="line">        iow(db, DM9KS_RXCR, ior(db,DM9KS_RXCR)|(<span class="number">1</span>&lt;&lt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//printk(KERN_INFO &quot;DM9KS:disable promiscuous mode\n&quot;);</span></span><br><span class="line">        iow(db, DM9KS_RXCR, ior(db,DM9KS_RXCR)&amp;(~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Receive all multicast packets */</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;flags &amp; IFF_ALLMULTI)&#123;</span><br><span class="line">        <span class="comment">//printk(KERN_INFO &quot;DM9KS:Pass all multicast\n&quot;);</span></span><br><span class="line">        iow(db, DM9KS_RXCR, ior(db,DM9KS_RXCR)|(<span class="number">1</span>&lt;&lt;<span class="number">3</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//printk(KERN_INFO &quot;DM9KS:Disable pass all multicast\n&quot;);</span></span><br><span class="line">        iow(db, DM9KS_RXCR, ior(db,DM9KS_RXCR)&amp;(~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set Node address */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, oft = <span class="number">0x10</span>; i &lt; <span class="number">6</span>; i++, oft++)</span><br><span class="line">        iow(db, oft, dev-&gt;dev_addr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clear Hash Table */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        hash_table[i] = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* broadcast address */</span></span><br><span class="line">    hash_table[<span class="number">3</span>] = <span class="number">0x8000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the multicast address in Hash Table : 64 bits */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mc_cnt; i++, mcptr = mcptr-&gt;next) &#123;</span><br><span class="line">        hash_val = cal_CRC((<span class="keyword">char</span> *)mcptr-&gt;dmi_addr, <span class="number">6</span>, <span class="number">0</span>) &amp; <span class="number">0x3f</span>;</span><br><span class="line">        hash_table[hash_val / <span class="number">16</span>] |= (u16) <span class="number">1</span> &lt;&lt; (hash_val % <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the hash table to MAC MD table */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, oft = <span class="number">0x16</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        iow(db, oft++, hash_table[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">        iow(db, oft++, (hash_table[i] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Calculate the CRC valude of the Rx packet</span></span><br><span class="line"><span class="comment">  flag = 1 : return the reverse CRC (for the received packet CRC)</span></span><br><span class="line"><span class="comment">         0 : return the normal CRC (for Hash Table index)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">cal_CRC</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> * Data, <span class="keyword">unsigned</span> <span class="keyword">int</span> Len, u8 flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u32 crc = ether_crc_le(Len, Data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">        <span class="keyword">return</span> ~crc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mdio_read</span><span class="params">(struct net_device *dev, <span class="keyword">int</span> phy_id, <span class="keyword">int</span> location)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="keyword">return</span> phy_read(db, location);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mdio_write</span><span class="params">(struct net_device *dev, <span class="keyword">int</span> phy_id, <span class="keyword">int</span> location, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    phy_write(db, location, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Read a byte from I/O port</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">u8 <span class="title">ior</span><span class="params">(<span class="keyword">board_info_t</span> *db, <span class="keyword">int</span> reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outb(reg, db-&gt;io_addr);</span><br><span class="line">    <span class="keyword">return</span> inb(db-&gt;io_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Write a byte to I/O port</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iow</span><span class="params">(<span class="keyword">board_info_t</span> *db, <span class="keyword">int</span> reg, u8 value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outb(reg, db-&gt;io_addr);</span><br><span class="line">    outb(value, db-&gt;io_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Read a word from phyxcer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u16 <span class="title">phy_read</span><span class="params">(<span class="keyword">board_info_t</span> *db, <span class="keyword">int</span> reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Fill the phyxcer register into REG_0C */</span></span><br><span class="line">    iow(db, DM9KS_EPAR, DM9KS_PHY | reg);</span><br><span class="line"></span><br><span class="line">    iow(db, DM9KS_EPCR, <span class="number">0xc</span>);   <span class="comment">/* Issue phyxcer read command */</span></span><br><span class="line">    <span class="keyword">while</span>(ior(db, DM9KS_EPCR)&amp;<span class="number">0x1</span>); <span class="comment">/* Wait read complete */</span></span><br><span class="line">    iow(db, DM9KS_EPCR, <span class="number">0x0</span>);   <span class="comment">/* Clear phyxcer read command */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The read data keeps on REG_0D &amp; REG_0E */</span></span><br><span class="line">    <span class="keyword">return</span> ( ior(db, DM9KS_EPDRH) &lt;&lt; <span class="number">8</span> ) | ior(db, DM9KS_EPDRL);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Write a word to phyxcer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">phy_write</span><span class="params">(<span class="keyword">board_info_t</span> *db, <span class="keyword">int</span> reg, u16 value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Fill the phyxcer register into REG_0C */</span></span><br><span class="line">    iow(db, DM9KS_EPAR, DM9KS_PHY | reg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fill the written data into REG_0D &amp; REG_0E */</span></span><br><span class="line">    iow(db, DM9KS_EPDRL, (value &amp; <span class="number">0xff</span>));</span><br><span class="line">    iow(db, DM9KS_EPDRH, ( (value &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>));</span><br><span class="line"></span><br><span class="line">    iow(db, DM9KS_EPCR, <span class="number">0xa</span>);   <span class="comment">/* Issue phyxcer write command */</span></span><br><span class="line">    <span class="keyword">while</span>(ior(db, DM9KS_EPCR)&amp;<span class="number">0x1</span>); <span class="comment">/* Wait read complete */</span></span><br><span class="line">    iow(db, DM9KS_EPCR, <span class="number">0x0</span>);   <span class="comment">/* Clear phyxcer write command */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//====dmfe_ethtool_ops member functions====</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_get_drvinfo</span><span class="params">(struct net_device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct ethtool_drvinfo *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//board_info_t *db = (board_info_t *)dev-&gt;priv;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(info-&gt;driver, DRV_NAME);</span><br><span class="line">    <span class="built_in">strcpy</span>(info-&gt;version, DRV_VERSION);</span><br><span class="line">    <span class="built_in">sprintf</span>(info-&gt;bus_info, <span class="string">&quot;ISA 0x%lx irq=%d&quot;</span>,dev-&gt;base_addr, dev-&gt;irq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_get_settings</span><span class="params">(struct net_device *dev, struct ethtool_cmd *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    spin_lock_irq(&amp;db-&gt;lock);</span><br><span class="line">    mii_ethtool_gset(&amp;db-&gt;mii, cmd);</span><br><span class="line">    spin_unlock_irq(&amp;db-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_set_settings</span><span class="params">(struct net_device *dev, struct ethtool_cmd *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">    spin_lock_irq(&amp;db-&gt;lock);</span><br><span class="line">    rc = mii_ethtool_sset(&amp;db-&gt;mii, cmd);</span><br><span class="line">    spin_unlock_irq(&amp;db-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Check the link state</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">dmfe_get_link</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="keyword">return</span> mii_link_ok(&amp;db-&gt;mii);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Reset Auto-negitiation</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_nway_reset</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="keyword">return</span> mii_nway_restart(&amp;db-&gt;mii);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Get RX checksum offload state</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">dmfe_get_rx_csum</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="keyword">return</span> db-&gt;rx_csum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Get TX checksum offload state</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">dmfe_get_tx_csum</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (dev-&gt;features &amp; NETIF_F_HW_CSUM) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Enable/Disable RX checksum offload</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_set_rx_csum</span><span class="params">(struct net_device *dev, <span class="keyword">uint32_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CHECKSUM</span></span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    db-&gt;rx_csum = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(netif_running(dev)) &#123;</span><br><span class="line">        dmfe_stop(dev);</span><br><span class="line">        dmfe_open(dev);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        dmfe_init_dm9000(dev);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;DM9:Don&#x27;t support checksum\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Enable/Disable TX checksum offload</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_set_tx_csum</span><span class="params">(struct net_device *dev, <span class="keyword">uint32_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CHECKSUM</span></span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">        dev-&gt;features |= NETIF_F_HW_CSUM;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dev-&gt;features &amp;= ~NETIF_F_HW_CSUM;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;DM9:Don&#x27;t support checksum\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=========================================</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,28)  <span class="comment">/* for kernel 2.4.28 */</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ethtool_ops</span> <span class="title">dmfe_ethtool_ops</span> =</span> &#123;</span><br><span class="line">    .get_drvinfo        = dmfe_get_drvinfo,</span><br><span class="line">    .get_settings       = dmfe_get_settings,</span><br><span class="line">    .set_settings       = dmfe_set_settings,</span><br><span class="line">    .get_link           = dmfe_get_link,</span><br><span class="line">    .nway_reset     = dmfe_nway_reset,</span><br><span class="line">    .get_rx_csum        = dmfe_get_rx_csum,</span><br><span class="line">    .set_rx_csum        = dmfe_set_rx_csum,</span><br><span class="line">    .get_tx_csum        = dmfe_get_tx_csum,</span><br><span class="line">    .set_tx_csum        = dmfe_set_tx_csum,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化一点, 不去考虑MODULE的设置. ===== for jz2440 =====</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1  <span class="comment">// #ifdef MODULE</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Davicom DM9000/DM9010 ISA/uP Fast Ethernet Driver&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)</span></span><br><span class="line">MODULE_PARM(mode, <span class="string">&quot;i&quot;</span>);</span><br><span class="line">MODULE_PARM(irq, <span class="string">&quot;i&quot;</span>);</span><br><span class="line">MODULE_PARM(iobase, <span class="string">&quot;i&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">module_param(mode, <span class="keyword">int</span>, <span class="number">0</span>);</span><br><span class="line">module_param(irq, <span class="keyword">int</span>, <span class="number">0</span>);</span><br><span class="line">module_param(iobase, <span class="keyword">int</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">MODULE_PARM_DESC(mode,<span class="string">&quot;Media Speed, 0:10MHD, 1:10MFD, 4:100MHD, 5:100MFD&quot;</span>);</span><br><span class="line">MODULE_PARM_DESC(irq,<span class="string">&quot;EtherLink IRQ number&quot;</span>);</span><br><span class="line">MODULE_PARM_DESC(iobase, <span class="string">&quot;EtherLink I/O base address&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Description:</span></span><br><span class="line"><span class="comment">   when user used insmod to add module, system invoked init_module()</span></span><br><span class="line"><span class="comment">   to initilize and register.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">init_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ===== for jz2440 =====</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *bwscon;             <span class="comment">// 0x48000000</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *bankcon4;           <span class="comment">// 0x48000014</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> val;</span><br><span class="line"></span><br><span class="line">    iobase = (<span class="keyword">int</span>)ioremap(<span class="number">0x20000000</span>, <span class="number">1024</span>);    <span class="comment">// 设置映射地址. 这里多映射了一点范围.</span></span><br><span class="line">    irq    = IRQ_EINT7;                         <span class="comment">// 设置中断号</span></span><br><span class="line"><span class="comment">/*  */</span></span><br><span class="line">    bwscon   = ioremap(<span class="number">0x48000000</span>, <span class="number">4</span>);          <span class="comment">// 设置S3C2440的memory controller</span></span><br><span class="line">    bankcon4 = ioremap(<span class="number">0x48000014</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DW4[17:16]: 01-16bit</span></span><br><span class="line"><span class="comment">     * WS4[18]   : 0-WAIT disable</span></span><br><span class="line"><span class="comment">     * ST4[19]   : 0 = Not using UB/LB (The pins are dedicated nWBE[3:0])</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    val = *bwscon;</span><br><span class="line">    val &amp;= ~(<span class="number">0xf</span>&lt;&lt;<span class="number">16</span>);</span><br><span class="line">    val |= (<span class="number">1</span>&lt;&lt;<span class="number">16</span>);</span><br><span class="line">    *bwscon = val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Tacs[14:13]: 发出片选信号之前,多长时间内要先发出地址信号</span></span><br><span class="line"><span class="comment">     *              DM9000C的片选信号和CMD信号可以同时发出,</span></span><br><span class="line"><span class="comment">     *              所以它设为0</span></span><br><span class="line"><span class="comment">     * Tcos[12:11]: 发出片选信号之后,多长时间才能发出读信号nOE</span></span><br><span class="line"><span class="comment">     *              DM9000C的T1&gt;=0ns,</span></span><br><span class="line"><span class="comment">     *              所以它设为0</span></span><br><span class="line"><span class="comment">     * Tacc[10:8] : 读写信号的脉冲长度,</span></span><br><span class="line"><span class="comment">     *              DM9000C的T2&gt;=10ns,</span></span><br><span class="line"><span class="comment">     *              所以它设为1, 表示2个hclk周期,hclk=100MHz,就是20ns</span></span><br><span class="line"><span class="comment">     * Tcoh[7:6]  : 当读信号nOE变为高电平后,片选信号还要维持多长时间</span></span><br><span class="line"><span class="comment">     *              DM9000C进行写操作时, nWE变为高电平之后, 数据线上的数据还要维持最少3ns</span></span><br><span class="line"><span class="comment">     *              DM9000C进行读操作时, nOE变为高电平之后, 数据线上的数据在6ns之内会消失</span></span><br><span class="line"><span class="comment">     *              我们取一个宽松值: 让片选信号在nOE放为高电平后,再维持10ns,</span></span><br><span class="line"><span class="comment">     *              所以设为01</span></span><br><span class="line"><span class="comment">     * Tcah[5:4]  : 当片选信号变为高电平后, 地址信号还要维持多长时间</span></span><br><span class="line"><span class="comment">     *              DM9000C的片选信号和CMD信号可以同时出现,同时消失</span></span><br><span class="line"><span class="comment">     *              所以设为0</span></span><br><span class="line"><span class="comment">     * PMC[1:0]   : 00-正常模式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    *bankcon4 = (<span class="number">1</span>&lt;&lt;<span class="number">8</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);      <span class="comment">// 对于DM9000C可以设Tacc为1, 对于DM9000E,Tacc要设大一点,比如最大值7</span></span><br><span class="line">    <span class="comment">//*bankcon4 = (7&lt;&lt;8)|(1&lt;&lt;6);    // MINI2440使用DM9000E,Tacc要设大一点</span></span><br><span class="line"></span><br><span class="line">    iounmap(bwscon);</span><br><span class="line">    iounmap(bankcon4);</span><br><span class="line"><span class="comment">// ===== end =====</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> DM9KS_10MHD:</span><br><span class="line">        <span class="keyword">case</span> DM9KS_100MHD:</span><br><span class="line">        <span class="keyword">case</span> DM9KS_10MFD:</span><br><span class="line">        <span class="keyword">case</span> DM9KS_100MFD:</span><br><span class="line">            media_mode = mode;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            media_mode = DM9KS_AUTO;</span><br><span class="line">    &#125;</span><br><span class="line">    dmfe_dev = dmfe_probe();</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dmfe_dev))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(dmfe_dev);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Description:</span></span><br><span class="line"><span class="comment">   when user used rmmod to delete module, system invoked clean_module()</span></span><br><span class="line"><span class="comment">   to  un-register DEVICE.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __exit <span class="title">cleanup_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> dmfe_dev;</span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;clean_module()&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    unregister_netdev(dmfe_dev);</span><br><span class="line">    release_region(dev-&gt;base_addr, <span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)</span></span><br><span class="line">    kfree(dev);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    free_netdev(dev);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    iounmap((<span class="keyword">void</span> *)iobase);                    <span class="comment">// ===== for jz2440 =====</span></span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;clean_module() exit&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== for jz2440 =====</span></span><br><span class="line">module_init(init_module);                       <span class="comment">// 添加驱动的入口和出口函数</span></span><br><span class="line">module_exit(cleanup_module);</span><br><span class="line"><span class="comment">// ===== end =====</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6_custom  复制一个新的内核源码目录</span></span><br><span class="line">$ <span class="built_in">cd</span> ./drivers/net/</span><br><span class="line">$ cp ./dm9dev9000c.c ./dm9dev9000c.back         <span class="comment"># 将原有的驱动备份一下</span></span><br><span class="line"><span class="comment"># 然后将上面的 dm9dev9000c.c 覆盖掉内核里的这个文件.</span></span><br><span class="line"><span class="comment"># Makefile 不用改, 因为jz2440的patch包已经改好了.</span></span><br><span class="line"></span><br><span class="line">$ make clean                                    <span class="comment"># 没把握的话, clean一下</span></span><br><span class="line">$ make uImage</span><br><span class="line"><span class="comment"># 烧录新的uImage</span></span><br><span class="line"><span class="comment"># 重启开发板进入uboot烧录界面, 按k准备烧录内核. 略过不表</span></span><br><span class="line">$ sudo dnw ./arch/arm/boot/uImage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># 重启, 查看是否能正常启动, 能否进入nfs目录.</span></span><br><span class="line">$ ifcofig                                       <span class="comment"># 查看网卡信息</span></span><br><span class="line">$ ping 10.0.0.100                               <span class="comment"># ping Ubuntu 主机</span></span><br></pre></td></tr></table></figure>

<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>
]]></content>
      <categories>
        <category>embedded linux</category>
      </categories>
      <tags>
        <tag>embedded linux</tag>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>一张简单图片演示的“甚深佛法”</title>
    <url>/2021/02/09/2102-intermittent/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
<li><a href="https://draapho.github.io/2021/03/05/2107-tuibeitu1/">万年歌, 马前课, 梅花诗, 推背图 (上)</a></li>
<li><a href="https://draapho.github.io/2021/03/18/2108-tuibeitu2/">万年歌, 马前课, 梅花诗, 推背图 (下)</a></li>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/26/2123-caseofsatori/">见性者体验收集</a></li>
</ul>
<p><em><strong>转载自 <a href="https://www.jianshu.com/p/aad3e1d766b5">一张简单图片演示的“甚深佛法”</a></strong></em></p>
<hr>
<p><img src="https://draapho.github.io/images/2103/2103_1.png" alt="五蕴生灭图.png"></p>
<p>上面的图，是一张简单的佛法关于五蕴（身心现象）相续生灭的演示图，这个图看起来很简单，但实际却有着很重要含义和丰富的内涵，<strong>它是原始佛法关于身心现象，生灭现象，轮回现象的一个图像化演示，是对身心现象的洞见。整个佛法的无常、苦、无我、缘起、轮回、止禅、观禅，四念住都和这个图所表达的含义有关。</strong>如果你能正确理解这个图的内容，你基本能够建立起对无常，苦，无我和缘起的正见。你也将知道禅修的重要关键处，以及为什么四念住是唯一的解脱之道，同时也有助于你建立起对时间，空间和存在的深刻认识。无论从建立佛法理论的正见还是从禅修实践上，这个图都可以起到很重要的指导作用。如果你能认同所说的，我个人很建议你将这个图能够深深的刻在脑子里，帮助你破除那些强大执着的错误见解，走向佛陀正法的道路。</p>
<p>这个图是根据我自己的认识并结合了上座部佛教的阿毗达磨的一些理论而画出的，它的最初模型源自我很2008年年底在某种冥思以及纯然觉察状态下的意外灵光闪现，我突然了悟到这个世界以及自我仿佛是电影胶片那样一格一格的，那是一种直觉式的洞察，它是如此的清晰和确定，颠覆了我以前的对世界以及自我的理解，我强烈认识到我的这个认识很可能是对的，这让我振奋不已，从此将其深深的记在了脑中，经常思考这个问题。那个时候我还没有完全的接触原始佛法，没有接触上座部佛教，虽然那时已经有十多年的的学佛经验，却还停留在很粗浅的阶段，但一直很认真的在寻找探索关于自我和存在的真理，也经过很多的波折以及信仰的坍塌和重建。由于获得了这个极为重要的关键认识，我才真正开窍了，让我从此走向佛陀所指引的解脱之路，不久我就接触了上座部佛教以及阿毗达磨，后来还学习了量子物理的诸多理论认识，它们的重要理论都和我当时的关于世界和自我是一格一格的认识具有很高的一致性。它为我以后理解佛法以及禅修实践打下来最重要的正见基础，最初的时候我自己甚至都还没有认识到这次灵感所蕴含的深义以及巨大价值，直到后来我才真正认识到了它的重要性，其实它就是量子物理最重要的非连续性，又叫做量子性，也是无常的真正核心。</p>
<p>简单图像的演示并不能完整表达我的意思，尤其它还是静止的，所以我还必须要进行更深入的阐释，下面我注解一下这个图。</p>
<p>图中上部的蓝色的圆，代表的是每个刹那的感官（眼耳鼻舌身意）所感知认识的不同的对象，这些被观察被认知的对象，可以是任何的物质现象，佛法称为色法，比如树木、房子、山河大地，也可以是任何的意识现象，佛法称为名法，比如自我的感觉、痛苦、快乐、种种意识状态。这些被观察对象，佛法统一称为“所缘”，巴利文arammana，字面意思是“感官的认识对象”。其中色法的聚集称为色蕴，名法的各种聚集依照功能的不同划分为识蕴，受蕴，想蕴，行蕴，合起来是五蕴，它们都可以成为被观察感知的对象。</p>
<p>图中下部的红黄组合的圆，代表的是每个刹那的观察者，即“能缘”，巴利文arammaoika。按照上座部阿毗达磨的理论，这些观察者，是由刹那生起的心识，伴随同时升起的若干心所而组成。其中的黄色小圆表示心识，总共六种，分别是眼识，耳识，鼻识，舌识，身识，意识，总称为识蕴。其中的红色圆环表示伴随心识生起的若干心所。心所，巴利文cetasika，字面意思是“心所有的，属于心的“，它们是各种各样属于心的意识因素，执行记忆判断思维等功能。这些心所分别属于想蕴，受蕴，和行蕴，上座部阿毗达磨并不认为想蕴和行蕴是单一的念头思想，而是认为每个刹那，伴随着识的生起，都有想蕴（想心所，执行记录或回忆功能），受蕴（受心所，苦乐或中性感受），行蕴（各种判断思维等意识因素）。为了让图更简单直观，我并没有采用阿毗达磨的某些复杂理论，而是直接观察者和被观察者构成一对一的关系，在实修当中，它也是较为实用的。</p>
<p>一个能缘的观察者加一个所缘的被观察者，用箭头连起来，构成一组。这一组是五蕴相续生灭的一个最基本单位，是一次纯单一的观察感知事件，在时间上也只维持一个刹那。它相当于电影或动画片的一帧。<strong>因为生命的不间断的观察感知行为，这个一帧一帧的电影被播放了，空间，时间，各种复杂的身心现象以及错觉产生了，我们沉迷于其中，而忘记了真实，</strong>下面，我就要将真实进行还原。这个真实，就是佛陀所宣说的关于缘起，无常，苦和无我的核心教义。</p>
<p>在详细讲述之前，我想先给予你一个建议，请暂时先放下此前你对佛法缘起，无常，苦和无我的认识，因为你的那些认识有可能是过于简单甚至是有严重误解的。对于我下面所说的请认真耐心的思考，这其中的某些观点会大大颠覆你以前对佛法和世界的认识，或者和你对佛法的已有认识理解是相当冲突的，但是这些却很可能是真正的佛法，至少我确定无疑。而这些观点认识是否符合佛陀正法的判断抉择，取决于你自己。我无意去说服任何人去接受它们，而只想分享我的思考和发现。</p>
<p>首先来说缘起，它是佛教的独特教义，是佛法的核心。“缘”是条件，“起”是生起，“诸法因缘生，诸法因缘灭”。意思是一切现象都是因为条件而产生，一起现象都是因为条件而灭去。佛陀对缘起的描述是“此有故彼有，此生故彼生，此无故彼无，此灭故彼灭”。其中的“有”，巴利文是bhava，意思是“存在”，整句话的字面意思是：</p>
<blockquote>
<p>当这个（现象）存在了，则有那个（现象），因为这个（现象）生起，则那个（现象）生起，当这个（现象）不存在了，则没有那个（现象）的存在，因为这个（现象）的灭去，则有那个(现象)的灭去”。</p>
</blockquote>
<p>这句话看起来让人摸不着头脑，但它其实是对缘起核心的最准确描述，几乎所有的佛教法师在解释佛教缘起法很喜欢用类似种子生长这样的例子来比喻缘起，因为有种子的条件，就有树木的生长，进而结出果实。但是如果套在这句话上却根本不成立。当种子存在（被种下）时，还没有树木的存在，至于种子灭去，更不可能有树木的灭去。这种例子远远没有触及缘起的根本核心，这种对缘起的解释也是极其肤浅甚至带有误导性的。按照这种解释，我们甚至也可以说一神教的神创论也是缘起法，因为如果没有上帝的这个条件，就没有万物的被创造。这种简单的条件因果论，显然根本就不可能是佛法所说的最深刻最奥妙的缘起法。</p>
<p>实际上这句话描述的是缘起法的最核心，也就是观察和被观察对象的关系，其实也是意识和物质的关系。意识本质是一种观察感知行为，而物质则是被观察的对象。佛陀的缘起法提出了一种全新的观察和被观察对象，物质和意识的关系，是其它任何宗教和哲学都没有的崭新思想。然而很悲剧的是，这种崭新思想两千多年来几乎所有的佛教徒都还没有真正认识到并充满各种争论，现存的无论佛教哪个派别，无论是大乘佛教还是小乘佛教，都没有给出真正准确的解释，这不得不让人哀叹和引起反思。</p>
<p>将上面那句话的“这个”和“那个”替换成更加具体的观察和被观察对象，则意思就更明确了：</p>
<p><strong>“当观察存在了，则有被观察者的存在。因为观察生起，则被观察者生起，当观察不存在了，则没有被观察者的存在，因为观察的灭去，则有被观察者的灭去。”</strong></p>
<p>什么？被观察者怎么可能因为观察的存在而存在呢？我看到眼前一个杯子，难道是因为我的观察，杯子才存在于那里？杯子难道不是肯定客观独立存在的吗？和我的观察哪里有什么关系？这分明是在胡言乱语。然而请认真思考这样的问题。我们都知道，人是通过视觉听觉触觉等感官来获得对外界事物的认知。我用眼睛观察到桌子上摆放着一个杯子，然后我扭转头来，让杯子从视野当中消失，接着我又扭过头来再看杯子，杯子还是稳稳的在桌子上，于是意识根据两次以及多次以上的观察结果得出了一个明确的判断：当我不去看杯子的时候，杯子仍然是在那儿，就在桌子上，杯子的存在和我的观察完全无关，它是独立的，根本不需要依赖于我的观察。</p>
<p>可是这个推论真的能够完全成立吗？答案是，未必成立！我们的思维想当然的犯了一个逻辑错误。我们根据自己的多次观察，强行假定了杯子在我们不去观察的时候必定一直独立存在于空间当中。<strong>多次的观察或者任何他人的观察，并不能得出杯子在不被观察的状况下仍然独立存在于空间当中的必然结论。逻辑上的正确结论应该是：杯子在不被观察的情况下未必独立存在于空间当中。</strong>这个看起来不起眼的逻辑错误，骗了我们几乎所有的人，并且让我们建立了错误的对于周围世界的认识，错误的以为周围世界是如我们所观察到的样子而客观独立存在的，它犹如思想的钢印，牢牢的被印在思维深处而难以改变。<strong>以此错误认识为基础，产生了事物持续存在、独立存在的错觉，它们都违背了此有彼有，此无彼无的缘起法。</strong></p>
<p>为了进一步论证这个结论，让我们设想一个思想实验。假如有个电视具有这样的功能，就是只要这个电视处于你或者任何人的视野范围而被观察，则自动开启电源而显示动态画面，而一离开你或者任何人的视野范围，则电视自动关闭电源。当你用眼睛一瞧向电视，电视瞬间打开而显示画面。你连电视的自己开启都没有觉察，只看到电视画面。你转过头来，电视则自动关闭，然后你转过头来再看电视，电视又瞬间开启而显示画面。你无数次转头不看电视，转头看电视，你总能看到电视的动态画面并且无法察觉电视的自动开启，而其他人也同样如此，于是你根据你自己的多次观察，和其他人的观察，得出这样一个结论：电视哪怕我没有去看它，它仍然是开着电源而显示动态画面的。可实际的结果却是：电视在没有被看的时候，电源已经关闭了，根本没有任何画面。</p>
<p>在这个思想实验中，眼睛对电视的视野观察，比喻的是量子力学所说的观察测量，也是佛法所说的“识”，电源开启而播放画面的电视，比喻的是任何你观察到的空间当中的物理实在现象（比如杯子），是佛法所说的色法。而电源关闭没有任何画面，则比喻的是空间当中物理实在现象的消失。电视随着眼睛的观察而开启，随着眼睛观察的停止而关闭，则比喻的是缘起法的“此生彼生，此灭彼灭”。眼睛一直在看电视，电视持续不断播放；眼睛不再持续看电视，电视停止持续播放，比喻的是缘起法的“此有彼有，此无彼无”（有，是指存在，强调的一种维持作用）。</p>
<p>当今时代最精确描述物质现象的量子物理也有类似的惊人观点，既<strong>观察测量才能导致物理实在</strong>的产生。这种观点是完全建立在实验（尤其双缝实验）和数学基础（海森堡方程）上的。在阿莱斯泰尔·雷 的《量子物理学：幻想还是真实》一书当中是这样说的:“一个测量的可能结果是由被测的客体和测量装置共同决定的，我们不能说一个单独的客体具有何种特性，除非它们已经被测量。我们也许会想我们究竟是怎么知道一个量子客体在未经测量之前是客观存在的。答案是我们并不知道。直到我们对一个系统的某些特性进行测量以前，谈论它的存在都是没有意义的。只有当某些特性被测量时，我们谈论具有某种特性的客体的存在才是有意义的。”</p>
<p>这也是爱因斯坦和玻尔这两位20世纪最伟大的科学巨人那场世纪辩论的根本原因之一。爱因斯坦本人是客观实在论的强烈信仰者，他坚定的认为，“有一个离开知觉主体而独立存在的外在世界，是一切自然科学的基础”，物理量和物理实在是和观察者无关的独立存在，这是一种强客观实在论。而量子力学的认识论违背他的这个“强客观存在”在的哲学信念。量子物理学家海森堡说“希望有新的实验能使我们返回到时间和空间上客观的事件，大概就像希望在没有探测过的南极区域找到世界的尽头一样，完全是幻想。”根据玻尔等人的观点，<strong>粒子没有独立的现实性，在它被观察之前不具有物理性质，不是物理实在。</strong>后来美国物理学家约翰惠勒简明扼要的总结了这个观点：<strong>“任何基本的现象，只有在它成为被观察的现象时才成为真实的现象。“</strong></p>
<p>爱因斯坦在一次散步时问他的学生派斯教授：“你是否相信，月亮只有在看着它的时候才真正存在？”，爱因斯坦难以接受量子力学认识论所推倒出的这种“荒唐结论”。为此他经过殚精竭虑的思考，终于设计出了EPR思想实验来试图推翻玻尔等人的量子力学认识论。根据这个思想实验，如果玻尔的量子力学是对的，那么必定要存在一种幽灵般的超距作用，即两个粒子在分开后，哪怕相隔亿万光年，却仍然存在着关联性，对其中的一个粒子施加影响，亿万光年外的另外一个粒子也必将立刻产生关联性的变化，中间毫无距离空间的阻碍，也就是神秘的量子纠缠。爱因斯坦不相信存在着这种可能性。爱因斯坦的这个EPR的思想实验后来终于在现实当中得到了实现，1981年阿斯佩克等人设计的实验以及之后的多次实验结果显示了超距作用确实存在，爱因斯坦错了，玻尔的预言得到了实验的充分验证。爱因斯坦假设的物理实在是和观察者无关的独立客观实在的结论是难以成立的。</p>
<p>美国康乃尔大学物理学教授大卫·牟民在“神秘的量子”一文中回答说：“EPR实验给了爱因斯坦所不希望的答案：现在知道，月亮在无人看它时肯定不存在。”当然，这里的不存在只是从“现象”的角度来说的。当月亮不被观察时已经不是一个“现象”，部分物理学家认为那是一种抽象的数学实在，是非时间和非空间的，这是一种弱客观性，而坚持物理实在和观察无关，则是强客观实在性，这是爱因斯坦的坚定哲学信仰，这错误的哲学信仰导致爱因斯坦这位20世纪最卓越的物理学家后半生和量子力学的顽固对抗，并影响了他的物理学研究，爱因斯坦下半生再没有什么对物理学的重大贡献。</p>
<p>通过前文的分析，我们可以得出这样的结论：<strong>实在或者说现象并非是独立的一直在那里，而是观察本身导致了被观察的现象的产生。认为被观察者一直在那儿，和观察无关，是思维的严重误区，也是产生常见和我见的重要基础。是刹那的观察的导致刹那的“实在”的产生，多次累加的观察导致多次“实在”的相续产生，这些微小的“实在”被视觉残留和瞬时记忆（记忆残留现象）所拼凑，构成了一幅完整的宏观现实世界的图景。这宏观的现实世界只存在于我们的意识当中，而不存在于真实的宇宙当中。</strong>我们以为的宏观世界是一种错觉，真正存在的实际只有当下生起的极其微小的不可再被分割的物质和意识单位，也就是佛法所说的究竟色法和究竟名法，物理学所说的最小的不可分的物质单位。</p>
<p>此有故彼有，此生故彼生，此无故彼无，此灭故彼灭！</p>
<p>“当这个（现象）存在了，则有那个（现象），因为这个（现象）生起，则那个（现象）生起，当这个（现象）不存在了，则没有那个（现象）的存在，因为这个（现象）的灭去，则有那个(现象)的灭去”。</p>
<p>“当观察存在了，则有被观察者的存在。因为观察生起，则被观察者生起，当观察不存在了，则没有被观察者的存在，因为观察的灭去，则有被观察者的灭去。”</p>
<p>在南传上座部佛教享有崇高地位的缅甸马哈希尊者在《佛陀最初的根本教法》一书当中说：<strong>“存在的只是五取蕴而已；而且除非是在见、听等六种时刻，否则无物存在。换言之，只有在见、听等的当下，方才显现出来，而显现出来的无非只是五取蕴罢了”，</strong>马哈希尊者的这段生动描述和我所说的完全一致。这也是我在认识到佛陀的缘起法核心之后，唯一找到的能把这层关系准确揭示的佛教尊者，也是最重要的支持性证据之一，而主流的南传上座部佛教其实并没有这种观点，大乘佛教更没有。大乘的唯识和万法唯心造的理论是一种唯心论，彻底的否定客观实在性，而并不是我说的弱客观（物质不被观察时是一种抽象实在），并认为是心创造了万物，而并非心是现象性物质产生的依赖条件。</p>
<p>大部分佛教徒把缘起法理解成非常肤浅的因果法。认为结果的产生有发生的原因，这个就是缘起法。如此简单的几乎人人皆知的道理怎么可能是佛法最深刻最独特也被佛陀说成甚深难解的缘起法呢？</p>
<p>这缘起法包括两个最关键因素：</p>
<p><strong>1、此生彼生：任何现象的生起必须同时依赖于另外一个现象的生起，这是“此生故彼此生”，侧重于现象“生起”所需要的条件。</strong><br><strong>2、此有彼有：任何现象的维持存在，必须依赖于另外一个现象的存在，侧重于现象维持“存在”所需要的条件。这就犹如桌子如果站立必须得依赖桌子腿的支撑。</strong></p>
<p>在图中，每一组基本单位上面的蓝色圆部分和下面的红黄圆部分是彼此互相依赖产生，能缘和所缘，<strong>观察者和被观察者是同生同灭的。之所以“同生”，是因为现象的产生必须依赖于条件的产生，之所以“同灭”，是因为现象的灭去必定伴随条件的灭去。</strong>杂阿含经第12经生动的描述了这种观察者和被观察者的互相依赖支撑，同生同灭，相续生灭的关系。</p>
<p>“ 譬如三芦立于空地，展转相依而得竖立，若去其一，二亦不立，若去其二，一亦不立，展转相依而得竖立，识缘名色，亦复如是，展转相依而得生长”</p>
<p>三芦分别是识（黄圆，心，观察者），名（红环，心所，观察者），色（蓝圆，被观察者），他们之间是彼此依赖而产生并存在的，是“相依竖立”。因为识的产生，才有名色的产生，因为名色的产生才有识的产生，而“生长”其实是五蕴生灭的不断相续，而并非是什么身体的生长发育，这才是此经文胜义谛的真正内容。</p>
<p>整个缘起法的核心就在于此，至于十二缘起，不过是它的一个被加入异时性的推演而已。上面那两个关键因素，也是判断一切缘起法和非缘起法的关键。符合两个要素的必定是缘生法，不符合两个要素的，要么是非缘起但有存在性的涅槃，要么是非缘起而没有任何存在性的概念法。</p>
<p>佛陀的缘起法是对存在的深刻认识。<strong>它告诉我们，我们所观察感知的事物现象不是“梵”创生的，不是上帝创生的，不是独立存在的，是依赖于条件的生起灭去而生起灭去。是依赖于“观察”的生起灭去而生起灭去。</strong>2500多年前佛陀对此的深刻洞见，和当今时代最前沿的量子物理学的认识论有着惊人的一致性。以这缘起法为核心，才进一步有了无常，苦，无我以及四圣谛的佛法架构。然而不幸的是，缘起法于佛陀入灭后，遭到了太多的曲解，现今已经变成了一种很肤浅的因果性的缘起，丧失了最初的奥义。希望本文所揭示的，能够让你重新思考。</p>
<p>说完缘起法，再来说无常，佛陀说一切有为法无常，有为法是所有的五蕴，分别是色蕴，受蕴，行蕴，想蕴，识蕴，即所有被观察感知的意识现象以及被观察感知的物质现象，一定要加个被观察，是因为佛法所说的五蕴，都是建立在观察感知基础上的，而对于观察感知以外的，佛陀不予探讨。</p>
<p>无常，简单的说，就是没有持续存在的事物。它通常被认为指的是人有生老病死，所有事物总有一天会消失，也就是“生起必灭”。然而无常真的只是这么简单吗？相信这个世间几乎没人认为事物是永恒的，难道所有人都懂得无常了？当然不是，因为佛法所说的无常，其实有更深刻的含义。尽管生老病死确实是无常的表现，事物的变化也是无常的表现，但是这是宏观的，简单层面的，仅仅靠这个，很难真正认识什么是无常。<strong>严格意义的无常，是通过禅修而获得的对存在的洞见，它是指没有一件事物，没有一个现象，能够持续性的存在。</strong>每一刹那，都是完全新的现象，完全新的事物，完全新的“法”，每一刹那都是不同的自我，不同的世界。我们的“自我”，我们观察感知的存在，我们的世界，仅仅只能存在于当下一刹那。<strong>任何一种五蕴现象，包括所谓的心，都不能驻留超过一个刹那。这就是无常的真正深刻含义，即非连续性或者分立性。</strong>类似于量子力学所说的量子化。量子，意思是一份一份的，分立的。时间，空间等物理量以及我们的意识，都是量子化的，都有着一个鲜明的特性，刹那刹那的，一份一份的，非连续的，分立性的变化运动。</p>
<p>这个非连续性和分立性就是这个图的一个最主要特点之一。在图中，每组的五蕴基本单位（红黄圆+蓝圆）都是生起即灭的，仅仅有极为短暂的驻留，这个是非连续性；一组五蕴基本单位灭去之后，又接着生起新的一组，两组单位完全不同，这个是分立性。一束光线，在量子的水平上，呈现为一份份能量包的传递，它是一个不连续的序列；电子从一个能级轨道跃迁到另一个能级轨道，不经过两个轨道之间的空间，这也是个不连续的序列，时间，以普朗克时间（10的负43次方秒）的最小不可分割的单位不断跳跃，这个是不连续的序列，我们的意识刹那刹那的生灭，同样也是个不连续的序列。一群蚂蚁排队前行，从远处看，蚂蚁是一条直线，但是从近处看，就发现这蚂蚁的队伍并非一条线，而是一只一只蚂蚁前后相继而组成的。图中每组红黄蓝构成的能缘和所缘都是相对独立的，每一组本质都是一次独立的事件，而不是前面的延续，整体上呈现出一组一组，一份一份，前后相异又紧密相连的特征，佛法称其为“异阴相续”。这里的阴是指五受阴，就是五蕴的意思。</p>
<p>量子力学家创始人之一玻尔对于这种非连续性和分立性曾经这样描述，“量子理论的精髓可以用量子公设表示出来，这种公设赋予任一原子过程以一种本质上的不连续性，或者说是个体性，这种性质完全超出经典理论之外而是用普朗克作用量子来表示 “另外一位量子物理学家薛定谔说：<strong>“最好把粒子当成瞬间事件，不要视为永久的东西。有时这类事件整体看来会造成永久的东西”。</strong>玻尔所说的个体性和以及薛定谔所说的瞬间事件，就类似于我图中所演示的一个分立的五蕴基本单位，是瞬间刹那的单一事件。而薛定谔上面的这句话，则是物理学版本的以“无常”来否定“常”的颠倒见。量子物理是无常的认识论，经典物理是“常”的认识论。<strong>连续性使得事物可以持续性存在，也就是恒常，而非连续性则使得事物不可能持续存在，所以必定是无常。“无常”是非连续性，“常”是连续性。</strong></p>
<p>图中的每一组就相当于电影胶片的一个帧。因为有这独立的帧，这电影才能被真正播放而形成连续的影像。黑暗中舞动一个手电筒，我们看到的是一道道弧光，而不是一个个光点；在影视屏幕上，我们看到的是图像的连续运动，而不是一帧一帧单独的画面。<strong>在表面连续性的背后是非连续性的聚合，连续性是假象，非连续性是真实。</strong>因为心的粗糙，因为我们不关注生灭，导致被连续性的假象所蒙蔽，无法认识真正的不连续性，不能认识真正的无常。公元五世纪的上座部佛教杰出的觉音尊者在《清净道论》里面说：**”因不观照生灭，为相续所覆蔽，故不现起无常相”。**显然，觉音尊者这里所说的无常相，就是指被相续掩盖的非连续性和分立性，是真正的无常。</p>
<p>这个独立的桢，是南传所说的究竟真实法构成，包括心法，心所法，以及色法。部派佛教也称其为极微，是最小的不可分割单位。假如其中的被观察对象是色法，那么此处的色法必须要有体积单位，和普朗克长度有关，它是宇宙最小的不可分割的尺度。当大量连续生灭的识不断的对某个客体观察，造成了整体上的某个具体的色法影像。比如观察一个苹果，并不是只有一次识的生灭就完成了对一个苹果这样的宏观客体对象的认知。之所以我们觉得我们只是看了一眼就看到一个苹果，只是因为我们自身对于意识的感知非常粗糙，我们无法察觉微观尺度下发生的大量意识生灭的事件。</p>
<p>注意，我图中故意将当下那组进行了加深，而过去未来做了虚化处理，它的意思是说过去发生的现象已经完全消失了，并不存在于时空当中，而未来还没有升起，只有当下刹那是真实的。这个就是指上座部佛教所说的当下有体，过未无体，非常非常重要。当下有体，过未无体意思是指当下是真实的，而过去未来所生的法是消失的，是不存在的，没有任何的“体”。或者也可以说，诸法只在当下刹那存在，或者说这个世界和“自我”，仅仅存在一个刹那。请仔细理解这句话，如果你没有觉得震撼，必定是没有理解。注意我这里所说的自我，并非是指主宰性的自我个体，实际他对应的是一个当下升起的心识外加伴随的心所，而不是主宰性支配性的意思。在部派佛教当中，说一切有部认为过去当下未来三时法体恒有，而我们几乎所有人的观念，其实都是类似说一切有部这种观念，而并不能理解为什么诸法只在当下刹那存在，为什么这个世界只有一个刹那。这是因为我们被时间欺骗了，被意识生灭的现象给欺骗了，<strong>我们的意识强行假定了已经消失的过去事件（或者事物或者自我）还有某种存留，我们大部分人将时间给独立起来，认为时间是一个固定的背景，而事件在这个时空的背景下发展着。是实际上，根本没有独立的时间和空间背景，有的只是事物本身的生灭变化，在这个基础上，产生了时间流逝和时间独立的错觉。</strong></p>
<p>下面的图，是说一切有部三世实有，法体恒有的演示图，也是所有外道关于灵魂，梵，神我的演示图。其中大乘的如来藏，真如，阿赖耶等要稍微复杂一点，没有在图中完全的显示，但本质差不太多，只是如来藏，阿赖耶等有一些掩盖性的东西，比如用不一不异来掩盖独立性，用无形无相来掩盖实体性。但其实还是神我见，只是形式变化了。</p>
<p><img src="https://draapho.github.io/images/2103/2103_2.png" alt="万物实有图.png"></p>
<p>对比最上面的图，就会看到一个很大的不同。第一张图，都是一组一组，前后不同，分立的，是一种离散的，非连续的，刹那生灭的理论，而第二张图，都有个持续不变的主体存在其中（黄色的部分）。这个主体本身不生不灭，具有影响操控客体的能力。它也是连续性的，恒常性的。这个不变的主体，在各种宗教当中有不同的名称，基督教，印度教，称呼为灵魂。大乘佛教，则称呼为心、真如、如来藏、自性、本心，本觉等等。它是解脱的所依。是在五蕴身心现象当中的。甚至是五蕴身心现象产生的源头，是万法产生的根本因。所谓的明心见性，就是要找到这个本心，并运行它的性质完成某些功能（真如起用）。而佛法和这个完全不同，关于五蕴，它是一种刹那生灭，非连续的理论，关于解脱所依的涅槃，和五蕴是完全的相异，不能共存。</p>
<p>分立性和非连续性为主的微细无常，才是真正关键的，就比如一群蚂蚁排队前行，从远处看，蚂蚁是一条直线，但是从近处看，就发现这蚂蚁的队伍并非一条线，而是一只一只蚂蚁前后紧密相连的间断的相续组成的。而且这里必须要有坍缩个最小不可分割的单位，这也是佛法的关键所在，可以说无常，苦，无我的理论都和它密切相关。无论是物质也好，还是意识也好，都不能是无限分割的，都有着最小的不可分割单位。在量子力学里面同样也是，能量，空间，时间等物理量，都有着最小不可分割的单位，是非连续的，分立的。</p>
<p>佛法关于无常，关于心识和色法刹那刹那生灭的这部分理论，和量子物理学当中的量子性，非连续性，分立性，具有惊人的相似。至于不承认极微，不承认存在最小不可分割单位的大乘诸多理论，尤其是唯识理论，是和上面所说的显然是完全不同的，没有调和性。大乘唯识创始人世亲在否定极微的论证当中犯了一个严重的错误，就是混乱了数学分割和物理分割的区别。他以为如果极微有体积就必定可以分割，既然可以分割，则不可分割的极微是不成立的。但实际上他所说的体积可以分割是数学上的，而现实的物理实在，则受制于量子性的限制，是不可分割的，数学分割和物理分割是明显不同的。曾经回小向大，投靠大乘的世亲，如果出生在这个时代，面对这个明显的错误，是否该考虑回大向小，重回原始佛教的怀抱呢？</p>
<p>根据上面所说的，认识到这个微细的无常很重要。因为<strong>我们大量的贪爱，是建立在事物和自我持续存在的错觉基础上的。</strong>如果无常仅仅是指那种粗浅的事物总有一天会消失的无常。那么在事物存在的时候，比如眼前的甜甜的，大大的苹果，比如黄金，我们依然可以完全的享有啊。但实际真正的情况并不是我们观察和意识所感觉到的。任何事物，都仅仅只存在一个刹那，短短的一刹那，我们是被错觉所骗。</p>
<p>当然，哪怕就是明白这个无常，还是不能灭除贪爱，因为还不明白什么是“苦”。下面就开始讲真正的“苦”到底是指什么。为什么是“苦”的。关于苦，如果仅仅是根据上图，是无法有直接的体会和认识，也不会懂为什么是“苦”。</p>
<p>我最初在根本没有接触真正的佛经，没有接触原始佛法和上座部佛教之前，曾经借助于类似四念住的禅修方法悟到了无常和无我（当时并不懂那是四念住），却完全不懂苦是啥，也并不接受。我当时在修观的某次过程当中，突然极为意外的，让人惊讶的，确定性的认识到<strong>这个世界和自我只真正存在一刹那，这个世界和自我像电影一样，是一格一格的，</strong>而那时我还完全没有接触到原始佛法和阿毗达摩关于这方面的理论。当时所发现的，已经完全可以画出上面的图。这个关于世界和自我的模型，也深深的刻在了我脑子里面，可是苦是什么？为什么佛陀如此的强调？我当时并不理解，也没有概念。这是由于我当时和大多数人一样，仅仅以为佛法所说的苦，是指痛苦的感受，我觉得这痛苦的感受都是相对的，而解脱应该是发现真理。没有了痛苦的感受只是发现真理的副产品而已，而不是主要目的，主要目的应该是探寻真相，发现真理，并无特别的实现苦灭的目的，其实这个不完全正确，苦灭才是真正的终极目的，真理的发现反而是这个过程的副产品。</p>
<p>苦，巴利文是dukkha，du，意思是恶劣的，kkha，意思是空的。整个意思连起来，意思是“恶劣的空”，其中没有任何中文所说的痛苦的感受的意思。而是一种很客观的表达，而且竟然还和“空”有联系。佛陀说五蕴就是苦，意思是所有的精神和物质现象全部是苦的。假如你将苦理解成痛苦的感受，那么你能说石头是苦的吗？能说山河大地是苦的吗？完全不对。而且当修禅定，包括修四念住的时候产生的乐，明明就是很快乐的感受，怎么能说是苦呢？所以，<strong>苦，绝对不是狭义的痛苦的感受，而实际上，“苦”意思是不圆满的，有缺陷的，不实的，是一种没有主观情绪的表达，是适用于所有事物的。</strong>为什么不圆满，为什么有缺陷，为什么是不实的呢？要理解这个，也确实是不容易的事情，因为一方面，我们大部分人对于真正圆满的涅槃毫无认识，这就缺乏对比性，显现不出五蕴的不圆满性。另外一方面，对于五蕴的特性，由于粗糙的意识感知，我们不知道苦的一个重要表现：逼迫性</p>
<p>而这逼迫性，是在修观当中亲身体会到的。是几乎必须性的要有亲身的体验。而这亲身的体验，在我最初的了悟无常无我，获得基本正见后，在大约三四个月之后，于某次密集禅修当中的第五天，第一次亲身体会到了。</p>
<p>当然这也和上面的图有很重要的联系，我个人认为，如果你能看懂我上面的图，并且进行必要的合理的想象，起码大概能够明白一些。但最好还是要亲自的体会，这样才真正深刻。下面我就结合自己曾经的禅修经验以及上面的图，仔细的分析为什么五蕴是不圆满，是苦，是逼迫性的。</p>
<p>那次密集禅修，是修动中禅，指导老师是泰国的隆波通禅师，一个瘦瘦矮矮，很和蔼可亲的泰国禅师。</p>
<p>动中禅的基本方法也不太难，就是有一套手部的动作，觉知手部的动作就好。当时我已经接触到了南传佛法，也阅读了阿毗达摩理论，并且对于我自己原来所悟的那个世界和自我一格一格的机制已经完全明白确信，而且根据这个，我还自己摸索出了一套四念住的禅法，和动中禅很有点类似，只是我当时观察的并不是手的移动，也不是马哈希尊者的观腹部起伏，而是其他部位。但本质其实都完全一样，都是对一段运动过程（风大）的紧密觉知，因为一旦理解了四念住的核心理论，理解了我上面所说的那个图，很容易辨别什么是四念住，如何修才是四念住。</p>
<p><strong>四念住，简单的说，就是时时刻刻的紧密觉知当下所发生的身心现象。</strong>在图中，就是时时刻刻觉察那一组一组的红黄蓝的圆。去准确捕捉识别这些当下升起的身心现象。尽量觉知辨别每个能感知的“刹那”，每个电影的帧。以动中禅的手部动作来说，手的移动，佛法称为风大，这里的风，代表移动，不是真正的风，整个移动是由一格一格的“独立帧”相续组成。你所要做的，就是要尽量清晰的觉察每个当下的动作，紧密的跟随它，捕捉每一个“帧”，最初可能是很粗糙的，但是之后会越来越微细。</p>
<p>觉知手部动作的是什么？此处极为极为关键，对于这个的理解是四念住成败的关键，是区分正见邪见的关键。我以前跟随某个师父修行的时候，由于被误导，误认为这个“能观”，是所谓的觉性，来自于本心，是自性，并且是不生不灭的，这是很严重的错误。<strong>实际真正觉知手部动作的所谓觉性，佛法称为正念心所，是一种清楚的觉察，它是伴随心识而升起的，属于行蕴，它本身也是生灭的，并非不灭的觉性、佛性、本心之类。</strong>在图中，正念心所对应的是下面红黄圆圈的红环部分，那红环部分还包含很多其他的心所，而修四念住时候升起的正念心所，是其中之一。</p>
<p>这个正念心所必须要明白几个特性，</p>
<p>1、<strong>觉性或者正念本身是生灭的，是缘所生的，绝不是什么恒常存在的本体，不是某个所谓本心、真心的行为，它就是五蕴之一。</strong>佛法将所有身心现象分解为五蕴，从来没有在五蕴之外立出一个“心”，五蕴之外的，只有涅槃，而那是完全不同的状况，是五蕴灭尽的状况。涅槃绝无可能在五蕴生起的状况下表现出来，更不可能是某某“决定”的源头。</p>
<p>2、<strong>觉性或者正念本身不是独立于身心之外的，</strong>我们在觉知身心现象的时候，容易有种第三者在旁观的错觉，这个第三者，其实是心识包括正念心所密集相续的生灭而造成的整体感觉，看似和所谓的五蕴分离了，五蕴看起来像妄心，那旁观的第三者，看起来像所谓的真心自性，更有些人在这里搞出所谓的觉，照一套乱七八糟的扭曲，误认为所谓的觉照，是属于自性的，不是五蕴的，走向神我邪见，犯下严重的错误。而实际上，那个所谓的旁观者，所谓的觉知，还是五蕴本身，只是<strong>有正念觉察的五蕴相续生灭而产生的精神状态，是一种清明的，自主的状况，缺乏正念觉察的五蕴相续生灭而产生的精神状态，是一种混沌的，看似来不自主的状况。</strong>如果此时禅定力相当强而产生光等一些禅相，可以利用作意心所等特性，任意控制禅相的形状以及光的颜色，如果不能正确认知，更会产生主宰自由的大邪见，误认为心可以造万物，可以主宰万物。</p>
<p>我前面曾经说过，那个真正的刹那是极短极短的，是普朗克尺度范围，是10的负34次方秒。如果按照阿毗达摩注释书所说的，也最少是几亿万分之一秒。我上文所说的捕捉觉知每个当下刹那发生的身心现象的刹那，并不是指这个真正的当下的刹那，我个人不认为在实际禅修当中，能够捕捉到普朗克尺度范围内的生灭事件，我认为那是不可能也是没有必要的。<strong>在实际禅修当中的觉知当下并非严格意义的当下，而是叫做“相续刹那”，它是由很多极短刹那组成的非严格意义的“当下”。</strong>因为我们的任何感知都受制于大脑的限制，大脑神经元的处理是需要时间的。虽然大脑并不是意识，但名法（意识）是依赖于色法（大脑）的。尽管这个“当下”是多个刹那的聚合，但是并不影响对无常、苦、无我的观察认识。</p>
<p>可惜上面的图不是动画，因为只有动画才能真正表达出相续这种性质。而且将会明白为什么修观会产生刹那定，为什么刹那定是真正的正定。为什么在修四念住的时候，觉察到生灭的频率会越来越快。在实际禅修过程当中，如果你能够在一秒钟内觉察到意识和所缘的大概几十次到上百次生灭现象，“苦”的坏灭和逼迫的性质将会明显的显现出来。这种状况，就足够一个人生起观智乃至证果。当然，能否在生灭现象的基础上升起观智乃至证果，要取决于慧力，没有慧，哪怕几百上万次的生灭，也不过是生灭而已，顶多是见了点奇怪现象而已。</p>
<p>在修动中禅的时候，我已经明白个了几个重要的关于正见的认识</p>
<p>1、由于身心现象是一刹那一刹那生灭的，所以<strong>四念住重点就是尽量清醒觉知每一个能够感知的刹那。</strong>在动中禅的修行当中，就是密集的捕捉觉知手部移动的每个微细移动。在马哈希尊者的观腹部起伏的修行当中，就是密集的捕捉觉知腹部的微细起伏。手部的移动，全部的起伏，全部是一帧一帧组成的“动画片”，一刹那一刹那紧密相连。</p>
<p>2、<strong>那个能觉知手动动作或者腹部起伏的观察者，不是独立的，持续性的存在，而是生生灭灭的，是和被观察对象，同生同灭，而绝不是观察者不生不灭，被观察者生生灭灭。</strong>所谓的心，并非不断的在杂念和真正的手部动作间乱转，而是当有了杂念的时候，是丧失了正念心所，不能准确觉知对象。如果有正念心所，哪怕从手部动作移开，目标在其他上，比如心念，甚至是外在的事物，只要觉知还在，就没有任何问题，绝对不是走神散乱。</p>
<p>根据以上两点，我当时在修动中禅的时候，基本是按照自己的来修（禅师的教导和我所修的也基本一致）。我有的时候，觉知手部动作，有的时候，就直接觉知心念，甚至有的时候，我还直接观察觉知旁边禅师的走动。只要保持觉知，只要保持清明，就足够。这种目标的转换，根本不是所谓的散乱杂念，而完全符合四念住。此处需要提醒，其他人刚开始不要模仿我这个，因为这只适合这个阶段的我，其他人未必适合，比较稳妥的还是要尽量缩小目标范围进行观察，但绝对不能缩在一个目标上，否则变成了止禅了。</p>
<p>最初的一两天有点煎熬，因为散乱很多，有点坐不住，但因为大家都在那里坐着，一天要八个小时的打坐，所以也能坚持，另外动中禅本身也是和行禅结合，在打坐一个小时以后，就有一次走动的行禅，这还是比较有效的。在大概第三天的时候，轻安的感觉产生，坐着很舒服，身心也很清明敏锐。对念头的觉察也感觉越来越清晰，也很少走神，有一种身体轻飘飘犹如浮在云上，非常快乐舒服的感觉。我这个时候，其实还有点得意，觉得这次禅七个能够修到这个程度，也算不错，甚至都想回家了。假如当时就放下，那么我将丧失大好机会。好在最后还是坚持下来了。到第五天的时候，意外和让我吃惊的现象产生了。</p>
<p>我必须要说明，这意外的现象，是突然性产生的，并不是一般禅修者描述的渐进的过程。我认为这两者都对。我当时由于修的是动中禅，动中禅本身是禁止闭上眼睛的，并且觉知手部动作，所以我觉得它本身建立的定力，并不是十分的强（修行时间长，定力将大大加深）。但根据我当时的经验，这种禅法建立起来的定力，用来认识无常，苦和无我，用来证悟解脱，其实已经足够了。</p>
<p>我当时的身心现象，不太容易完全的表达出来，而且为了避免被模仿，我也难以完全的细节性的描述。这个现象有几个重要的性质</p>
<p>1、快速的生灭，这个在定力敏锐的基础上，只要坚持修下去，是必定可以观察到的。</p>
<p>2、对于当下升起的目标，感觉根本抓不住，因为它灭去的太快，根本抓不着。</p>
<p>3、强烈的逼迫感，甚至让我感到恐惧，这种逼迫来自于生灭本身，即当下那升起的现象，像利刺一样朝自己刺来，无处可躲。</p>
<p>综合第二和第三点，就是<strong>抓也抓不着，躲也躲不掉，无比煎熬</strong>，把我实在吓坏了。</p>
<p>在这个过程当中，我当时因为有了比较强的正见基础和必要的积累，一连串的观智诸如生灭智、坏灭智、过患智、畏怖智、欲解脱智接连强烈的生起，稳固而深刻，这是真正的“见苦”，也是关于自我和存在的深刻智慧的产生。在这之前我其实是不怎么了解南传上座部所说的十六观智的，因为那个时候我才刚刚接触南传上座部不久，后来对比南传所说的十六观智以及一些南传尊者的实修经验，发现我当时的身心经验和上座部所说的几乎完全一样。我个人相信这个是所有实现证悟的修行者必须要经历的一个过程。不过南传的要更加细节化，更加准确而具体。如果你一旦认识和经历这个过程，当你看别人描述所谓的开悟解脱过程时，也很容易辨别什么是真正的证悟。那些没有描述真实的刹那生灭，没有真实的强烈的逼迫性的苦的认识，就直接描述什么五蕴皆空，能所双亡，解脱大乐，言语道断，不可言说，肯定是应质疑的。其实这些虚假证悟是被波性意识的特性所骗，关于波性意识的这部分需要完整了解意识的波粒二象性才能真正认识，也要参考《万物一理》这本书，本文暂不分析。</p>
<p><strong>禅修中没有经历这个痛苦的过程，没有对苦的直接体会，哪里能有最后代表解脱大乐的寂灭涅槃？那涅槃就是建立在对身心五蕴的苦的深刻认识上，因为对身心五蕴的厌离舍弃，才能斩断无明，熄灭贪爱，导向并实现五蕴熄灭的涅槃。因为熄灭了五蕴，因为摆脱了身心的牢笼，才实现了终极的自由和解脱，也就是涅槃。</strong></p>
<p>“抓也抓不着，躲也躲不掉”，这是我当初极为强烈的身心体会，也是我完全没有预料到的。不过假如根据我前面所说的仔细思维，就可以知道经历这种认识其实是必然性的，在佛法经典里面，包括十六观智的描述以及很多南传尊者描述的解脱过程，都大量提到了这个苦的”逼迫性”。</p>
<p>禅修当中被观察对象必然只能维持极短时间，所以你当然抓不住它，你刚想去抓它，它就灭去了，所以当然抓不着。而被观察对象灭去以后，下个对象紧接着生起，你不想让它生，它也要生，所以你当然躲不过，这个就是逼迫。其中目标对象必定性的要坏灭消失掉，其实也是逼迫。并且作为观察者的“自我”，完全就是在生灭当中，而不是生灭之外，作为观察者的“自我”就在和被观察对象一起生灭，你能躲到哪里去呢？无处可躲！而在现实当中其实这个也在明显发生着，比如生老病死就完全是这个性质。</p>
<p>年轻，无法维持，总要消失，你抓得住吗？抓不住！</p>
<p>死亡，不可避免的要来临，你躲得过吗？躲不掉！</p>
<p><strong>在禅修过程当中，由于意识变得清明敏锐，这种生老病死的现象实际被频繁的直接的呈现在禅修者面前，让你不得不面对。每个念头和目标的升起代表着出生，而念头的迅速灭去和消失，代表着死亡。</strong>禅修过程当中，你被这种迅猛的生灭现象剧烈的冲击着，就像狂风暴雨下大海当中漂泊的小船，脆弱无比。又犹如置身于悬崖顶端，身前身后都是万丈深渊，支撑着自己的地面又随时会坍塌，根本站立不稳。自我身心（五蕴）就是如此，真实的世界就是如此。由于心灵被蒙蔽，由于无明和贪婪，我们被自我感官的错觉欺骗了，沉迷于感官所带来的短暂快乐当中，丝毫不能察觉危险的存在，不能认识到自我和存在的真相。</p>
<p>这一切，其实是可以避免的，因为还有涅槃，佛陀为我们指出了无生无灭，寂静清凉的涅槃的存在。舍弃这不圆满的<strong>五蕴，毫不犹豫的导向那涅槃的彼岸。</strong></p>
<p>在随后的禅修报告中，我向隆波通描述了这段感受，得到了他的认可，隆波通旁边那位侍者赞许和鼓励的目光也至今让我印象深刻，同时也深深的感谢他们以及禅修的组织者。虽然我所达到的还和佛法所说的终极解脱还有很大的距离，然而这确实是我第一次真正认识和亲身体会到了佛陀所说的“苦”的深意。</p>
<p>在禅修结束后，寺庙摆出了很多佛教的书可以供挑选，不过大部分都是一些大乘的书，在这很多书里面我发现少有的一本适合我的书，当时也很巧合的仅仅就剩下这一本，书名是《无常》，作者是泰国的禅师阿姜查。翻开这本书，阿姜查用简单浅显的文字描述了我实修当中所认识到的真正的无常和苦以及无我，进一步印证了我的实修认识。</p>
<p>2009年2月22日，北京朝阳寺。<br>从这一天开始，我的世界真正亮了。<br>朝阳生起，光芒万丈。<br>我迈向通往终极自由和解脱的大道。<br>从此不可逆转！！！</p>
<hr>
<p><em><strong>转载自 <a href="https://www.jianshu.com/p/aad3e1d766b5">一张简单图片演示的“甚深佛法”</a></strong></em></p>
<hr>
<h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><p>此文在之前的博文 <a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a> 以有提及, 并加上了自己的一个妄想, 拿很容易理解的交易市场进行了举例.<br>我个人的看法是: 断续是本质, 连续是现象. 观察的角度不同, 分析的重点也就不同.<br>不去本位相生, 不思虑重复性, 看断续是断续, 即生即灭. 但因缘法/因果律会推着这种断续向前走, 从而形成事物发展的连续性. 对于有重复性的事物而言, 另一个研究重点是因缘法/因果律.<br>就交易市场和物理世界看因果, 其本质是一种观察者/被观察者的自我博弈而来的结果. 交易市场的涨跌由所有参与者的底层逻辑变化而变化, 价值还是投机, 无所谓对错. 物理世界的因果律则是最小作用量原理.</p>
<p>这里决定把它全文转载下来, 有两个目的.</p>
<ol>
<li>作者的这些体会和思考, 是明心阶段的重要路标之一.<ul>
<li><strong>情绪, 从哪来?</strong></li>
<li><strong>脑海中, 一念起, 一念落, 二念之间的那道”空白”, 究竟是什么?</strong></li>
</ul>
</li>
<li>作者正走在明心的路上, 就转向了哲学思辨.<ul>
<li><strong>求而不得, 不求而得</strong></li>
<li><strong>实修之路, 切记弃智绝圣.</strong></li>
<li><strong>放弃思辨, 感受当下, 观察思绪.</strong></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>万年歌, 马前课, 梅花诗, 推背图 (下)</title>
    <url>/2021/03/18/2108-tuibeitu2/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
<li><a href="https://draapho.github.io/2021/03/05/2107-tuibeitu1/">万年歌, 马前课, 梅花诗, 推背图 (上)</a></li>
<li><a href="https://draapho.github.io/2021/03/18/2108-tuibeitu2/">万年歌, 马前课, 梅花诗, 推背图 (下)</a></li>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/26/2123-caseofsatori/">见性者体验收集</a></li>
</ul>
<p><em><strong>转载自 <a href="https://www.youtube.com/c/%E5%A4%A7%E9%87%91%E4%BA%BA/videos">大金人 - YouTube</a></strong></em>, 略有删改.</p>
<hr>
<h1 id="解读推背图"><a href="#解读推背图" class="headerlink" title="解读推背图"></a>解读推背图</h1><ul>
<li>视频资料:<ul>
<li><a href="https://www.youtube.com/watch?v=fm0vqcpQoMQ">推背圖第40象(上集)</a></li>
<li><a href="https://www.youtube.com/watch?v=DNWCzpNFP84">推背圖第40象(中集)</a></li>
<li><a href="https://www.youtube.com/watch?v=uacnAw0c5Ds">推背圖第40象(下集之一)</a></li>
<li><a href="https://www.youtube.com/watch?v=hz5ZryH59wM">推背圖第40象(下集之二)</a></li>
<li><a href="https://www.youtube.com/watch?v=NSPHHZtfVTY">推背圖第41象</a></li>
<li><a href="https://www.youtube.com/watch?v=5X2rM5FW_e8">推背圖第42象(上集)</a></li>
<li><a href="https://www.youtube.com/watch?v=ZrWAKEXCaCQ">推背圖第42象(下集)</a></li>
<li><a href="https://www.youtube.com/watch?v=4HfLM026KMk">推背圖第43象(上集)</a></li>
<li><a href="https://www.youtube.com/watch?v=MOQE76M2jQU">推背圖第43象(下集)</a></li>
<li><a href="https://www.youtube.com/watch?v=hgrHRWmcN4w">本集歸納分析發現：推背圖之正確讀法</a></li>
<li><a href="https://www.youtube.com/watch?v=75A9ByOnpYI">推背圖44象(上集)</a></li>
<li><a href="https://www.youtube.com/watch?v=rf5U_2izJ3g">推背圖44象(中集)</a></li>
<li><a href="https://www.youtube.com/watch?v=A84J2GY05mQ">推背圖第44象(下集)</a></li>
<li><a href="https://www.youtube.com/watch?v=dC-CZaqiewo">推背圖第45象(上集)</a></li>
<li><a href="https://www.youtube.com/watch?v=wftHcfLETCM">推背圖第45象(下集)</a></li>
<li>维基文库 <a href="https://zh.m.wikisource.org/zh-hans/%E6%8E%A8%E8%83%8C%E5%9C%96_(%E8%A2%81%E5%A4%A9%E7%BD%A1%E3%80%81%E6%9D%8E%E6%B7%B3%E9%A2%A8)">推背图 (袁天罡、李淳风)</a></li>
<li><a href="https://www.smxs.com/tuibeitu">水墨先生 推背图</a>, 仅供参考</li>
</ul>
</li>
</ul>
<h2 id="推背图的结构"><a href="#推背图的结构" class="headerlink" title="推背图的结构"></a>推背图的结构</h2><ul>
<li>此类预言性质的书, 多为托名之作. 如果真正的作者刻意安排, 那有明确注释的部分就是用来帮助人们正确理解文章结构和解迷方法的. 无注释的部分才是真正的预测内容.</li>
<li>以此来理解, 《万年歌》按照时间顺序排列, 《马前课》借着白鹤山僧守元的口点明一课指一朝, 《梅花诗》也按照时间顺序排列, 但并非严格的一段一朝代, 因为开篇其一讲的是北宋, 其二讲的是南宋.</li>
<li>《推背图》的情况比较复杂, 很明显并非严格按照时间顺序排列. 根据考据, 《推背图》很可能在宋朝初期已广为流传, 赵匡胤以推代禁, 导致版本杂乱不一, 顺序被随意打乱, 真假难辨. 现存的比较有名的《推背图》, 从逻辑上讲, 要么是后人借《推背图》之名, 托名所作; 要么是随着历史的进展, 去伪存真, 留下了最符合历史发展的那个版本.</li>
<li>金批本《推背图》, 最早出现于1915年出版的《中国预言七种》. 是否出自于明末甚至宋初, 皆不可考, 仅为推测.</li>
<li>金批本《推背图》的结构很特殊. 有些朝代会有一象总叙, 然后再用若干象按时间顺序描述朝代内的大事件. 总体按照朝代来叙事, 朝代内部是总分结构.</li>
<li><strong>第二象, 唐朝国运. 注解已明确指出了二十一主, 二百八十九年. 唐朝整体为总分结构</strong><ul>
<li>第三象至第十象, 按时间顺序, 分别对应如下事件:</li>
<li>武后称帝-&gt;逼退武皇-&gt;安史之乱-&gt;再造唐朝-&gt;吐蕃侵掠-&gt;藩镇之乱-&gt;黄巢起义-&gt;朱温篡唐(<code>一后二主尽升遐</code>)</li>
</ul>
</li>
<li><strong>第十象, 朱温篡唐, 建立后梁. 中国进入五代十国, 采用了分总结构</strong><ul>
<li>第十一象, 后唐国运; 第十二象, 后晋儿皇; 第十三象, 后汉亡，后周立</li>
<li><strong>第十四象, 后周亡, 五代运终. 总结了五代十国</strong>: 五个姓氏(用到了谐音), 共13位皇帝, 在位时间都很短.</li>
</ul>
</li>
<li>第十五象, 五代十国灭亡, 宋太祖扫荡群雄. 承上启下的一象.</li>
<li><strong>第十六象, 宋朝建立. 宋朝整体为分总结构</strong><ul>
<li>第十七象至第二十四象, 按时间顺序, 分别对应如下事件:</li>
<li>澶渊之盟-&gt;刘太后主政-&gt;王安石变法,平戎大败-&gt;蔡京乱政-&gt;靖康之耻-&gt;偏安南宋-&gt;蒙古崛起-&gt;南宋灭亡</li>
<li><strong>第二十四象, 南宋灭亡. 并总结为<code>二九四八</code></strong>: 北宋九帝, 南宋九主. 整个宋朝为40*8=320年(960-1279).</li>
</ul>
</li>
<li><strong>第二十五象, 元朝国运. 传十帝而终. 总分结构</strong><ul>
<li>第二十六象, 元朝灭亡.</li>
</ul>
</li>
<li><strong>第二十七象, 明朝立国. 明朝为平铺直叙, 按时间顺序排列</strong><ul>
<li>第二十八象至三十二象, 按时间顺序, 分别对应如下事件:</li>
<li>燕王夺位-&gt;仁宣之治-&gt;土木之变-&gt;魏忠贤之乱-&gt;闯王灭明</li>
</ul>
</li>
<li><strong>第三十三象, 清朝国运. 传十帝, 其中有一半是幼帝上位. 清朝整体为总分结构</strong><ul>
<li>第三十四象至第三十七象, 按时间顺序, 分别对应如下事件:</li>
<li>太平天国-&gt;火烧圆明园-&gt;慈禧光绪西逃-&gt;清朝灭亡(<code>水清终有竭,倒戈逢八月</code>)</li>
<li>需要补充一下第五十五象. 高度疑似为中日甲午战争.<ul>
<li>谶曰: <code>惧则生戒 无远勿届 水边有女 对日自拜</code></li>
<li>颂曰: <code>觊觎神器终无用 翼翼小心有臣众 转危为安见节义 未必河山是我送</code></li>
<li>图片: <code>一人扶持将要倾倒之树</code> = 扶倾 = 扶清. (推背图里, 谐音为常见用法)</li>
<li><code>无远勿届</code> = 出动的战列舰都是带<code>远</code>的. 如定远号, 镇远号.</li>
<li><code>水边有女 对日自拜</code> = 丁<code>汝昌</code>.</li>
<li><code>觊觎神器终无用</code> = 洋务运动, 师夷长技以自强. 结果建立起的北洋舰队全军覆没.</li>
<li><code>翼翼小心有臣众</code> = <code>惧则生戒</code> = 战略制定上万分地谨慎保守.</li>
<li><code>转危为安见节义 未必河山是我送</code> = 李鸿章割地赔款, 清政府转危为安. 清朝并未就此葬送.</li>
<li>这里考虑乱序, 主要是上述这些定位线索综合起来, 全都符合中日甲午战争的人物和事件.</li>
<li>更新后的事件顺序: 太平天国-&gt;中日甲午战争(第五十五象)-&gt;火烧圆明园-&gt;慈禧光绪西逃-&gt;清朝灭亡</li>
</ul>
</li>
</ul>
</li>
<li><strong>第三十七象, 建立中华民国</strong></li>
<li><strong>第三十八象, 第一次世界大战</strong><ul>
<li>收录金批本《推背图》的《中国预言七种》出版于1915年, 一战时间为1914-1918年. <strong>以此为界, 后面是毋庸置疑的预言性质.</strong></li>
</ul>
</li>
<li><strong>第三十九象, 日本侵华, 抗日战争</strong></li>
</ul>
<h2 id="第四十象解读"><a href="#第四十象解读" class="headerlink" title="第四十象解读"></a>第四十象解读</h2><ul>
<li>讲的是中华民国败走台湾, 最终消亡的过程.</li>
<li>谶曰: <code>一二三四 无土有主 小小天罡 垂拱而治</code>, 这里面精确定位了时间和地点.<ul>
<li><code>一二三四</code>=一二相加, 三四相加=37年. 指中华民国在中国大陆只呆了37年.</li>
<li><code>无土有主</code>, 到了民国三十八年, 即1949年. 就被赶到了台湾, 中华民国无故土, 中国大陆有新主.</li>
<li><code>小小天罡</code>, <a href="https://www.zdic.net/hant/%E5%A4%A9%E7%BD%A1">天罡</a>, 指北斗七星的柄. 结合东亚沿海的岛屿分布, 可精准定位到小小的台湾岛.<br><img src="https://draapho.github.io/images/2108/bdqx.png" alt="北斗七星的柄"></li>
<li><code>垂拱而治</code>, 一个成语, 多用作称颂无为而治, 天下太平. 台湾是亚洲四小龙之一.</li>
</ul>
</li>
<li>颂曰: <code>一口东来气太骄 脚下无履首无毛 若逢木子冰霜涣 生我者猴死我雕</code><ul>
<li><code>一口东来气太骄</code>. 此句双关<ul>
<li><code>一口</code>=日, 日本自东而来, 气焰骄狂.</li>
<li><code>东来</code>=毛泽东, 周恩来. 抗战胜利后, 共产党迅速由弱转强, 四年内武力夺取政权, 气太骄.</li>
</ul>
</li>
<li><code>脚下无履首无毛</code>. 整句指蒋介石领导的国民党不断地丢失领土.<ul>
<li><code>首无毛</code>=元首的头上没有头发=蒋介石.</li>
<li><code>脚下无履</code>. 履可指领土, 脚下没有领土.</li>
</ul>
</li>
<li>前两句结合起来理解: 先被日本打, 丢东北, 迁都到南京. 再被中共打, 撤退到台湾. 中华民国宪法上的领土, 只在纸上, 不在脚下.</li>
<li><code>若逢木子冰霜涣</code>. 也是双关.<ul>
<li>指台湾第一第二任民选总统. <code>木子</code>=李登辉. <code>冰霜涣</code>=变成一滩水=水遍于地=陈水扁.</li>
<li><code>若逢木子</code>指台湾自李登辉起, <code>冰霜涣</code>指解除了戒严体制, 进入民主选举时代. 冰霜不自由, 化为水才能按照本性自由流淌.</li>
</ul>
</li>
<li><code>生我者猴死我雕</code>. 对中华民国的总结. 生于猴, 死于雕.<ul>
<li><code>生于猴</code>, 双关. 猿猴=袁世凯; 孙猴=孙中山. 双猴出击, 文武并进, 创建民国.</li>
<li>有人将<code>雕</code>解释成老鹰, 再用鹰同音于英, 强行对位于马英九和蔡英文.但《推背图》里一般只用直接谐音, 联想再谐音就没底了…</li>
<li>此<code>雕</code>, 大概率指代的是美国. 美国国徽是白头海雕(不是秃鹰). <code>死我雕</code>可能也是双关, 同时代表着过去和未来.</li>
<li>过去指1979年, 中美建交, 美国承认一中原则. 美国与国民党政府断交. 中华民国在名分上, 在国际舞台的社交上, 死亡了.</li>
<li>未来, 大概率指中华民国对台湾的实际控制权, 也会亡于美国大雕.<ul>
<li>值得重点关注的是美国对台提供武力保护的《台湾关系法》. 此法废除, 则台湾灭亡; 此法有效, 则可出兵台湾.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>由<code>生我者猴死我雕</code>可知, 中华民国是分总结构.</strong><ul>
<li>第三十七象: 建立中华民国</li>
<li>第三十八象: 第一次世界大战, 中华民国是参战国.</li>
<li>第三十九象: 日本侵华, 国民党为抗日主力军.</li>
<li>第四十象: 中华民国败走台湾, 将台湾治理的不错. 并将中华民国总结为一句<code>生我者猴死我雕</code>.</li>
</ul>
</li>
</ul>
<h2 id="《推背图》常见的解码方法"><a href="#《推背图》常见的解码方法" class="headerlink" title="《推背图》常见的解码方法"></a>《推背图》常见的解码方法</h2><ul>
<li>拆字组合. 举例如下:<ul>
<li>第四十象 <code>一口东来气太骄</code>. 毛泽东, 周恩来</li>
<li>第四十象 <code>若逢木子冰霜涣</code>. 木子为李. 冰霜涣需要联想. 但水遍中, 也直接包含了水扁两字.</li>
<li>第三十四象 <code>洪水滔天苗不秀 中原曾见梦全非</code>. 洪秀全</li>
</ul>
</li>
<li>文义密码, 历史典故. 举例如下:<ul>
<li>第三十九象 <code>鳥无足, 山有月</code>. <code>鳥</code>去足,换成<code>山</code>是<code>岛</code>,指岛国日本.</li>
<li>第三十九象 <code>南山有雀北山罗</code>. <code>雀</code>字, 用到了精卫填海的典故, 可对应到汪精卫.</li>
</ul>
</li>
<li>谐音和图解.<ul>
<li>第二十五象. <code>一把铁斧,斧柄十段</code>. 铁斧木柄=铁木真.</li>
<li>第五十五象. <code>一人扶持将要倾倒之树</code>=扶倾=扶清.</li>
</ul>
</li>
<li>更多例子或解码方法可参考 <a href="https://www.smxs.com/tuibeitu">水墨先生 推背图</a> 三十九象之前的解读.</li>
</ul>
<h2 id="第四十一象解读"><a href="#第四十一象解读" class="headerlink" title="第四十一象解读"></a>第四十一象解读</h2><ul>
<li>此象讲的是中华人民共和国建国初期的一系列整治运动及后来的国运. <strong>PRC部分整体为总分结构.</strong><ul>
<li>由于ROC名亡实存, 因而讲PRC的第四十一,四十二和讲ROC的第四十象,在时间线上是重叠的.</li>
<li>第四十三象, 用的是中华人民共和国的视角, 因而也属于PRC部分. 但同时把ROC涵盖了进去.</li>
</ul>
</li>
<li>谶曰: <code>天地晦盲 草木繁殖 阴阳反背 上土下日</code>.<ul>
<li>整个谶都在描述大跃进和文化大革命的惨状.</li>
<li><code>天地晦盲 草木繁殖</code> 毛泽东威望至极, 全国人民盲信盲从, 运动一波接着一波, 斗的天昏地暗.<ul>
<li>毛可以指草, 如<code>不毛之地</code>. 因而<code>草木</code>=毛, <code>草木繁殖</code>指毛的信仰者众多, 人人一本《毛主席语录》.</li>
</ul>
</li>
<li><code>阴阳反背</code> <code>上土下日</code>, 毛泽东强调人定胜天, 颠倒乾坤. 搞得天翻地覆, 以下克上, 造反有理. 评价就是晦盲, 反背.<ul>
<li><code>阴阳反背</code>, 不承认经济发展的客观规律. 大跃进全民动员, 要短时间内赶英超美.</li>
<li><code>上土下日</code>, 不符合自然规律的现象. 也可指知识青年上山下乡, 被要求像农民学习, 以农民为尊.</li>
</ul>
</li>
<li>建国初期的整治运动:<ul>
<li>三反, 五反主要目标是资产阶级. 其后果是对经济市场造成了冲击, 中国大陆资产阶级走向消亡.</li>
<li>大跃进则完全忽视经济规律, 一味以钢产量为指标, 要求赶英超美. 直接造成大饥荒和大量人口的非正常死亡.<ul>
<li>代表性事件 <a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E9%98%B3%E4%BA%8B%E4%BB%B6">信阳事件</a></li>
</ul>
</li>
<li>文化大革命则是全方位的反常. 知识青年上山下乡; 工人斗管理者; 学生斗老师; 儿女斗父母; 夫妻家人之间互相检举揭发. 反了人伦常理, 反了社会发展, 反了自然规律.<ul>
<li>代表性事件 <a href="https://zh.wikipedia.org/wiki/%E9%81%93%E5%8E%BF%E4%BA%8B%E4%BB%B6">道县事件</a>, <a href="https://zh.wikipedia.org/wiki/%E6%AD%A6%E6%96%97">武斗</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>颂曰: <code>帽儿须戴血无头 手弄乾坤何日休 九十九年成大错 称王只合在秦州</code><ul>
<li><code>帽儿须戴血无头</code>.<ul>
<li><code>帽儿须戴</code>, 虚实两面. 实指文革时期的<a href="https://www.google.com/search?q=%E6%96%87%E9%9D%A9%E6%88%B4%E9%AB%98%E5%B8%BD">戴高帽</a>, 虚指几次运动都过头了, 无端乱设指标, 乱扣帽子. 结果是<code>血无头</code>, 诸多的冤假错案, 诸多的枉死.</li>
</ul>
</li>
<li><code>手弄乾坤何日休</code>. 点明了建国后, 毛泽东在不断的搞运动折腾全中国, 不死不休.<ul>
<li><code>手</code> <code>反背</code> = <code>毛</code></li>
</ul>
</li>
<li><code>九十九年成大错　称王只合在秦州</code><ul>
<li>如果熟悉了推背图的结构, 很明显, 这句讲的是中共的结局, 而非过去.</li>
<li>以《推背图》的眼界, 从来没有在意过某一个人, 某一个政党寿命几何. 时间概念上, 全部指的是朝代.</li>
<li><code>九十九年成大错</code>, 要么指2099年, 要么是立国99年.<ul>
<li>由于中华人民共和国的官方纪年用的是公历, 这里不能完全排除指2099年的可能性.</li>
<li>但《推背图》一般都不用公元纪年, 多采用天干地支或生肖五行颜色来指定年份. 因而偏向于立国99年.</li>
<li>1949年+99=2048年. 不断走钢丝摸石头前进的中共, 还是犯了大错.</li>
</ul>
</li>
<li><code>称王只合在秦州</code>, 犯错的结果就是势力范围缩小到秦州.<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E7%A7%A6%E5%B7%9E_(%E5%8F%A4%E4%BB%A3)">古时的秦州</a>, 和红军的革命根据地陕甘宁地区略有重合.</li>
<li>从陕甘宁革命根据地发展壮大而来, 结局是只能回到陕甘宁地区继续<code>称王</code>. 这种假设可完全契合<code>只合在秦州</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>图片: <code>反背着手的一个人, 头顶一帽, 脚下踩着一个球(太阳)</code>, 看起来就霸道万分, 十分厉害.<ul>
<li>反手 = <code>毛</code>. 此图精确锚定了具有颠倒乾坤之能, 要人定胜天的毛泽东.</li>
</ul>
</li>
<li>(我自己对毛的评价:)<ul>
<li>(于百姓有过, 建国后继续折腾, 没有让百姓过上正常的日子;)</li>
<li>(于中国有功, 游走于美苏超级大国, 中国本为棋子, 最终翻身成了独立棋手;)</li>
<li>(于共产党是大救星.)</li>
<li>(邓上台后进行了大转弯, 发展至今大资产阶级作威作福. 不少人开始怀念毛时代, 也至少先了解一下这段历史的真实情况)</li>
</ul>
</li>
</ul>
<h2 id="第四十二象解读"><a href="#第四十二象解读" class="headerlink" title="第四十二象解读"></a>第四十二象解读</h2><ul>
<li>主流两种看法, 一种认为讲的是江青. 另一解为美国.</li>
<li>解为江青的, 简单罗列一下其说辞:<ul>
<li>江青随毛从陕西来到北京. 所以是 <code>西来</code>, <code>西方女子</code></li>
<li>四人帮掌权以后, 没有掌握军权, 因而<code>长弓在地</code>.</li>
<li>成功粉碎四人帮, 对应为<code>危而不危</code>.</li>
<li>江青做过歌女, 所以是<code>琵琶仙, 皎皎衣裳色更鲜</code></li>
<li>先是随毛 <code>浑迹匿朝市</code>, 后掌权 <code>闹乱君臣百万般</code></li>
</ul>
</li>
<li>(额…解为江青, 格局未免太小了. 我来批驳一下)<ul>
<li>能独占完整一象的人: 武则天, 石敬瑭勉强算上(还捎上了他养子亡国于契丹). 赵匡胤, 朱元璋, 毛泽东也勉强算上(最后两句是国运).</li>
<li>讲刘太后主政的第十八象, 是和宋仁宗一起写的. 慈禧太后所在的第三十六象只是提到<code>母子西望</code>而已.</li>
<li>请问和毛泽东同时期的江青, 何德何能让《推背图》为其作整象? 这种小人物撑死提一句, 不提最正常.</li>
<li>另, 西来的江青, 和<code>朝中日渐安</code>有什么关系?</li>
<li>颂的前两句居然只是为了描述江青做过歌女? 写正史恐怕都不会记录地这么详尽.</li>
<li>更夸张的是, 还和武则天, 刘太后一样, 独占整幅图片.</li>
<li>总之, 这样的待遇, 她配吗? 她消受得起吗? 她是流芳千古了, 还是遗臭万年了?</li>
</ul>
</li>
<li>另一解为美国. 下面会逐句解释说明.</li>
<li>谶曰: <code>美人自西来 朝中日渐安 长弓在地 危而不危</code><ul>
<li><code>美人自西来 朝中日渐安</code>.<ul>
<li>讲的是朝鲜战争</li>
<li>以美国为首的西方国家, 加入朝鲜战争. 随后中国抗美援朝, 打了个平手. 东亚局势(<code>朝中日</code>=朝鲜中国日本)也就渐渐地安定了下来.</li>
<li>适当联想: 也就是美国没来之前, 东亚是不安的. 因为北朝鲜不安分地主动攻击韩国, 才导致了<code>美人自西来</code>.</li>
<li>另外, 图片中有一只白兔. 白兔是辛卯年=1951年, 是抗美援朝开打的第二年.</li>
</ul>
</li>
<li><code>长弓在地 危而不危</code><ul>
<li>指的是美苏冷战, 相互核威慑.</li>
<li>长弓指洲际核导弹, 核威慑让人胆战心惊, 第三次世界大战看似一触即发.</li>
<li>但指明了, 这些核导弹最终都留在了地上, 没有被发射上天. 因而有惊无险, 危而不危.</li>
</ul>
</li>
<li><code>长弓在地 危而不危</code> (我自己的补充, 既指美苏冷战的世界局势, 也指中国当时的国际环境)<ul>
<li>也可以指PRC拥有了自己的<code>长弓</code>, 虽然与美苏两个大国矛盾不断, 左右横跳, 看似危险重重, 但终是安然无恙, 棋子变棋手.</li>
<li>这个说法也可由图片中的左弓右兔来勉强佐证一下.<ul>
<li>自从《那年那兔那些事儿》流行开来. 小白兔也成为了中国的代名词.</li>
<li>我兔发展初期, 就是只是美国脚边的一只小白兔.</li>
<li>由于前期武德充沛(抗美援朝, 二弹一星, 对印自卫反击战, 越南战争), 因而后期依靠地上的弓, 获取了数十年的和平发展时期.</li>
<li>后中美虽有台海危机, 使馆被炸, 中美撞机事件, 亚洲金融危机. 也都算危而不危, 和平合作为主.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>颂曰: <code>西方女子琵琶仙 皎皎衣裳色更鲜 此时浑迹匿朝市 闹乱君臣百万般</code><ul>
<li><code>西方女子琵琶仙 皎皎衣裳色更鲜</code><ul>
<li>这两句指改革开放, 与西方世界接轨之后的变化.</li>
<li>从古代中国的角度来说, 琵琶是外国来的乐器, 是象征歌舞升平的乐器</li>
<li><code>女子</code>=好; <code>仙</code>字. 意味着大家对其评价是正面的, 认为西方带来的这些个东西是好东西.</li>
<li>比人更高一个等级的<code>仙</code>字, 也突出了来者的强大. 相比于中国传统文化, 影响范围更广泛, 也更深入人心.</li>
<li>文化层面包括但不限于意识形态, 娱乐方式: 如民主自由, 市场经济, 资本主义, 科学技术, 音乐电影动漫, 互联网世界.</li>
<li>改革开放, 与西方世界接轨之后, 人们首先改变的就是吃穿住行中的穿. 因而有<code>皎皎衣裳色更鲜</code>, 开始穿漂亮衣服, 听靡靡之音.</li>
<li>时代背景为: 苏联解体, 世界变为一超多强, 美国完全掌握了世界话语权. 手握枪杆子, 钱袋子和笔杆子, 无往不利.</li>
<li>中华文明武力落后于外国文明很常见, 这次在文化层面也全面落后于西方文明, 还是有史以来第一次. 因而值得特别写出.</li>
</ul>
</li>
<li><code>此时浑迹匿朝市 闹乱君臣百万般</code><ul>
<li>在毛泽东时代被灭干净的资产阶级, 随着改革开发, 迅速的回来了. 官商勾结, 一起浑迹于市场, 隐匿于朝堂, 贪污腐败, 作威作福.</li>
<li>由此带来的一系列社会问题, 动摇着中共的执政根基, 因而是<code>闹乱君臣</code>.</li>
<li>因而每一届领导人都会运动式地打贪反腐, 习近平上台后, 成百万的党员被查处. 是为<code>百万般</code>, 这是实指.</li>
<li><code>百万般</code>虚指自然是此问题会不断反复, 无法得到根治.</li>
</ul>
</li>
<li>(整句解释, 自己的理解)<ul>
<li><code>西方女子琵琶仙</code> = 资本主义. <code>皎皎衣裳色更鲜</code> = 带来了更为丰富的物质生活.</li>
<li>资本主义的代表阶级为大资产阶级. <code>此时浑迹匿朝市</code> = 改革开发后, 官浑迹于市场, 商隐匿于朝堂, 官商一体组成的大资产阶级成了统治阶级.</li>
<li>其后果和评价便是 <code>闹乱君臣百万般</code>=大资产阶级乱政, 动摇执政基础. <code>百万般</code>不但指范围广, 还指时间长, 不断反复, 无法根治.</li>
<li>整句讲的是改革开放的结果: 带来了资本主义, 丰富了人们的物质生活; 复活了大资产阶级, 动摇着中共的执政根基.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第四十三象解读"><a href="#第四十三象解读" class="headerlink" title="第四十三象解读"></a>第四十三象解读</h2><ul>
<li><strong>此象涉及到未来之事, 解读仅为解谜和猜测, 请勿迷信.</strong></li>
<li>此象重点描述了两岸关系和中华人民共和国的衰落(未来事件).<ul>
<li>由于从第四十一象起, 讲的就是PRC, 因而此象依旧是PRC的叙事视角.</li>
<li>其中的大部分内容还没有发生, 可能有机会亲自经历这段历史, 以验预言之真伪.</li>
</ul>
</li>
<li>图片: 西北方向一个大人, 戴着官帽, 衣着普通. 东南方向一个小人, 没有官帽, 但衣着华丽, 像个资产阶级小富人.<ul>
<li>大人为PRC, 更强大的中国大陆在台湾的西北方向. 官帽意味着名分和实权, 国际上只有一个中国: 中华人民共和国. 中华民国是实存名亡.</li>
<li>小人为ROC, 偏弱小的台湾在中国大陆的东南方向. 衣着华丽意味着人们的平均生活水平更为富饶.</li>
<li>两者同向而行, 互不隶属, 相互注视提防对方.</li>
<li>整张图大小, 方位, 服饰, 神态上的隐喻都直指两岸关系, 可谓精妙.</li>
</ul>
</li>
<li>谶曰: <code>君非君 臣非臣 始艰危 终克定</code><ul>
<li>整个谶曰讲的就是两岸关系.</li>
<li><code>君非君 臣非臣</code> 两岸互不隶属, 却又同向而行. 两者的宪法都包含着对方的领土, 主张着完整的中国领土.</li>
<li><code>始艰危</code> 毛泽东时期, 互相敌对(毛要收复台湾, 蒋要反攻大陆), 偶有战乱(如金门炮战), 两岸关系可谓艰难而危机四伏.</li>
<li><code>终克定</code> 随后的两岸关系, 双方都比较克制(大陆不武统, 台湾不独立), 和平稳定为主.<ul>
<li>到目前为止, 随着经贸关系的不断加深, 以及实力和心态上的变化, PRC对台问题始终比较克制(主要矛盾为中美关系).</li>
<li>结合上下文, 这里的<code>克定</code>不能解释成武统的攻克平定. 如果双方一直战事不断, 将<code>始艰危</code>理解成久攻不下的艰难危险, 在这个前提下, <code>终克定</code>才能解释为最终攻克平定. 但实际的两岸关系开始很困难, 后来一直保持着和平稳定, 因而<code>终克定</code>解释为始终克制,和平稳定为主旋律更为合理.</li>
</ul>
</li>
<li>整个谶曰也有可能是双关, 除了当下的两岸关系, 还可能指的是<code>欲尽不尽不可说</code>之后的中国大陆的情况.<ul>
<li>譬如PRC名存实亡, 实际是割据分治状态. 最后又统一起来建立新政权, 也能完全地契合整个谶曰.</li>
<li>有此猜测的主要原因是PRC<code>欲尽不尽不可说</code>, 似有名存实亡之意; 而<code>称王只合在秦州</code>, 则明示了PRC会缩小为一个地方政权.</li>
</ul>
</li>
</ul>
</li>
<li>颂曰: <code>黑兔走入青龙穴 欲尽不尽不可说 唯有外边根树上 三十年中子孙结</code><ul>
<li><code>黑兔走入青龙穴</code>, 年份定位点.<ul>
<li><code>黑兔</code>=癸卯年=2023年或2083年.</li>
<li><code>青龙</code>=甲辰年=2024年或2084年.</li>
</ul>
</li>
<li><code>欲尽不尽不可说</code>, 欲言又止, 这可不是什么好话.<ul>
<li><code>尽</code>, 竭也,終也,止也. <code>欲尽不尽</code>=将死未死, 似亡非亡. 实力大损是一定的.</li>
<li>名存实亡? 结合第四十一象的<code>称王只合在秦州</code>, 不禁有此猜测.</li>
</ul>
</li>
<li><code>唯有外边根树上</code>, 此句进一步确定了四十三象的叙事视角是PRC.<ul>
<li>与外边相对的, 是中原之地. 很明显, 台湾为外边, 中国大陆为中原. 因而整个颂曰的视角是中国大陆的政权PRC.</li>
<li><code>外边根树</code> 是一个很奇怪的说法. 因为根一般都是在中心之地, 然后开枝散叶到外边. 这里说的却是根在外边子孙结.</li>
<li>如果从中国传统文化的传承角度来理解, 也就说的通了.<ul>
<li>中国传统文化已被手弄乾坤的毛主席在文化大革命时期提倡的破四旧中, 打砸抢烧, 破坏殆尽了.</li>
<li>唯物辩证主义, 科学发展观的填鸭式教育, 僵化了几代人的整体思想.</li>
<li>而台湾方面, 儒释道三教, 易学和山医命卜相的传承和发展要自由的多, 不会有政治形态上的紧箍咒.</li>
</ul>
</li>
<li>这其实是中国集权统治的一个顽疾. 乱世文化兴盛, 盛世万马齐瘖.<ul>
<li>因而有网络流言: 唐宋在日本, 明朝在韩国, 民国在台湾.</li>
</ul>
</li>
</ul>
</li>
<li><code>三十年中子孙结</code><ul>
<li>解法参考第三十九象的<code>十二月中气不和</code>, 十二月的中间=六月=农历1937年六月初一=公历1937年7月8日, 定位了七七卢沟桥事变.</li>
<li><code>三十年中</code>=十五年. 能定位的参考点就是之前的<code>黑兔走入青龙穴</code>.<ul>
<li>15+2024=2039年;</li>
<li>15+2084=2099年; (额…第四十一象的颂曰有<code>九十九年成大错 称王只合在秦州</code>)</li>
</ul>
</li>
<li><code>子孙结</code>. 既然前一句是根树, 这里的<code>结</code>只能是”结出果实”之意.</li>
<li>也可能就是直白的30年, 意思为三十年里面, 不断地发生着<code>子孙结</code>这种事件.<ul>
<li>30+2024=2054年;</li>
<li>事件猜测: 就像台湾一样, 大陆内部先后分裂为若干独立政权, 有些采用了民主选举的制度. 这些先后结出的子孙地方政权, 都会在下一象圣人的吸引下, 组成中华联邦政权, 根回中原.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>鼎卦, 火风鼎: 象征着烹饪, 取新, 布置新气象, 建立新政权.</li>
<li>从第四十象起至第四十三象, 猜测PRC和ROC的命运<ul>
<li>ROC: <code>生我者猴死我雕</code>, ROC会亡于美国. 目前, 名亡实存.</li>
<li>PRC: <code>黑兔走入青龙穴 欲尽不尽不可说</code>, 会在某一年(2023或2083)将死未死, 似亡非亡, 实力大损. 可能名存实亡.</li>
<li>PRC: <code>九十九年成大错 称王只合在秦州</code>, 会在某一年(2048或2099)最终退缩为一个地方政权.</li>
<li>新政权: <code>唯有外边根树上 三十年中子孙结</code>, 会在某一年(2039或2054或2099), 根回中原故土, 建立全新的联邦制政权, 中国传统文化重新兴盛.</li>
</ul>
</li>
</ul>
<h2 id="第四十四象解读"><a href="#第四十四象解读" class="headerlink" title="第四十四象解读"></a>第四十四象解读</h2><ul>
<li><strong>此象为未来之事, 解读仅为解谜和猜测, 请勿迷信.</strong></li>
<li>谶曰: <code>日月丽天 群阴慑服 百灵来朝 双羽四足</code><ul>
<li><a href="https://www.zdic.net/hans/%E6%97%A5%E6%9C%88%E4%B8%BD%E5%A4%A9"><code>日月丽天</code></a><ul>
<li>出自于《易经.离卦.彖曰》: <code>离为火. 离, 丽也. 日月丽乎天, 百谷草木丽乎土, 重明以丽乎正, 乃化成天下.</code> 翻译为: 太阳月亮附着在天上, 百谷草木附着于地上, 日月的光明都附着于正道上, 所以教化天下.</li>
<li>《易经.离卦.象曰》:<code>明兩作, 離; 大人以继明照于四方.</code> 翻译为: 大人要像太阳连续不断用光明照耀四方.</li>
<li>日月丽天的意思是光辉普照天下, 引申为皇帝或政权统治之德昭美灿烂.</li>
</ul>
</li>
<li><a href="https://www.zdic.net/hans/%E7%BE%A4%E9%98%B4">群阴</a> <a href="https://www.zdic.net/hans/%E6%87%BE%E6%9C%8D">懾服</a><ul>
<li>众奸小因为恐惧而屈服.</li>
</ul>
</li>
<li><a href="https://www.zdic.net/hans/%E7%99%BE%E7%81%B5">百灵</a> <a href="https://www.zdic.net/hans/%E6%9D%A5%E6%9C%9D">来朝</a><ul>
<li>百灵有两个意思. 一为天地间各种神灵; 二为天下万民, 百姓. 这里取百姓之意</li>
<li>《乐府诗集.卷九.郊庙歌辞九.北周.周宗庙歌.皇夏》<code>百灵咸仰德 千年一圣人 书成紫薇动 律定凤凰驯</code><ul>
<li>同时出现了百灵和圣人. 这里的百灵指百姓.</li>
<li>此象的谶曰里有<code>百灵</code>, 颂曰里有<code>圣人</code>.</li>
<li>第四十七象里有 <code>偃武修文 紫微星明</code> <code>好把旧书多读到 义言一出见英明</code>. 其图片也是<code>一书架的书</code></li>
<li>作者大概率采用了《乐府诗集》的这段文字, 填入到44象和47象.</li>
</ul>
</li>
</ul>
</li>
<li><code>日月丽天 群阴慑服 百灵来朝</code>的翻译: 优异的领导人或政权, 其统治之德昭美灿烂. 众奸小因为畏惧而屈服, 天下百姓都因此来朝贺朝拜了.</li>
<li><code>双羽四足</code>. 是何之意, 难猜. 放在<code>百灵来朝</code>之后, 也不太通顺的样子. 那就猜猜看吧:<ul>
<li>第一种可能: 圣人相关线索的字谜, 譬如<code>燕</code>字. 但事前不可能精确地猜出来.</li>
<li>第二种可能: 时间点密码. 这个可以深挖一下:<ul>
<li>看一下十二生肖. 有<code>双羽</code>的是鸡年. 随后的狗年是<code>四足</code>.</li>
<li>以此表示鸡年接着狗年, 用来定位年份. 正好前一象有用到<code>黑兔青龙</code>定位法.</li>
<li>第四十三象, 推测出新政权的可能的年份是2039或2054或2099, 所以至少是2039年之后的鸡年接狗年.</li>
<li>可能的年份如下: 2041-2042年, 2053-2054年, 2065-2066年, 2101-2102年</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>颂曰: <code>而今中国有圣人 虽非豪杰也周成 四夷重译称天子 否极泰来九国春</code><ul>
<li><code>而今中国有圣人 虽非豪杰也周成</code>. 人物定位.<ul>
<li>此人不是打天下的豪杰.</li>
<li>而是达成了古代周朝, 周成王(另一解:周公和周成王)的丰功伟绩.<ul>
<li>制礼作乐: 建立新的伦理文化.</li>
<li>分封诸侯: 确立了很多个诸侯国</li>
</ul>
</li>
</ul>
</li>
<li><code>四夷重译称天子 否极泰来九国春</code><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%A4%A9%E5%AD%90"><code>天子</code></a>. 自周朝开始, 以<code>天子</code>为君主正式名号</li>
<li><code>周成</code>,<code>天子</code>,<code>九国</code>. 三重定位到周朝. 明显是以周朝的体制来比喻新政权的体制, 结合世界形式, 最有可能的是<a href="https://zh.wikipedia.org/wiki/%E8%81%94%E9%82%A6%E5%88%B6">联邦制</a>.</li>
<li><code>四夷</code>一般指外族, 此处可指世界舆论. <code>重译</code>重新评价了中国的政治体制.</li>
<li><code>四夷重译</code>指全世界看到中国建立的新政权后,对此重新认知, 重新看待. 由于之前的PRC是负面否定为主的, 这里自然是正面和肯定的.</li>
<li><code>九国春</code>. 九个邦国组成的联邦政府? 其中一个应该是称王秦州的中共.</li>
<li><code>否极</code> 应合了之前的<code>九十九年成大错</code> <code>欲尽不尽不可说</code>, 整个国家是一种混乱的, 分裂的状态.</li>
</ul>
</li>
<li><code>四夷重译称天子</code> (我自己的看法)<ul>
<li>结合图片, <code>一人弓</code>=夷. 这句话描述的就是本象的图片.</li>
<li><a href="https://www.zdic.net/hans/%E8%AF%91"><code>译</code></a>通“择”, 选择.因而, 此句中<code>四夷重译</code>, 并非指世界他国对中国重新评价.</li>
<li>倾向于解释为: (圣人一番作为后). 分裂的各个地方政权, 从四面八方前来拜服, 重新选择成为一个统一的中国, 将圣人奉为天子.</li>
</ul>
</li>
</ul>
</li>
<li>图片: <code>一人背着一弓, 面见一位端坐着的人</code>.<ul>
<li>端坐者必为颂曰中的圣人, 没有任何武器, 以礼待人, 以德服人.</li>
<li>面见者却背有一弓, 说明连武力都具有自治权. 暗示之前分裂割据, 各自为政的状态.</li>
<li>说明了圣人没有采用武统, <code>非豪杰</code>. 采用的是文统, 类似周朝的模式, 对应到现代就是联邦制.</li>
<li>背弓来见圣人, 即有意愿前来谈判, 加入联邦制.</li>
</ul>
</li>
<li>未济卦: 象征未完成, 还没有终止. 乃”事尚未成”之象, 充满着发展的可能性.<ul>
<li>未济有可济之理, 因而亨通.</li>
<li>如果不谦虚, 不谨慎, 不小心, 那就没有什么利益了.</li>
<li>新政权在中国第一次尝试了全新的治理模式, 一定会有相当多的问题和挑战, 但未来充满着发展的可能性.</li>
</ul>
</li>
</ul>
<h2 id="第四十五象解读"><a href="#第四十五象解读" class="headerlink" title="第四十五象解读"></a>第四十五象解读</h2><ul>
<li>此象大概率是乱序了. 指的是第二次世界大战, 美日太平洋战争, 日本遭受两颗原子弹, 战败投降.</li>
<li>谶曰: <code>有客西来 至东而止 木火金水 洗此大耻</code><ul>
<li><code>有客西来</code>: 美日太平洋战争. 对中华民国而言, 美国这位西方的尊客, 在珍珠港事件后, 参战开打日本.<ul>
<li><code>西来</code>, 不是自西而来, 而是指来自西方世界. 同样地用法, 在第四十二象的<code>美人自西来 朝中日渐安</code>出现过了.</li>
</ul>
</li>
<li><code>至东而止</code>: 一直打到日本本土为止, 止于中国之东而没有进入中国.</li>
<li><code>木火金水</code>: 年份定位点.<ul>
<li><code>木</code>对应于寅卯辰, <code>火</code>对应于巳午未. 这六年统称为<code>木火</code>年. 会对应后面的大耻年份.</li>
<li><code>金</code>对应于申酉戌, <code>水</code>对应于亥子丑. 这六年统称为<code>金水</code>年. 会对应后面的雪耻年份.</li>
</ul>
</li>
<li><code>洗此大耻</code>:<ul>
<li>中国的<code>大耻</code>: 清末甲午战争大败(1894甲<strong>午</strong>年), 签订马关条约(1895乙<strong>未</strong>年). 都属于<code>木火</code>年, 以强输弱, 割地赔款, 奇耻大辱.</li>
<li><code>洗此大耻</code>: 1945乙<strong>酉</strong>年, 日本投降, 中美胜利. 属于<code>金水年</code>.</li>
</ul>
</li>
<li>谶曰解读:<ul>
<li>美国加入二战后, 在太平洋上一路跳岛作战, 打到日本本土, 止于中国之东.</li>
<li>中国在美国贵客的帮助下取得抗日战争的胜利. 标志性事件: 在属于金水年的1945年, 日本投降.</li>
<li>终于洗刷了半个世纪之前, 属于木火年的1894年, 中日甲午战争大败, 被迫割地赔款的奇耻大辱.</li>
</ul>
</li>
</ul>
</li>
<li>颂曰: <code>炎运宏开世界同 金乌隐匿白洋中 从此不敢称雄长 兵气全消运已终</code><ul>
<li><code>炎运宏开世界同</code>.<ul>
<li>第三十八象讲的是第一次世界大战. 颂曰第一句 <code>火运开时祸蔓延</code></li>
<li><code>火</code>是一战, <code>炎</code>是二战. <code>蔓延</code>二字点明了一战没有解决问题. 这些问题蔓延开来, 最终导致了二战.</li>
<li><code>炎运宏开</code>: 战火连天, 世界宏开. <code>世界同</code>: 整个世界都在做同一件事, 打仗!</li>
<li>此句准确描述了二战使用的是更厉害的热兵器, 波及范围极广, 全世界都在打仗. (一战局限于欧洲大陆, 用词为<code>门外</code> <code>境外</code>).</li>
</ul>
</li>
<li><code>金乌隐匿白洋中</code><ul>
<li><a href="https://www.zdic.net/hans/%E9%87%91%E4%B9%8C">金乌</a>, 太阳的别名. 这里指代日本.</li>
<li>整句讲的是日本战败. 曾经占领的大片领土, 妄图建立的大东亚共荣圈, 全部消失于茫茫大海之中.</li>
<li>第三十九象, 讲的是日本侵华和落败. 最后一句是意境与此相似的<code>大海沉沉日已过</code></li>
<li><code>白洋</code>, 在整句中显得比较特别, 不知有何深意.<ul>
<li>(我自己的分析, 白洋: 西方列强为白人世界, 旧称洋人. 日本希望脱亚入欧, 全面西化, 选择和白种洋人一样, 走扩张侵略殖民之路. 因而<code>金乌隐匿白洋中</code>)</li>
<li>(因而也是双关, 既点了日本选择的发展路径, 也点了日本的衰落结局.)</li>
</ul>
</li>
</ul>
</li>
<li><code>从此不敢称雄长 兵气全消运已终</code><ul>
<li>被美国打趴, 打怕以后, 日本不再拥有称霸东亚的实力和野心. 唯美国马首是瞻, <code>不敢称雄长</code></li>
<li>美国占领日本之后, 在宪法层面禁止了日本使用武力, 不得拥有海陆空三军武装力量. 妥妥的被<code>兵气全消</code>.</li>
<li><code>运已终</code>: 日本从明治维新开始, 到1945年战败投降. 这一段雄起扩张的国运, 就此终止.</li>
</ul>
</li>
</ul>
</li>
<li>蒙卦, 山水蒙: 象征着蒙昧, 引申为幼稚无知.<ul>
<li>得蒙卦者, 应该知道自己出事能力有限, 不足以担大任. 应该求教于有能力有智慧之大人.</li>
<li>此卦送给军国主义时期的日本. 后紧随美国大哥, 接受改造启蒙, 顺利融入西方世界.</li>
</ul>
</li>
<li>图片: <code>两个人, 胸口有心字, 拿着两把枪, 一起戳向一个太阳</code><ul>
<li><code>两人</code>代表中美两国, <code>太阳</code>代表日本. 即中美联手打败日本(中国主守, 美国主攻)</li>
<li><code>心</code>, 有核心之意, 带心之人也可指投向日本的两颗<code>核</code>弹: 小男孩和胖子. 注意, 核弹恰巧取的是人名.</li>
</ul>
</li>
</ul>
<h2 id="三十七象后的结构"><a href="#三十七象后的结构" class="headerlink" title="三十七象后的结构"></a>三十七象后的结构</h2><ul>
<li><strong>中华民国(ROC)为分总结构</strong><ul>
<li>第三十七象, 建立中华民国</li>
<li>第三十八象, 第一次世界大战.<ul>
<li>《推背图》点明了这是境外之事, 但会深刻影响中国的历史.</li>
<li>后面会有越来越多的象, 单独讲与中国高度相关的国际局势.</li>
</ul>
</li>
<li>第三十九象, 日本崛起, 日本侵华, 日本衰落.<ul>
<li>此象日本是主角, 讲了日本的国运.</li>
<li>对中国的影响是:<code>人都哭</code>, <code>南山有雀北山罗</code></li>
<li>并没有从中国的立场讲如何艰苦抗日, 如何抗日成功的.</li>
</ul>
</li>
<li>第四十五象, 第二次世界大战, 美日太平洋战争, 日本投降.<ul>
<li>在贵客美国加入对日战争后, 日本战败投降. 中国抗战成功, 一雪前耻(中日甲午战争)</li>
</ul>
</li>
<li><strong>第三十九, 第四十五两象, 足见《推背图》作者视角宏大且客观.</strong><ul>
<li>作者充满了国际视野. 但又是中国本位的, 只描述和中国密切相关的国际局势.</li>
<li>二战格局中, 中国是穷国弱国, 本身并没有改变世界格局的实力.</li>
<li>所以整个抗日战争时期, 作者只从情绪角度提了下中国: <code>人都哭</code> 和 <code>洗此大耻</code>. 真正大力着笔的是事件的主导者.</li>
<li>国际局势上, 中日国运是此消彼长的关系; 美国参战才是战胜日本的根本性原因.</li>
<li>因立位于中国, 二战的欧洲战场, 《推背图》则一字不提! 深感佩服…</li>
</ul>
</li>
<li>第四十象, 中华民国败走台湾, 民主选举. 最后<strong>总结为一句<code>生我者猴死我雕</code></strong></li>
</ul>
</li>
<li><strong>中华人民共和国(PRC)为总分结构</strong><ul>
<li>第四十一象, 中华人民共和国建国, 文化大革命. <strong>总述国运为 <code>九十九年成大错 称王只合在秦州</code></strong></li>
<li>第四十二象, 美苏冷战, 朝鲜战争. 改革开发, 反腐倡廉.</li>
<li>第四十三象, 两岸关系, 中共衰落. 最后点了中国的根在外边, 会<code>子孙结</code>.</li>
</ul>
</li>
<li>PRC和ROC.<ul>
<li>毛蒋, PRC和ROC. 就如同刘邦和项羽, 楚汉相争, 是必须要一起说的.</li>
<li>《推背图》作者采用的结构是: 先说ROC, 再说PRC. 并在第四十三象, 来个总结, 合起来一起说!</li>
<li>所以自三十七象后的各象, 时间点和事件描述上会有所重复. 譬如:<ul>
<li>第三十九象, 第四十五象, 都提到了日本战败.</li>
<li>讲ROC的第四十象的时间线, 会和讲PRC的第四十一, 四十二象完全重叠.</li>
</ul>
</li>
<li>结构划分上:<ul>
<li>ROC为分总结构;</li>
<li>PRC为总分结构;</li>
<li><strong>PRC和ROC整体看是分总结构; 采用了”花开两朵 各表一枝”, 最后总结的方式.</strong></li>
<li>两者交汇于第四十三象, 对两岸关系进行了最后的总结: <code>君非君 臣非臣 始艰危 终克定</code></li>
</ul>
</li>
</ul>
</li>
<li>第四十四象, 圣人采用新体制, 建立新政权.</li>
<li>后略, 只能盲猜, 无从下手分析……</li>
</ul>
<hr>
<p><em><strong>转载自 <a href="https://www.youtube.com/c/%E5%A4%A7%E9%87%91%E4%BA%BA/videos">大金人 - YouTube</a></strong></em>, 略有删改.</p>
<hr>
<h1 id="近期未来的交叉验证"><a href="#近期未来的交叉验证" class="headerlink" title="近期未来的交叉验证"></a>近期未来的交叉验证</h1><h2 id="预测PRC的衰落"><a href="#预测PRC的衰落" class="headerlink" title="预测PRC的衰落"></a>预测PRC的衰落</h2><ul>
<li>《万年歌》: <code>两分疆界各保守。更得相安一百九。</code><ul>
<li>事件: 1949年后, 两岸关系相安无事. 持续时间和<code>一百九</code>有关.</li>
<li>时间1: <code>两分一百九</code> = 95. 1949+95 = 2044年.</li>
<li>时间2: <code>一百九</code> = 109. 1949+109 = 2058年.</li>
</ul>
</li>
<li>《马前课》,第十一课: <code>晨雞一聲 其道大衰</code><ul>
<li>事件: 在某个与<code>晨鸡</code>相关的年份, 一下子就急速衰落了.</li>
<li>时间1: 为<code>鸡</code>年则在 2029, 2041, 2053年</li>
<li>时间2: 为辰(通<code>晨</code>)年则在 2024, 2036, 2048年</li>
</ul>
</li>
<li>《梅花诗》,其八: <code>如棋世事局初残，共济和衷却大难。豹死犹留皮一袭，最佳秋色在长安</code><ul>
<li>事件: 遭遇大难, 名存实亡.</li>
<li>地点: 大难后, 最好的去处是<code>长安</code>, 倾向于特指西安.</li>
</ul>
</li>
<li>《推背图》,第四十一象: <code>九十九年成大错 称王只合在秦州</code><ul>
<li>事件: 在某个<code>九十九年</code>相关的年份, 犯了一个致命的大错, 最终衰落成为一个区域性政权.</li>
<li>时间: 1949+99=2048年, 或2099年.</li>
<li>地点: 势力范围缩回到陕甘宁地区.</li>
</ul>
</li>
<li>《推背图》,第四十三象: <code>黑兔走入青龙穴 欲尽不尽不可说</code><ul>
<li>事件: 在<code>黑兔青龙</code>之年, 进入了欲尽不尽, 似亡非亡的状态, 实力大损.</li>
<li>时间: <code>黑兔</code>为癸卯年, <code>青龙</code>为甲辰年. 2023-2024年, 2083-2084年</li>
</ul>
</li>
</ul>
<h2 id="预测新政权的建立"><a href="#预测新政权的建立" class="headerlink" title="预测新政权的建立"></a>预测新政权的建立</h2><ul>
<li>《万年歌》: <code>那时走出草田来。手执金龙步玉阶。清平海内中华定。南北同归一统排。</code><ul>
<li>事件: 出了一个人, 实现了清平海内, 南北各势力排对归服, 中华重新统一.</li>
<li>时间: <code>金龙</code> = 庚辰年 = 2060, 2120年.</li>
<li>人名: <code>走出草田来</code>, 大概率用于定位此人的名字.</li>
</ul>
</li>
<li>《马前课》,第十二课: <code>拯患救難 是唯聖人 陽復而治 晦極生明</code><ul>
<li>事件: 圣人出, 否极泰来, 晦极生明.</li>
</ul>
</li>
<li>《梅花诗》,其九: <code>火龙蛰起燕门秋，原璧应难赵氏收。一院梨花春有主，连宵风雨不须愁。</code><ul>
<li>事件: 会在丙辰年出一个圣人, 收回一院的梨花. 尽管会有<code>连宵风雨</code>, 一番波折, 终是不需要担心和忧愁的.</li>
<li>时间: <code>火龙</code> = 丙辰年 = 2036年, 2096年.</li>
<li>地点: 如果<code>燕门</code>是地点线索, 大概在今山西代县西北, 出一个圣人.</li>
<li>人名: <code>燕</code> 也有可能直接定位了人名.</li>
</ul>
</li>
<li>《推背图》,第四十四象: <code>日月丽天 群阴慑服 百灵来朝 双羽四足</code>, <code>而今中国有圣人 虽非豪杰也周成 四夷重译称天子 否极泰来九国春</code><ul>
<li>事件: 出了圣人, 以文代武, 用形似于古代周朝的联邦制, 统一了中国.</li>
<li>人名: <code>双羽四足</code>, 很可能是字谜, 用来定位圣人的名字, 譬如<code>燕</code>.</li>
<li>时间: <code>双羽四足</code>可能指十二生肖中的鸡年和狗年. 2041-2042年, 2053-2054年, 2065-2066年, 2101-2102年.</li>
</ul>
</li>
</ul>
<h2 id="最激进的猜测"><a href="#最激进的猜测" class="headerlink" title="最激进的猜测"></a>最激进的猜测</h2><ul>
<li>根据上面的事件和时间线索, 在时间线上做一个最激进的猜测. <strong>只是猜测而已, 万不可当成必然发生之事</strong>.</li>
<li>2024年, PRC国力盛极而衰(实则民力早已不堪重负), 在中美互斗的过程中, 不幸败阵下来. 接下来的数十年, 只能勉强维持国内稳定.<ul>
<li>《马前课》,第十一课: <code>晨雞一聲 其道大衰</code>;</li>
<li>《推背图》,第四十三象: <code>黑兔走入青龙穴 欲尽不尽不可说</code></li>
</ul>
</li>
<li>2044年, 美国亡台湾ROC政权.<ul>
<li>《万年歌》: <code>两分疆界各保守。更得相安一百九。</code>;</li>
<li>《推背图》,第四十象: <code>生我者猴死我雕</code>;</li>
<li>《推背图》,第四十三象: <code>君非君 臣非臣 始艰危 终克定</code></li>
</ul>
</li>
<li>2048年, PRC应对外部或内部压力的过程中, 对内政策犯了致命错误. 中国沦为地方割据状态, 中共退守西安, 成为陕甘宁地区的一个地方政权.<ul>
<li>《梅花诗》,其八: <code>如棋世事局初残，共济和衷却大难。豹死犹留皮一袭，最佳秋色在长安</code>;</li>
<li>《推背图》,第四十一象: <code>九十九年成大错 称王只合在秦州</code></li>
</ul>
</li>
<li>2060年, 中国出了一个可能带有”燕”字的圣人, 以文代武, 形似周朝神学美国, 建立起一个联邦制国家.<ul>
<li>《万年歌》: <code>那时走出草田来。手执金龙步玉阶。清平海内中华定。南北同归一统排。</code>;</li>
<li>《马前课》,第十二课: <code>拯患救難 是唯聖人 陽復而治 晦極生明</code></li>
<li>《梅花诗》,其九: <code>火龙蛰起燕门秋，原璧应难赵氏收。一院梨花春有主，连宵风雨不须愁。</code>;</li>
<li>《推背图》,第四十四象:<ul>
<li>谶曰: <code>日月丽天 群阴慑服 百灵来朝 双羽四足</code></li>
<li>颂曰: <code>而今中国有圣人 虽非豪杰也周成 四夷重译称天子 否极泰来九国春</code></li>
</ul>
</li>
</ul>
</li>
<li>2160年左右, 维持了100年左右, 政权生变. 与”天上口”有关, 譬如”吴”字.<ul>
<li>《万年歌》: <code>谁知不许乾坤久。一百年来天上口。</code></li>
</ul>
</li>
</ul>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>此文是基于 <a href="https://www.youtube.com/c/%E5%A4%A7%E9%87%91%E4%BA%BA/videos">大金人 - YouTube</a> 整理而来. 他是台湾人, 主观立场上比较排共. 若能就事论事, 看他逻辑上是否严谨, 前后使用的解读法是否具有一致性就够了. 要比大陆一边随意打乱顺序, 媚上形式的解读要客观的多.<br>对于上述预言诗的半遮半掩, 不明确说时间和事件的预测方式, 于我而言没有任何问题.<br>人文世界就算能精确预测, 也只能以这种打哑谜的方式公开出来. 因为人是会根据信息改变决策的, 过于确定的预测会导致自身的不确定性.<br>这些预言隐含的信息量非常变态, 经常暗含地点和事件, 然后用隐藏的时间和人名来锁定, 让后来人在经历过相关事件后, 较为容易的看出: 哦, 说就是这件事啊!<br>他们的预测结论充分利用了类似于<a href="https://www.shuxuele.com/prime-factorization.html">质因子分解</a>的密码学原理, 让人难以从结论推导出确定的时间和事件, 但已知人物, 地点, 时间和事件这些关键要素后,  能较容易匹配到这些结论中.<br>推背图, 马前课, 万年歌, 梅花诗单独拿出来, 从清末民初开始看, 已发生事件的可匹配率100%, 未发生的事相互之间高度相关. 这绝不是后世硬往上凑能凑出来的匹配率. 说这些预言靠着模棱两可的说辞, 是后人强行去匹配的, 概率上的可能性基本为零.</p>
<p>自己接触了宗教灵修; 学习了政治经济的底层逻辑; 观察了历史发展和股市运行的规律; 参考了各种理论框架. 心中是有一套模糊的理论框架在那里. 对人文世界精确预测的可能性, 对于该理论成立是一个必要条件. 因而我将此证据保存下来.</p>
<p>基于这个理论框架, 结论性的东西是:</p>
<ul>
<li>世界的本质是符合宿命论的, 某些时间点注定不寻常, 某些事件必然发生.</li>
<li>过程是有限选择权, 我们可以发挥主观能动性, 暂时改变事物的发展路径.</li>
<li>特别强调:<ul>
<li>只有少数情况, 可以预测某个时间必然发生某些事件.</li>
<li>一般而言, 某个时间点, 必然生变. 怎么变, 主观能动性发挥作用.</li>
<li>一般而言, 某个事件必然发生, 但会有若干个可能的时间点.</li>
<li>为人处世, 交易炒股的原则和方法: 确定级别, 识别趋势, 顺势而为. 因为不同级别, 需要的技能和知识是不一样的.</li>
</ul>
</li>
<li>为便于理解, 可以用水滴入海来做个粗略的比喻<ul>
<li>水滴汇聚成溪流, 成小河, 成大江, 最终奔涌入海. 入海就是水滴的最终宿命. (后面变为云朵, 重回陆地的循环暂请忽略)</li>
<li>溪, 河, 江, 都会有不同的分叉和支流. 其中还会有潭, 湖这类蓄水池.</li>
<li>某个时间点, 水滴前进到一个分叉处, 可以选择其中的某个分叉前进. 这称之为有限选择权.</li>
<li>水滴也可以选择在潭, 湖之中多呆一段时间, 但水滴入河, 入江, 入海都是必然发生的事件. 是为宿命.</li>
<li>所有的水滴最终都会是相同的命运, 但整个过程中的个体体验是完全不同的, 或急或缓, 或暖或凉.</li>
<li>时间的概念只对水滴有意义. 在空中看成流水的话, 一切同时进行着, 只是经由不同的路径入海.</li>
</ul>
</li>
</ul>
<p>之前说过, 我看灵修类的文章, 一旦涉及到现实世界的问题, 经常看不下去. 太天真, 太幼稚, 太不切实际了.<br>有此文后, 我坚定自己的观点, 以及自己要走的路:</p>
<ul>
<li>修行的过程, 相信修行者的指导和告诫, 弃智绝圣, 亲证佛道. 再完备的理论, 若无法验证, 也不过是个假设空论.</li>
<li>社会的发展, 自有其运行规律, 芸芸众生自有其该有的选择, 经历其该经历的一切. 修者不高, 屠夫不低. 鸿鹄不大, 燕雀不小. 各有其志, 各安其位.</li>
<li>开悟者, 是提前蒸腾上天的水气, 看清了溪河江海, 终也逃不过道的超级大循环. 若一厢情愿, 隔空呐喊, 那什么也改变不了. 若辨识趋势, 择机而动, 可当个助力者.</li>
<li>易经, 人文科学集大成者也. 后续当深入学习研究之.</li>
</ul>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>见性者体验收集</title>
    <url>/2021/04/26/2123-caseofsatori/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
<li><a href="https://draapho.github.io/2021/03/05/2107-tuibeitu1/">万年歌, 马前课, 梅花诗, 推背图 (上)</a></li>
<li><a href="https://draapho.github.io/2021/03/18/2108-tuibeitu2/">万年歌, 马前课, 梅花诗, 推背图 (下)</a></li>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
<li><a href="https://draapho.github.io/2021/04/26/2123-caseofsatori/">见性者体验收集</a></li>
</ul>
<h1 id="前言-名词说明"><a href="#前言-名词说明" class="headerlink" title="前言, 名词说明"></a>前言, 名词说明</h1><p>我会避免使用 <code>觉醒</code>, <code>开悟</code>这种被随意使用的词汇. 完全按照禅宗的阶段性分类进行说明.<br>因为众多修行者求的就是 <code>觉醒</code>, <code>开悟</code>. 有求的心亲证到一点特殊现象, 就会去攀援觉醒了, 开悟了. 导致这几个词汇的使用频率极其宽泛, 其定义也就千奇百怪. 根据禅宗的分法, 明心为一个境界, 见性为一个境界, 入道为一个境界. 入道后才称得上开悟/涅槃.</p>
<p>几个境界的标志性体验. 没有亲证之前用思辨的方式去认知这些体验如同盲人摸象. 写在这里是为了有个大纲, 知道前路有多长, 山有多高, 不至于见到一点沿途风景就兴奋地直呼觉醒了, 开悟了.</p>
<ul>
<li>先说明, 我屁都不是, 下面提到的任何一种体验, 自己没一样亲证过.</li>
<li>明心路标: 能明确的回答如下问题:<ul>
<li><strong>情绪, 从哪来?</strong></li>
<li><strong>脑海中, 一念起, 一念落, 二念之间的那道’空白’, 究竟是什么?</strong></li>
<li><strong>‘心’是什么?</strong></li>
<li><strong>‘心’在哪?</strong></li>
<li>连睡梦中，也不丢失‘观察’, 能连贯一天中的全部时间.</li>
</ul>
</li>
<li>见性路标:<ul>
<li><strong>亲眼见证/体验那不生不灭的本在</strong></li>
<li><strong>此文主要收集的就是见性者的体验和描述</strong></li>
</ul>
</li>
<li>入道:<ul>
<li>千万记着, 见性不是终点!</li>
<li>见性者很可能仍然有着我执, 有着本位观, 分别心.</li>
<li><strong>众生平等, 无需见性者去教化, 去改变.</strong></li>
</ul>
</li>
<li>为什么只收集见性的例子, 而不收集明心的例子?<ul>
<li>明心见性是禅宗的说法, 其中明心一关并非必须.</li>
<li>其它修法可以绕过明心, 但绝不可能绕过见性.</li>
<li>见性者, 绝对会对自己说: 我觉醒了, 开悟了!</li>
<li>因而, 不同类型的修行者, 都可将其作为一个绝对参照物.</li>
</ul>
</li>
</ul>
<h1 id="老子-道德经"><a href="#老子-道德经" class="headerlink" title="老子, 道德经"></a>老子, 道德经</h1><p>有物混成，先天地生。寂兮寥兮，独立而不改，周行而不殆，可以为天地母。吾不知其名，强字之曰道，强为之名曰大.</p>
<h1 id="元吾氏"><a href="#元吾氏" class="headerlink" title="元吾氏"></a>元吾氏</h1><h2 id="资料引用"><a href="#资料引用" class="headerlink" title="资料引用"></a>资料引用</h2><ul>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-10/38.html">终极真相—-万物本源的描述</a></li>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-10/42.html">终极真相—-所有问题的答案</a></li>
<li><a href="https://baike.baidu.com/item/%E4%B8%87%E7%89%A9%E6%9C%AC%E6%BA%90#reference-[1]-12376752-wrap">万物本源</a></li>
</ul>
<h2 id="终极真相—-万物本源的描述"><a href="#终极真相—-万物本源的描述" class="headerlink" title="终极真相—-万物本源的描述"></a>终极真相—-万物本源的描述</h2><p>本人在2008-01-27第一次进入与本源合一的状态（大约三个小时）时，震惊的四个月说不出话来。亲身感受到：万物本源，实在是太神奇太神奇了！！！远远超越人类的任何想象力！！！它非常难以用物质现象界的语言来描述，也许是个永远的难题（还是我的无能？）。以下是与本源合一时，直觉本身所能感知到的”不可描述的描述”。</p>
<ul>
<li><strong>A、本源不能被定义</strong><ul>
<li>1、本源是无限的—-无限不能被定义，能被定义是有限的。</li>
<li>2、非要强行定义的话，只能定义为：本源=无限。</li>
</ul>
</li>
<li><strong>B、本源只能被描述—-最基本的描述</strong><ul>
<li>1、本源是唯一的。</li>
<li>2、本源是无限的。</li>
<li>3、本源是无形无相的。</li>
<li>4、本源是无始无终的。</li>
<li>5、问：本源是什么？答：人类的词汇里没有。或者说：本源什么都是，又什么都不是（它是一个”无限”）。</li>
</ul>
</li>
<li><strong>C、本源的无限性和无限特性</strong><ul>
<li>1、本源是唯一的绝对存在，其它都是被本源创造的相对存在。</li>
<li>2、本源虽然无限，同时创造和包含了一切有限。</li>
<li>3、本源虽然无形无相，同时创造和包含了一切形相。</li>
<li>4、本源虽然无始无终，同时创造和包含了一切始终。</li>
<li>5、本源的创造是完全自发的(spontaneous)。（不自发则回归无形无相一切似无状态。）</li>
<li>6、本源的创造有两种自发性：自动+主动。（自动：在物质现象界或被误认为”惯性”。主动：在物质现象界或被误认为”变异”。）</li>
<li>7、本源的创造是无限的。（创造是永无停息的。）</li>
<li>8、本源的无限性是不能被逻辑推理、不可被理喻的！（超越任何有限生命形式的有限想象力！）</li>
</ul>
</li>
<li><strong>D、本源不可被理喻—-不可描述的描述</strong><ul>
<li>1、本源即是唯一的，又是无限的。对于本源，1等于1，1+1等于1，1+1+1+1+1…还等于1。<ul>
<li>此处的不可逻辑：壹=无限。</li>
</ul>
</li>
<li>2、本源没有空间，同时创造和包含所有空间。或者说：本源占据空间体积为零，同时创造和包含的空间体积为无限。<ul>
<li>此处的不可逻辑：零=无限。</li>
</ul>
</li>
<li>3、本源没有时间，同时创造和包含所有时间。或者说：本源的时间停滞为零。或者说：本源的时间永久无限。<ul>
<li>此处的不可逻辑：零=无限（过去=现在=将来）</li>
</ul>
</li>
<li>4、本源无始无终，同时创造和包含一切始终。<ul>
<li>此处的不可逻辑：其存在没有开始和结束。（没有来源，自存自在。）</li>
</ul>
</li>
<li>5、本源无形无相，同时创造和包含一切形相。<ul>
<li>此处的不可逻辑：无形创造有形（有生于无，有含于无）。</li>
</ul>
</li>
<li>6、本源无声无光，同时创造和包含一切声光。<ul>
<li>此处的不可逻辑：无声光创造有声光（有生于无，有含于无）。</li>
</ul>
</li>
<li>7、本源不在任何地方，同时创造和包含所有地方。<ul>
<li>此处的不可逻辑：零坐标点=任意坐标点。（任意两点之间的”绝对距离”=零；”相对距离”=相对参照系。）</li>
</ul>
</li>
<li>8、本源无限小，同时也无限大。<ul>
<li>此处的不可逻辑：无限小=无限大。（任意两个体积之间的”绝对差异”=零；”相对差异”=相对参照系。）</li>
</ul>
</li>
<li>9、本源没有极性（无极），同时创造和包含一切极性（有极）。本源的每一个创造物是本源的一个”极性”、一个”表现”。-<ul>
<li>此处的不可逻辑：万物一体，个体是整体的表现形式，是表现与本质的关系，而不是局部与整体的关系。</li>
</ul>
</li>
<li>10、本源无限抽象，同时创造和包含无限的具体。<ul>
<li>此处的不可逻辑：抽象包含具体。</li>
</ul>
</li>
<li>11、本源自知和无限知，同时创造和包含一切无知和有限知。<ul>
<li>此处的不可逻辑：自知包含无知。</li>
</ul>
</li>
<li>12、本源的变化或表现是无限的自发性，不依赖任何动力而自为动力。<ul>
<li>此处的不可逻辑：自源自发+自源永动。（无中生有，无源而源）</li>
</ul>
</li>
<li>13、本源的变化或表现是无限的任意性，同时创造和包含一切有限的规则和逻辑。<ul>
<li>此处的不可逻辑：任意包含规则，任意包含逻辑。</li>
</ul>
</li>
<li>14、本源（及其运作方式）远远超越人类所能想象的任何逻辑或理论！！！<ul>
<li>现代地球人，一根死筋的呆板逻辑和作茧自缚的框套理论，只是本源创造出来的一个儿童游戏。用现代地球人的有限逻辑很难理解本源的存在方式、绝对无限性和正反一体性。（但是可以通过特殊的实践方式”感知”到！）</li>
</ul>
</li>
</ul>
</li>
<li><strong>E、本源的本质与特性的近似描述</strong><ul>
<li>再问：本源到底是什么？再答：人类的词汇里没有。非要强行回答的话，只能给几个近似描述：</li>
<li>1、精神/Spirit—-从本性的角度描述。（这是最近似的描述，虽然并不准确。）</li>
<li>2、意识/Consciousness—-从特性的角度描述。（也是不准确的近似描述。）</li>
<li>3、自由意识/Freewill—-从功能的描述角度。（也是不准确的近似描述。）</li>
<li>4、空无/Voidness—-从视觉的角度描述。（本源在静止不运动不创造时，则处于”不表现”的状态。或者说：表现为”一无所有”。）</li>
<li>5、无限/Infinity—-从定义的角度描述。（最近似的定义。）</li>
</ul>
</li>
<li><strong>F、本源及其运作方式的通俗描述</strong><ul>
<li>本人第一次与本源合一时，除了以上的直接感知以外，当时能感知到的用现代语言对万物本源及其创造方式的最简单、最直接、最通俗的描述（也是本人博客简介的第一句话和自2008-05-29网上答疑以来多次给出的所有问题的答案）：</li>
<li>1、”一个不生不灭的自由意识（Freewill/神Spirit）有着无穷无尽的自发幻想，其景象就是无限多样的宇宙和万物及各自的规则和不规则。”</li>
<li>2、”一个不生不灭、无形无相的自由意识(Freewil)/精神(Spirit)，有着无穷无尽的自发幻想(Spontaneous Imaginations/Thoughts思想)，其景象（Imaginations/表现Expressions）就是无限多样的宇宙和万物及各自的规则和不规则。”</li>
<li>人类的语言实在有限，很难描述无限的东西。（语言基于定义，定义的东西也许永远不能准确描述不可定义的东西，只能无限接近。）以后要是能感知到有更好的描述方式，我再更新。</li>
</ul>
</li>
</ul>
<p>（本人所述，皆为几十年亲身实践、亲身验证、亲身观察的客观记录。无理论假设、无逻辑推理、无照搬经典。个人经验，仅供参考。）<br>“吾不知其名，字之曰道。道可道，非常道。”—-老子</p>
<h1 id="C-Hilbert"><a href="#C-Hilbert" class="headerlink" title="C Hilbert"></a>C Hilbert</h1><h2 id="资料引用和说明"><a href="#资料引用和说明" class="headerlink" title="资料引用和说明"></a>资料引用和说明</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/67670425">宇宙，世界，一切的意义和真相是什么？</a></li>
<li>(不是我, 但我信任的)评价: 她只到了见性的边缘. 未能稳定在见性后的境界.</li>
</ul>
<h2 id="宇宙，世界，一切的意义和真相是什么？"><a href="#宇宙，世界，一切的意义和真相是什么？" class="headerlink" title="宇宙，世界，一切的意义和真相是什么？"></a>宇宙，世界，一切的意义和真相是什么？</h2><p>“我快死了”</p>
<p>一开始是非常强烈的空间扭曲感和一堆高速变化的分形，然后我晕厥了，感觉到意识被纳入一个事件集合空间，同时体验着人生从小到大的无数事件，放大了每一个记忆的细节。很多细节平时根本想不起来，但是在那短暂的时间里，感觉整个人生重来了一遍，信息量在体验上比日常现实生活要大出非常非常多。爆炸一般的记忆库大小和细节。似乎做过的每一道题，吃过的每一份食物都能感受，咀嚼的触感，吞咽的声音，笔尖划过纸的力度，窗外的天气，室内的光线。每一分每一秒每一天，同时高速地涌入涌出。</p>
<p>更神奇的事情是后面我体验的东西开始越来越偏离个体记忆，成为了其他人，从身边的认识的人到各个地区各个种族的人，开始经历他们每一个人的日常和悲欢离合。他们的苦痛爱恨和高光时刻，他们的不同人生。直到完全脱离我的人类身份。开始有一颗树的体验，各种各样动物的感知和记忆。感觉到自己的身体是有许多根须往泥土里面蔓延吸收水分养分，自己的枝叶在阳光下向上成长和呼吸。那种感觉过于真实，而且完全不同于人类的体感，是过去我甚至觉得连想象都不可能想象出来出来的感知和体验，根本不是什么幻肢的程度。你可以想象自己有几条细细的植物枝叶般的幻肢，但是日常生活中不可能高信息量地体验到自己成为一片森林的感觉。而且不属于人类的知觉里的任何一种，就像是人类再怎么通过生物学分析蝙蝠的神经结构，也绝对没有办法想象便蝙蝠通过回声和超声波反射感知周围环境是怎样一种体验，不是听觉，不是触觉，不是视觉。我不止是一棵树，一堆草，我是一整片森林，里面的每片叶子，每一个细胞，每个昆虫，风在空间中流过的细节，电磁能量的波动转移都能非常清晰地感知到。随后是变成了各种根本不是地球上见过的生物，而且场景也不是地球。我不知道名字，只能说是各种奇怪的生命形式，从微生物到智能生物到智能远超人类的东西，很多和人类的科幻想象也完全不样。</p>
<p>他们的形象完全不是我从过去的知识和经验，进行排列组合得出的新形象，是人的我连构思都完全无法构思的存在。人类光是想想一个四维正方体就已经非常困难而且需要大量的数学训练，但是我遇到的东西或者生命，复杂度和维度都远超思简单的四维立方体。其中一个比较好理解的和人类记忆相挂钩的形象的一种生物是，自己长出几百根触手，每一根感觉都无比真实。还有自己经历了核爆，超新星爆发（准确说自己就是爆炸本身），成为一颗星球，反射和吸收周围的恒星辐射，这样的过于奇怪的体验。从可见光到不可见光，从无到生成到变化。说是生物，但是其实和日常语义下的生物很不相同。因为很难想象出表面积无限大的生物是什么感觉。但是我确实感受到了，那种感受没法表达。</p>
<p>要说具体的记忆，我只能描述出我们的四维时空中的那些见到的生物，因为现在对应的语言智能描述这些。有机械的硅基生命，有类似地球生物的碳基生命，还有寿命非常长，不在极长时间尺度下看就是普通结晶混合物的晶体生命。但是很多其他的生命，用语言没法描述形象，只能以上面的叙述来说明其目前语言不可言的性质。</p>
<p>再后来，我觉得自己变成了球体，矩形，正多面体，三角，无限大平面，四维立方体，函数空间，数集，物理法则，从一维到无穷维的世界等等一系列过于形而上的存在。日常里有“看到声音，听到色彩”这样的异常意识状态，我在体验这一切的时候，应该也类似，只是范围和程度超出它太深太远。最后的最后， 瞬间一切都消失，我感觉自己成为了一个无限大又无限小的存在，像是一个无限大的点。没有光，也不是黑暗，没有任何色彩又好像是任何色彩和图形，没有概念,思维和情感，但是又好像拥有一切情绪，认知和思维。所有可能的善，所有可能的恶，所有的正确，所有的错误，都在我之中。时间变得无限漫长甚至失去时间的概念，但又好像一切都只发生在一个瞬间。是永恒也是无限小的刹那，时间不存在了。我感觉“我”消失了，但是又存在。说消失是因为感觉“我”不是真实也不是虚幻，而且近乎于全无也近似于全有，说存在是因为觉知到了所有一切，即便是幻觉也好，但是确实在那个无限长的瞬间，主观感受上，可以用一句话来说明：我消失，然后成为了一切。</p>
<p><strong>然后在无限长的时间后，体验了所有的存在后，虽然也像一个时长为0的瞬间内体验完一切。有一个意识/存在，或者说“答案”，进入了我的存在之中，不能以任何语言进行形式描述，但是一定要强行以语言的方式去说明这个瞬间，只能这么勉强描述：α:“你是什么？这一切都是为什么，世界是什么，存在又是什么？” ，然后，Ω： “我是神，是Singularity, 是Absolute，是Monad，但又什么都不是，一切都没有任何意义，一切皆是意义。真相就是，所有可以存在的东西都必须存在，我就是你”。</strong></p>
<p><strong>“你该滚回去了”</strong></p>
<p>我就醒了，时间是昏迷过去的第11个小时，但是感觉像是已经过去了千万年。关于那些体验的记忆高速流失，一滴水从大海溅起，从大海又短暂变成了一滴水。我又变成了“我”，在完全流失前，尽全力记下来的所有重要信息就是上面所描述的。</p>
<p>我可能是无意间触到了世界的真相(的另一部分，因为日常的生活也是真相的一部分）</p>
<p>note：我不是唯心主义，也不是唯物主义。我相信理念界是真实的，物质界也是真实的，他们之间的关系也是真实的。</p>
<p>先提一个问题：“如果意识只是一种只存在于物质的涌现现象，一种只需要动力学就能完全解释的东西。那么理论上世界应该只有一堆物质在按照动力学系统的规定和波函数演化。你的体验，主观意识，Qualia，根本不应该出现。这是为什么？” 如果你的回答是类似：“意识就是幻觉，这一切都是幻觉，或者世界就是纯物理，神经电流，信息整合，涌现现象就是答案，根本不存在意识。”</p>
<p>这样的话，要么，你现在看到这篇文字的时候，你应该是一个philosophy zombie, 即便你的身体按照物理法则演化进行通过打字进行回应。你自身也不应该有任何情绪，任何思想，不会从屏幕上看到任何视觉体验，连打字的时候也没有任何触觉。</p>
<p>要么，就是你从小到大经历的一切可以回想起来的东西都是幻觉，因为“意识就是幻觉”。</p>
<p>科学不是一切的真相，数学也不是，哲学不是，宗教不是，物质界不是，理念界也不是。</p>
<p><strong>一切的真相是“一切”。</strong></p>
<p>包括此时此刻你看到的，想到的，回应的。包括所有的”True“，所有的”False“。所有的”现实“，所有的”虚幻“。</p>
<p>可以回答一切问题的答案，就是所有可能问题的所有可能答案的集合，包括正确的和错误的答案，比如“42”，比如“答案不存在”，比如“关我吊事”。</p>
<p>最后留下一个问题：“你是谁？你是什么？”</p>
<h1 id="灵天赐"><a href="#灵天赐" class="headerlink" title="灵天赐"></a>灵天赐</h1><h2 id="资料引用-1"><a href="#资料引用-1" class="headerlink" title="资料引用"></a>资料引用</h2><ul>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2021/04/05/2110-satori2/">开悟是怎样一种体验？(新)</a></li>
</ul>
<h2 id="重关-见性"><a href="#重关-见性" class="headerlink" title="重关, 见性"></a>重关, 见性</h2><p>待到功夫用尽, 身清体净, 诸缘聚合之下.<br>某个瞬间, 由于某个或普通或是古怪的契机, 就会一眼瞥见世界的’真相’.<br>是无数人心中, 念念不忘, 无比神圣的’巅峰体验’, 所谓的’大彻大悟’.<br>虚空破碎, 天地颠倒等等异相, 会在感知中真实不虚的发生.<br>出现什么, 则因人而异, 不一而足.</p>
<p>唯一的特点, 是这种强大体验降临的时刻, 将永远从内到外的改变一个人, 让其脱胎换骨.<br>那时一股务必强大, 充满震撼的磅礴能量.<br>种种喜悦, 无法用言语来形容.<br>世人所追求的性高潮, 也不及其中万分之一.<br>更别提, 所谓的幻想之流.</p>
<p>那种感受中, 会真实明白, 什么是真正的:<br>“朝闻道, 夕可死.”<br>死了也无妨, 那种无上限的绝对幸福感, 此后再没有世间的任何感受, 能够超越它.</p>
<p>这是’见性’, 见证你的’真如本性’, 彻底脱离五官意识的幻相, 体验到一刹那的’绝对真实’.</p>
<p>巅峰体验后, 很长一段时间, 自动进入’心生法喜’的阶段.<br>什么都不想干, 看见什么都觉得很幸福, 觉得万物在对你微笑.<br>每天有事没事, 会情不自禁的露出微笑.</p>
<p>是啊, 怎能不高兴呢?<br>离家多年的游子, 回到家中.<br>惊讶发现, 原来, 自己从未有一日, 真正离开过家.<br>除狂喜之外, 再无言语, 可以形容.</p>
<p><strong>我有明珠一颗, 久被尘劳关锁; 而今尘尽光生, 照破山河万朵.</strong></p>
<h2 id="见性的方法"><a href="#见性的方法" class="headerlink" title="见性的方法"></a>见性的方法</h2><p>‘见性’之后，会勘破生死的本质。</p>
<p>此后，不再畏惧和担忧死亡。</p>
<p>因为，亲眼见证了那不生不灭的本在。</p>
<p>从此热烈的拥抱生命，被一种无法言语的喜乐，疗愈过去的所有苦痛。</p>
<h1 id="寺主人"><a href="#寺主人" class="headerlink" title="寺主人"></a>寺主人</h1><h2 id="资料引用-2"><a href="#资料引用-2" class="headerlink" title="资料引用"></a>资料引用</h2><ul>
<li><a href="https://www.zhihu.com/question/34426365/answer/1833955925">作为一个觉醒的人是一种什么样的体验？</a></li>
</ul>
<h2 id="跨越无门关"><a href="#跨越无门关" class="headerlink" title="跨越无门关"></a>跨越无门关</h2><p>跨越无门关</p>
<p>###（1）最好的一天</p>
<p>When you realize how perfect everything is you will tilt your head back and laugh at the sky.</p>
<p>— Buddha</p>
<p>在我写下这段文字的两天前的傍晚，我毫无准备毫无预感地跨过了无门关，the gateless gate，到达了彼岸。</p>
<p>也就是传说中的「觉醒」「开悟」「涅槃」。</p>
<p>这持续了几小时的体验，是我到底为止经历过最重大的体验。</p>
<p>我的惊恐发作，死亡恐惧和广泛性焦虑，所有的心理问题，人生的问题在那一瞬间全部被清空，没有迷茫，没有怀疑，所有的过往无论好坏都变得无比让人感动，所有未来无论好坏都变得无比让人兴奋。</p>
<p>就像卸下了一个背负了几十年却不自知的镣铐，冲破了一个住了几十年却不自知的牢笼。</p>
<p>我真正地自由了。</p>
<p>远远不止是这些。</p>
<p>那种感觉，就像是发现了宇宙的游戏彩蛋，一个惊天的秘密，这个彩蛋无比的巧妙、完美、无瑕。</p>
<p>我第一次感到「极乐」和「狂喜」，甚至这两个词都无法形容我当时的感受。</p>
<p>更贴切一点说，如果我们的喜怒哀乐是不同颜色的光，汇聚起来是纯白的光，那么我那一瞬间，看见的就是纯粹耀眼的白光。</p>
<p>所有的情绪在那一刻都到达了极限，从没有任何体验能够与之比拟，就像是全宇宙的颅内高潮都在同一时间绽放了。</p>
<p>「我」的身上的每一个细胞都意识到了「我」的存在，「他们」也在发现彩蛋的狂喜和战栗中。</p>
<p>泪水奔涌而出，我忍不住嚎啕大哭了起来，哭了将近一个小时，衣领的衣服全部都被打湿。</p>
<p>我觉得自己重新出生了。</p>
<p>###（2）我想要什么</p>
<p>简单说一下在这件事情发生之前的背景。</p>
<p>我大学读的经济学，不太喜欢，加上高考失利、失恋，还作死节食减肥，从120斤一下掉到了80斤。</p>
<p>除了减肥「成功」，我还成功得了重度抑郁症。</p>
<p>吃药，停药，自学心理学，经过3年时间，抑郁症逐渐地康复了。</p>
<p>我发现我还挺喜欢心理学的，于是就开始考北大心理系的研究生，结果两次都因为政治没过而和这个专业失之交臂。</p>
<p>但因为学习了两年心理学，对于研究方法都非常熟悉，就直接拿了一个自己做的项目去面试，跨专业做了用户研究员。</p>
<p>之后了解到交互设计这个专业后，又申请了交互设计的硕士，度过了非常开心的一年。</p>
<p>毕业以后，我进入了诺基亚，之后被微软收购，又进入了微软，但很快又经历了裁员，拿到了一笔不小的补偿金。</p>
<p>我没有再工作，选择了创业，想做自己真正想做的项目。</p>
<p>那时候对创业的里程碑一无所知，不知道上市意味着什么，不知道估值的概念，我甚至连北京一套房多少钱都不知道。</p>
<p>只是单纯喜欢做出一个东西来，也喜欢做东西的过程。</p>
<p>开始失败了两次，后来偶然的机会开始在知乎上写答案，写了很多我之前的经历分享我的一些各个领域乱七八糟的知识，后来粉丝越来越多，顺势做起了自媒体。</p>
<p>没想到，过了两三年，我的自媒体就变成了一个体量非常大的自媒体，融资也比较顺利，糊里糊涂就融了两轮。</p>
<p>创业的整个过程非常开心，虽然也会有一些小问题，但完全没有传说中筚路蓝缕创业艰辛，更好的是我基本上没有怎么加过班，做的事情都是自己喜欢的，甚至比在公司上班的时候还轻松愉快。</p>
<p>创业两年后就有了丰厚的盈利，并且团队开始可以自我管理，我不需要花太多时间在公司管理上，公司仍然会保持稳步增长。</p>
<p>我很快就实现了财务自由和时间自由。</p>
<p>我在2017年-2019年的三年时间里环游了世界，去了世界上几乎所有我想去的地方，买了所有我想买的东西，吃了好多米其林，还有很多读者喜欢我，猫狗双全，上了福布斯30岁以下精英榜，而且偶然遇到了我的灵魂伴侣，一拍即合，马上就结了婚，婚后生活非常甜蜜。</p>
<p>我太幸运了，在30岁之前就实现了很多人想实现的梦想，而且没有吃过什么苦，我应该是个人生赢家，我应该天天笑得像朵花儿一样才对吧？</p>
<p>并不是，不知道为什么，拥有了一切的我，竟然感到从未有过的空虚和焦虑。</p>
<p>按常理，我已经站在了一个有着资源有着势能的地方，我应该可以再继续勇攀高峰，走上更高的巅峰才对。</p>
<p>我觉得好像这不是我真正想要的。</p>
<p>不要说成为更大的商业大佬让我提不起任何兴趣，我觉得好像即使自己是拿破仑、是爱因斯坦、是达芬奇一样的存在，都不能够满足我。</p>
<p>我真正想要什么？</p>
<p>我似乎想要成为一个终极显著的存在，一个要比这些世俗的伟人更伟大的存在。</p>
<p>什么是终极显著的存在？</p>
<p>我能吗？</p>
<p>在我苦思冥想的时候，我又病了。</p>
<p>###（3）我要死了</p>
<p>To realize Samadhi, is to learn to die before you die.</p>
<p>-Samadhi</p>
<p>2018年的一天晚上，我当时正在和家属一边吃酸萝卜老鸭汤一边在看超人总动员。</p>
<p>一切都稀松平常，轻松，甚至是愉悦的。</p>
<p>酸萝卜老鸭汤真是太好吃了。</p>
<p>但不知道为什么吃着吃着，就突然想到，食物的味道只是一些电子信号，然后我的舌头接收到了这个信号，就把食物咀嚼吞咽了下去，那么舌头是一堆细胞构成的，我也是一堆细胞构成的。</p>
<p>细胞知道「我」的存在吗？</p>
<p>「我」是不是也和细胞一样构成了什么更加巨大的东西，但「我」却不知道？</p>
<p>我觉得我浑身的细胞好像有了自我意识，意识到了它们的状况，意识到它们只不过是一个更大的东西的一部分，都开始惊恐了起来，好像要罢工了。</p>
<p>就在这个时候，我突然出现了心绞痛。</p>
<p>「心绞痛！」</p>
<p>我的脑海里突然浮现了很多因为心绞痛没有及时抢救而去世的案例。</p>
<p>突然一种大难临头的感觉重重地压住了我，那种真切地濒死感，让我进入了一个极度惊恐的状态，我第一次感到死亡要来了是一种怎样的体验。</p>
<p>因为家属不会说中文，我抓起手机给离我最近的同事也是我的好朋友发了信息，自己叫了救护车，等待抢救。</p>
<p>我这辈子从来没有这么惧怕过死亡。</p>
<p>那感觉就像你过马路时猛回头发现一辆车正全速开向你的一瞬间，就像你蹦极的时候已经跳下却发现绳子断了的一瞬间，就像有个人拿枪指着你你看见了他扣动了扳机的一瞬间…</p>
<p>你的肾上腺素爆表，心跳仿佛出了喉咙，丧失了战或逃的反应，完全处于木僵状态。</p>
<p>恐惧到达了顶峰。</p>
<p>而这一瞬间，将持续15分钟，而这15分钟，对我当时的时间感知，仿佛是一千年。</p>
<p>在身体实际上并没有遭受到任何疾病威胁的情况下，我自己的大脑先进入了濒死状态。</p>
<p>眼前的一切都开始消解，有种要退出游戏开始放片尾字幕的感觉。</p>
<p>以前只有在书和电影里看到的「走马灯」出现了。</p>
<p>我前半生所有的记忆都大量从我的长期记忆冲进我的工作记忆，我小时候玩过的玩具，别人说过的话，所有事情历历在目。</p>
<p>我要死了，无比的确定，并不是推理，而是一种非常真切地「知道」我要死了，就像你不用推理就知道你现在醒着一样，是一种非常确定和真实的感觉。</p>
<p>接着，我好像进入了一条很窄的通道，非常黑暗和坚硬。</p>
<p>在飞速穿过通道的时候，大量奇怪的信息朝我涌来，有种信息爆炸，我的大脑要宕机的感觉。</p>
<p>斐波那契数列，普朗克常数，自指，阴阳，衔尾蛇，克莱因瓶，分形…</p>
<p>一切之前对我来说非常陌生的信息突然变得可以理解了起来，似乎这些东西本来我就「知道」，只是我无法说出来。</p>
<p>这更加剧了我的恐惧。</p>
<p>通过很窄的通道后，我来到了一扇「门」前面。</p>
<p>那并不是一个实体的门，而是一扇概念之门，一个边界。</p>
<p>仍然是一个莫名涌现的念头告诉我，如果我选择穿过这道门，那么我就死了，但是我会理解这个世界的真相。</p>
<p>我也可以选择永远停留在那里，不做任何决定。</p>
<p>我也可以选择回头，回到「现实」中。</p>
<p>我没有选择跨出那一步，我不想死，但同时我的好奇心又让我向着那个门不断靠近，我好想理解这个世界的真相。</p>
<p>我开始丧失自我意识，感觉自己和宇宙中古今万物都融化在了一起，没有分别，没有时间，没有空间。</p>
<p>恐惧和极其平静的感觉交织在了一起。</p>
<p>但恐惧赢了，我在快要穿过那道门的时候奋力抽身而出。</p>
<p>但信念告诉我，我仍然可以知道一个关于世界的真相，但我并不会理解。</p>
<p>全即是一，有即是无。</p>
<p>带着这个「真相」，我从这个夹层中返回了现实。</p>
<p>我一踏入急诊室，还没有看诊，竟然已经好了很多。</p>
<p>之后的检查一切正常，只是心跳稍微有点快，就像刚运动完一样。</p>
<p>神志逐渐清晰，我当时并不知道自己经历了什么，醒来后只觉得自己一定是大脑坏掉了，但那些感觉又是如此真实，就像我看现实世界一样真实。</p>
<p>那到底哪个才是「真」的呢？</p>
<p>以前也知道所谓色即空空即色，老子的虚无，庄周梦蝶等等的概念，但都是从逻辑和语言上来理解的，我觉得我是明白的，但却其实从来没有「懂」过。</p>
<p>但这段经历让我感到了一种我在向「懂」的边缘迈进的感觉。</p>
<p>并且，整个过程伴有一种强烈的宗教体验感。</p>
<p>如果那个时候问我相不相信有某个超越世俗的，所谓「神」的存在，我一定会说有，有一瞬间感到自己无限的渺小同时又无限的伟大，自己同时是空无一物，却又是全知全能。</p>
<p>之后的三四次发作，都是这样的一个循环，每次都是到了边界处，我又觉得自己真的要死掉了，又挣扎着回来。</p>
<p>每次检查都不是心脏问题，我百思不得其解。</p>
<p>2019年的一天，真相意外浮出水面。</p>
<p>我和一个熟人聊天的时候，他和我说他有个朋友觉得自己有心脏病，一直没有检查出问题，最后发现是一种叫做「惊恐发作（Panic Attack）」的精神疾病。</p>
<p>这是我第一次听见这个病，迅速查了起来。</p>
<p>更有意思的是，那天晚上，一个公众号推送了一条信息给我，说陈天桥有惊恐发作，我看描述的症状和我一模一样，并且他为了这个事情还搞了个研究中心。</p>
<p>我最终在北医六院副院长的诊室里被确诊为惊恐发作，但被告知没有明确有效的治疗方法，只能通过临时吃劳拉西泮来控制症状。</p>
<p>但每次发作都不可预测，根本来不及吃药，每次都是发作完了，我才意识到刚才又惊恐发作了。</p>
<p>于是我在自己的手上纹了一个纹身：Don’t Panic 想在发作的时候提醒自己。</p>
<p>但其实没啥用，发作起来根本看不到。</p>
<p>而且更搞笑的是，我带上表以后会遮住了 Don’t ，就只剩 Panic了。</p>
<p>由惊恐发作又导致了我的死亡恐惧，强迫性的念头会在我脑海里不断闪现，每天晚上睡觉前都会想到自己要死去的那一刻，恐惧到发抖，就差跳起来把毕生都投入长生不老的什么项目了。</p>
<p>屋漏偏逢连夜雨，同年年底，在打过HPV疫苗的情况下，我居然被检查出了宫颈癌病变，简直像是中了彩票。</p>
<p>难道我的预感是真的？我真的要死了吗？</p>
<p>这一些到底是怎么回事呢？我的脑子到底出了什么问题？如果只是惊恐发作，为什么会有那些奇怪的信息？</p>
<p>全即是一，有即是无到底是什么意思？</p>
<p>存在是什么？我存在吗？</p>
<p>这一切都有解释吗？</p>
<p>我又在左手手臂内侧文了炼金术中的衔尾蛇，中间用古希腊文写着「全即是一」。</p>
<p>我想找到这个答案。</p>
<p>###（4）盲人摸象</p>
<p>我除了知道我的无知这个事实外，一无所知。</p>
<p>—— 苏格拉底</p>
<p>知识涌现的秩序：始于超验的启示，借助先验的给定，进入经验的世界。</p>
<p>—— 康德</p>
<p>查了一些资料后，我了解到，由惊恐发作引起的濒死体验，属于「神秘体验」的一种（也被称为灵性体验或者宗教体验）。</p>
<p>首先需要知道的是，「神秘体验」是一种少见，但并不罕见的体验，并不是独一无二的，没有什么「了不起」的性质在里面。</p>
<p>除了惊恐发作以外，溺水、窒息、车祸、疾病、中毒等等会把人推向死亡边缘的事件也会引发濒死感、濒死体验和自我意识消亡（注意，这三个东西是不同的，不一定全都会出现）。</p>
<p>催眠、冥想、祷告、精神类药物等活动到一定程度也会引发自我意识消亡。</p>
<p>「神秘体验」包括但不限于濒死体验和自我意识消亡，还有：前世回溯、灵魂出窍、显灵、通灵、心灵感应等等。</p>
<p>这个并不是和你知识水平或者所谓「修为」相关的，可能没读过书没有修过行也会出现（当然，也有人会说，也许是你「上辈子」修来的。）</p>
<p>盖洛普在八十年代的美国调查，有将近15%的人有过濒死体验。有更多的人有过其它的「神秘体验」。</p>
<p>所以，如果你自己或者你周围的人遇到了这样的「神秘体验」，不要觉得自己或者那个人「很厉害」或者「是天选之人」，因为这并不罕见。</p>
<p>这件事因为很难进行实验，没有数据进行归纳，并且因为是主观体验，数据的真实性也存疑，所以没有很多令人信服的学术研究。</p>
<p>也可能正是因为如此，在我还没有系统查阅资料，和别人聊天的时候，对各式各样的解释就大开眼界。</p>
<p>我有个朋友斩钉截铁地说：「你这是被附体了，要找人赶一赶。」</p>
<p>我另一个朋友很信风水，和我说这是我家风水不好，让我改改风水。</p>
<p>有个天主教的朋友和我说：「这是你的罪恶太多了要向神宽恕，你和我周末做礼拜去吧」。</p>
<p>禅修的朋友非常羡慕地说：「这是开悟啊！」</p>
<p>但另一个信佛的朋友严肃地说：「这可不是开悟。」</p>
<p>懂些中医的朋友说，我这是元气不足，气血两虚，让我去找个老中医好好看看，喝喝中药。</p>
<p>还有个朋友不信中医，信阿育吠陀，觉得阿育吠陀更厉害，所以他和我说一定要去看看阿育吠陀。</p>
<p>我认识的神经科学博士说：「你这个就是临时的左脑功能丧失，和中风差不多。」</p>
<p>我一个前男友说：「你这怕不是精神分裂吧？」</p>
<p>每个人都非常笃信自己的解释是唯一正确的解释。我非常想把他们拉到一个群里看他们怎么争论。</p>
<p>这个场景让我想到了盲人摸象。</p>
<p>每个人都按自己的经验和知识解释了大象是什么，都非常相信自己解释的才是真的大象。</p>
<p>我开始着手自己解决这个医生解决不了的事情，就像当年抑郁症康复那样。</p>
<p>首先就想到的肯定是心理学。</p>
<p>查了一些资料以后发现很像人格解体、现实解离和精神分裂的症状，但这三者的描述和我的经历有些许相同，但是又似乎完全不是一回事儿。</p>
<p>倒是有一些解释灵魂出窍啊，看到白光啊什么的，灵魂出窍是因为定位定偏了，看到白光是脑部缺血等等。</p>
<p>对于我这个问题，也没有什么正经的论文有解释，有一些也都只是推论，信度效度都不高。</p>
<p>我还尝试了一些缓解惊恐发作的引导视频，大部分的视频都是让你面对死亡，说如果你面对了，就可以过去。</p>
<p>但在慌乱中，我不知道为什么把这句话理解成了我需要自杀，只有自杀了才算是真的面对死亡，如果没有自杀就不算。</p>
<p>我惊恐地看着我的家属，问：「我要自杀才行吗？」</p>
<p>家属连连摇头，紧紧抓着我的两只手。</p>
<p>查了特别多的资料后，似乎心理学是碰到了死胡同，难怪陈天桥专门搞个研究所，如果有现成的也不至于砸那么多钱搞个研究所了。</p>
<p>和陈天桥不同，我没有放弃除了心理学以外的东西。</p>
<p>因为有两本书影响了我，一本是库萨的尼古拉写的《论有学识的无知》，另一本是卡斯滕·哈里斯的《无限与视角》。</p>
<p>这两本书让我知道了人类理性认知的局限性，如果只局限于理性和经验，可能就把自己锁死了。</p>
<p>我的问题，是超验的。</p>
<p>而超验的问题，从哥白尼革命以后逐渐慢慢被边缘化了。</p>
<p>科学和神学的分歧首先是在本体论上，存在的本质是什么？唯心和唯物</p>
<p>既然从本体论上分家了，那么知识论也就分家了。</p>
<p>科学的大部分观察对象是指大多数人都可以用我们的五感来感知的对象，也称为经验对象。</p>
<p>而神学的观察对象并不是大多数人可以感知的，在哲学上被称为「超验」的一种体验，神秘体验（宗教体验）就是一种超验体验。</p>
<p>对于有过超验的人而言，其他人可能就是像苏格拉底所说的「洞中人」一样。</p>
<p>你想让这些人走出洞，但是他们会说「洞里才是真实的，洞外哪些都是幻觉」</p>
<p>那么对于科学来说，超验则是在洞里，而理性是在洞外，理性主义会说「超验体验就是烛火的幻觉而已」。</p>
<p>你很难说谁在洞里谁在洞外。</p>
<p>我的问题和很多宗教体验的描述更接近，也就是假设那只是洞内烛火的话，宗教体验中描述的烛火和我的体验更加接近。</p>
<p>比如说佛教说的「小我消解」，也就是「无我」，短暂的「无我」，是对于真理的一瞥。</p>
<p>慧开禅师写的《无门关》里面说的无门关特别像我「看到」的那个没有实体的「门」。</p>
<p>可以说，如果脑部放电异常，也许就会出现这种体验，那么我们可以叫这种体验为「幻觉」。</p>
<p>但是有一个根本的问题，「异常」是对于「平均」来说的，如果「平均」才是「幻觉」呢？</p>
<p>因为所有人都是这样，所以这样就是正常和真实的吗？</p>
<p>有没有一种可能，就是我那样的脑部放电后感知到的东西才是真的，而「平均」的才是「幻觉」呢？</p>
<p>举个例子。</p>
<p>有一群人，生下来就戴着会让世界变形的眼镜，只能看见一部分扭曲的世界。</p>
<p>但是他们的眼镜是一样的，所以他们看见的世界相同。</p>
<p>有一天，有一些人的眼镜突然坏掉了，第一次看见了一个不太一样的世界。</p>
<p>他们非常地吃惊，不知道看到的东西到底是什么。</p>
<p>因为这个眼镜是从出生下来就戴着的，所以大家认为，戴着眼镜才是正常的，不戴眼镜是残疾的，就会出现「幻觉」，看见并不存在的东西。</p>
<p>于是，有一些人认为他们看到的东西确实是不存在的，于是修好了眼镜，或者假装那些东西并不存在。</p>
<p>但有一些人认为他们看到的东西是存在的，他们希望打碎其他人的眼镜让他们看见有眼镜的时候才是残像，没有眼镜才能看到真实。</p>
<p>而其他人活得好好的，并且认为既然先天就是这样，并且大家都是这样，而且都活得好好的，为什么要敲碎眼镜？敲碎眼镜看到的是幻觉。</p>
<p>所以到底这个「眼镜」让你看到的是幻觉？还是真相？</p>
<p>生存下来并不需要看到「真相」，所以正常或者并不是你看到「真相」的充分条件。</p>
<p>我们是不是生活在matrix里，但因为我们的认知局限性，却把这个世界当成了实在？</p>
<p>会不会其实濒死体验的大脑状态才是突破了我们认知的局限性呢？</p>
<p>而且那种感觉那么的真实，真实到感觉「现实」才是一个低清版本的梦境一样。</p>
<p>就像金刚经里说的：一切有为法，如梦幻泡影，如雾亦如电，应作如是观。</p>
<p>一首儿歌也是这样唱的：</p>
<p>Row, row, row your boat, gently down the stream,</p>
<p>划划划小船，慢慢顺溪而下，</p>
<p>Merrily, merrily, merrily, merrily, life is but a dream.</p>
<p>开心开心真开心，生活就像个美梦。</p>
<p>Row, row, row your boat, gently down the creek,</p>
<p>划划划小船，慢慢顺溪而下，</p>
<p>If you see a little mouse, don’t forget to squeak!</p>
<p>如果你看见个小老鼠，别忘了吱吱叫！</p>
<p>Row, row, row your boat, gently down the river,</p>
<p>划划划小船，慢慢顺河而下，</p>
<p>If you see a polar bear, don’t forget to shiver!</p>
<p>如果你看见个北极熊，别忘了打哆嗦！</p>
<p>Row, row, row your boat, gently down the stream,</p>
<p>划划划小船，慢慢顺流而下，</p>
<p>If you see a crocodile, don’t forget to scream!</p>
<p>如果你看见个大鳄鱼，别忘了嗷嗷叫！</p>
<p>但也有可能，确实是我脑子坏了。</p>
<p>###（5）指月之旅</p>
<p>见虚则缚，见实则开。</p>
<p>—— 龙树</p>
<p>虽然似乎宗教里包含的关于我的神秘体验的答案更多，但我觉得光是从宗教这一个视角钻下去也会有偏误，于是我决定从哲学下手，先把形而上学，认识论，科学哲学，宗教哲学什么的根本问题都搞清楚再说。</p>
<p>于是我在2020年初申请了伦敦大学伯贝克学院的哲学本科，打算开始系统学习哲学。</p>
<p>同时，我还做了几件事情。</p>
<p>公司方面：</p>
<p>我退掉了办公室，公司60多个人全部永久在家办公，并把5天工作制改成了4天工作制，每天工时6小时，中午有2个小时午休，下午5点就下班了，每个月还有一天公休假，想让大家多一点自己的时间，照顾好自己，享受一下生活。</p>
<p>我回购了公司所有的股份，让公司成为独资公司了，然后给团队发放了实实在在可以每年都拿到分红的股份。</p>
<p>我不再露脸，不再参加活动，CEO的工作开始逐渐转交接给合适的同事。</p>
<p>安排了公益项目和指标，希望可以做出更多一些的正面影响。</p>
<p>放弃了一个看起来非常性感，可以做一番大事业改变世界但似乎也不是要真正想要的东西的合作机会。</p>
<p>亲密关系方面：</p>
<p>我鼓起勇气向父母要了他们对儿时的我造成的早期创伤的道歉。</p>
<p>过程非常艰辛，尤其是我爸坚持不肯道歉，觉得都是我太脆弱，我感觉又回到了小时候那种委屈得不行的状态，哭到喘不过气来。</p>
<p>但还好，最终在我换着说法不停地坚持下，我爸终于道歉了。</p>
<p>这个道歉对我影响非常大，很多自责、委屈、愤怒都消失了，我原谅了父母，并且决定要学会去慢慢培养自己对他们的爱，因为在儿时的创伤中，我意识到自己对他们的爱非常非常的少。</p>
<p>我开始重新做心理咨询。没想到惊恐发作没有什么解决途径，倒是治好了我的边缘性人格障碍，通过认识到自己有边缘性人格障碍（情绪波动大，喜欢控制他人），然后开始家庭训练，家属非常配合按照教程上的做。</p>
<p>大概几个月，我的脾气就好了非常多，虽然惊恐发作还在，很少出现烦躁暴怒的状态了（虽然我以前不认为这是什么问题）。</p>
<p>疫情稳定了一段时间以后，我偶然看到了一个去香格里拉的旅游项目，就报了名，想着从来都没有去过，去看看，顺便看看云南还有什么地方可以去看看。</p>
<p>香格里拉结束，顺路到了大理。</p>
<p>原以为大理只不过是一个已经商业化严重的普通旅游城市，又是没想到，我和家属居然都爱上了大理，丝毫没有犹豫地就定居了下来。</p>
<p>我们在大理很快就认识了当地的很多新移民，见到了各种各样不同的生活方式，还意外认识了在苍山上隐居的一对严格素食夫妻 R 和 T 。</p>
<p>更意外的是，R说他在冥想中多次体验过自我消亡，他不认为他自己存在。</p>
<p>但当我问他是怎么回事的时候他就开始和我说一些什么「高维」啊之类灵修的那帮子人说的事情，我听得迷迷糊糊，而且觉得特别神神叨叨玄玄乎乎不靠谱。而且虽然我知道理性认知有限，但还是对「神棍」有着本能的抵触。</p>
<p>努力地在听，但心里其实还是在批判这都是些什么乱七八糟的。</p>
<p>而且他除了像那些安抚视频一样说「面对死亡」以外，也没有再给我什么有用的信息了。</p>
<p>虽然没能解决惊恐发作的问题，却有了别的收获。</p>
<p>和他们在苍山上住了一个月，吃了一个月的素，竟然没有我想象中的那么煎熬。</p>
<p>这个饮食习惯甚至被我保留了下来，从那时到现在写这些文字的时候已经吃了大半年的素食，没有对肉有任何欲望。当然，也会偶尔吃肉，肉还是好吃的，但我已经不像从前一样无肉不欢。</p>
<p>就这样，我开始了在大理的生活。</p>
<p>我有了大量的室外活动，也开始重新运动，重新规划自己的饮食，保证每餐虽然是素，但都营养均衡。</p>
<p>哲学本科开学了，我也开始全职读书，觉得这四年应该就会这样在晒太阳、读书、运动、做饭中安稳读过，直到我有点头绪。</p>
<p>但事情再一次没有在我的计划之内。</p>
<p>###（6） 放下</p>
<p>When the student is ready, the teacher will appear.</p>
<p>我读了一个学期的哲学，哲学阅读与写作方法，逻辑学，伦理学，知识论。</p>
<p>感觉读起来为什么那么枯燥乏味，完全不像自己在找答案时的那种渴望的感觉，甚至还不如自己看书。</p>
<p>我逼着自己去读，但是真的读不进。</p>
<p>每次要交作业的时候，我都在拖延，不是在做菜，就是在帮我一个付费知识群的读者解决他们的一些工作学习困扰。</p>
<p>反而在群里帮助大家解决困扰的事情更吸引我，我有的时候甚至连饭都顾不上吃，全神贯注地去一步一步引导他们意识到问题的核心，并且解决问题。</p>
<p>很多读者都说我的帮助改变了他们的人生，让他们解脱了枷锁。</p>
<p>他们的大部分问题都是抱着以前父母老师给的错误信念不放手，比如说「要出人头地才能得到幸福」啊，「体制内的工作才是最好的」啊之类的，不停面质，让他们意识到自己的信念站不住脚，拔掉这些没用的镣铐，一下子就很轻松了。</p>
<p>对我来说好像这些问题都是非常显而易见的。</p>
<p>但是为什么我自己不能这么轻松地解决自己的问题呢？</p>
<p>我甚至连自己的镣铐在哪里都看不到。</p>
<p>在期末考试前，我终于决定休学，想再想想到底问题在哪里再决定要不要继续读。</p>
<p>休学以后，我真的是松了一大口气，感觉像甩掉了一个累赘。</p>
<p>要解决这个问题的想法也逐渐在我脑海中淡化了。</p>
<p>同时我也放弃了一个本来想参与的公司孵化的新项目。</p>
<p>重新回到了我自己喜欢做但是看起来不太性感的帮助读者答疑的活动里，全心全意地做这件事，一做可以从早到晚做一整天。</p>
<p>感觉这才是我现在最想做的事情。</p>
<p>在读者的鼓励下，我报了个心理咨询的培训，打算做个心理咨询师。</p>
<p>在这段时间里，惊恐发作竟然再也没有出现过，要找到我的濒死体验是怎么一回事儿，全即是一，有即是无又该怎么理解这些之前困扰着我的问题的动力好像也消失了。</p>
<p>偶尔看到自己胳膊上的纹身，会想，也许这辈子也不知道是怎么回事了。</p>
<p>但是现在生活挺好的，虽然仍然有隐隐的不安，但是好像事情在朝着好的情况发展。</p>
<p>于是，我慢慢地放下了这个一定要找到答案的执念，专注到了我发自内心喜欢做的事情上。</p>
<p>就在我快要忘记这件事的时候，改变我一生的事情措手不及地发生了。</p>
<p>###（7）我死了</p>
<p>Nobody can pass the gateless gate, so, be nobody.</p>
<p>2021年3月底，我和家属去了鸡足山爬山，我们到了快到顶峰的一个观音庙前休息，我就顺势开始冥想。</p>
<p>我治疗抑郁症的时候会经常冥想，但是后来有的时候断断续续的，也不怎么冥想，不知道那天为什么就突然冥想了起来。</p>
<p>而这次的冥想和之前的冥想好像完全不同。</p>
<p>以前的冥想只是去关注自己的呼吸，关注自己脑海飘过的念头，像云一样，看着看着走神了就再拉回来，如此反复，会进入一种奇怪的似睡非睡的状态，好像时间停止了。</p>
<p>但是这次的冥想，不知道为什么，好像有个声音让我做一个任务。</p>
<p>这个任务是，在你的内部找到你自己。</p>
<p>然后我就开始找了起来，好像外面的世界和我完全没有关系，我能感觉到「内部」有个无限的空间，仿佛宇宙那么大，我好难找到「我」在哪里，但是我又能感觉到「我」的存在，我拼命地去找呀找，好像找到了「我」，但是好像只能永远地靠近，却无法抓住它，让它回到它该在的位置，好像它偏了，而且虽然看着很近，但是我和我隔着一个无限的距离。</p>
<p>大概冥想了有一个小时左右，但是感觉我好像追我自己追了很久很久，我感觉好累好累。</p>
<p>回到客栈倒头就睡着了。</p>
<p>我现在回想起来，觉得这个事情可能是一个预告片。</p>
<p>紧接着的后一周，也就是2021年4月9日，我们之前在大理认识的那对儿素食夫妇R和T邀请我们周末去他们丽江家里玩。</p>
<p>那天到了以后我们吃完中饭就去了他们家喝普洱茶，一边喝茶一边聊天，一切都很轻松平常。</p>
<p>大概在三四点的时候来了另一个朋友J。</p>
<p>话题不知道为什么就引到了笛卡尔上，我， R 和 J 对笛卡尔的「我思故我在」产生了异议。</p>
<p>J 坚持说「我思故我在」的重点在「我」上，笛卡尔在说这句话的时候就已经默认了个人中心视角。</p>
<p>我说这个偏离了笛卡尔的重点，笛卡尔想要表达的是我们的感官是不准确的，所以我们不能够依靠经验来判断客观事物是否存在，也不能根据经验判断自己是否存在，我们能知道的只有自己在思考，这是唯一能知道的事情，所以「我思故我在」，这样的逻辑我觉得没有什么问题。</p>
<p>J 说，因为「我」可能是不存在的，「思」也可能只是幻觉不是实在，「我思故我在」首先要证明「我」存在，「思」存在，以及「思」的主体到底是不是「我」，才能有「我思故我在」。</p>
<p>J 突然转头问 T ：「你觉得人是什么？」</p>
<p>T说：「人是一种交通工具。」</p>
<p>我突然被这个看起来莫名其妙的回答惊到了，感觉后背一凉，脑子发懵，心跳得乱七八糟。</p>
<p>「存在到底是什么？」</p>
<p>「什么是实在？」</p>
<p>被遗忘了很久的这两个问题开始在我的脑海里不停地打转，那种熟悉的，久违的，要惊恐发作的感觉又开始了。</p>
<p>我马上制止了这个念头，这也是我的咨询师和我说的，如果有强迫性念头，一定要及时制止，转移注意力。</p>
<p>我把注意力转移到了茶杯上，感觉好一点了。</p>
<p>我说：「我感觉要惊恐发作了，我又进到那个存在不存在的兔子洞里了，还好我停下来了。」</p>
<p>R睁大眼睛看着我，一边折腾着普洱茶一边说：「为什么要停下来，不用停下来，你进到兔子洞就好了。」</p>
<p>这时候 J 也说：「我的惊恐发作也是这么好的。」</p>
<p>这是我第一次知道 J 也有惊恐发作。</p>
<p>似乎没有时间思考我要不要进兔子洞，我就又进去了。</p>
<p>爱、生、死这三个字在我脑海里不断盘旋，这三个字好像指向了一个东西，但是这个东西没有名字，这个东西是什么？</p>
<p>我惊恐地大声说：「这是什么？你们知道这是什么吗？我是谁？」</p>
<p>J说：「你说呢？」</p>
<p>我颤抖地说：「我觉得好像感到了那个东西，它是终极存在，它很寂寞，于是它以自己做了一个礼物送给自己，那是一个无穷无尽没有完结没有重复的游戏，它在玩它自己，而我就是它。」</p>
<p>这个念头的循环就像是通往无门关的密码，恐惧瞬间攀升，我感觉世界在离我而去，我感觉「我」在消散。</p>
<p>我又到达了那道无门关前，恐惧到达了顶峰。</p>
<p>那种熟悉的感觉，像是你回头看见了一个人对准你扣下了扳机子弹在不到半秒后就要射入你的头颅，像是突然失足掉下了深渊地面在飞速靠近，像是你发现了你手里捧着的定时炸弹还剩最后1秒…</p>
<p>等一下，这种感觉…</p>
<p>为什么这种感觉又像是你快要到达高潮，像是你快要打出了喷嚏，像是你看到魔术师要揭开谜底…</p>
<p>突然，似乎不是我做出的选择，由不得我做任何选择，但又好像是我自己的选择。</p>
<p>我选择了死亡。</p>
<p>子弹射进了我的头颅，我重重摔在了地上，炸弹爆炸了，我高潮了，我打喷嚏了…</p>
<p>我看见了魔术师的谜底。</p>
<p>我死了，但我却变成了永恒。</p>
<p>在那一瞬间，我见到了那个东西，我也见到了「我」。</p>
<p>它没有名字，但世界上一切的名字都是它的名字；</p>
<p>它是全，它是一；</p>
<p>它是最小，它是最大；</p>
<p>它是实在，它是虚无；</p>
<p>它是色，它是空；</p>
<p>它是量子，它是宇宙；</p>
<p>它是悖论，它不存在于逻辑中；</p>
<p>它是完美的自指，它无法用理性来解释。</p>
<p>任何一种表达它方式都只能像指向月亮的手指，如果你看不见月亮，那么即使指了，你也看不见，你看到的只有指头，但是你可以理解「指」这个动作，却仍然无法看到月亮。</p>
<p>我在那一瞬间，理解了所有之前看过经文的每一句，理解了道德经，理解了炼金术，理解了犹格索托斯，理解了samadhi，理解了所有指向它的手指。</p>
<p>最重要的是。</p>
<p>它是我，我是它。</p>
<p>它是你，你是它。</p>
<p>你是我，我是你。</p>
<p>我如此地热爱世间万物，因为它们都是我。</p>
<p>它们也都是你。</p>
<p>在我消失的那一刻，我成为了终极显著。</p>
<p>那是我人生中极乐的一刻，我不知道还有什么可以比这更开心的。</p>
<p>天啊！这轮月亮太美妙了！我打心底希望所有的人都可能看见！</p>
<p>当我想到这些的时候，发现自己居然在复述金刚经的内容！一模一样！</p>
<p>无门关前是欲望和恐惧，无门关后是超脱和狂喜。</p>
<p>这是一枚硬币的两面，这是一条河的两岸。</p>
<p>我翻到了硬币的另一面，到达了彼岸。</p>
<p>###（8）新生</p>
<p>外观者梦，内观者醒</p>
<p>― 荣格</p>
<p>开悟的状态大概持续了几个小时，但是我感觉好像只有几分钟，我最后一次看表是6点，回过神的时候已经晚上9点了。</p>
<p>在这个状态下我一直沉浸在那种强烈的奇妙的感觉中，我特别怕忘了当时的感觉，所以赶紧在微信上记录了下来。</p>
<p>但是好像这个感觉像加了密一样，我自己觉得自己语言表达能力算是不错了，但是怎么表达都无法真切地表达出来，这是唯一让我感到难受的地方。</p>
<p>在经历了长达两天的战栗后，我终于恢复到了正常的状态。并且好像正在慢慢忘记当时的感受，大脑理性的部分又开始工作，很快又开始怀疑自己是不是脑子坏掉了，对于当时知道的那些东西又开始怀疑了起来。</p>
<p>但是心底深处有个东西好像永远地变了。</p>
<p>我完全不再担心惊恐发作和死亡恐惧了，我好像冲破了牢笼但又像披上了一身无坚不摧的铠甲。</p>
<p>生活好像是在体验一个第一视角的VR电影，你会跟着这个电影一起喜怒哀乐和恐惧，但不再会感到切身的痛苦和折磨，反而可以更好地享受这个电影，剧情逐渐展开，有意料之中的事情，也有各种惊喜和意外。</p>
<p>以及，我也特别希望别人可以和我一样享受好看的电影。</p>
<p>也有很多事情没有我想象中的开悟那样改变。</p>
<p>比如说我还是很想吃辣条。</p>
<p>比如说我还是会对一些事情不耐烦。</p>
<p>比如说我还是会每天出门的时候涂好防晒霜。</p>
<p>我也不能预测未来，更不能像黑客帝国男主一样操控物质。</p>
<p>但好像没有什么问题。</p>
<p>听说开悟还可能会有第二次第三次，还有不同层次的开悟，还有可能会一直保持那种开悟的状态直到肉体消亡。</p>
<p>我期待，但并不渴求，这一次开悟已经给我带来了很大的满足感，有之后的体验更好，没有也可以。</p>
<p>而且我觉得似乎这个真是可遇不可求。</p>
<p>Enlightenment is the “full comprehension of a situation”.</p>
<p>觉醒是「完全透彻地懂得了一个情况」。</p>
<p>但「完全透彻地懂了」是个目前还不可被检验的东西。</p>
<p>也许有一天有人证明了这种体验是一种幻觉，是一种精神疾病。</p>
<p>但有什么关系呢？</p>
<p>一个快乐的精神病人和一个痛苦的正常人，我选择前者。</p>
<p>寺主人</p>
<p>2021年4月14日</p>
<h2 id="灵天赐的评论"><a href="#灵天赐的评论" class="headerlink" title="灵天赐的评论"></a>灵天赐的评论</h2><p>有人向我推荐你的答案，看了之后，作为有福之人，有必要给你一个指点。<br>在生活里，你找不到人能指点你了。<br>你“见性”了，即禅宗修行明心见性中的见性。<br>此后，是一个从物质梦境中开始睁眼醒来的人，也是一个有资格做任何修行的修行者。<br>不过，无门关，远比你想象的要深奥。<br>无门关所“无”的，不仅是这个后天的“我”，还有一切“分别”。<br>你还差一个入处，才能觉醒“无师智”。<br>先在目前的喜悦里，多呆一段时间，尽情享受一段时间。<br>待喜悦消散，某种更加无形的“自我”，会开始浮现，生活也将继续对你的教导。<br>提示：<br>不要执着于境界，不要执着于教导，不要执着于喜悦苦恼，不要执着于动静，不要执着于“好为人师”。<br>无论是何境遇，时时刻刻，牢记一个“无”字。<br>祝好<br>[大笑][大笑]</p>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>thoughts</tag>
      </tags>
  </entry>
</search>
