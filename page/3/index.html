<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"draapho.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta name="description" content="explore">
<meta property="og:type" content="website">
<meta property="og:title" content="DRA&amp;PHO">
<meta property="og:url" content="https://draapho.github.io/page/3/index.html">
<meta property="og:site_name" content="DRA&amp;PHO">
<meta property="og:description" content="explore">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="draapho">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://draapho.github.io/page/3/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>
<title>DRA&PHO</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">DRA&PHO</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">thinking & logging</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">draapho</p>
  <div class="site-description" itemprop="description">explore</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">123</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">80</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2018/04/12/1815-suspend/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/12/1815-suspend/" class="post-title-link" itemprop="url">博客暂停更新</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-04-12 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-12T00:00:00+10:00">2018-04-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-08 10:54:33" itemprop="dateModified" datetime="2021-03-08T10:54:33+11:00">2021-03-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/thoughts/" itemprop="url" rel="index"><span itemprop="name">thoughts</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
<li><a href="https://draapho.github.io/2021/03/05/2107-tuibeitu/">推背图, 马前课, 万年歌, 梅花诗</a></li>
</ul>
<h1 id="本博客暂停更新"><a href="#本博客暂停更新" class="headerlink" title="本博客暂停更新"></a>本博客暂停更新</h1><p>原因的话, 最大的兴趣点始终是在人文和生命本源这一块. 参考 <a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a><br>当下可能找到了一种方法, 让生活和兴趣可以两全. 我需要全力去试一试.</p>
<p>第一阶段, 独善其身:</p>
<ul>
<li>于资本汇聚之地得自由</li>
<li>于人性汇聚之地得自在</li>
<li>万物皆空, 上善若水<ul>
<li>贪嗔痴疑慢, 万物皆烦恼. 舍万物?求信仰? 终是不究竟.</li>
<li>水无所依, 可依万物. 心无所执, 可着万境.</li>
</ul>
</li>
</ul>
<p>第二阶段, 兼济天下:</p>
<ul>
<li>人文学科和生命本源数学化, 理论化.</li>
<li>已有大致思路:<ul>
<li>心为本, 物为载体, 心可改变物.</li>
<li>一切出发点是基本生命体的相互关系, 这种相互关系就是本源, 不随级别改变.</li>
<li>环境的影响首先作用于心, 心影响生命体的相互关系, 从而影响整个群体的行为和特性.</li>
</ul>
</li>
<li>主观上, 我认为佛教的世界观是正确的; 但受限于”客观”的观察要求, 要证明比较困难.<ul>
<li>所谓大千世界, 是指不同级别包含生命体的世界. 每个人, 每朵花, 每个细胞都是一世界. (分子,原子不敢确定)</li>
<li>世界就是玻璃缸, 人是没有什么”客观”的方法去观察玻璃缸外的情况的.</li>
<li>人之所以稍微特殊一点, 是因为以人为基础单位, 明显已经发展出多样的更高层次的生命体(企业, 国家等各种形态的组织)</li>
<li>更重要的, 人有潜能进行星际殖民, 从而把星球发展成为更高级的”基础细胞”.</li>
</ul>
</li>
</ul>
<p>最后, 无论成败, 先在此感谢 <a target="_blank" rel="noopener" href="http://blog.sina.com.cn/u/1215172700">缠中说禅</a> 不但指明了实用的生存方法, 更是给予了我无穷的灵感!<br>读君博文, 方觉虚度光阴30载. 愿君彼岸安好.</p>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2018/02/09/1815-drv-i2c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/09/1815-drv-i2c/" class="post-title-link" itemprop="url">驱动之I2C驱动</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2018-02-09 00:00:00 / Modified: 17:14:10" itemprop="dateCreated datePublished" datetime="2018-02-09T00:00:00+11:00">2018-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/embedded-linux/" itemprop="url" rel="index"><span itemprop="name">embedded linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/02/09/1815-drv-i2c/">驱动之I2C驱动</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 由于jz2440开发板没有板载I2C设备, 因此源码部分无法实际测试.</p>
<h1 id="I2C驱动框架分析"><a href="#I2C驱动框架分析" class="headerlink" title="I2C驱动框架分析"></a>I2C驱动框架分析</h1><p>I2C协议本身不是太复杂, 但Linux内核为了通用化, 搞了一套复杂的总线系统.</p>
<p><img src="https://draapho.github.io/images/1815/layer.png" alt="layer.png"></p>
<p><strong>最要理解i2c框架, 尝试理解 <code>i2c_add_adapter</code> 和 <code>i2c_add_driver</code> 就行了.</strong></p>
<ul>
<li><code>i2c_adapter</code> 对i2c主机的抽象概念, 与 <code>i2c_add_adapter</code> 相关<ul>
<li>这部分的架构都是已经搭好的, 由CPU厂商完成.</li>
<li>针对特定的开发板, 一般情况只会有一个 <code>i2c_adapter</code>. 会在<code>/drivers/i2c/busses</code>下选取一个</li>
<li>但特殊情况, 如果需要用不同的数据预处理方式, 如 <code>i2c-algo-bit</code>, 那么也可以抽象出多个 <code>i2c_adapter</code></li>
</ul>
</li>
<li><code>i2c_driver</code>  对i2c从机的抽象概念, 与 <code>i2c_add_driver</code> 相关<ul>
<li>Linux内核给了很多i2c芯片的驱动范例. 我们所说的开发i2c驱动, 是位于这一端的.</li>
<li>一个真实的i2c从机设备并非对应唯一的 <code>i2c_driver</code>.</li>
<li>譬如i2c芯片24cXX. 可以对APP端抽象出多种概念:<ul>
<li>linux内核为了让APP端能直接操作i2c, 通过 <code>i2c-dev.c</code> 实现了一个 <code>i2c_driver</code></li>
<li>系统里的<code>eeprom.c</code>, 帮我们实现了通用eeprom的操作. 就是另一个 <code>i2c_driver</code></li>
<li>我们自己也可以写一个驱动, 将24cXX认为是一块加密芯片. 就是第三个 <code>i2c_driver</code></li>
<li>这样, i2c从机端的底层都是一样的, 但上层的抽象概念是不同的. 或许, 这也是将主机端取名为 <code>i2c_adapter</code> 的原因, 它只是一个通讯适配器. 将APP层的不同抽象概念适配到一个个具体的i2c芯片上.</li>
</ul>
</li>
</ul>
</li>
<li><code>i2c_adapter</code> 和 <code>i2c_driver</code> 的关联方式<ul>
<li>就是 platform 总线架构, 两个链表有新加内容后, 循环查找匹配.</li>
<li>是否匹配有两个要点:<ul>
<li>一是 <code>i2c_adapter.nr</code> 和 <code>i2c_client_address_data</code> 里的设置是否一样</li>
<li>这里基本都不用这个值去匹配的. 总线驱动也没去设置 <code>i2c_adapter.nr</code>. 设备端驱动直接设置为 <code>ANY_I2C_BUS</code> 即可.</li>
<li>二是 i2c 的物理地址, 根据物理地址实际通讯一下, 来进行匹配.</li>
<li>如果用了 <code>i2c_client_address_data.force</code>, 那么物理地址的检测过程也将被忽略.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ul>
<li><code>./drivers/i2c/i2c-core.c</code> 这个文件实现了I2C核心的功能以及/proc/bus/i2c*接口。<ul>
<li>此文件就是 <code>i2c核心层</code> 作用是承上启下:</li>
<li>对上, 提供统一的调用接口, 屏蔽硬件差异. 如提供 <code>read</code> <code>write</code> 函数.</li>
<li>对下, 抽象出i2c操作通用的部分, 简化i2c的硬件驱动开发.</li>
</ul>
</li>
<li>　<code>./drivers/i2c/busses</code> 包含了各个芯片厂商的I2C总线的驱动<ul>
<li>如 <code>i2c-s3c2410.c</code> 针对S3C系列处理器的I2C控制器驱动.</li>
</ul>
</li>
<li><code>./drivers/i2c/i2c-dev.c</code> 实现了I2C适配器设备文件的功能，每一个I2C适配器都被分配一个设备.<ul>
<li>把这个文件理解为系统提供的一个i2c设备驱动程序即可. 需要手动加载.</li>
<li>此文件会调用 <code>i2c_add_driver</code>, 系统默认注册的一个i2c设备, 可供app端直接调用.</li>
<li>i2c芯片另外需要自己的驱动程序, 去调用 <code>i2c_add_driver</code>, 并注册设备.</li>
</ul>
</li>
<li><del><code>./drivers/i2c/algos</code>　文件夹实现了一些I2C总线适配器的algorithm.</del><ul>
<li>algorithm 这个词让人容易误解. 我的理解是数据预处理方式的不同.</li>
<li><code>i2c-algo-pca.c</code>. 可参考 <a target="_blank" rel="noopener" href="https://www.nxp.com/docs/en/data-sheet/PCF8584.pdf">PCF8584 I2C-bus controller</a></li>
<li><code>i2c-algo-pcf.c</code>. 可参考 <a target="_blank" rel="noopener" href="https://www.nxp.com/docs/en/data-sheet/PCA9564.pdf">PCA9564 Parallel bus to I2C-bus controller</a></li>
<li><code>i2c-algo-sgi.c</code>. 应该针对给2款早已过时的PC机用的.</li>
<li><code>I2C_ALGO_XXX</code> 的宏定义可以在 <code>./include/linux/i2c-id.h</code> 下找到</li>
</ul>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li><code>struct i2c_driver</code> 提供 <code>probe</code> <code>remove</code> 等函数接口. i2c从机设备驱动使用<ul>
<li><code>i2c_add_driver</code> 函数使用. 与 <code>i2c_adapter</code> 对应, 两者需要匹配.</li>
</ul>
</li>
<li><code>struct i2c_adapter</code> 适配器. 就是将多种多样的底层I2C硬件需求(不同地址, 不同通讯方法)给一个统一的方法接入到I2C核心层.<ul>
<li>指定通讯方式(i2c_algorithm)</li>
<li>指定i2c设备(i2c_client)</li>
<li><code>i2c_add_adapter</code> 函数使用. 与 <code>i2c_driver</code> 对应, 两者需要匹配.</li>
</ul>
</li>
<li><code>struct i2c_client</code> 描述了真实设备的所有必要信息, 如 i2c addr, 设备名称, 中断号等等.<ul>
<li>除了提供给 <code>i2c_adapter</code> 外, 还直接和 <code>i2c_driver</code> 想关联.</li>
<li>原因应该是内核层和应用层都需要方便的读取真实i2c设备的必要信息</li>
</ul>
</li>
<li><code>struct i2c_algorithm</code> 通讯方法. 其中两个函数指针是由底层硬件实现的. 相当于 i2c核心层和底层的接口<ul>
<li>algorithm 这个词让人容易误解. 我的理解是数据预处理方式的不同.</li>
<li>只和 <code>i2c_adapter</code> 相关, 给i2c主机提供收发功能</li>
<li><code>.master_xfer</code> 发送函数, 需要底层实现.</li>
<li><code>struct i2c_msg</code> 用于存放通讯时的地址, 数据buf, 长度等信息</li>
<li><code>.functionality</code> 驱动支持的功能, 需要底层明确.</li>
<li>底层没有接收函数. 因为i2c通讯必须由主机发起并提供时钟, 发送的同时就会接收数据.</li>
</ul>
</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><img src="https://draapho.github.io/images/1815/function.png" alt="function.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// =========== 从 i2c_add_driver 看 ==========</span></span><br><span class="line">i2c_add_driver                                              <span class="comment">// I2C 设备驱动会调用, 如自己写的驱动</span></span><br><span class="line">    i2c_register_driver</span><br><span class="line">        driver-&gt;driver.bus = &amp;i2c_bus_type;</span><br><span class="line">        driver_register(&amp;driver-&gt;driver);</span><br><span class="line">        list_add_tail(&amp;driver-&gt;<span class="built_in">list</span>,&amp;drivers);              <span class="comment">// 将 i2c_driver 放到链表尾部</span></span><br><span class="line"></span><br><span class="line">        list_for_each_entry(adapter, &amp;adapters, <span class="built_in">list</span>) &#123;</span><br><span class="line">            driver-&gt;attach_adapter(adapter);                <span class="comment">// 尝试匹配 i2c_adapter</span></span><br><span class="line">            <span class="comment">// driver-&gt;attach_adapter 就会去调用驱动里指定的 attach_adapter 函数.</span></span><br><span class="line">            <span class="comment">// 一般的, 就是直接调用 i2c_probe. &quot;i2c-dev.c&quot; 除外, 它关联所有的 &quot;i2c_adapter&quot;.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i2c_probe(adapter, &amp;addr_data, eeprom_detect);              <span class="comment">// adapter 是系统传过来的</span></span><br><span class="line">    adap_id = i2c_adapter_id(adapter)                       <span class="comment">// i2c_adapter.nr 作为判断.</span></span><br><span class="line">    <span class="comment">// 判断 address_data 里是否有 forces.类型匹配即可. 强制类型不会检查I2C从设备是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (address_data-&gt;forces) &#123;</span><br><span class="line">        <span class="comment">// force里的类型与 i2c_adapter.nr 一致, 或者是 ANY_I2C_BUS</span></span><br><span class="line">        <span class="keyword">if</span> (forces[kind][i] == adap_id || forces[kind][i] == ANY_I2C_BUS) &#123;</span><br><span class="line">            i2c_probe_address();                            <span class="comment">// 调用 i2c_probe_address</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// address_data.probe 里的地址和类型不受ignore影响.</span></span><br><span class="line">    <span class="comment">// probe 的数据格式也必须是 &#123;I2C_BUS_ID, ADDR, I2C_BUS_ID, ADDR, I2C_CLIENT_END&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (address_data-&gt;probe[i] == adap_id || address_data-&gt;probe[i] == ANY_I2C_BUS) &#123;</span><br><span class="line">            i2c_probe_address();                            <span class="comment">// 调用 i2c_probe_address</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// address_data.normal_i2c, 就是排除 .ignore 后, 进行 i2c_probe_address</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i2c_probe_address                                           <span class="comment">// 发出S信号,发出设备地址(来自addr_data)</span></span><br><span class="line">    i2c_smbus_xfer</span><br><span class="line">        i2c_smbus_xfer_emulated</span><br><span class="line">            i2c_transfer</span><br><span class="line">                adap-&gt;algo-&gt;master_xfer                     <span class="comment">// 就是调用 s3c24xx_i2c_xfer</span></span><br><span class="line">    found_proc(adapter, addr, kind);</span><br><span class="line">    <span class="comment">// 回调用户设置的的 detection 函数, 告知匹配成功. 可以做一些收发数据的初始化准备.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// =========== 从 i2c_add_adapter 看 ==========</span></span><br><span class="line">i2c_add_adapter                                             <span class="comment">// I2C 总线驱动会调用, 如 &quot;i2c-s3c2410.c&quot;</span></span><br><span class="line">    i2c_register_adapter</span><br><span class="line">        device_register(&amp;adap-&gt;dev);                        <span class="comment">// 在 i2c-adapter 下注册 i2c-X</span></span><br><span class="line">        list_for_each(item,&amp;drivers) &#123;</span><br><span class="line">            driver = list_entry(item, struct i2c_driver, <span class="built_in">list</span>);</span><br><span class="line">            driver-&gt;attach_adapter(adap);                   <span class="comment">// 尝试匹配 i2c_adapter</span></span><br><span class="line">            <span class="comment">// driver-&gt;attach_adapter 就会去调用i2c设备驱动里指定的 attach_adapter 函数.</span></span><br><span class="line">            <span class="comment">// 后续过程和后面的 i2c_add_driver 一样, 略过不表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于 i2c_adapter.nr 应该是由这里的驱动在设定, 作为对接的依据之一.</span></span><br><span class="line"><span class="comment">// 但实际上, 大多数CPU厂商都没有用这个 i2c_adapter.nr 去作为 I2C_BUS 的ID. 默认值应该是0</span></span><br><span class="line"><span class="comment">// 所以最终是否能匹配就变成了根据 I2C 的地址, 实际检测一下设备是否存在...</span></span><br></pre></td></tr></table></figure>


<h1 id="编写I2C设备驱动"><a href="#编写I2C设备驱动" class="headerlink" title="编写I2C设备驱动"></a>编写I2C设备驱动</h1><p>一般的, I2C总线驱动也由芯片公司完成了.<br>因此, 当外接了某个i2c设备时, 只需要编写一下设备驱动就可以了.<br>linux内核还包含了常用的 i2c 设备如eeprom. 可以在 <code>./drivers/i2c/chips</code> 下看看.</p>
<p>核心步骤如下:</p>
<ul>
<li>分配一个i2c_driver结构体</li>
<li>设置:<pre><code>- `attach_adapter`, 它直接调用 i2c_probe (adap, 设备地址, 发现这个设备后要调用的函数)
- `detach_client`,  卸载这个驱动后,如果之前发现能够支持的设备,则调用它来清理
</code></pre>
</li>
<li>注册： <code>i2c_add_driver</code></li>
<li>注册为<code>字符设备</code>或其它. 如 <code>input系统</code> <code>块设备</code>, 并实现对应的操作函数.</li>
</ul>
<h2 id="at24cxx-c"><a href="#at24cxx-c" class="headerlink" title="at24cxx.c"></a>at24cxx.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/jiffies.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> ignore[]      = &#123; I2C_CLIENT_END &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> normal_addr[] = &#123; <span class="number">0x50</span>, I2C_CLIENT_END &#125;;     <span class="comment">// 地址值是7位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ignore 数组范例</span></span><br><span class="line"><span class="comment">// static unsigned short ignore[]      = &#123; ANY_I2C_BUS, 0x60, I2C_CLIENT_END &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// probe 数组范例</span></span><br><span class="line"><span class="comment">// static unsigned short probe[]       = &#123; ANY_I2C_BUS, 0x60, I2C_CLIENT_END &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// force 数组范例</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> force_addr[] = &#123;ANY_I2C_BUS, <span class="number">0x60</span>, I2C_CLIENT_END&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> *forces[] = &#123;force_addr, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client_address_data</span> <span class="title">addr_data</span> =</span> &#123;</span><br><span class="line">    .normal_i2c = normal_addr,              <span class="comment">// 要发出S信号和设备地址并得到ACK信号, 才确认设备存在</span></span><br><span class="line">    .probe      = ignore,</span><br><span class="line">    .ignore     = ignore,</span><br><span class="line">    <span class="comment">// 一般不用 .forces 的. 由于jz2440没有i2c从设备, 因此这里用一下.</span></span><br><span class="line">    .forces     = forces,                   <span class="comment">// 强制认为存在这个设备</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> major;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">cls</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">at24cxx_driver</span>;</span>    <span class="comment">// i2c_driver 结构体, 初始化在后面</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">at24cxx_client</span>;</span>          <span class="comment">// i2c_client 结构体</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">at24cxx_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> * offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> address;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span>                  <span class="comment">// i2c_msg 结构体</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">1</span>)                          <span class="comment">// 只接受1个参数, 表地址.</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    copy_from_user(&amp;address, buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读AT24CXX时,要先把要读的存储空间的地址发给它</span></span><br><span class="line">    msg[<span class="number">0</span>].addr  = at24cxx_client-&gt;addr;    <span class="comment">// 目的</span></span><br><span class="line">    msg[<span class="number">0</span>].buf   = &amp;address;                <span class="comment">// 源</span></span><br><span class="line">    msg[<span class="number">0</span>].len   = <span class="number">1</span>;                       <span class="comment">// 地址=1 byte</span></span><br><span class="line">    msg[<span class="number">0</span>].flags = <span class="number">0</span>;                       <span class="comment">// 表示写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后启动读操作</span></span><br><span class="line">    msg[<span class="number">1</span>].addr  = at24cxx_client-&gt;addr;    <span class="comment">// 源</span></span><br><span class="line">    msg[<span class="number">1</span>].buf   = &amp;data;                   <span class="comment">// 目的</span></span><br><span class="line">    msg[<span class="number">1</span>].len   = <span class="number">1</span>;                       <span class="comment">// 数据=1 byte</span></span><br><span class="line">    msg[<span class="number">1</span>].flags = I2C_M_RD;                <span class="comment">// 表示读</span></span><br><span class="line"></span><br><span class="line">    ret = i2c_transfer(at24cxx_client-&gt;adapter, msg, <span class="number">2</span>);    <span class="comment">// 发送+接受</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">2</span>) &#123;</span><br><span class="line">        copy_to_user(buf, &amp;data, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">at24cxx_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> val[<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[1];</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">2</span>)                          <span class="comment">// 只接受2个参数, 表地址和数据.</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    copy_from_user(val, buf, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    msg[<span class="number">0</span>].addr  = at24cxx_client-&gt;addr;    <span class="comment">// 目的</span></span><br><span class="line">    msg[<span class="number">0</span>].buf   = val;                     <span class="comment">// 源</span></span><br><span class="line">    msg[<span class="number">0</span>].len   = <span class="number">2</span>;                       <span class="comment">// 地址+数据=2 byte</span></span><br><span class="line">    msg[<span class="number">0</span>].flags = <span class="number">0</span>;                       <span class="comment">// 表示写</span></span><br><span class="line"></span><br><span class="line">    ret = i2c_transfer(at24cxx_client-&gt;adapter, msg, <span class="number">1</span>);    <span class="comment">// 发送</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">at24cxx_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .read  = at24cxx_read,</span><br><span class="line">    .write = at24cxx_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">at24cxx_detect</span><span class="params">(struct i2c_adapter *adapter, <span class="keyword">int</span> address, <span class="keyword">int</span> kind)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;at24cxx_detect\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个i2c_client结构体: 收发数据时会用到它</span></span><br><span class="line">    at24cxx_client = kzalloc(<span class="keyword">sizeof</span>(struct i2c_client), GFP_KERNEL);</span><br><span class="line">    at24cxx_client-&gt;addr    = address;</span><br><span class="line">    at24cxx_client-&gt;adapter = adapter;</span><br><span class="line">    at24cxx_client-&gt;driver  = &amp;at24cxx_driver;</span><br><span class="line">    <span class="built_in">strcpy</span>(at24cxx_client-&gt;name, <span class="string">&quot;at24cxx&quot;</span>);</span><br><span class="line">    i2c_attach_client(at24cxx_client);      <span class="comment">// 关联到 i2c_driver 和 i2c_adapter</span></span><br><span class="line"></span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;at24cxx&quot;</span>, &amp;at24cxx_fops);</span><br><span class="line"></span><br><span class="line">    cls = class_create(THIS_MODULE, <span class="string">&quot;at24cxx&quot;</span>);</span><br><span class="line">    class_device_create(cls, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;at24cxx&quot;</span>);           <span class="comment">// /dev/at24cxx</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">at24cxx_attach</span><span class="params">(struct i2c_adapter *adapter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 主动调用 probe 函数, 符合要求后, 会调用 at24cxx_detect</span></span><br><span class="line">    <span class="keyword">return</span> i2c_probe(adapter, &amp;addr_data, at24cxx_detect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">at24cxx_detach</span><span class="params">(struct i2c_client *client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;at24cxx_detach\n&quot;</span>);</span><br><span class="line">    class_device_destroy(cls, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">    class_destroy(cls);</span><br><span class="line">    unregister_chrdev(major, <span class="string">&quot;at24cxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    i2c_detach_client(client);</span><br><span class="line">    kfree(i2c_get_clientdata(client));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">at24cxx_driver</span> =</span> &#123; <span class="comment">// i2c_driver 结构体</span></span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;at24cxx&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .attach_adapter = at24cxx_attach,</span><br><span class="line">    .detach_client  = at24cxx_detach,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">at24cxx_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i2c_add_driver(&amp;at24cxx_driver);        <span class="comment">// i2c_add_driver, 会自动去匹配 i2c_add_adapter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">at24cxx_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i2c_del_driver(&amp;at24cxx_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(at24cxx_init);</span><br><span class="line">module_exit(at24cxx_exit);</span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TEST_FILE   := i2c_test</span><br><span class="line"></span><br><span class="line">obj-m       := at24cxx.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br><span class="line">    rm -f <span class="variable">$(TEST_FILE)</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">    arm-linux-gcc <span class="variable">$(TEST_FILE)</span>.c -o <span class="variable">$(TEST_FILE)</span></span><br></pre></td></tr></table></figure>


<h2 id="i2c-test-c"><a href="#i2c-test-c" class="headerlink" title="i2c_test.c"></a>i2c_test.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* i2c_test r addr</span></span><br><span class="line"><span class="comment"> * i2c_test w addr val</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_usage</span><span class="params">(<span class="keyword">char</span> *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s r addr\n&quot;</span>, file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s w addr val\n&quot;</span>, file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((argc != <span class="number">3</span>) &amp;&amp; (argc != <span class="number">4</span>)) &#123;</span><br><span class="line">        print_usage(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/at24cxx&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open /dev/at24cxx\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        buf[<span class="number">0</span>] = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        read(fd, buf, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;data: %c, %d, 0x%2x\n&quot;</span>, buf[<span class="number">0</span>], buf[<span class="number">0</span>], buf[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;w&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        buf[<span class="number">0</span>] = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        buf[<span class="number">1</span>] = strtoul(argv[<span class="number">3</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        write(fd, buf, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        print_usage(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/i2c/             # i2c驱动目录</span></span><br><span class="line">$ make modules</span><br><span class="line">$ make <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line">$ cat /proc/devices                             <span class="comment"># 注册的驱动, 如调用 &quot;register_chrdev&quot;</span></span><br><span class="line">$ ls /sys/class/                                <span class="comment"># 注册的类, 如调用 &quot;class_create&quot;</span></span><br><span class="line">i2c-adapter                                     <span class="comment"># 由 i2c-core.c 生成</span></span><br><span class="line"><span class="comment"># 里面有个 i2c-0 设备, 是i2c主机端概念,</span></span><br><span class="line"><span class="comment"># 由 i2c_add_adapter 生成. 就是 s3c2440-i2c.</span></span><br><span class="line"></span><br><span class="line">$ ls /sys/class/class_name                      <span class="comment"># 注册的设备, 如调用 &quot;device_create&quot;</span></span><br><span class="line">$ ls /dev/                                      <span class="comment"># mdev根据注册的设备, 使用mknod生成的设备节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440//kernel/linux-2.6.22.6/drivers/i2c   # i2c驱动目录, nfs</span></span><br><span class="line">$ insmod i2c-dev.ko                             <span class="comment"># 加载系统自带的i2c</span></span><br><span class="line"><span class="comment"># 源码里会调用 i2c_add_driver 表示一个从机设备, 供APP端直接操作此i2c设备</span></span><br><span class="line"></span><br><span class="line">$ cat /proc/devices</span><br><span class="line"> 89 i2c                                         <span class="comment"># 固定的主设备号89, i2c 从设备</span></span><br><span class="line">$ ls /sys/class/</span><br><span class="line">i2c-dev                                         <span class="comment"># 找到了 i2c-dev 类</span></span><br><span class="line">$ ls /sys/class/i2c-dev</span><br><span class="line">i2c-0                                           <span class="comment"># 这个i2c0是从机端概念, 由 i2c_add_driver 生成</span></span><br><span class="line"><span class="comment"># ls /dev/i2c*</span></span><br><span class="line">/dev/i2c-0                                      <span class="comment"># 是 i2c-dev 的 i2c-0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续做实验</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/i2c/             # i2c驱动目录, nfs</span></span><br><span class="line">$ insmod at24cxx.ko                             <span class="comment"># 加载驱动</span></span><br><span class="line">at24cxx_detect                                  <span class="comment"># 使用的强制加载, 因此没有外设也说检测到了</span></span><br><span class="line"></span><br><span class="line">$ cat /proc/devices</span><br><span class="line"> 89 i2c                                         <span class="comment"># APP可以通过这里操作i2c底层</span></span><br><span class="line">252 at24cxx                                     <span class="comment"># APP可以通过这里认为只是在读写eeprom, 虽然底层实现是i2c通讯</span></span><br><span class="line">$ ls /sys/class/</span><br><span class="line">at24cxx                                         <span class="comment"># 由自己的i2c驱动代码生成, 与 i2c_add_driver 相关</span></span><br><span class="line">i2c-adapter                                     <span class="comment"># 由 i2c-core 生成, 与 i2c_add_adapter 相关</span></span><br><span class="line">i2c-dev                                         <span class="comment"># 由 i2c-dev 生成, 与 i2c_add_driver 相关</span></span><br><span class="line">$ ls /dev/at* /dev/i2c*</span><br><span class="line">/dev/at24cxx  /dev/i2c-0                        <span class="comment"># 两个设备节点.</span></span><br><span class="line"><span class="comment"># i2c-adapter 是不会出现在这里的. 因为只会对i2c从机进行读写操作, 是不会对i2c主机做什么操作的.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># at24c芯片操作.</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/i2c/             # i2c驱动目录, nfs</span></span><br><span class="line">$ ./i2c_test r 0</span><br><span class="line">$ ./i2c_test w 0 0x59</span><br><span class="line">$ ./i2c_test r 0                                <span class="comment"># 回读应该也是 0x59 才对.</span></span><br><span class="line"><span class="comment"># 断电后再读也应该是0x59. eeprom是非易失性存储器</span></span><br><span class="line"><span class="comment"># 对jz2440肯定是失败的, 因为没有这个外设.</span></span><br></pre></td></tr></table></figure>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/lcw/p/3297889.html">【驱动】linux下I2C驱动架构全面分析</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/hanmengaidudu/article/details/10159787">用户空间使用i2c-dev.c</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/08/1814-drv-rtc/" class="post-title-link" itemprop="url">驱动之RTC分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2018-02-08 00:00:00 / Modified: 11:06:08" itemprop="dateCreated datePublished" datetime="2018-02-08T00:00:00+11:00">2018-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/embedded-linux/" itemprop="url" rel="index"><span itemprop="name">embedded linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a></li>
<li><a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a></li>
<li><a href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">驱动之RTC分析</a></li>
<li><a href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">驱动之LCD驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/11/1806-drv-ts/">驱动之触摸屏驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">驱动之USB基础概念和框架</a></li>
<li><a href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">驱动之USB设备驱动程序</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="字符设备驱动另一种写法"><a href="#字符设备驱动另一种写法" class="headerlink" title="字符设备驱动另一种写法"></a>字符设备驱动另一种写法</h1><p>在 <a href="https://draapho.github.io/2017/11/22/1733-drv-chr1/">驱动之字符设备-框架</a> 里, 使用的是函数 <code>register_chrdev</code> 进行注册的.<br>其缺点是, 默认调用了 <code>__register_chrdev_region(major, 0, 256, name);</code>, 也就是会把256个次设备号全部注册掉.<br>为了合理使用次设备号, 就需要另外一种写法.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> major;                               <span class="comment">// 确定主设备号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_fops</span> =</span> &#123;    <span class="comment">// fop数据结构</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = hello_open,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __init hello_init(<span class="keyword">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主设备号已知, 用 register_chrdev_region 即可</span></span><br><span class="line">    <span class="comment">// devid = MKDEV(major, 0);</span></span><br><span class="line">    <span class="comment">// register_chrdev_region(devid, HELLO_CNT, &quot;hello&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主设备号需要系统分配, 用 alloc_chrdev_region 函数</span></span><br><span class="line">    alloc_chrdev_region(&amp;devid, <span class="number">0</span>, HELLO_CNT, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    major = MAJOR(devid);                       <span class="comment">// 提取主设备号</span></span><br><span class="line"></span><br><span class="line">    cls = class_create(THIS_MODULE, <span class="string">&quot;hello&quot;</span>);   <span class="comment">// 创建类</span></span><br><span class="line">    cdev_init(&amp;hello_cdev, &amp;hello_fops);        <span class="comment">// 初始化</span></span><br><span class="line">    cdev_add(&amp;hello_cdev, devid, HELLO_CNT);    <span class="comment">// 添加指定个数的字符设备</span></span><br><span class="line">    device_create(cls , <span class="literal">NULL</span> , MKDEV(major, <span class="number">0</span>), <span class="string">&quot;hello0&quot;</span>);  <span class="comment">// 和 class_device_create 没有本质区别.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质上, 就是自己实现一遍 <code>register_chrdev</code> 函数里的内容, 来控制子设备号个数.<br>博客里 <a href="https://draapho.github.io/2017/11/30/1740-drv-chr2/">驱动之基于LinK+设计按键驱动</a> 这些内容都是由 <code>LinK+</code> 自动实现的.</p>
<h1 id="RTC源码分析"><a href="#RTC源码分析" class="headerlink" title="RTC源码分析"></a>RTC源码分析</h1><p>这里以RTC源码为例进行分析, 用于熟悉字符设备的写法和分离分层即platform的概念</p>
<p><code>/drivers/rtc/rtc-dev.c</code> 提供了所有的RTC驱动层读写函数.<br>里面进一步调用了 <code>/drivers/rtc/class.c</code> 的一些函数.<br>这两个文件是linux内核RTC驱动设备的软件抽象核心.</p>
<p>显然的, 后面的很多文件是芯片厂商提供的硬件相关的RTC部分. 譬如 <code>rtc-s3c.c</code>.<br>也可以通过分析 <code>rtc-dev.c</code> 里的 <code>rtc_dev_add_device</code> 倒过来找到这些文件.</p>
<p>下面, 我们从底层硬件(<code>rtc-s3c.c</code>)往上层进行分析, 看看rtc字符设备的整个注册过程.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// subsys_initcall(rtc_init), 系统初始化时调用</span></span><br><span class="line">rtc_init();                                         <span class="comment">// 此函数位于 &quot;class.c&quot;</span></span><br><span class="line">    class_create(THIS_MODULE, <span class="string">&quot;rtc&quot;</span>);               <span class="comment">// =====&gt; class_create</span></span><br><span class="line">    rtc_dev_init();</span><br><span class="line">        alloc_chrdev_region();                      <span class="comment">// =====&gt; alloc_chrdev_region, 分配 RTC_DEV_MAX 个子设备号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// module_init(s3c_rtc_init), 驱动入口函数. insmod 时被调用</span></span><br><span class="line">s3c_rtc_init();                                     <span class="comment">// 此函数位于 &quot;rtc-s3c.c&quot;</span></span><br><span class="line">    platform_driver_register(&amp;s3c2410_rtcdrv);</span><br><span class="line">    <span class="comment">// 明显用了platform框架, 根据 .name = &quot;s3c2410-rtc&quot; 去找 platform_device_register</span></span><br><span class="line">    <span class="comment">// 在 &quot;/arch/arm/plat-s3c24xx/devs.c&quot; 下找到了 s3c_device_rtc. 但没有被内核调用. 后面再说.</span></span><br><span class="line">s3c_rtc_probe();                                    <span class="comment">// platform 的 driver 和 device 匹配后, 自动调用 probe</span></span><br><span class="line">    <span class="comment">// 一系列的RTC硬件相关操作, 忽略</span></span><br><span class="line">    rtc_device_register();                          <span class="comment">// 此函数位于 &quot;class.c&quot;</span></span><br><span class="line">        rtc_dev_prepare();                          <span class="comment">// 此函数位于 &quot;rtc-dev.c&quot;</span></span><br><span class="line">            rtc-&gt;dev.devt = MKDEV(MAJOR(rtc_devt), rtc-&gt;id);</span><br><span class="line">            cdev_init();                            <span class="comment">// =====&gt; cdev_init</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// device_create 里最终调用的就是 device_register.</span></span><br><span class="line">        <span class="comment">// rtc-&gt;dev.devt 的值已经在 rtc_dev_prepare 设置好了.</span></span><br><span class="line">        device_register();                          <span class="comment">// =====&gt; 等效于 device_create.</span></span><br><span class="line">        rtc_dev_add_device();</span><br><span class="line">            cdev_add();                             <span class="comment">// =====&gt; cdev_add</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这两个函数似乎也和设备注册相关. 详请不明</span></span><br><span class="line">        rtc_sysfs_add_device();</span><br><span class="line">        rtc_proc_add_device();</span><br></pre></td></tr></table></figure>

<h1 id="RTC-测试"><a href="#RTC-测试" class="headerlink" title="RTC 测试"></a>RTC 测试</h1><p>前面的分析源码说过, <code>s3c_device_rtc</code> 没有被调用, 因此当前的系统也无法使用rtc.<br>这里就加入rtc功能, 并测试.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6</span></span><br><span class="line"><span class="comment"># 打开 ./arch/arm/plat-s3c24xx/common-smdk.c</span></span><br><span class="line">    <span class="comment"># 找到数组 static struct platform_device __initdata *smdk_devs[]</span></span><br><span class="line">    <span class="comment"># 加入一行   &amp;s3c_device_rtc,</span></span><br><span class="line">    <span class="comment"># 此数组会被 &quot;smdk_machine_init&quot; 调用, 里面有 &quot;platform_add_devices&quot;,</span></span><br><span class="line">    <span class="comment"># 此函数会对数组里的内容依次进行 &quot;platform_device_register&quot;</span></span><br><span class="line"></span><br><span class="line">$ make clean                                    <span class="comment"># 没把握的话, clean一下</span></span><br><span class="line">$ make uImage</span><br><span class="line"><span class="comment"># 烧录新的uImage</span></span><br><span class="line"><span class="comment"># 重启开发板进入uboot烧录界面, 按k准备烧录内核. 略过不表</span></span><br><span class="line">$ sudo dnw ./arch/arm/boot/uImage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line">$ ls /dev/rtc* -l                               <span class="comment"># 查看设备, 有 rtc0</span></span><br><span class="line">$ date                                          <span class="comment"># 显示系统时间</span></span><br><span class="line">Mon Apr  3 06:53:50 UTC 2006</span><br><span class="line"></span><br><span class="line">$ date 020811002018.30                          <span class="comment"># 设置系统时间 date [MMDDhhmm[[CC]YY][.ss]]</span></span><br><span class="line">Thu Feb  8 11:00:30 UTC 2018</span><br><span class="line">$ hwclock -w                                    <span class="comment"># 把系统时间写入RTC. HardWare CLOCK</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 断电, 重启.</span></span><br><span class="line">$ date</span><br><span class="line">Thu Feb  8 11:02:01 UTC 2018                    <span class="comment"># 设置的时间还在.</span></span><br></pre></td></tr></table></figure>





<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2018/02/06/1813-drv-net/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/06/1813-drv-net/" class="post-title-link" itemprop="url">驱动之网卡驱动</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2018-02-06 00:00:00 / Modified: 20:16:30" itemprop="dateCreated datePublished" datetime="2018-02-06T00:00:00+11:00">2018-02-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/embedded-linux/" itemprop="url" rel="index"><span itemprop="name">embedded linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/22/1809-drv-blk/">驱动之块设备-框架</a></li>
<li><a href="https://draapho.github.io/2018/01/24/1810-drv-nand1/">驱动之NAND Flash框架</a></li>
<li><a href="https://draapho.github.io/2018/01/25/1811-drv-nand2/">驱动之NAND Flash源码</a></li>
<li><a href="https://draapho.github.io/2018/01/26/1812-drv-nor/">驱动之NOR Flash</a></li>
<li><a href="https://draapho.github.io/2018/02/06/1813-drv-net/">驱动之网卡驱动</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="虚拟网卡源码"><a href="#虚拟网卡源码" class="headerlink" title="虚拟网卡源码"></a>虚拟网卡源码</h1><p>网络驱动的实现很复杂, Linux内核都帮我们做掉了, 对用户端直接进行socket编程即可.<br>而具体到硬件, 网卡驱动十分简单. 与网络驱动通过二个函数和一个变量.</p>
<ul>
<li>网卡发送函数: <code>hard_start_xmit</code></li>
<li>网卡接收函数: <code>netif_rx</code></li>
<li>数据: <code>sk_buff</code></li>
</ul>
<p>网卡驱动的基本步骤:</p>
<ol>
<li>分配一个 <code>net_device</code> 结构体: <code>alloc_netdev</code></li>
<li>设置: 实现发送 <code>hard_start_xmit</code>, 接收 <code>netif_rx</code>, 以及其它设置</li>
<li>发送函数注意使用 <code>netif_stop_queue</code> <code>dev_kfree_skb_irq</code> <code>netif_wake_queue</code></li>
<li>注册: <code>register_netdev</code>.</li>
</ol>
<h2 id="vnet-c"><a href="#vnet-c" class="headerlink" title="vnet.c"></a>vnet.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考 drivers\net\cs89x0.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/etherdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bitops.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/system.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">vnet_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参考LDD3, 虚构一个ping应答包</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">emulator_rx_packet</span><span class="params">(struct sk_buff *skb, struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *type;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ih</span>;</span></span><br><span class="line">    __be32 *saddr, *daddr, tmp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   tmp_dev_addr[ETH_ALEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">ethhdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">rx_skb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从硬件读出/保存数据</span></span><br><span class="line">    ethhdr = (struct ethhdr *)skb-&gt;data;                        <span class="comment">// 对调源/目的的mac地址</span></span><br><span class="line">    <span class="built_in">memcpy</span>(tmp_dev_addr, ethhdr-&gt;h_dest, ETH_ALEN);</span><br><span class="line">    <span class="built_in">memcpy</span>(ethhdr-&gt;h_dest, ethhdr-&gt;h_source, ETH_ALEN);</span><br><span class="line">    <span class="built_in">memcpy</span>(ethhdr-&gt;h_source, tmp_dev_addr, ETH_ALEN);</span><br><span class="line"></span><br><span class="line">    ih = (struct iphdr *)(skb-&gt;data + <span class="keyword">sizeof</span>(struct ethhdr));   <span class="comment">// 对调源/目的的ip地址</span></span><br><span class="line">    saddr = &amp;ih-&gt;saddr;</span><br><span class="line">    daddr = &amp;ih-&gt;daddr;</span><br><span class="line">    tmp = *saddr;</span><br><span class="line">    *saddr = *daddr;</span><br><span class="line">    *daddr = tmp;</span><br><span class="line">    <span class="comment">//((u8 *)saddr)[2] ^= 1; /* change the third octet (class C) */</span></span><br><span class="line">    <span class="comment">//((u8 *)daddr)[2] ^= 1;</span></span><br><span class="line"></span><br><span class="line">    type = skb-&gt;data + <span class="keyword">sizeof</span>(struct ethhdr) + <span class="keyword">sizeof</span>(struct iphdr);</span><br><span class="line">    <span class="comment">// printk(&quot;tx package type = %02x\n&quot;, *type);</span></span><br><span class="line">    *type = <span class="number">0</span>;                                  <span class="comment">// 修改类型, 原来0x8表示ping, 0表示reply</span></span><br><span class="line">    ih-&gt;check = <span class="number">0</span>;                              <span class="comment">// rebuild the checksum (ip needs it)</span></span><br><span class="line">    ih-&gt;check = ip_fast_csum((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)ih,ih-&gt;ihl);</span><br><span class="line"></span><br><span class="line">    rx_skb = dev_alloc_skb(skb-&gt;len + <span class="number">2</span>);       <span class="comment">// 构造一个sk_buff</span></span><br><span class="line">    skb_reserve(rx_skb, <span class="number">2</span>);                     <span class="comment">// align IP on 16B boundary</span></span><br><span class="line">    <span class="built_in">memcpy</span>(skb_put(rx_skb, skb-&gt;len), skb-&gt;data, skb-&gt;len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write metadata, and then pass to the receive level */</span></span><br><span class="line">    rx_skb-&gt;dev = dev;</span><br><span class="line">    rx_skb-&gt;protocol = eth_type_trans(rx_skb, dev);</span><br><span class="line">    rx_skb-&gt;ip_summed = CHECKSUM_UNNECESSARY; <span class="comment">/* don&#x27;t check it */</span></span><br><span class="line">    dev-&gt;stats.rx_packets++;</span><br><span class="line">    dev-&gt;stats.rx_bytes += skb-&gt;len;</span><br><span class="line"></span><br><span class="line">    netif_rx(rx_skb);                           <span class="comment">// 提交sk_buff</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vnet_send_packet</span><span class="params">(struct sk_buff *skb, struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    printk(<span class="string">&quot;virt_net_send_packet cnt = %d\n&quot;</span>, ++cnt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对于真实的网卡, 把skb里的数据通过网卡发送出去 */</span></span><br><span class="line">    netif_stop_queue(dev);                      <span class="comment">// 停止该网卡的队列</span></span><br><span class="line">    <span class="comment">/* 实际网卡的话, 把skb的数据写入网卡 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用发送的数据虚构应答数据, 所以放这里了</span></span><br><span class="line"><span class="comment">     * 实际网卡应该是用中断实现数据接收和 netif_rx 上报的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    emulator_rx_packet(skb, dev);</span><br><span class="line">    dev-&gt;stats.tx_packets++;                    <span class="comment">// 更新统计信息</span></span><br><span class="line">    dev-&gt;stats.tx_bytes += skb-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断里的话, 需要使用 dev_kfree_skb_irq</span></span><br><span class="line">    dev_kfree_skb (skb);                        <span class="comment">// 释放skb.</span></span><br><span class="line">    netif_wake_queue(dev);                      <span class="comment">// 数据全部发送出去后,唤醒网卡的队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vnet_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 1. 分配一个net_device结构体 */</span></span><br><span class="line">    vnet_dev = alloc_netdev(<span class="number">0</span>, <span class="string">&quot;vnet%d&quot;</span>, ether_setup);</span><br><span class="line">    <span class="comment">// 也可用 alloc_etherdev 指定了网卡名称为 eth%d</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 设置 */</span></span><br><span class="line">    vnet_dev-&gt;hard_start_xmit = vnet_send_packet;   <span class="comment">// 指定发送函数</span></span><br><span class="line">    vnet_dev-&gt;dev_addr[<span class="number">0</span>] = <span class="number">0x08</span>;                   <span class="comment">// 设置MAC地址</span></span><br><span class="line">    vnet_dev-&gt;dev_addr[<span class="number">1</span>] = <span class="number">0x89</span>;</span><br><span class="line">    vnet_dev-&gt;dev_addr[<span class="number">2</span>] = <span class="number">0x89</span>;</span><br><span class="line">    vnet_dev-&gt;dev_addr[<span class="number">3</span>] = <span class="number">0x89</span>;</span><br><span class="line">    vnet_dev-&gt;dev_addr[<span class="number">4</span>] = <span class="number">0x89</span>;</span><br><span class="line">    vnet_dev-&gt;dev_addr[<span class="number">5</span>] = <span class="number">0x11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置下面两项才能ping通</span></span><br><span class="line">    vnet_dev-&gt;flags    |= IFF_NOARP;</span><br><span class="line">    vnet_dev-&gt;features |= NETIF_F_NO_CSUM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 注册 */</span></span><br><span class="line">    register_netdev(vnet_dev);</span><br><span class="line">    <span class="comment">// 不建议直接使用 register_netdevice.</span></span><br><span class="line">    <span class="comment">// register_netdev 是 register_netdevice 的加锁版.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vnet_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unregister_netdev(vnet_dev);</span><br><span class="line">    free_netdev(vnet_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(vnet_init);</span><br><span class="line">module_exit(vnet_exit);</span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m       := vnet.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/net/             # net驱动目录</span></span><br><span class="line">$ make modules                                  <span class="comment"># 生成vnet.ko</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/net/             # net驱动目录, nfs</span></span><br><span class="line">$ insmod vnet.ko                                <span class="comment"># 加载驱动</span></span><br><span class="line"></span><br><span class="line">$ ifconfig vnet0 3.3.3.3                        <span class="comment"># 设置ip</span></span><br><span class="line">$ ifconfig                                      <span class="comment"># 查看网卡信息</span></span><br><span class="line">eth0      ......</span><br><span class="line">vnet0     Link encap:Ethernet  HWaddr 08:89:89:89:89:11             <span class="comment"># mac地址</span></span><br><span class="line">          inet addr:3.3.3.3  Bcast:3.255.255.255  Mask:255.0.0.0    <span class="comment"># ip地址相关</span></span><br><span class="line">          UP BROADCAST RUNNING NOARP MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">$ ping 3.3.3.3                                  <span class="comment"># ping自己</span></span><br><span class="line">PING 3.3.3.3 (3.3.3.3): 56 data bytes</span><br><span class="line"><span class="comment"># 这里没有应答, 应该是没有设置lo回环的关系.</span></span><br><span class="line"><span class="comment"># 可以知道 ping 自己不会调用到底层的网卡驱动</span></span><br><span class="line">$ ping 3.3.3.4                                  <span class="comment"># ping其它网段</span></span><br><span class="line">PING 3.3.3.4 (3.3.3.4): 56 data bytes</span><br><span class="line">virt_net_send_packet cnt = 1                    <span class="comment"># 代码里的发送计数</span></span><br><span class="line">64 bytes from 3.3.3.4: seq=0 ttl=64 time=0.856 ms</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">$ ifconfig                                      <span class="comment"># 查看网卡信息</span></span><br><span class="line"><span class="comment"># 可以查看 RX packets, TX packets, RX bytes, TX bytes</span></span><br></pre></td></tr></table></figure>


<h1 id="移植网卡驱动"><a href="#移植网卡驱动" class="headerlink" title="移植网卡驱动"></a>移植网卡驱动</h1><p>在实际选用网卡时, 网卡厂商都会提供linux驱动.<br>只需要在此基础上, 针对自己的板子, 部分修改即可.<br>网卡对于s3c2440而言, 其物理接口用的是 <code>MEMORY CONTROLLER</code><br>主要的注意点如下:</p>
<ul>
<li>网卡位宽: 8/16, 实际用的16位宽</li>
<li>片选使用了 <code>nGCS4</code>, 对应基地址为 <code>0x20000000</code></li>
<li>DM9000C 的<code>CMD</code>接的是<code>LADDR2</code>, 因此读指令时, LADDR2要置位.</li>
<li>收发数据时, 中断引脚的设置.</li>
<li>初始化时, S3C2440端相关的寄存器设置.</li>
<li>复位应交 <code>nRESET</code>, 如果需要软件对网卡进行硬件复位, 则需要自己实现.</li>
<li>其它引脚如 <code>LANACK</code> <code>LANLINK</code>, 可知接到led上的, 无需关心.</li>
</ul>
<h2 id="dm9dev9000c-c"><a href="#dm9dev9000c-c" class="headerlink" title="dm9dev9000c.c"></a>dm9dev9000c.c</h2><p>下面, 基于 DM9000C 的厂家驱动, 针对 jz2440 开发板进行修改.<br>修改的地方全部会打上标记 <code>===== for jz2440 ===== </code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  dm9ks.c: Version 2.08 2007/02/12</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        A Davicom DM9000/DM9010 ISA NIC fast Ethernet driver for Linux.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    This program is free software; you can redistribute it and/or</span></span><br><span class="line"><span class="comment">    modify it under the terms of the GNU General Public License</span></span><br><span class="line"><span class="comment">    as published by the Free Software Foundation; either version 2</span></span><br><span class="line"><span class="comment">    of the License, or (at your option) any later version.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    This program is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment">    GNU General Public License for more details.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  (C)Copyright 1997-2007 DAVICOM Semiconductor,Inc. All Rights Reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">V2.00 Spenser - 01/10/2005</span></span><br><span class="line"><span class="comment">            - Modification for PXA270 MAINSTONE.</span></span><br><span class="line"><span class="comment">            - Modified dmfe_tx_done().</span></span><br><span class="line"><span class="comment">            - Add dmfe_timeout().</span></span><br><span class="line"><span class="comment">V2.01   10/07/2005  -Modified dmfe_timer()</span></span><br><span class="line"><span class="comment">            -Dected network speed 10/100M</span></span><br><span class="line"><span class="comment">V2.02   10/12/2005  -Use link change to chage db-&gt;Speed</span></span><br><span class="line"><span class="comment">            -dmfe_open() wait for Link OK</span></span><br><span class="line"><span class="comment">V2.03   11/22/2005  -Power-off and Power-on PHY in dmfe_init_dm9000()</span></span><br><span class="line"><span class="comment">            -support IOL</span></span><br><span class="line"><span class="comment">V2.04   12/13/2005  -delay 1.6s between power-on and power-off in</span></span><br><span class="line"><span class="comment">             dmfe_init_dm9000()</span></span><br><span class="line"><span class="comment">            -set LED mode 1 in dmfe_init_dm9000()</span></span><br><span class="line"><span class="comment">            -add data bus driving capability in dmfe_init_dm9000()</span></span><br><span class="line"><span class="comment">             (optional)</span></span><br><span class="line"><span class="comment">10/3/2006   -Add DM8606 read/write function by MDC and MDIO</span></span><br><span class="line"><span class="comment">V2.06   01/03/2007  -CONT_RX_PKT_CNT=0xFFFF</span></span><br><span class="line"><span class="comment">            -modify dmfe_tx_done function</span></span><br><span class="line"><span class="comment">            -check RX FIFO pointer</span></span><br><span class="line"><span class="comment">            -if using physical address, re-define I/O function</span></span><br><span class="line"><span class="comment">            -add db-&gt;cont_rx_pkt_cnt=0 at the front of dmfe_packet_receive()</span></span><br><span class="line"><span class="comment">V2.08   02/12/2007  -module parameter macro</span></span><br><span class="line"><span class="comment">            2.4  MODULE_PARM</span></span><br><span class="line"><span class="comment">            2.6  module_param</span></span><br><span class="line"><span class="comment">            -remove #include &lt;linux/config&gt;</span></span><br><span class="line"><span class="comment">            -fix dmfe_interrupt for kernel 2.6.20</span></span><br><span class="line"><span class="comment">V2.09 05/24/2007    -support ethtool and mii-tool</span></span><br><span class="line"><span class="comment">05/30/2007  -fix the driver bug when ifconfig eth0 (-)promisc and (-)allmulti.</span></span><br><span class="line"><span class="comment">06/05/2007  -fix dm9000b issue(ex. 10M TX idle=65mA, 10M harmonic)</span></span><br><span class="line"><span class="comment">            -add flow control function (option)</span></span><br><span class="line"><span class="comment">10/01/2007  -Add #include &lt;asm/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">            -Modyfy dmfe_do_ioctl for kernel 2.6.7</span></span><br><span class="line"><span class="comment">11/23/2007  -Add TDBUG to check TX FIFO pointer shift</span></span><br><span class="line"><span class="comment">            - Remove check_rx_ready()</span></span><br><span class="line"><span class="comment">        - Add #define CHECKSUM to modify CHECKSUM function</span></span><br><span class="line"><span class="comment">12/20/2007  -Modify TX timeout routine(+)check TCR&amp;0x01</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define CHECKSUM</span></span><br><span class="line"><span class="comment">//#define TDBUG     /* check TX FIFO pointer */</span></span><br><span class="line"><span class="comment">//#define RDBUG   /* check RX FIFO pointer */</span></span><br><span class="line"><span class="comment">//#define DM8606</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_NAME    <span class="meta-string">&quot;dm9KS&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_VERSION <span class="meta-string">&quot;2.09&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_RELDATE <span class="meta-string">&quot;2007-11-22&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MODVERSIONS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/modversions.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;linux/config.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/etherdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/dma.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/crc32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mii.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ethtool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_MAINSTONE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/hardware.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== for jz2440 =====</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch-s3c2410/regs-mem.h&gt;</span></span></span><br><span class="line"><span class="comment">// ===== end =====</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Board/System/Debug information/definition ---------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_ID        0x90000A46</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9010_ID       0x90100A46</span></span><br><span class="line"><span class="comment">/*-------register name-----------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_NCR       0x00    <span class="comment">/* Network control Reg.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_NSR       0x01    <span class="comment">/* Network Status Reg.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_TCR       0x02    <span class="comment">/* TX control Reg.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_RXCR      0x05    <span class="comment">/* RX control Reg.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_BPTR      0x08</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_FCTR      0x09</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_FCR           0x0a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_EPCR      0x0b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_EPAR      0x0c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_EPDRL     0x0d</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_EPDRH     0x0e</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_GPR           0x1f    <span class="comment">/* General purpose register */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_CHIPR     0x2c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_TCR2      0x2d</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_SMCR      0x2f    <span class="comment">/* Special Mode Control Reg.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_ETXCSR    0x30    <span class="comment">/* Early Transmit control/status Reg.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_TCCR      0x31    <span class="comment">/* Checksum cntrol Reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_RCSR      0x32    <span class="comment">/* Receive Checksum status Reg.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_BUSCR     0x38</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MRCMDX    0xf0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MRCMD     0xf2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MDRAL     0xf4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MDRAH     0xf5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MWCMD     0xf8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MDWAL     0xfa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MDWAH     0xfb</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_TXPLL     0xfc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_TXPLH     0xfd</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_ISR           0xfe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_IMR           0xff</span></span><br><span class="line"><span class="comment">/*---------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_REG05     0x30    <span class="comment">/* SKIP_CRC/SKIP_LONG */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_REGFF     0xA3    <span class="comment">/* IMR */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_DISINTR   0x80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_PHY           0x40    <span class="comment">/* PHY address 0x01 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_PKT_RDY       0x01    <span class="comment">/* Packet ready to receive */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Added for PXA of MAINSTONE */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_MAINSTONE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/mainstone.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MIN_IO        (MST_ETH_PHYS + 0x300)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MAX_IO            (MST_ETH_PHYS + 0x370)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9K_IRQ        MAINSTONE_IRQ(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MIN_IO        0x300</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_MAX_IO        0x370</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_IRQ       3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_VID_L     0x28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_VID_H     0x29</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_PID_L     0x2A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_PID_H     0x2B</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_RX_INTR       0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_TX_INTR       0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_LINK_INTR     0x20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_DWORD_MODE    1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_BYTE_MODE     2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9KS_WORD_MODE     0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE            1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE           0</span></span><br><span class="line"><span class="comment">/* Number of continuous Rx packets */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONT_RX_PKT_CNT     0xFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DMFE_TIMER_WUT  jiffies+(HZ*5)  <span class="comment">/* timer wakeup time : 5 second */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DM9KS_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DMFE_DBUG(dbug_now, msg, vaule)\</span></span><br><span class="line"><span class="keyword">if</span> (dmfe_debug||dbug_now) printk(KERN_ERR <span class="string">&quot;dmfe: %s %x\n&quot;</span>, msg, vaule)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DMFE_DBUG(dbug_now, msg, vaule)\</span></span><br><span class="line"><span class="keyword">if</span> (dbug_now) printk(KERN_ERR <span class="string">&quot;dmfe: %s %x\n&quot;</span>, msg, vaule)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_ARCH_MAINSTONE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RX_DESC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u8 rxbyte;</span><br><span class="line">    u8 status;</span><br><span class="line">    u16 length;</span><br><span class="line">&#125;RX_DESC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    u8 buf[<span class="number">4</span>];</span><br><span class="line">    RX_DESC desc;</span><br><span class="line">&#125; <span class="keyword">rx_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_ARCH_MAINSTONE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DM9KS_PHY_mode</span> &#123;</span></span><br><span class="line">    DM9KS_10MHD   = <span class="number">0</span>,</span><br><span class="line">    DM9KS_100MHD  = <span class="number">1</span>,</span><br><span class="line">    DM9KS_10MFD   = <span class="number">4</span>,</span><br><span class="line">    DM9KS_100MFD  = <span class="number">5</span>,</span><br><span class="line">    DM9KS_AUTO    = <span class="number">8</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Structure/enum declaration ------------------------------- */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">board_info</span> &#123;</span></span><br><span class="line">    u32 io_addr;<span class="comment">/* Register I/O base address */</span></span><br><span class="line">    u32 io_data;<span class="comment">/* Data I/O address */</span></span><br><span class="line">    u8 op_mode;<span class="comment">/* PHY operation mode */</span></span><br><span class="line">    u8 io_mode;<span class="comment">/* 0:word, 2:byte */</span></span><br><span class="line">    u8 Speed;   <span class="comment">/* current speed */</span></span><br><span class="line">    u8 chip_revision;</span><br><span class="line">    <span class="keyword">int</span> rx_csum;<span class="comment">/* 0:disable, 1:enable */</span></span><br><span class="line"></span><br><span class="line">    u32 reset_counter;<span class="comment">/* counter: RESET */</span></span><br><span class="line">    u32 reset_tx_timeout;<span class="comment">/* RESET caused by TX Timeout */</span></span><br><span class="line">    <span class="keyword">int</span> tx_pkt_cnt;</span><br><span class="line">    <span class="keyword">int</span> cont_rx_pkt_cnt;<span class="comment">/* current number of continuos rx packets  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device_stats</span> <span class="title">stats</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> srom[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mii_if_info</span> <span class="title">mii</span>;</span></span><br><span class="line">&#125; <span class="keyword">board_info_t</span>;</span><br><span class="line"><span class="comment">/* Global variable declaration ----------------------------- */</span></span><br><span class="line"><span class="comment">/*static int dmfe_debug = 0;*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> * <span class="title">dmfe_dev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ethtool_ops</span> <span class="title">dmfe_ethtool_ops</span>;</span></span><br><span class="line"><span class="comment">/* For module input parameter */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> mode       = DM9KS_AUTO;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> media_mode = DM9KS_AUTO;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>  irq        = DM9KS_IRQ;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> iobase     = DM9KS_MIN_IO;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0  <span class="comment">// use physical address; Not virtual address</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> outb</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> outb</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> outw</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> outw</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> outl</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> outl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> inb</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> inb</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> inw</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> inw</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> inl</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> inl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outb</span><span class="params">(u8 reg, u32 ioaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*(<span class="keyword">volatile</span> u8 *)(ioaddr)) = reg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outw</span><span class="params">(u16 reg, u32 ioaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*(<span class="keyword">volatile</span> u16 *)(ioaddr)) = reg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outl</span><span class="params">(u32 reg, u32 ioaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*(<span class="keyword">volatile</span> u32 *)(ioaddr)) = reg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">u8 <span class="title">inb</span><span class="params">(u32 ioaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">volatile</span> u8 *)(ioaddr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">u16 <span class="title">inw</span><span class="params">(u32 ioaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">volatile</span> u16 *)(ioaddr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">u32 <span class="title">inl</span><span class="params">(u32 ioaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">volatile</span> u32 *)(ioaddr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* function declaration ------------------------------------- */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dmfe_probe1</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_open</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_start_xmit</span><span class="params">(struct sk_buff *, struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_tx_done</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_packet_receive</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_stop</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> struct net_device_stats * <span class="title">dmfe_get_stats</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_do_ioctl</span><span class="params">(struct net_device *, struct ifreq *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_interrupt</span><span class="params">(<span class="keyword">int</span> , <span class="keyword">void</span> *, struct pt_regs *)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,19)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">dmfe_interrupt</span><span class="params">(<span class="keyword">int</span> , <span class="keyword">void</span> *, struct pt_regs *)</span></span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">dmfe_interrupt</span><span class="params">(<span class="keyword">int</span> , <span class="keyword">void</span> *)</span></span>;<span class="comment">/* for kernel 2.6.20 */</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_timer</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_init_dm9000</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">cal_CRC</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, u8)</span></span>;</span><br><span class="line"><span class="function">u8 <span class="title">ior</span><span class="params">(<span class="keyword">board_info_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iow</span><span class="params">(<span class="keyword">board_info_t</span> *, <span class="keyword">int</span>, u8)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> u16 <span class="title">phy_read</span><span class="params">(<span class="keyword">board_info_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">phy_write</span><span class="params">(<span class="keyword">board_info_t</span> *, <span class="keyword">int</span>, u16)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> u16 <span class="title">read_srom_word</span><span class="params">(<span class="keyword">board_info_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dm9000_hash_table</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_timeout</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_reset</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mdio_read</span><span class="params">(struct net_device *, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mdio_write</span><span class="params">(struct net_device *, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_get_drvinfo</span><span class="params">(struct net_device *, struct ethtool_drvinfo *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_get_settings</span><span class="params">(struct net_device *, struct ethtool_cmd *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_set_settings</span><span class="params">(struct net_device *, struct ethtool_cmd *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">dmfe_get_link</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_nway_reset</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">dmfe_get_rx_csum</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">dmfe_get_tx_csum</span><span class="params">(struct net_device *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_set_rx_csum</span><span class="params">(struct net_device *, <span class="keyword">uint32_t</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_set_tx_csum</span><span class="params">(struct net_device *, <span class="keyword">uint32_t</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DM8606</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dm8606.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DECLARE_TASKLET(dmfe_tx_tasklet,dmfe_tx_done,0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* DM9000 network baord routine ---------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Search DM9000 board, allocate space and register it</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct net_device * __init <span class="title">dmfe_probe</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_probe()&quot;</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)</span></span><br><span class="line">    dev = init_etherdev(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(struct board_info));</span><br><span class="line">    <span class="comment">//ether_setup(dev);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    dev= alloc_etherdev(<span class="keyword">sizeof</span>(struct board_info));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!dev)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">        SET_MODULE_OWNER(dev);</span><br><span class="line">    err = dmfe_probe1(dev);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,0)</span></span><br><span class="line">    err = register_netdev(dev);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> out1;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> dev;</span><br><span class="line">out1:</span><br><span class="line">    release_region(dev-&gt;base_addr,<span class="number">2</span>);</span><br><span class="line">out:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)</span></span><br><span class="line">    kfree(dev);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    free_netdev(dev);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">dmfe_probe1</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">board_info</span> *<span class="title">db</span>;</span>    <span class="comment">/* Point a board information structure */</span></span><br><span class="line">    u32 id_val;</span><br><span class="line">    u16 i, dm9000_found = FALSE;</span><br><span class="line">    u8 MAC_addr[<span class="number">6</span>]=&#123;<span class="number">0x00</span>,<span class="number">0x60</span>,<span class="number">0x6E</span>,<span class="number">0x33</span>,<span class="number">0x44</span>,<span class="number">0x55</span>&#125;;</span><br><span class="line">    u8 HasEEPROM=<span class="number">0</span>,chip_info;</span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_probe1()&quot;</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search All DM9000 serial NIC */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * ===== for jz2440 =====</span></span><br><span class="line"><span class="comment">         * 这里详细说明一下 iobase</span></span><br><span class="line"><span class="comment">         * 片选为 nGCS4, 所以 iobase=0x20000000</span></span><br><span class="line"><span class="comment">         * outb 的时候, LADDR2=0</span></span><br><span class="line"><span class="comment">         * inb(iobase + 4), 相当于 inb(0x20000004),</span></span><br><span class="line"><span class="comment">         * 本质就是让 LADDR2=1, 读指令.</span></span><br><span class="line"><span class="comment">         * ===== end =====</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        outb(DM9KS_VID_L, iobase);</span><br><span class="line">        id_val = inb(iobase + <span class="number">4</span>);</span><br><span class="line">        outb(DM9KS_VID_H, iobase);</span><br><span class="line">        id_val |= inb(iobase + <span class="number">4</span>) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">        outb(DM9KS_PID_L, iobase);</span><br><span class="line">        id_val |= inb(iobase + <span class="number">4</span>) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">        outb(DM9KS_PID_H, iobase);</span><br><span class="line">        id_val |= inb(iobase + <span class="number">4</span>) &lt;&lt; <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id_val == DM9KS_ID || id_val == DM9010_ID) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Request IO from system */</span></span><br><span class="line">            <span class="keyword">if</span>(!request_region(iobase, <span class="number">2</span>, dev-&gt;name))</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">            printk(KERN_ERR<span class="string">&quot;&lt;DM9KS&gt; I/O: %x, VID: %x \n&quot;</span>,iobase, id_val);</span><br><span class="line">            dm9000_found = TRUE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Allocated board information structure */</span></span><br><span class="line">            <span class="built_in">memset</span>(dev-&gt;priv, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct board_info));</span><br><span class="line">            db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">            dmfe_dev    = dev;</span><br><span class="line">            db-&gt;io_addr  = iobase;</span><br><span class="line">            db-&gt;io_data = iobase + <span class="number">4</span>;</span><br><span class="line">            db-&gt;chip_revision = ior(db, DM9KS_CHIPR);</span><br><span class="line"></span><br><span class="line">            chip_info = ior(db,<span class="number">0x43</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取消型号检测, 硬件和给的驱动不匹配, 但能用. ===== for jz2440 =====</span></span><br><span class="line">            <span class="comment">// if((db-&gt;chip_revision!=0x1A) || ((chip_info&amp;(1&lt;&lt;5))!=0) || ((chip_info&amp;(1&lt;&lt;2))!=1)) return -ENODEV;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* driver system function */</span></span><br><span class="line">            dev-&gt;base_addr      = iobase;</span><br><span class="line">            dev-&gt;irq        = irq;</span><br><span class="line">            dev-&gt;open       = &amp;dmfe_open;</span><br><span class="line">            dev-&gt;hard_start_xmit    = &amp;dmfe_start_xmit;</span><br><span class="line">            dev-&gt;watchdog_timeo = <span class="number">5</span>*HZ;</span><br><span class="line">            dev-&gt;tx_timeout     = dmfe_timeout;</span><br><span class="line">            dev-&gt;stop       = &amp;dmfe_stop;</span><br><span class="line">            dev-&gt;get_stats      = &amp;dmfe_get_stats;</span><br><span class="line">            dev-&gt;set_multicast_list = &amp;dm9000_hash_table;</span><br><span class="line">            dev-&gt;do_ioctl       = &amp;dmfe_do_ioctl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,28)</span></span><br><span class="line">            dev-&gt;ethtool_ops = &amp;dmfe_ethtool_ops;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CHECKSUM</span></span><br><span class="line">            <span class="comment">//dev-&gt;features |=  NETIF_F_IP_CSUM;</span></span><br><span class="line">            dev-&gt;features |=  NETIF_F_IP_CSUM|NETIF_F_SG;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            db-&gt;mii.dev = dev;</span><br><span class="line">            db-&gt;mii.mdio_read = mdio_read;</span><br><span class="line">            db-&gt;mii.mdio_write = mdio_write;</span><br><span class="line">            db-&gt;mii.phy_id = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,20)</span></span><br><span class="line">            db-&gt;mii.phy_id_mask = <span class="number">0x1F</span>;</span><br><span class="line">            db-&gt;mii.reg_num_mask = <span class="number">0x1F</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="comment">//db-&gt;msg_enable =(debug == 0 ? DMFE_DEF_MSG_ENABLE : ((1 &lt;&lt; debug) - 1));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Read SROM content */</span></span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">64</span>; i++)</span><br><span class="line">                ((u16 *)db-&gt;srom)[i] = read_srom_word(db, i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Get the PID and VID from EEPROM to check */</span></span><br><span class="line">            id_val = (((u16 *)db-&gt;srom)[<span class="number">4</span>])|(((u16 *)db-&gt;srom)[<span class="number">5</span>]&lt;&lt;<span class="number">16</span>);</span><br><span class="line">            printk(<span class="string">&quot;id_val=%x\n&quot;</span>, id_val);</span><br><span class="line">            <span class="keyword">if</span> (id_val == DM9KS_ID || id_val == DM9010_ID)</span><br><span class="line">                HasEEPROM =<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Set Node Address */</span></span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (HasEEPROM) <span class="comment">/* use EEPROM */</span></span><br><span class="line">                    dev-&gt;dev_addr[i] = db-&gt;srom[i];</span><br><span class="line">                <span class="keyword">else</span>    <span class="comment">/* No EEPROM */</span></span><br><span class="line">                    dev-&gt;dev_addr[i] = MAC_addr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//end of if()</span></span><br><span class="line">        iobase += <span class="number">0x10</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(!dm9000_found &amp;&amp; iobase &lt;= DM9KS_MAX_IO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dm9000_found ? <span class="number">0</span>:-ENODEV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Open the interface.</span></span><br><span class="line"><span class="comment">  The interface is opened whenever &quot;ifconfig&quot; actives it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_open</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    u8 reg_nsr;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_open&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0表示不触发, 重新设置为上升沿触发中断.  ===== for jz2440 =====</span></span><br><span class="line">    <span class="keyword">if</span> (request_irq(dev-&gt;irq,&amp;dmfe_interrupt,IRQF_TRIGGER_RISING,dev-&gt;name,dev))</span><br><span class="line">    <span class="comment">// if (request_irq(dev-&gt;irq,&amp;dmfe_interrupt,0,dev-&gt;name,dev))</span></span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initilize DM910X board */</span></span><br><span class="line">    dmfe_init_dm9000(dev);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DM8606</span></span><br><span class="line">    <span class="comment">// control DM8606</span></span><br><span class="line">    printk(<span class="string">&quot;[8606]reg0=0x%04x\n&quot;</span>,dm8606_read(db,<span class="number">0</span>));</span><br><span class="line">    printk(<span class="string">&quot;[8606]reg1=0x%04x\n&quot;</span>,dm8606_read(db,<span class="number">0x1</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Init driver variable */</span></span><br><span class="line">    db-&gt;reset_counter   = <span class="number">0</span>;</span><br><span class="line">    db-&gt;reset_tx_timeout    = <span class="number">0</span>;</span><br><span class="line">    db-&gt;cont_rx_pkt_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check link state and media speed */</span></span><br><span class="line">    db-&gt;Speed =<span class="number">10</span>;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        reg_nsr = ior(db,DM9KS_NSR);</span><br><span class="line">        <span class="keyword">if</span>(reg_nsr &amp; <span class="number">0x40</span>) <span class="comment">/* link OK!! */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* wait for detected Speed */</span></span><br><span class="line">            mdelay(<span class="number">200</span>);</span><br><span class="line">            reg_nsr = ior(db,DM9KS_NSR);</span><br><span class="line">            <span class="keyword">if</span>(reg_nsr &amp; <span class="number">0x80</span>)</span><br><span class="line">                db-&gt;Speed =<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                db-&gt;Speed =<span class="number">100</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        mdelay(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span>(i&lt;<span class="number">3000</span>); <span class="comment">/* wait 3 second  */</span></span><br><span class="line">    <span class="comment">//printk(&quot;i=%d  Speed=%d\n&quot;,i,db-&gt;Speed);</span></span><br><span class="line">    <span class="comment">/* set and active a timer process */</span></span><br><span class="line">    init_timer(&amp;db-&gt;timer);</span><br><span class="line">    db-&gt;timer.expires   = DMFE_TIMER_WUT;</span><br><span class="line">    db-&gt;timer.data      = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)dev;</span><br><span class="line">    db-&gt;timer.function  = &amp;dmfe_timer;</span><br><span class="line">    add_timer(&amp;db-&gt;timer);  <span class="comment">//Move to DM9000 initiallization was finished.</span></span><br><span class="line"></span><br><span class="line">    netif_start_queue(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set PHY operationg mode</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_PHY_mode</span><span class="params">(<span class="keyword">board_info_t</span> *db)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DM8606</span></span><br><span class="line">    u16 phy_reg0 = <span class="number">0x1000</span>;<span class="comment">/* Auto-negotiation*/</span></span><br><span class="line">    u16 phy_reg4 = <span class="number">0x01e1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !(db-&gt;op_mode &amp; DM9KS_AUTO) ) <span class="comment">// op_mode didn&#x27;t auto sense */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(db-&gt;op_mode) &#123;</span><br><span class="line">            <span class="keyword">case</span> DM9KS_10MHD:  phy_reg4 = <span class="number">0x21</span>;</span><br><span class="line">                                       phy_reg0 = <span class="number">0x1000</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DM9KS_10MFD:  phy_reg4 = <span class="number">0x41</span>;</span><br><span class="line">                       phy_reg0 = <span class="number">0x1100</span>;</span><br><span class="line">                                       <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DM9KS_100MHD: phy_reg4 = <span class="number">0x81</span>;</span><br><span class="line">                       phy_reg0 = <span class="number">0x3000</span>;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DM9KS_100MFD: phy_reg4 = <span class="number">0x101</span>;</span><br><span class="line">                       phy_reg0 = <span class="number">0x3100</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="comment">// end of switch</span></span><br><span class="line">    &#125; <span class="comment">// end of if</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FLOW_CONTROL</span></span><br><span class="line">    phy_write(db, <span class="number">4</span>, phy_reg4|(<span class="number">1</span>&lt;&lt;<span class="number">10</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    phy_write(db, <span class="number">4</span>, phy_reg4);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//end of FLOW_CONTROL</span></span></span><br><span class="line">    phy_write(db, <span class="number">0</span>, phy_reg0|<span class="number">0x200</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/* Fiber mode */</span></span><br><span class="line">    phy_write(db, <span class="number">16</span>, <span class="number">0x4014</span>);</span><br><span class="line">    phy_write(db, <span class="number">0</span>, <span class="number">0x2100</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//end of DM8606</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (db-&gt;chip_revision == <span class="number">0x1A</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//set 10M TX idle =65mA (TX 100% utility is 160mA)</span></span><br><span class="line">        phy_write(db,<span class="number">20</span>, phy_read(db,<span class="number">20</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">11</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//:fix harmonic</span></span><br><span class="line">        <span class="comment">//For short code:</span></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 0000h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x0000</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA00h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa00</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 0017h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x0017</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA17h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa17</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 002Fh</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x002f</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA2Fh</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa2f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 0037h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x0037</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA37h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa37</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 0040h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x0040</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA40h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa40</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//For long code:</span></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 0050h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x0050</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA50h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa50</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 006Bh</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x006b</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA6Bh</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa6b</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 007Dh</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x007d</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA7Dh</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa7d</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 008Dh</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x008d</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA8Dh</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa8d</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 009Ch</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x009c</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AA9Ch</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaa9c</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 00A3h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x00a3</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AAA3h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaaa3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 00B1h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x00b1</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AAB1h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaab1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 00C0h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x00c0</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AAC0h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaac0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 00D2h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x00d2</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AAD2h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaad2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 00E0h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x00e0</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- AAE0h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0xaae0</span>);</span><br><span class="line">        <span class="comment">//PHY_REG 27 (1Bh) &lt;- 0000h</span></span><br><span class="line">        phy_write(db, <span class="number">27</span>, <span class="number">0x0000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Initilize dm9000 board</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_init_dm9000</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_init_dm9000()&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    spin_lock_init(&amp;db-&gt;lock);</span><br><span class="line"></span><br><span class="line">    iow(db, DM9KS_GPR, <span class="number">0</span>);  <span class="comment">/* GPR (reg_1Fh)bit GPIO0=0 pre-activate PHY */</span></span><br><span class="line">    mdelay(<span class="number">20</span>);     <span class="comment">/* wait for PHY power-on ready */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do a software reset and wait 20us */</span></span><br><span class="line">    iow(db, DM9KS_NCR, <span class="number">3</span>);</span><br><span class="line">    udelay(<span class="number">20</span>);     <span class="comment">/* wait 20us at least for software reset ok */</span></span><br><span class="line">    iow(db, DM9KS_NCR, <span class="number">3</span>);  <span class="comment">/* NCR (reg_00h) bit[0] RST=1 &amp; Loopback=1, reset on */</span></span><br><span class="line">    udelay(<span class="number">20</span>);     <span class="comment">/* wait 20us at least for software reset ok */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I/O mode */</span></span><br><span class="line">    db-&gt;io_mode = ior(db, DM9KS_ISR) &gt;&gt; <span class="number">6</span>; <span class="comment">/* ISR bit7:6 keeps I/O mode */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set PHY */</span></span><br><span class="line">    db-&gt;op_mode = media_mode;</span><br><span class="line">    set_PHY_mode(db);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Program operating register */</span></span><br><span class="line">    iow(db, DM9KS_NCR, <span class="number">0</span>);</span><br><span class="line">    iow(db, DM9KS_TCR, <span class="number">0</span>);      <span class="comment">/* TX Polling clear */</span></span><br><span class="line">    iow(db, DM9KS_BPTR, <span class="number">0x3f</span>);  <span class="comment">/* Less 3kb, 600us */</span></span><br><span class="line">    iow(db, DM9KS_SMCR, <span class="number">0</span>);     <span class="comment">/* Special Mode */</span></span><br><span class="line">    iow(db, DM9KS_NSR, <span class="number">0x2c</span>);   <span class="comment">/* clear TX status */</span></span><br><span class="line">    iow(db, DM9KS_ISR, <span class="number">0x0f</span>);   <span class="comment">/* Clear interrupt status */</span></span><br><span class="line">    iow(db, DM9KS_TCR2, <span class="number">0x80</span>);  <span class="comment">/* Set LED mode 1 */</span></span><br><span class="line">    <span class="keyword">if</span> (db-&gt;chip_revision == <span class="number">0x1A</span>)&#123;</span><br><span class="line">        <span class="comment">/* Data bus current driving/sinking capability  */</span></span><br><span class="line">        iow(db, DM9KS_BUSCR, <span class="number">0x01</span>); <span class="comment">/* default: 2mA */</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FLOW_CONTROL</span></span><br><span class="line">    iow(db, DM9KS_BPTR, <span class="number">0x37</span>);</span><br><span class="line">    iow(db, DM9KS_FCTR, <span class="number">0x38</span>);</span><br><span class="line">    iow(db, DM9KS_FCR, <span class="number">0x29</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DM8606</span></span><br><span class="line">    iow(db,<span class="number">0x34</span>,<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;features &amp; NETIF_F_HW_CSUM)&#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;DM9KS:enable TX checksum\n&quot;</span>);</span><br><span class="line">        iow(db, DM9KS_TCCR, <span class="number">0x07</span>);  <span class="comment">/* TX UDP/TCP/IP checksum enable */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (db-&gt;rx_csum)&#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;DM9KS:enable RX checksum\n&quot;</span>);</span><br><span class="line">        iow(db, DM9KS_RCSR, <span class="number">0x02</span>);  <span class="comment">/* RX checksum enable */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ETRANS</span></span><br><span class="line">    <span class="comment">/*If TX loading is heavy, the driver can try to anbel &quot;early transmit&quot;.</span></span><br><span class="line"><span class="comment">    The programmer can tune the &quot;Early Transmit Threshold&quot; to get</span></span><br><span class="line"><span class="comment">    the optimization. (DM9KS_ETXCSR.[1-0])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Side Effect: It will happen &quot;Transmit under-run&quot;. When TX under-run</span></span><br><span class="line"><span class="comment">    always happens, the programmer can increase the value of &quot;Early</span></span><br><span class="line"><span class="comment">    Transmit Threshold&quot;. */</span></span><br><span class="line">    iow(db, DM9KS_ETXCSR, <span class="number">0x83</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set address filter table */</span></span><br><span class="line">    dm9000_hash_table(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Activate DM9000/DM9010 */</span></span><br><span class="line">    iow(db, DM9KS_IMR, DM9KS_REGFF); <span class="comment">/* Enable TX/RX interrupt mask */</span></span><br><span class="line">    iow(db, DM9KS_RXCR, DM9KS_REG05 | <span class="number">1</span>);   <span class="comment">/* RX enable */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Init Driver variable */</span></span><br><span class="line">    db-&gt;tx_pkt_cnt      = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    netif_carrier_on(dev);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Hardware start transmission.</span></span><br><span class="line"><span class="comment">  Send a packet to media from the upper layer.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_start_xmit</span><span class="params">(struct sk_buff *skb, struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="keyword">char</span> * data_ptr;</span><br><span class="line">    <span class="keyword">int</span> i, tmplen;</span><br><span class="line">    u16 MDWAH, MDWAL;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> TDBUG <span class="comment">/* check TX FIFO pointer */</span></span></span><br><span class="line">            u16 MDWAH1, MDWAL1;</span><br><span class="line">            u16 tx_ptr;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_start_xmit&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (db-&gt;chip_revision != <span class="number">0x1A</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(db-&gt;Speed == <span class="number">10</span>)</span><br><span class="line">            &#123;<span class="keyword">if</span> (db-&gt;tx_pkt_cnt &gt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            &#123;<span class="keyword">if</span> (db-&gt;tx_pkt_cnt &gt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (db-&gt;tx_pkt_cnt &gt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* packet counting */</span></span><br><span class="line">    db-&gt;tx_pkt_cnt++;</span><br><span class="line"></span><br><span class="line">    db-&gt;stats.tx_packets++;</span><br><span class="line">    db-&gt;stats.tx_bytes+=skb-&gt;len;</span><br><span class="line">    <span class="keyword">if</span> (db-&gt;chip_revision != <span class="number">0x1A</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (db-&gt;Speed == <span class="number">10</span>)</span><br><span class="line">            &#123;<span class="keyword">if</span> (db-&gt;tx_pkt_cnt &gt;= <span class="number">1</span>) netif_stop_queue(dev);&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            &#123;<span class="keyword">if</span> (db-&gt;tx_pkt_cnt &gt;= <span class="number">2</span>) netif_stop_queue(dev);&#125;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (db-&gt;tx_pkt_cnt &gt;= <span class="number">2</span>) netif_stop_queue(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Disable all interrupt */</span></span><br><span class="line">    iow(db, DM9KS_IMR, DM9KS_DISINTR);</span><br><span class="line"></span><br><span class="line">    MDWAH = ior(db,DM9KS_MDWAH);</span><br><span class="line">    MDWAL = ior(db,DM9KS_MDWAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set TX length to reg. 0xfc &amp; 0xfd */</span></span><br><span class="line">    iow(db, DM9KS_TXPLL, (skb-&gt;len &amp; <span class="number">0xff</span>));</span><br><span class="line">    iow(db, DM9KS_TXPLH, (skb-&gt;len &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Move data to TX SRAM */</span></span><br><span class="line">    data_ptr = (<span class="keyword">char</span> *)skb-&gt;data;</span><br><span class="line"></span><br><span class="line">    outb(DM9KS_MWCMD, db-&gt;io_addr); <span class="comment">// Write data into SRAM trigger</span></span><br><span class="line">    <span class="keyword">switch</span>(db-&gt;io_mode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> DM9KS_BYTE_MODE:</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; skb-&gt;len; i++)</span><br><span class="line">                outb((data_ptr[i] &amp; <span class="number">0xff</span>), db-&gt;io_data);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DM9KS_WORD_MODE:</span><br><span class="line">            tmplen = (skb-&gt;len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmplen; i++)</span><br><span class="line">        outw(((u16 *)data_ptr)[i], db-&gt;io_data);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DM9KS_DWORD_MODE:</span><br><span class="line">      tmplen = (skb-&gt;len + <span class="number">3</span>) / <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; tmplen; i++)</span><br><span class="line">                outl(((u32 *)data_ptr)[i], db-&gt;io_data);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ETRANS</span></span><br><span class="line">    <span class="comment">/* Issue TX polling command */</span></span><br><span class="line">    iow(db, DM9KS_TCR, <span class="number">0x1</span>); <span class="comment">/* Cleared after TX complete*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> TDBUG <span class="comment">/* check TX FIFO pointer */</span></span></span><br><span class="line">            MDWAH1 = ior(db,DM9KS_MDWAH);</span><br><span class="line">            MDWAL1 = ior(db,DM9KS_MDWAL);</span><br><span class="line">            tx_ptr = (MDWAH&lt;&lt;<span class="number">8</span>)|MDWAL;</span><br><span class="line">            <span class="keyword">switch</span> (db-&gt;io_mode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_BYTE_MODE:</span><br><span class="line">                    tx_ptr += skb-&gt;len;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_WORD_MODE:</span><br><span class="line">                    tx_ptr += ((skb-&gt;len + <span class="number">1</span>) / <span class="number">2</span>)*<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_DWORD_MODE:</span><br><span class="line">                    tx_ptr += ((skb-&gt;len+<span class="number">3</span>)/<span class="number">4</span>)*<span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tx_ptr &gt; <span class="number">0x0bff</span>)</span><br><span class="line">                    tx_ptr -= <span class="number">0x0c00</span>;</span><br><span class="line">            <span class="keyword">if</span> (tx_ptr != ((MDWAH1&lt;&lt;<span class="number">8</span>)|MDWAL1))</span><br><span class="line">                    printk(<span class="string">&quot;[dm9ks:TX FIFO ERROR\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Saved the time stamp */</span></span><br><span class="line">    dev-&gt;trans_start = jiffies;</span><br><span class="line">    db-&gt;cont_rx_pkt_cnt =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free this SKB */</span></span><br><span class="line">    dev_kfree_skb(skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Re-enable interrupt */</span></span><br><span class="line">    iow(db, DM9KS_IMR, DM9KS_REGFF);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Stop the interface.</span></span><br><span class="line"><span class="comment">  The interface is stopped when it is brought.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_stop</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_stop&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* deleted timer */</span></span><br><span class="line">    del_timer(&amp;db-&gt;timer);</span><br><span class="line"></span><br><span class="line">    netif_stop_queue(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free interrupt */</span></span><br><span class="line">    free_irq(dev-&gt;irq, dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* RESET devie */</span></span><br><span class="line">    phy_write(db, <span class="number">0x00</span>, <span class="number">0x8000</span>);    <span class="comment">/* PHY RESET */</span></span><br><span class="line">    <span class="comment">//iow(db, DM9KS_GPR, 0x01);     /* Power-Down PHY */</span></span><br><span class="line">    iow(db, DM9KS_IMR, DM9KS_DISINTR);  <span class="comment">/* Disable all interrupt */</span></span><br><span class="line">    iow(db, DM9KS_RXCR, <span class="number">0x00</span>);  <span class="comment">/* Disable RX */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dump Statistic counter */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FALSE</span></span><br><span class="line">    printk(<span class="string">&quot;\nRX FIFO OVERFLOW %lx\n&quot;</span>, db-&gt;stats.rx_fifo_errors);</span><br><span class="line">    printk(<span class="string">&quot;RX CRC %lx\n&quot;</span>, db-&gt;stats.rx_crc_errors);</span><br><span class="line">    printk(<span class="string">&quot;RX LEN Err %lx\n&quot;</span>, db-&gt;stats.rx_length_errors);</span><br><span class="line">    printk(<span class="string">&quot;RESET %x\n&quot;</span>, db-&gt;reset_counter);</span><br><span class="line">    printk(<span class="string">&quot;RESET: TX Timeout %x\n&quot;</span>, db-&gt;reset_tx_timeout);</span><br><span class="line">    printk(<span class="string">&quot;g_TX_nsr %x\n&quot;</span>, g_TX_nsr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_tx_done</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> dmfe_dev;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="keyword">int</span>  nsr;</span><br><span class="line"></span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_tx_done()&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    nsr = ior(db, DM9KS_NSR);</span><br><span class="line">    <span class="keyword">if</span> (nsr &amp; <span class="number">0x0c</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nsr &amp; <span class="number">0x04</span>) db-&gt;tx_pkt_cnt--;</span><br><span class="line">        <span class="keyword">if</span>(nsr &amp; <span class="number">0x08</span>) db-&gt;tx_pkt_cnt--;</span><br><span class="line">        <span class="keyword">if</span>(db-&gt;tx_pkt_cnt &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printk(KERN_DEBUG <span class="string">&quot;DM9KS:tx_pkt_cnt ERROR!!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(ior(db,DM9KS_TCR) &amp; <span class="number">0x1</span>)&#123;&#125;</span><br><span class="line">            db-&gt;tx_pkt_cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(ior(db,DM9KS_TCR) &amp; <span class="number">0x1</span>)&#123;&#125;</span><br><span class="line">        db-&gt;tx_pkt_cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    netif_wake_queue(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  DM9000 insterrupt handler</span></span><br><span class="line"><span class="comment">  receive the packet to upper layer, free the transmitted packet</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_interrupt</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">else</span></span></span></span><br><span class="line"><span class="function">    <span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,19)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">dmfe_interrupt</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function">    <span class="meta">#<span class="meta-keyword">else</span></span></span></span><br><span class="line"><span class="function">    <span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">dmfe_interrupt</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span> <span class="comment">/* for kernel 2.6.20*/</span></span></span><br><span class="line"><span class="function">    <span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> dev_id;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db;</span><br><span class="line">    <span class="keyword">int</span> int_status,i;</span><br><span class="line">    u8 reg_save;</span><br><span class="line"></span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_interrupt()&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A real interrupt coming */</span></span><br><span class="line">    db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    spin_lock(&amp;db-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save previous register address */</span></span><br><span class="line">    reg_save = inb(db-&gt;io_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Disable all interrupt */</span></span><br><span class="line">    iow(db, DM9KS_IMR, DM9KS_DISINTR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Got DM9000/DM9010 interrupt status */</span></span><br><span class="line">    int_status = ior(db, DM9KS_ISR);        <span class="comment">/* Got ISR */</span></span><br><span class="line">    iow(db, DM9KS_ISR, int_status);     <span class="comment">/* Clear ISR status */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Link status change */</span></span><br><span class="line">    <span class="keyword">if</span> (int_status &amp; DM9KS_LINK_INTR)</span><br><span class="line">    &#123;</span><br><span class="line">        netif_stop_queue(dev);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">500</span>; i++) <span class="comment">/*wait link OK, waiting time =0.5s */</span></span><br><span class="line">        &#123;</span><br><span class="line">            phy_read(db,<span class="number">0x1</span>);</span><br><span class="line">            <span class="keyword">if</span>(phy_read(db,<span class="number">0x1</span>) &amp; <span class="number">0x4</span>) <span class="comment">/*Link OK*/</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* wait for detected Speed */</span></span><br><span class="line">                <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">200</span>;i++)</span><br><span class="line">                    udelay(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">/* set media speed */</span></span><br><span class="line">                <span class="keyword">if</span>(phy_read(db,<span class="number">0</span>)&amp;<span class="number">0x2000</span>) db-&gt;Speed =<span class="number">100</span>;</span><br><span class="line">                <span class="keyword">else</span> db-&gt;Speed =<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            udelay(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        netif_wake_queue(dev);</span><br><span class="line">        <span class="comment">//printk(&quot;[INTR]i=%d speed=%d\n&quot;,i, (int)(db-&gt;Speed));</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Received the coming packet */</span></span><br><span class="line">    <span class="keyword">if</span> (int_status &amp; DM9KS_RX_INTR)</span><br><span class="line">        dmfe_packet_receive(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Trnasmit Interrupt check */</span></span><br><span class="line">    <span class="keyword">if</span> (int_status &amp; DM9KS_TX_INTR)</span><br><span class="line">        dmfe_tx_done(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (db-&gt;cont_rx_pkt_cnt&gt;=CONT_RX_PKT_CNT)</span><br><span class="line">    &#123;</span><br><span class="line">        iow(db, DM9KS_IMR, <span class="number">0xa2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Re-enable interrupt mask */</span></span><br><span class="line">        iow(db, DM9KS_IMR, DM9KS_REGFF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore previous register address */</span></span><br><span class="line">    outb(reg_save, db-&gt;io_addr);</span><br><span class="line"></span><br><span class="line">    spin_unlock(&amp;db-&gt;lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,0)</span></span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Get statistics from driver.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct net_device_stats * <span class="title">dmfe_get_stats</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_get_stats&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> &amp;db-&gt;stats;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Process the ethtool ioctl command</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_ethtool_ioctl</span><span class="params">(struct net_device *dev, <span class="keyword">void</span> *useraddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//struct dmfe_board_info *db = dev-&gt;priv;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ethtool_drvinfo</span> <span class="title">info</span> =</span> &#123; ETHTOOL_GDRVINFO &#125;;</span><br><span class="line">    u32 ethcmd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;ethcmd, useraddr, <span class="keyword">sizeof</span>(ethcmd)))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ethcmd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> ETHTOOL_GDRVINFO:</span><br><span class="line">            <span class="built_in">strcpy</span>(info.driver, DRV_NAME);</span><br><span class="line">            <span class="built_in">strcpy</span>(info.version, DRV_VERSION);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sprintf</span>(info.bus_info, <span class="string">&quot;ISA 0x%lx %d&quot;</span>,dev-&gt;base_addr, dev-&gt;irq);</span><br><span class="line">            <span class="keyword">if</span> (copy_to_user(useraddr, &amp;info, <span class="keyword">sizeof</span>(info)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Process the upper socket ioctl command</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_do_ioctl</span><span class="params">(struct net_device *dev, struct ifreq *ifr, <span class="keyword">int</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,7) <span class="comment">/* for kernel 2.6.7 */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mii_ioctl_data</span> *<span class="title">data</span>=</span>(struct mii_ioctl_data *)&amp;ifr-&gt;ifr_data;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> rc=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_do_ioctl()&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!netif_running(dev))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmd == SIOCETHTOOL)</span><br><span class="line">        rc = dmfe_ethtool_ioctl(dev, (<span class="keyword">void</span> *) ifr-&gt;ifr_data);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        spin_lock_irq(&amp;db-&gt;lock);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,7) <span class="comment">/* for kernel 2.6.7 */</span></span></span><br><span class="line">            rc = generic_mii_ioctl(&amp;db-&gt;mii, data, cmd, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            rc = generic_mii_ioctl(&amp;db-&gt;mii, if_mii(ifr), cmd, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        spin_unlock_irq(&amp;db-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Our watchdog timed out. Called by the networking layer */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_timeout</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_TX_timeout()&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    printk(<span class="string">&quot;TX time-out -- dmfe_timeout().\n&quot;</span>);</span><br><span class="line">    db-&gt;reset_tx_timeout++;</span><br><span class="line">    db-&gt;stats.tx_errors++;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FALSE</span></span><br><span class="line">    printk(<span class="string">&quot;TX packet count = %d\n&quot;</span>, db-&gt;tx_pkt_cnt);</span><br><span class="line">    printk(<span class="string">&quot;TX timeout = %d\n&quot;</span>, db-&gt;reset_tx_timeout);</span><br><span class="line">    printk(<span class="string">&quot;22H=0x%02x  23H=0x%02x\n&quot;</span>,ior(db,<span class="number">0x22</span>),ior(db,<span class="number">0x23</span>));</span><br><span class="line">    printk(<span class="string">&quot;faH=0x%02x  fbH=0x%02x\n&quot;</span>,ior(db,<span class="number">0xfa</span>),ior(db,<span class="number">0xfb</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((i++&lt;<span class="number">100</span>)&amp;&amp;(ior(db,DM9KS_TCR) &amp; <span class="number">0x01</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        udelay(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            db-&gt;tx_pkt_cnt = <span class="number">0</span>;</span><br><span class="line">            netif_wake_queue(dev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">            dmfe_reset(dev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_reset</span><span class="params">(struct net_device * dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    u8 reg_save;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">/* Save previous register address */</span></span><br><span class="line">    reg_save = inb(db-&gt;io_addr);</span><br><span class="line"></span><br><span class="line">    netif_stop_queue(dev);</span><br><span class="line">    db-&gt;reset_counter++;</span><br><span class="line">    dmfe_init_dm9000(dev);</span><br><span class="line"></span><br><span class="line">    db-&gt;Speed =<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) <span class="comment">/*wait link OK, waiting time=1 second */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(phy_read(db,<span class="number">0x1</span>) &amp; <span class="number">0x4</span>) <span class="comment">/*Link OK*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(phy_read(db,<span class="number">0</span>)&amp;<span class="number">0x2000</span>) db-&gt;Speed =<span class="number">100</span>;</span><br><span class="line">            <span class="keyword">else</span> db-&gt;Speed =<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        udelay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    netif_wake_queue(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore previous register address */</span></span><br><span class="line">    outb(reg_save, db-&gt;io_addr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  A periodic timer routine</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_timer</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> * <span class="title">dev</span> =</span> (struct net_device *)data;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_timer()&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (db-&gt;cont_rx_pkt_cnt&gt;=CONT_RX_PKT_CNT)</span><br><span class="line">    &#123;</span><br><span class="line">        db-&gt;cont_rx_pkt_cnt=<span class="number">0</span>;</span><br><span class="line">        iow(db, DM9KS_IMR, DM9KS_REGFF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Set timer again */</span></span><br><span class="line">    db-&gt;timer.expires = DMFE_TIMER_WUT;</span><br><span class="line">    add_timer(&amp;db-&gt;timer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Received a packet and pass to upper layer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_packet_receive</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">    u8 rxbyte;</span><br><span class="line">    u16 i, GoodPacket, tmplen = <span class="number">0</span>, MDRAH, MDRAL;</span><br><span class="line">    u32 tmpdata;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rx_t</span> rx;</span><br><span class="line"></span><br><span class="line">    u16 * ptr = (u16*)&amp;rx;</span><br><span class="line">    u8* rdptr;</span><br><span class="line"></span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dmfe_packet_receive()&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    db-&gt;cont_rx_pkt_cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/*store the value of Memory Data Read address register*/</span></span><br><span class="line">        MDRAH=ior(db, DM9KS_MDRAH);</span><br><span class="line">        MDRAL=ior(db, DM9KS_MDRAL);</span><br><span class="line"></span><br><span class="line">        ior(db, DM9KS_MRCMDX);      <span class="comment">/* Dummy read */</span></span><br><span class="line">        rxbyte = inb(db-&gt;io_data);  <span class="comment">/* Got most updated data */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CHECKSUM</span></span><br><span class="line">        <span class="keyword">if</span> (rxbyte&amp;<span class="number">0x2</span>)         <span class="comment">/* check RX byte */</span></span><br><span class="line">        &#123;</span><br><span class="line">      printk(<span class="string">&quot;dm9ks: abnormal!\n&quot;</span>);</span><br><span class="line">            dmfe_reset(dev);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(rxbyte&amp;<span class="number">0x1</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> (rxbyte==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rxbyte&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">      printk(<span class="string">&quot;dm9ks: Rxbyte error!\n&quot;</span>);</span><br><span class="line">          dmfe_reset(dev);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* A packet ready now  &amp; Get status/length */</span></span><br><span class="line">        GoodPacket = TRUE;</span><br><span class="line">        outb(DM9KS_MRCMD, db-&gt;io_addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read packet status &amp; length */</span></span><br><span class="line">        <span class="keyword">switch</span> (db-&gt;io_mode)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">case</span> DM9KS_BYTE_MODE:</span><br><span class="line">                    *ptr = inb(db-&gt;io_data) +</span><br><span class="line">                               (inb(db-&gt;io_data) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">                    *(ptr+<span class="number">1</span>) = inb(db-&gt;io_data) +</span><br><span class="line">                        (inb(db-&gt;io_data) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> DM9KS_WORD_MODE:</span><br><span class="line">                    *ptr = inw(db-&gt;io_data);</span><br><span class="line">                    *(ptr+<span class="number">1</span>)    = inw(db-&gt;io_data);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> DM9KS_DWORD_MODE:</span><br><span class="line">                    tmpdata  = inl(db-&gt;io_data);</span><br><span class="line">                    *ptr = tmpdata;</span><br><span class="line">                    *(ptr+<span class="number">1</span>)    = tmpdata &gt;&gt; <span class="number">16</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Packet status check */</span></span><br><span class="line">        <span class="keyword">if</span> (rx.desc.status &amp; <span class="number">0xbf</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GoodPacket = FALSE;</span><br><span class="line">            <span class="keyword">if</span> (rx.desc.status &amp; <span class="number">0x01</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                db-&gt;stats.rx_fifo_errors++;</span><br><span class="line">                printk(KERN_INFO<span class="string">&quot;&lt;RX FIFO error&gt;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rx.desc.status &amp; <span class="number">0x02</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                db-&gt;stats.rx_crc_errors++;</span><br><span class="line">                printk(KERN_INFO<span class="string">&quot;&lt;RX CRC error&gt;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rx.desc.status &amp; <span class="number">0x80</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                db-&gt;stats.rx_length_errors++;</span><br><span class="line">                printk(KERN_INFO<span class="string">&quot;&lt;RX Length error&gt;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rx.desc.status &amp; <span class="number">0x08</span>)</span><br><span class="line">                printk(KERN_INFO<span class="string">&quot;&lt;Physical Layer error&gt;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!GoodPacket)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// drop this packet!!!</span></span><br><span class="line">            <span class="keyword">switch</span> (db-&gt;io_mode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_BYTE_MODE:</span><br><span class="line">                    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;rx.desc.length; i++)</span><br><span class="line">                        inb(db-&gt;io_data);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_WORD_MODE:</span><br><span class="line">                    tmplen = (rx.desc.length + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmplen; i++)</span><br><span class="line">                        inw(db-&gt;io_data);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_DWORD_MODE:</span><br><span class="line">                    tmplen = (rx.desc.length + <span class="number">3</span>) / <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmplen; i++)</span><br><span class="line">                        inl(db-&gt;io_data);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">/*next the packet*/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        skb = dev_alloc_skb(rx.desc.length+<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (skb == <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            printk(KERN_INFO <span class="string">&quot;%s: Memory squeeze.\n&quot;</span>, dev-&gt;name);</span><br><span class="line">            <span class="comment">/*re-load the value into Memory data read address register*/</span></span><br><span class="line">            iow(db,DM9KS_MDRAH,MDRAH);</span><br><span class="line">            iow(db,DM9KS_MDRAL,MDRAL);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Move data from DM9000 */</span></span><br><span class="line">            skb-&gt;dev = dev;</span><br><span class="line">            skb_reserve(skb, <span class="number">2</span>);</span><br><span class="line">            rdptr = (u8*)skb_put(skb, rx.desc.length - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Read received packet from RX SARM */</span></span><br><span class="line">            <span class="keyword">switch</span> (db-&gt;io_mode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_BYTE_MODE:</span><br><span class="line">                    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;rx.desc.length; i++)</span><br><span class="line">                        rdptr[i]=inb(db-&gt;io_data);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_WORD_MODE:</span><br><span class="line">                    tmplen = (rx.desc.length + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmplen; i++)</span><br><span class="line">                        ((u16 *)rdptr)[i] = inw(db-&gt;io_data);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_DWORD_MODE:</span><br><span class="line">                    tmplen = (rx.desc.length + <span class="number">3</span>) / <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmplen; i++)</span><br><span class="line">                        ((u32 *)rdptr)[i] = inl(db-&gt;io_data);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Pass to upper layer */</span></span><br><span class="line">            skb-&gt;protocol = eth_type_trans(skb,dev);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CHECKSUM</span></span><br><span class="line">        <span class="keyword">if</span>((rxbyte&amp;<span class="number">0xe0</span>)==<span class="number">0</span>)    <span class="comment">/* receive packet no checksum fail */</span></span><br><span class="line">                skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            netif_rx(skb);</span><br><span class="line">            dev-&gt;last_rx=jiffies;</span><br><span class="line">            db-&gt;stats.rx_packets++;</span><br><span class="line">            db-&gt;stats.rx_bytes += rx.desc.length;</span><br><span class="line">            db-&gt;cont_rx_pkt_cnt++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RDBG <span class="comment">/* check RX FIFO pointer */</span></span></span><br><span class="line">            u16 MDRAH1, MDRAL1;</span><br><span class="line">            u16 tmp_ptr;</span><br><span class="line">            MDRAH1 = ior(db,DM9KS_MDRAH);</span><br><span class="line">            MDRAL1 = ior(db,DM9KS_MDRAL);</span><br><span class="line">            tmp_ptr = (MDRAH&lt;&lt;<span class="number">8</span>)|MDRAL;</span><br><span class="line">            <span class="keyword">switch</span> (db-&gt;io_mode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_BYTE_MODE:</span><br><span class="line">                    tmp_ptr += rx.desc.length+<span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_WORD_MODE:</span><br><span class="line">                    tmp_ptr += ((rx.desc.length+<span class="number">1</span>)/<span class="number">2</span>)*<span class="number">2</span>+<span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DM9KS_DWORD_MODE:</span><br><span class="line">                    tmp_ptr += ((rx.desc.length+<span class="number">3</span>)/<span class="number">4</span>)*<span class="number">4</span>+<span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmp_ptr &gt;=<span class="number">0x4000</span>)</span><br><span class="line">                tmp_ptr = (tmp_ptr - <span class="number">0x4000</span>) + <span class="number">0xc00</span>;</span><br><span class="line">            <span class="keyword">if</span> (tmp_ptr != ((MDRAH1&lt;&lt;<span class="number">8</span>)|MDRAL1))</span><br><span class="line">                printk(<span class="string">&quot;[dm9ks:RX FIFO ERROR\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (db-&gt;cont_rx_pkt_cnt&gt;=CONT_RX_PKT_CNT)</span><br><span class="line">            &#123;</span><br><span class="line">                dmfe_tx_done(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">while</span>((rxbyte &amp; <span class="number">0x01</span>) == DM9KS_PKT_RDY);</span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;[END]dmfe_packet_receive()&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Read a word data from SROM</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u16 <span class="title">read_srom_word</span><span class="params">(<span class="keyword">board_info_t</span> *db, <span class="keyword">int</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iow(db, DM9KS_EPAR, offset);</span><br><span class="line">    iow(db, DM9KS_EPCR, <span class="number">0x4</span>);</span><br><span class="line">    <span class="keyword">while</span>(ior(db, DM9KS_EPCR)&amp;<span class="number">0x1</span>); <span class="comment">/* Wait read complete */</span></span><br><span class="line">    iow(db, DM9KS_EPCR, <span class="number">0x0</span>);</span><br><span class="line">    <span class="keyword">return</span> (ior(db, DM9KS_EPDRL) + (ior(db, DM9KS_EPDRH) &lt;&lt; <span class="number">8</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Set DM9000/DM9010 multicast address</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dm9000_hash_table</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_mc_list</span> *<span class="title">mcptr</span> =</span> dev-&gt;mc_list;</span><br><span class="line">    <span class="keyword">int</span> mc_cnt = dev-&gt;mc_count;</span><br><span class="line">    u32 hash_val;</span><br><span class="line">    u16 i, oft, hash_table[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;dm9000_hash_table()&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable promiscuous mode */</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;flags &amp; IFF_PROMISC)&#123;</span><br><span class="line">        <span class="comment">//printk(KERN_INFO &quot;DM9KS:enable promiscuous mode\n&quot;);</span></span><br><span class="line">        iow(db, DM9KS_RXCR, ior(db,DM9KS_RXCR)|(<span class="number">1</span>&lt;&lt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//printk(KERN_INFO &quot;DM9KS:disable promiscuous mode\n&quot;);</span></span><br><span class="line">        iow(db, DM9KS_RXCR, ior(db,DM9KS_RXCR)&amp;(~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Receive all multicast packets */</span></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;flags &amp; IFF_ALLMULTI)&#123;</span><br><span class="line">        <span class="comment">//printk(KERN_INFO &quot;DM9KS:Pass all multicast\n&quot;);</span></span><br><span class="line">        iow(db, DM9KS_RXCR, ior(db,DM9KS_RXCR)|(<span class="number">1</span>&lt;&lt;<span class="number">3</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//printk(KERN_INFO &quot;DM9KS:Disable pass all multicast\n&quot;);</span></span><br><span class="line">        iow(db, DM9KS_RXCR, ior(db,DM9KS_RXCR)&amp;(~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set Node address */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, oft = <span class="number">0x10</span>; i &lt; <span class="number">6</span>; i++, oft++)</span><br><span class="line">        iow(db, oft, dev-&gt;dev_addr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clear Hash Table */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        hash_table[i] = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* broadcast address */</span></span><br><span class="line">    hash_table[<span class="number">3</span>] = <span class="number">0x8000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the multicast address in Hash Table : 64 bits */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mc_cnt; i++, mcptr = mcptr-&gt;next) &#123;</span><br><span class="line">        hash_val = cal_CRC((<span class="keyword">char</span> *)mcptr-&gt;dmi_addr, <span class="number">6</span>, <span class="number">0</span>) &amp; <span class="number">0x3f</span>;</span><br><span class="line">        hash_table[hash_val / <span class="number">16</span>] |= (u16) <span class="number">1</span> &lt;&lt; (hash_val % <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the hash table to MAC MD table */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, oft = <span class="number">0x16</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        iow(db, oft++, hash_table[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">        iow(db, oft++, (hash_table[i] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Calculate the CRC valude of the Rx packet</span></span><br><span class="line"><span class="comment">  flag = 1 : return the reverse CRC (for the received packet CRC)</span></span><br><span class="line"><span class="comment">         0 : return the normal CRC (for Hash Table index)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">cal_CRC</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> * Data, <span class="keyword">unsigned</span> <span class="keyword">int</span> Len, u8 flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u32 crc = ether_crc_le(Len, Data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">        <span class="keyword">return</span> ~crc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mdio_read</span><span class="params">(struct net_device *dev, <span class="keyword">int</span> phy_id, <span class="keyword">int</span> location)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="keyword">return</span> phy_read(db, location);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mdio_write</span><span class="params">(struct net_device *dev, <span class="keyword">int</span> phy_id, <span class="keyword">int</span> location, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    phy_write(db, location, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Read a byte from I/O port</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">u8 <span class="title">ior</span><span class="params">(<span class="keyword">board_info_t</span> *db, <span class="keyword">int</span> reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outb(reg, db-&gt;io_addr);</span><br><span class="line">    <span class="keyword">return</span> inb(db-&gt;io_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Write a byte to I/O port</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iow</span><span class="params">(<span class="keyword">board_info_t</span> *db, <span class="keyword">int</span> reg, u8 value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outb(reg, db-&gt;io_addr);</span><br><span class="line">    outb(value, db-&gt;io_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Read a word from phyxcer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u16 <span class="title">phy_read</span><span class="params">(<span class="keyword">board_info_t</span> *db, <span class="keyword">int</span> reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Fill the phyxcer register into REG_0C */</span></span><br><span class="line">    iow(db, DM9KS_EPAR, DM9KS_PHY | reg);</span><br><span class="line"></span><br><span class="line">    iow(db, DM9KS_EPCR, <span class="number">0xc</span>);   <span class="comment">/* Issue phyxcer read command */</span></span><br><span class="line">    <span class="keyword">while</span>(ior(db, DM9KS_EPCR)&amp;<span class="number">0x1</span>); <span class="comment">/* Wait read complete */</span></span><br><span class="line">    iow(db, DM9KS_EPCR, <span class="number">0x0</span>);   <span class="comment">/* Clear phyxcer read command */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The read data keeps on REG_0D &amp; REG_0E */</span></span><br><span class="line">    <span class="keyword">return</span> ( ior(db, DM9KS_EPDRH) &lt;&lt; <span class="number">8</span> ) | ior(db, DM9KS_EPDRL);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Write a word to phyxcer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">phy_write</span><span class="params">(<span class="keyword">board_info_t</span> *db, <span class="keyword">int</span> reg, u16 value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Fill the phyxcer register into REG_0C */</span></span><br><span class="line">    iow(db, DM9KS_EPAR, DM9KS_PHY | reg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fill the written data into REG_0D &amp; REG_0E */</span></span><br><span class="line">    iow(db, DM9KS_EPDRL, (value &amp; <span class="number">0xff</span>));</span><br><span class="line">    iow(db, DM9KS_EPDRH, ( (value &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>));</span><br><span class="line"></span><br><span class="line">    iow(db, DM9KS_EPCR, <span class="number">0xa</span>);   <span class="comment">/* Issue phyxcer write command */</span></span><br><span class="line">    <span class="keyword">while</span>(ior(db, DM9KS_EPCR)&amp;<span class="number">0x1</span>); <span class="comment">/* Wait read complete */</span></span><br><span class="line">    iow(db, DM9KS_EPCR, <span class="number">0x0</span>);   <span class="comment">/* Clear phyxcer write command */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//====dmfe_ethtool_ops member functions====</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmfe_get_drvinfo</span><span class="params">(struct net_device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct ethtool_drvinfo *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//board_info_t *db = (board_info_t *)dev-&gt;priv;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(info-&gt;driver, DRV_NAME);</span><br><span class="line">    <span class="built_in">strcpy</span>(info-&gt;version, DRV_VERSION);</span><br><span class="line">    <span class="built_in">sprintf</span>(info-&gt;bus_info, <span class="string">&quot;ISA 0x%lx irq=%d&quot;</span>,dev-&gt;base_addr, dev-&gt;irq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_get_settings</span><span class="params">(struct net_device *dev, struct ethtool_cmd *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    spin_lock_irq(&amp;db-&gt;lock);</span><br><span class="line">    mii_ethtool_gset(&amp;db-&gt;mii, cmd);</span><br><span class="line">    spin_unlock_irq(&amp;db-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_set_settings</span><span class="params">(struct net_device *dev, struct ethtool_cmd *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">    spin_lock_irq(&amp;db-&gt;lock);</span><br><span class="line">    rc = mii_ethtool_sset(&amp;db-&gt;mii, cmd);</span><br><span class="line">    spin_unlock_irq(&amp;db-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Check the link state</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">dmfe_get_link</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="keyword">return</span> mii_link_ok(&amp;db-&gt;mii);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Reset Auto-negitiation</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_nway_reset</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="keyword">return</span> mii_nway_restart(&amp;db-&gt;mii);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Get RX checksum offload state</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">dmfe_get_rx_csum</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    <span class="keyword">return</span> db-&gt;rx_csum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Get TX checksum offload state</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">dmfe_get_tx_csum</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (dev-&gt;features &amp; NETIF_F_HW_CSUM) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Enable/Disable RX checksum offload</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_set_rx_csum</span><span class="params">(struct net_device *dev, <span class="keyword">uint32_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CHECKSUM</span></span><br><span class="line">    <span class="keyword">board_info_t</span> *db = (<span class="keyword">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line">    db-&gt;rx_csum = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(netif_running(dev)) &#123;</span><br><span class="line">        dmfe_stop(dev);</span><br><span class="line">        dmfe_open(dev);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        dmfe_init_dm9000(dev);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;DM9:Don&#x27;t support checksum\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Enable/Disable TX checksum offload</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dmfe_set_tx_csum</span><span class="params">(struct net_device *dev, <span class="keyword">uint32_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CHECKSUM</span></span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">        dev-&gt;features |= NETIF_F_HW_CSUM;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dev-&gt;features &amp;= ~NETIF_F_HW_CSUM;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;DM9:Don&#x27;t support checksum\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=========================================</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,28)  <span class="comment">/* for kernel 2.4.28 */</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ethtool_ops</span> <span class="title">dmfe_ethtool_ops</span> =</span> &#123;</span><br><span class="line">    .get_drvinfo        = dmfe_get_drvinfo,</span><br><span class="line">    .get_settings       = dmfe_get_settings,</span><br><span class="line">    .set_settings       = dmfe_set_settings,</span><br><span class="line">    .get_link           = dmfe_get_link,</span><br><span class="line">    .nway_reset     = dmfe_nway_reset,</span><br><span class="line">    .get_rx_csum        = dmfe_get_rx_csum,</span><br><span class="line">    .set_rx_csum        = dmfe_set_rx_csum,</span><br><span class="line">    .get_tx_csum        = dmfe_get_tx_csum,</span><br><span class="line">    .set_tx_csum        = dmfe_set_tx_csum,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化一点, 不去考虑MODULE的设置. ===== for jz2440 =====</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1  <span class="comment">// #ifdef MODULE</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Davicom DM9000/DM9010 ISA/uP Fast Ethernet Driver&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)</span></span><br><span class="line">MODULE_PARM(mode, <span class="string">&quot;i&quot;</span>);</span><br><span class="line">MODULE_PARM(irq, <span class="string">&quot;i&quot;</span>);</span><br><span class="line">MODULE_PARM(iobase, <span class="string">&quot;i&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">module_param(mode, <span class="keyword">int</span>, <span class="number">0</span>);</span><br><span class="line">module_param(irq, <span class="keyword">int</span>, <span class="number">0</span>);</span><br><span class="line">module_param(iobase, <span class="keyword">int</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">MODULE_PARM_DESC(mode,<span class="string">&quot;Media Speed, 0:10MHD, 1:10MFD, 4:100MHD, 5:100MFD&quot;</span>);</span><br><span class="line">MODULE_PARM_DESC(irq,<span class="string">&quot;EtherLink IRQ number&quot;</span>);</span><br><span class="line">MODULE_PARM_DESC(iobase, <span class="string">&quot;EtherLink I/O base address&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Description:</span></span><br><span class="line"><span class="comment">   when user used insmod to add module, system invoked init_module()</span></span><br><span class="line"><span class="comment">   to initilize and register.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">init_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ===== for jz2440 =====</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *bwscon;             <span class="comment">// 0x48000000</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *bankcon4;           <span class="comment">// 0x48000014</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> val;</span><br><span class="line"></span><br><span class="line">    iobase = (<span class="keyword">int</span>)ioremap(<span class="number">0x20000000</span>, <span class="number">1024</span>);    <span class="comment">// 设置映射地址. 这里多映射了一点范围.</span></span><br><span class="line">    irq    = IRQ_EINT7;                         <span class="comment">// 设置中断号</span></span><br><span class="line"><span class="comment">/*  */</span></span><br><span class="line">    bwscon   = ioremap(<span class="number">0x48000000</span>, <span class="number">4</span>);          <span class="comment">// 设置S3C2440的memory controller</span></span><br><span class="line">    bankcon4 = ioremap(<span class="number">0x48000014</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DW4[17:16]: 01-16bit</span></span><br><span class="line"><span class="comment">     * WS4[18]   : 0-WAIT disable</span></span><br><span class="line"><span class="comment">     * ST4[19]   : 0 = Not using UB/LB (The pins are dedicated nWBE[3:0])</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    val = *bwscon;</span><br><span class="line">    val &amp;= ~(<span class="number">0xf</span>&lt;&lt;<span class="number">16</span>);</span><br><span class="line">    val |= (<span class="number">1</span>&lt;&lt;<span class="number">16</span>);</span><br><span class="line">    *bwscon = val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Tacs[14:13]: 发出片选信号之前,多长时间内要先发出地址信号</span></span><br><span class="line"><span class="comment">     *              DM9000C的片选信号和CMD信号可以同时发出,</span></span><br><span class="line"><span class="comment">     *              所以它设为0</span></span><br><span class="line"><span class="comment">     * Tcos[12:11]: 发出片选信号之后,多长时间才能发出读信号nOE</span></span><br><span class="line"><span class="comment">     *              DM9000C的T1&gt;=0ns,</span></span><br><span class="line"><span class="comment">     *              所以它设为0</span></span><br><span class="line"><span class="comment">     * Tacc[10:8] : 读写信号的脉冲长度,</span></span><br><span class="line"><span class="comment">     *              DM9000C的T2&gt;=10ns,</span></span><br><span class="line"><span class="comment">     *              所以它设为1, 表示2个hclk周期,hclk=100MHz,就是20ns</span></span><br><span class="line"><span class="comment">     * Tcoh[7:6]  : 当读信号nOE变为高电平后,片选信号还要维持多长时间</span></span><br><span class="line"><span class="comment">     *              DM9000C进行写操作时, nWE变为高电平之后, 数据线上的数据还要维持最少3ns</span></span><br><span class="line"><span class="comment">     *              DM9000C进行读操作时, nOE变为高电平之后, 数据线上的数据在6ns之内会消失</span></span><br><span class="line"><span class="comment">     *              我们取一个宽松值: 让片选信号在nOE放为高电平后,再维持10ns,</span></span><br><span class="line"><span class="comment">     *              所以设为01</span></span><br><span class="line"><span class="comment">     * Tcah[5:4]  : 当片选信号变为高电平后, 地址信号还要维持多长时间</span></span><br><span class="line"><span class="comment">     *              DM9000C的片选信号和CMD信号可以同时出现,同时消失</span></span><br><span class="line"><span class="comment">     *              所以设为0</span></span><br><span class="line"><span class="comment">     * PMC[1:0]   : 00-正常模式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    *bankcon4 = (<span class="number">1</span>&lt;&lt;<span class="number">8</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);      <span class="comment">// 对于DM9000C可以设Tacc为1, 对于DM9000E,Tacc要设大一点,比如最大值7</span></span><br><span class="line">    <span class="comment">//*bankcon4 = (7&lt;&lt;8)|(1&lt;&lt;6);    // MINI2440使用DM9000E,Tacc要设大一点</span></span><br><span class="line"></span><br><span class="line">    iounmap(bwscon);</span><br><span class="line">    iounmap(bankcon4);</span><br><span class="line"><span class="comment">// ===== end =====</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> DM9KS_10MHD:</span><br><span class="line">        <span class="keyword">case</span> DM9KS_100MHD:</span><br><span class="line">        <span class="keyword">case</span> DM9KS_10MFD:</span><br><span class="line">        <span class="keyword">case</span> DM9KS_100MFD:</span><br><span class="line">            media_mode = mode;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            media_mode = DM9KS_AUTO;</span><br><span class="line">    &#125;</span><br><span class="line">    dmfe_dev = dmfe_probe();</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dmfe_dev))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(dmfe_dev);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Description:</span></span><br><span class="line"><span class="comment">   when user used rmmod to delete module, system invoked clean_module()</span></span><br><span class="line"><span class="comment">   to  un-register DEVICE.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __exit <span class="title">cleanup_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> dmfe_dev;</span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;clean_module()&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    unregister_netdev(dmfe_dev);</span><br><span class="line">    release_region(dev-&gt;base_addr, <span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)</span></span><br><span class="line">    kfree(dev);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    free_netdev(dev);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    iounmap((<span class="keyword">void</span> *)iobase);                    <span class="comment">// ===== for jz2440 =====</span></span><br><span class="line">    DMFE_DBUG(<span class="number">0</span>, <span class="string">&quot;clean_module() exit&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== for jz2440 =====</span></span><br><span class="line">module_init(init_module);                       <span class="comment">// 添加驱动的入口和出口函数</span></span><br><span class="line">module_exit(cleanup_module);</span><br><span class="line"><span class="comment">// ===== end =====</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6_custom  复制一个新的内核源码目录</span></span><br><span class="line">$ <span class="built_in">cd</span> ./drivers/net/</span><br><span class="line">$ cp ./dm9dev9000c.c ./dm9dev9000c.back         <span class="comment"># 将原有的驱动备份一下</span></span><br><span class="line"><span class="comment"># 然后将上面的 dm9dev9000c.c 覆盖掉内核里的这个文件.</span></span><br><span class="line"><span class="comment"># Makefile 不用改, 因为jz2440的patch包已经改好了.</span></span><br><span class="line"></span><br><span class="line">$ make clean                                    <span class="comment"># 没把握的话, clean一下</span></span><br><span class="line">$ make uImage</span><br><span class="line"><span class="comment"># 烧录新的uImage</span></span><br><span class="line"><span class="comment"># 重启开发板进入uboot烧录界面, 按k准备烧录内核. 略过不表</span></span><br><span class="line">$ sudo dnw ./arch/arm/boot/uImage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># 重启, 查看是否能正常启动, 能否进入nfs目录.</span></span><br><span class="line">$ ifcofig                                       <span class="comment"># 查看网卡信息</span></span><br><span class="line">$ ping 10.0.0.100                               <span class="comment"># ping Ubuntu 主机</span></span><br></pre></td></tr></table></figure>

<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2018/01/26/1812-drv-nor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/26/1812-drv-nor/" class="post-title-link" itemprop="url">驱动之NOR Flash</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-01-26 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-26T00:00:00+11:00">2018-01-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2018-02-06 20:18:14" itemprop="dateModified" datetime="2018-02-06T20:18:14+11:00">2018-02-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/embedded-linux/" itemprop="url" rel="index"><span itemprop="name">embedded linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/22/1809-drv-blk/">驱动之块设备-框架</a></li>
<li><a href="https://draapho.github.io/2018/01/24/1810-drv-nand1/">驱动之NAND Flash框架</a></li>
<li><a href="https://draapho.github.io/2018/01/25/1811-drv-nand2/">驱动之NAND Flash源码</a></li>
<li><a href="https://draapho.github.io/2018/01/26/1812-drv-nor/">驱动之NOR Flash</a></li>
<li><a href="https://draapho.github.io/2018/02/06/1813-drv-net/">驱动之网卡驱动</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="NOR-Flash-基础知识"><a href="#NOR-Flash-基础知识" class="headerlink" title="NOR Flash 基础知识"></a>NOR Flash 基础知识</h1><h2 id="NAND-和-NOR-Flash的比较"><a href="#NAND-和-NOR-Flash的比较" class="headerlink" title="NAND 和 NOR Flash的比较"></a>NAND 和 NOR Flash的比较</h2><table>
<thead>
<tr>
<th>NOR FLASH</th>
<th>NAND FLASH</th>
</tr>
</thead>
<tbody><tr>
<td>接口时序同SRAM,易使用</td>
<td>地址/数据线复用，数据位较窄</td>
</tr>
<tr>
<td>读取速度较快</td>
<td>读取速度较慢</td>
</tr>
<tr>
<td>擦除速度慢，以64-128KB的块为单位</td>
<td>擦除速度快，以8－32KB的块为单位</td>
</tr>
<tr>
<td>写入速度慢</td>
<td>写入速度快</td>
</tr>
<tr>
<td>随机存取速度较快，支持XIP(eXecute In Place，芯片内执行)，适用于代码存储。在嵌入式系统中，常用于存放引导程序、根文件系统等。</td>
<td>顺序读取速度较快，随机存取速度慢，适用于数据存储(如大容量的多媒体应用)。在嵌入式系统中，常用于存放用户文件系统等。</td>
</tr>
<tr>
<td>单片容量较小，1-32MB</td>
<td>单片容量较大，8-128MB，提高了单元密度</td>
</tr>
<tr>
<td>最大擦写次数10万次</td>
<td>最大擦写次数100万次</td>
</tr>
</tbody></table>
<h2 id="硬件接口"><a href="#硬件接口" class="headerlink" title="硬件接口"></a>硬件接口</h2><p>看相关数据手册, 以jz2440v3开发板为例:</p>
<ul>
<li><code>MX29LV160DBTI-70G.pdf</code> NOR Flash 数据手册</li>
<li><code>S3C2440A_UserManual_Rev13.pdf</code> CPU 数据手册</li>
</ul>
<p><img src="https://draapho.github.io/images/1812/nor1.JPG" alt="nor1.png"></p>
<p>注意几点:</p>
<ul>
<li>NOR Flash 的特性和RAM一样, 可以直接用物理地址来操作.<ul>
<li>当开发板以NOR Flash启动时, 0开始的地址就是指向NOR Flash的.</li>
</ul>
</li>
<li>NOR Flash 数据位宽有两种接法, 16bit 和 8bit. jz2440用的16bit接法<ul>
<li>因此, 用uboot测试时, 需要使用 <code>mw.w</code> <code>md.w</code> 来操作内存地址</li>
<li><code>mw</code> Memory Write. uboot下的写内存指令</li>
<li><code>md</code> Memory Display. uboot下的读内存指令</li>
<li>使用16bit接法时, CPU的地址线0是不接的. 因而指令上有个错位.</li>
<li>譬如: jz2440发出 (555h&lt;&lt;1), NOR Flash才能收到555h这个地址.</li>
</ul>
</li>
<li>NOR Flash 有两种模式, jedec, cfi<ul>
<li>jedec, 无法直接从芯片内读取详细信息, 需要根据芯片ID软件查表.</li>
<li>cfi, Common Flash Interface, 可以直接查询芯片详细信息.</li>
<li>目前大多数 NOR Flash 都支持 cfi 规范.</li>
</ul>
</li>
</ul>
<h2 id="读写实验"><a href="#读写实验" class="headerlink" title="读写实验"></a>读写实验</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot 命令行, 确保是从 NOR Flash 启动的uboot!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 ID. 2440的A1接到NOR的A0，所以2440发出的地址全部要左移一位</span></span><br><span class="line">mw.w aaa aa             <span class="comment"># Addr = 555&lt;&lt;1</span></span><br><span class="line">mw.w 554 55             <span class="comment"># Addr = 2AA&lt;&lt;1</span></span><br><span class="line">mw.w aaa 90             <span class="comment"># Addr = 555&lt;&lt;1</span></span><br><span class="line">md.w 0 1</span><br><span class="line"><span class="comment"># 显示 00c2, Manifacture ID</span></span><br><span class="line">md.w 2 1                <span class="comment"># Addr = 1&lt;&lt;1</span></span><br><span class="line"><span class="comment"># 显示 2249, 表示型号 MX29LV160DB</span></span><br><span class="line">mw.w 0 f0               <span class="comment"># Reset Mode, 退出读ID</span></span><br></pre></td></tr></table></figure>

<h1 id="NOR-Flash-系统框架"><a href="#NOR-Flash-系统框架" class="headerlink" title="NOR Flash 系统框架"></a>NOR Flash 系统框架</h1><h2 id="系统自带驱动"><a href="#系统自带驱动" class="headerlink" title="系统自带驱动"></a>系统自带驱动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6</span></span><br><span class="line"></span><br><span class="line">$ make clean</span><br><span class="line">$ make menuconfig                                       <span class="comment"># 增加对NOR Flash的支持</span></span><br><span class="line"><span class="comment"># -&gt; Device Drivers</span></span><br><span class="line"><span class="comment">#   -&gt; Memory Technology Device (MTD) support</span></span><br><span class="line"><span class="comment">#     -&gt; Mapping drivers for chip access</span></span><br><span class="line"><span class="comment">#       &lt;M&gt; CFI Flash device in physical memory map     # CFI NOR Flash, 直接做物理映射就可以了</span></span><br><span class="line"><span class="comment">#       (0x0) Physical start address of flash mapping   # 物理基地址, 从0开始的</span></span><br><span class="line"><span class="comment">#       (0x2000000) Physical length of flash mapping    # 要映射的长度, 就是芯片的大小</span></span><br><span class="line"><span class="comment">#       (2)   Bank width in octets (NEW)                # 数据线位宽, 2就是2字节,  16bit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较 .config 会发现多了如下配置. 从而可以找到文件 &quot;drivers/mtd/chips/phram.c&quot;</span></span><br><span class="line"><span class="comment"># CONFIG_MTD_PHYSMAP=m</span></span><br><span class="line"><span class="comment"># CONFIG_MTD_PHYSMAP_START=0</span></span><br><span class="line"><span class="comment"># CONFIG_MTD_PHYSMAP_LEN=0x2000000</span></span><br><span class="line"><span class="comment"># CONFIG_MTD_PHYSMAP_BANKWIDTH=2</span></span><br><span class="line"></span><br><span class="line">$ make modules                                          <span class="comment"># 会生成 physmap.ko</span></span><br><span class="line">cp ./drivers/mtd/maps/physmap.ko ~/share/jz2440/drivers/nor/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nor/                     # NOR flash驱动目录, nfs</span></span><br><span class="line">$ ls /dev/mtd*                                          <span class="comment"># 查看一下mtd现有设备</span></span><br><span class="line">$ insmod physmap.ko                                     <span class="comment"># 加载驱动</span></span><br><span class="line">$ ls /dev/mtd*                                          <span class="comment"># 增加了若干mtd设备</span></span><br><span class="line">$ cat /proc/mtd</span><br></pre></td></tr></table></figure>

<h2 id="框架分析"><a href="#框架分析" class="headerlink" title="框架分析"></a>框架分析</h2><p>其基本框架和 NAND Flash 是一样的</p>
<p><img src="https://draapho.github.io/images/1812/nor2.png" alt="nor2.png"></p>
<p>下面, 分析一下 CFI NOR Flash 的内核代码框架</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -----&gt; /drivers/mtd/maps/physmap.c</span></span><br><span class="line">module_init(physmap_init)</span><br><span class="line">    platform_driver_register(&amp;physmap_flash_driver);    <span class="comment">// 上来就是自己玩platform框架</span></span><br><span class="line">    platform_device_register(&amp;physmap_flash);</span><br><span class="line"></span><br><span class="line"># 匹配后, 自然是调用probe函数</span><br><span class="line">physmap_flash_probe</span><br><span class="line">    probe_type = rom_probe_types;                       <span class="comment">// &quot;cfi_probe&quot; &quot;jedec_probe&quot; 都是用于NOR Flash的</span></span><br><span class="line">    do_map_probe(*probe_type, &amp;info-&gt;<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----&gt; /drivers/mtd/chips/chipreg.c</span></span><br><span class="line">    do_map_probe</span><br><span class="line">        drv = get_mtd_chip_driver(name);</span><br><span class="line">            list_entry(pos, typeof(*<span class="keyword">this</span>), <span class="built_in">list</span>)        <span class="comment">// this 是 mtd_chip_driver 类型</span></span><br><span class="line">        drv-&gt;probe(<span class="built_in">map</span>);</span><br><span class="line">        <span class="comment">// 搜索 mtd_chip_driver 查看来源. 可以猜出和文件 cfi_probe.c 有关.</span></span><br><span class="line">        <span class="comment">// 实际调用了 cfi_probe      // -----&gt; drivers/mtd/chips/cfi_probe.c</span></span><br><span class="line">    <span class="comment">// -----&gt; 结束, chipreg.c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// add_mtd_partitions                               // 有分区则进行分区, 最终也会调用 add_mtd_device</span></span><br><span class="line">    add_mtd_device                                      <span class="comment">// 添加mtd设备</span></span><br><span class="line">    <span class="comment">// 然后就会跳到 mtdcore.c 后面和 NAND Flash 一样了. 或参考下面的一个例子</span></span><br><span class="line">    <span class="comment">// 最终会去注册 字符设备 和 块设备</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, physmap.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----&gt; drivers/mtd/chips/cfi_probe.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_chip_driver</span> <span class="title">cfi_chipdrv</span>;</span>              <span class="comment">// .probe = cfi_probe</span></span><br><span class="line">cfi_probe</span><br><span class="line">    mtd_do_chip_probe(<span class="built_in">map</span>, &amp;cfi_chip_probe);            <span class="comment">// 识别cfi设备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----&gt; drivers/mtd/chips/gen_probe.c</span></span><br><span class="line">    mtd_do_chip_probe</span><br><span class="line">        genprobe_ident_chips</span><br><span class="line">            cp-&gt;probe_chip                              <span class="comment">// 调用 cfi_chip_probe.probe_chip</span></span><br><span class="line">            <span class="comment">// 实际调用函数 cfi_probe_chip</span></span><br><span class="line">        check_cmd_set                                   <span class="comment">// 初始化 mtd_info 结构体</span></span><br><span class="line">    <span class="comment">// -----&gt; 结束, gen_probe.c</span></span><br><span class="line"></span><br><span class="line">cfi_probe_chip</span><br><span class="line">    cfi_send_gen_cmd                                    <span class="comment">// 发送CFI指令, 获取芯片信息</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, cfi_probe.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/mtd/chips/jedec_probe.c 有 jedec_probe. 用于jedec设备</span></span><br><span class="line"><span class="comment">// drivers/mtd/chips/map_rom.c 有 map_rom_probe. 应该是用于CPU内置的ROM.</span></span><br></pre></td></tr></table></figure>

<p>这样就比较清楚了, 整个Linux代码尽可能的做到功能上的(代码上没有完全做到)分层分离.<br>大框架下有小框架. 譬如 NOR Flash 属于整个MTD大框架的一部分. 但其内部也有自己的一套小框架.</p>
<p>在 NOR Flash 这个例子里面,<br>将通用的底层驱动代码放在文件 <code>/drivers/mtd/maps/physmap.c</code><br>然后probe时, 具体的硬件操作被拆分三个部分 <code>cfi_probe.c</code> <code>jedec_probe.c</code> <code>map_rom.c</code><br>由于probe里面也有共性的东西, 又被提炼成 <code>gen_probe.c</code> 放在一起.</p>
<p>最后, 看一个最简单的例子, ram模拟mtd设备. 将底层硬件相关操作减到了最少.<br>这个RAM mtd设备和 NAND/NOR Flash 平级, 挂在 <code>mtdcore.c</code> 下.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -----&gt; /drivers/mtd/devices/phram.c</span></span><br><span class="line">module_param_call(phram, phram_setup, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">000</span>);         <span class="comment">// 由uboot传递参数进来</span></span><br><span class="line">phram_setup</span><br><span class="line">    register_device(name, start, len);</span><br><span class="line">        <span class="keyword">new</span>-&gt;mtd.XXX = XXX;                                     <span class="comment">// 初始化 mtd_info 结构体</span></span><br><span class="line">        add_mtd_device                                          <span class="comment">// 添加 mtd设备</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// -----&gt; /drivers/mtd/mtdcore.c                        // mtd 设备核心</span></span><br><span class="line">        add_mtd_device</span><br><span class="line">            <span class="keyword">not</span> = list_entry(<span class="keyword">this</span>, struct mtd_notifier, <span class="built_in">list</span>);  <span class="comment">// struct mtd_notifier 结构体是关键</span></span><br><span class="line">            <span class="keyword">not</span>-&gt;add(mtd);                                      <span class="comment">// 调用了add</span></span><br><span class="line">            <span class="comment">// 搜索 mtd_notifier 查看来源, 可知:</span></span><br><span class="line">            <span class="comment">// 实际调用了 mtd_notify_add         // -----&gt; drivers/mtd/mtdchar.c</span></span><br><span class="line">            <span class="comment">// 实际调用了 blktrans_notify_add    // -----&gt; drivers/mtd/mtd_blkdevs.c</span></span><br><span class="line">        <span class="comment">// -----&gt; 结束, mtdcore.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可见, 核心内容就是 初始化mtd_info结构体, 然后 add_mtd_device</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, phram.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----&gt; drivers/mtd/mtdchar.c                                 // 将mtd设备挂载成字符设备</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_notifier</span> <span class="title">notifier</span>;</span>                            <span class="comment">// .add = mtd_notify_add</span></span><br><span class="line">mtd_notify_add</span><br><span class="line">    class_device_create(<span class="string">&quot;mtd%d&quot;</span>)                                <span class="comment">// mtd字符设备, 可读写</span></span><br><span class="line">    class_device_create(<span class="string">&quot;mtd%dro&quot;</span>)                              <span class="comment">// mtd只读字符设备</span></span><br><span class="line">init_mtdchar                                                    <span class="comment">// mtdchar.c 的 module_init</span></span><br><span class="line">    register_chrdev(MTD_CHAR_MAJOR, <span class="string">&quot;mtd&quot;</span>, &amp;mtd_fops)           <span class="comment">// 注册为字符设备</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, mtdchar.c 完成了字符设备的核心步骤.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----&gt; drivers/mtd/mtd_blkdevs.c                             // 将mtd设备挂载成块设备</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_notifier</span> <span class="title">blktrans_notifier</span>;</span>                   <span class="comment">// .add = blktrans_notify_add</span></span><br><span class="line">blktrans_notify_add</span><br><span class="line">    tr = list_entry(<span class="keyword">this</span>, struct mtd_blktrans_ops, <span class="built_in">list</span>);       <span class="comment">// 一样的, 搜索 mtd_blktrans_ops</span></span><br><span class="line">    tr-&gt;add_mtd(tr, mtd);</span><br><span class="line">    <span class="comment">// 可以找到两个文件有初始化, 很明显是块设备读写还是只读的区别. 选取 /drivers/mtd/mtdblock.c</span></span><br><span class="line">    <span class="comment">// 实际调用了 mtdblock_add_mtd</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----&gt; /drivers/mtd/mtdblock.c</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_blktrans_ops</span> <span class="title">mtdblock_tr</span>;</span>                 <span class="comment">// .add_mtd = mtdblock_add_mtd</span></span><br><span class="line">    mtdblock_add_mtd</span><br><span class="line">        add_mtd_blktrans_dev</span><br><span class="line">            alloc_disk                                          <span class="comment">// 分配 gendisk</span></span><br><span class="line">            add_disk                                            <span class="comment">// 注册为块设备</span></span><br><span class="line">    init_mtdblock                                               <span class="comment">// mtdblock.c 的 module_init</span></span><br><span class="line">        register_mtd_blktrans</span><br><span class="line">            register_blkdev                                     <span class="comment">// 获得主设备号</span></span><br><span class="line">            blk_init_queue                                      <span class="comment">// 设置缓冲队列</span></span><br><span class="line">    <span class="comment">// -----&gt; 结束, mtdblock.c 完成了块设备的核心步骤.</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, mtd_blkdevs</span></span><br></pre></td></tr></table></figure>



<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="s3c-nor-c"><a href="#s3c-nor-c" class="headerlink" title="s3c_nor.c"></a>s3c_nor.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参考 drivers\mtd\maps\physmap.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mtd/mtd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mtd/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mtd/partitions.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">map_info</span> *<span class="title">s3c_nor_map</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> *<span class="title">s3c_nor_mtd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_partition</span> <span class="title">s3c_nor_parts</span>[] =</span> &#123;             <span class="comment">// 复杂一点, 做一个分区信息</span></span><br><span class="line">    [<span class="number">0</span>] = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;bootloader_nor&quot;</span>,</span><br><span class="line">        .size   = <span class="number">0x00040000</span>,</span><br><span class="line">        .offset = <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">1</span>] = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;root_nor&quot;</span>,</span><br><span class="line">        .offset = MTDPART_OFS_APPEND,</span><br><span class="line">        .size   = MTDPART_SIZ_FULL,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c_nor_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 1. 分配map_info结构体 */</span></span><br><span class="line">    s3c_nor_map = kzalloc(<span class="keyword">sizeof</span>(struct map_info), GFP_KERNEL);;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 设置: 物理基地址(phys), 大小(size), 位宽(bankwidth), 虚拟基地址(virt) */</span></span><br><span class="line">    s3c_nor_map-&gt;name = <span class="string">&quot;s3c_nor&quot;</span>;</span><br><span class="line">    s3c_nor_map-&gt;phys = <span class="number">0</span>;                                              <span class="comment">// 对应的物理地址</span></span><br><span class="line">    s3c_nor_map-&gt;size = <span class="number">0x2000000</span>;                                      <span class="comment">// NOR的容量</span></span><br><span class="line">    s3c_nor_map-&gt;bankwidth = <span class="number">2</span>;                                         <span class="comment">// 数据线位宽, 单位字节</span></span><br><span class="line">    s3c_nor_map-&gt;virt = ioremap(s3c_nor_map-&gt;phys, s3c_nor_map-&gt;size);  <span class="comment">// 对应的虚拟地址</span></span><br><span class="line">    simple_map_init(s3c_nor_map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 使用: 调用NOR FLASH协议层提供的函数来识别 */</span></span><br><span class="line">    printk(<span class="string">&quot;use cfi_probe\n&quot;</span>);</span><br><span class="line">    s3c_nor_mtd = do_map_probe(<span class="string">&quot;cfi_probe&quot;</span>, s3c_nor_map);               <span class="comment">// 直接去调用 .probe = cfi_probe</span></span><br><span class="line">    <span class="keyword">if</span> (!s3c_nor_mtd) &#123;</span><br><span class="line">        printk(<span class="string">&quot;use jedec_probe\n&quot;</span>);</span><br><span class="line">        s3c_nor_mtd = do_map_probe(<span class="string">&quot;jedec_probe&quot;</span>, s3c_nor_map);         <span class="comment">// 失败, 尝试 jedec 模式</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s3c_nor_mtd) &#123;</span><br><span class="line">        iounmap(s3c_nor_map-&gt;virt);</span><br><span class="line">        kfree(s3c_nor_map);</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. add_mtd_partitions */</span></span><br><span class="line">    add_mtd_partitions(s3c_nor_mtd, s3c_nor_parts, <span class="number">2</span>);                  <span class="comment">// 里面调用 add_mtd_device</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c_nor_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    del_mtd_partitions(s3c_nor_mtd);</span><br><span class="line">    iounmap(s3c_nor_map-&gt;virt);</span><br><span class="line">    kfree(s3c_nor_map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(s3c_nor_init);</span><br><span class="line">module_exit(s3c_nor_exit);</span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m       := s3c_nor.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nor/         # NOR flash驱动目录</span></span><br><span class="line">$ make modules                              <span class="comment"># 生成s3c_nor.ko</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nor/         # NOR flash驱动目录, nfs</span></span><br><span class="line">$ ls /dev/mtd*                              <span class="comment"># 查看现有的mtd设备</span></span><br><span class="line">$ insmod s3c_nor.ko                         <span class="comment"># 加载驱动</span></span><br><span class="line">$ ls /dev/mtd*                              <span class="comment"># 查看新增的mtd设备</span></span><br><span class="line">$ flash_eraseall -j /dev/mtd5               <span class="comment"># 格式化为 jffs2, 注意新增的不一定是mtd5</span></span><br><span class="line">$ mount -t jffs2 /dev/mtdblock5 /mnt        <span class="comment"># 挂载这个设备到 /mnt</span></span><br><span class="line"><span class="comment"># 在 /mnt 下进行文件的创建和操作, 测试该文件系统.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有 flash_eraseall 指令, 则需要编译mtd格式化工具 mtd-utils</span></span><br><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line">$ tar xjf mtd-utils-05.07.23.tar.bz2</span><br><span class="line">$ <span class="built_in">cd</span> mtd-utils-05.07.23/util</span><br><span class="line">$ vim Makefile</span><br><span class="line">    <span class="comment"># ===== 文件内容, 修改如下内容: =====</span></span><br><span class="line">    <span class="comment">#CROSS=arm-linux-   # 需要交叉编译, 取消注释</span></span><br><span class="line">    CROSS=arm-linux-</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line">$ make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端</span></span><br><span class="line"><span class="comment"># 通过nfs拷贝到bin目录下即可.</span></span><br><span class="line"><span class="comment"># pwd = ./mtd-utils-05.07.23/util           # nfs文件</span></span><br><span class="line">$ cp flash_erase flash_eraseall /bin</span><br></pre></td></tr></table></figure>


<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2018/01/25/1811-drv-nand2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/25/1811-drv-nand2/" class="post-title-link" itemprop="url">驱动之NAND Flash源码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-01-25 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-25T00:00:00+11:00">2018-01-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2018-02-06 20:18:14" itemprop="dateModified" datetime="2018-02-06T20:18:14+11:00">2018-02-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/embedded-linux/" itemprop="url" rel="index"><span itemprop="name">embedded linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/22/1809-drv-blk/">驱动之块设备-框架</a></li>
<li><a href="https://draapho.github.io/2018/01/24/1810-drv-nand1/">驱动之NAND Flash框架</a></li>
<li><a href="https://draapho.github.io/2018/01/25/1811-drv-nand2/">驱动之NAND Flash源码</a></li>
<li><a href="https://draapho.github.io/2018/01/26/1812-drv-nor/">驱动之NOR Flash</a></li>
<li><a href="https://draapho.github.io/2018/02/06/1813-drv-net/">驱动之网卡驱动</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>由 <strong>nand flash 系统框架</strong> 分析可知, Linux内核系统以及完成了Nand Flash设备的绝大部分的核心工作.<br>因此Nand Flash驱动真正要做的工作主要就是:</p>
<ul>
<li>分配并初始化 <code>nand_chip</code> 结构体</li>
<li>初始化硬件</li>
<li>调用 <code>nand_scan</code></li>
<li>调用 <code>add_mtd_partitions</code></li>
</ul>
<p>可以参考内核文件的相关源码, 学着写.</p>
<ul>
<li><code>drivers\mtd\nand\at91_nand.c</code></li>
<li><code>drivers\mtd\nand\s3c2410.c</code></li>
</ul>
<p>流程如下图:<br><img src="https://draapho.github.io/images/1810/nand3.jpg" alt="nand3"></p>
<h2 id="s3c-nand-c"><a href="#s3c-nand-c" class="headerlink" title="s3c_nand.c"></a>s3c_nand.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mtd/mtd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mtd/nand.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mtd/partitions.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/clk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-nand.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/nand.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s3c_nand_regs</span> &#123;</span>                              <span class="comment">// 2440芯片NAND Flash相关寄存器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfconf  ;                         <span class="comment">// 物理地址 0x4E000000</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfcont  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfcmd   ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfaddr  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfdata  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfeccd0 ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfeccd1 ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfeccd  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfstat  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfestat0;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfestat1;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfmecc0 ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfmecc1 ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfsecc  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfsblk  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfeblk  ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nand_chip</span> *<span class="title">s3c_nand</span>;</span>                  <span class="comment">// NAND Flash操作的核心结构体</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> *<span class="title">s3c_mtd</span>;</span>                    <span class="comment">// 给两个系统函数使用的结构体</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">s3c_nand_regs</span> *<span class="title">s3c_nand_regs</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_partition</span> <span class="title">s3c_nand_parts</span>[] =</span> &#123;    <span class="comment">// 分区信息</span></span><br><span class="line">    [<span class="number">0</span>] = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;bootloader&quot;</span>,</span><br><span class="line">        .size   = <span class="number">0x00040000</span>,</span><br><span class="line">        .offset = <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">1</span>] = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;params&quot;</span>,</span><br><span class="line">        .offset = MTDPART_OFS_APPEND,</span><br><span class="line">        .size   = <span class="number">0x00020000</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">2</span>] = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;kernel&quot;</span>,</span><br><span class="line">        .offset = MTDPART_OFS_APPEND,</span><br><span class="line">        .size   = <span class="number">0x00200000</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">3</span>] = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;root&quot;</span>,</span><br><span class="line">        .offset = MTDPART_OFS_APPEND,</span><br><span class="line">        .size   = MTDPART_SIZ_FULL,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能用Linux默认的片选函数(nand_set_defaults), 自己根据数据手册写一下.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c2440_select_chip</span><span class="params">(struct mtd_info *mtd, <span class="keyword">int</span> chipnr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (chipnr == <span class="number">-1</span>) &#123;</span><br><span class="line">        s3c_nand_regs-&gt;nfcont |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);            <span class="comment">// NFCONT bit1=1, 取消片选</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s3c_nand_regs-&gt;nfcont &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);           <span class="comment">// NFCONT bit1=0, 使能片选</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c2440_cmd_ctrl</span><span class="params">(struct mtd_info *mtd, <span class="keyword">int</span> dat, <span class="keyword">unsigned</span> <span class="keyword">int</span> ctrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ctrl &amp; NAND_CLE) &#123;</span><br><span class="line">        s3c_nand_regs-&gt;nfcmd = dat;                 <span class="comment">// NFCMMD=dat, 发送命令</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s3c_nand_regs-&gt;nfaddr = dat;                <span class="comment">// NFADDR=dat, 发送地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c2440_dev_ready</span><span class="params">(struct mtd_info *mtd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (s3c_nand_regs-&gt;nfstat &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>));        <span class="comment">// NFSTAT bit0=0, Busy else Ready</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c_nand_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">clk</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 分配nand_chip 和 mtd_info 结构体 */</span></span><br><span class="line">    s3c_nand = kzalloc(<span class="keyword">sizeof</span>(struct nand_chip), GFP_KERNEL);</span><br><span class="line">    s3c_mtd = kzalloc(<span class="keyword">sizeof</span>(struct mtd_info), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得寄存器的虚拟地址. 0x4E000000是这些寄存器的起始物理地址</span></span><br><span class="line">    s3c_nand_regs = ioremap(<span class="number">0x4E000000</span>, <span class="keyword">sizeof</span>(struct s3c_nand_regs));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 设置nand_chip */</span></span><br><span class="line">    <span class="comment">/* nand_chip 需要提供 NAND Flash 操作的基本函数. 通用的函数已经由 nand_set_defaults 设置好了.</span></span><br><span class="line"><span class="comment">     * 需要自己设置的函数主要有: 片选,发指令,发地址,发数据,读数据,判断状态的功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s3c_nand-&gt;select_chip = s3c2440_select_chip;    <span class="comment">// 片选函数</span></span><br><span class="line">    s3c_nand-&gt;cmd_ctrl    = s3c2440_cmd_ctrl;       <span class="comment">// 发送指令/地址</span></span><br><span class="line">    s3c_nand-&gt;IO_ADDR_R   = &amp;s3c_nand_regs-&gt;nfdata; <span class="comment">// 读数据的虚拟地址</span></span><br><span class="line">    s3c_nand-&gt;IO_ADDR_W   = &amp;s3c_nand_regs-&gt;nfdata; <span class="comment">// 发数据的虚拟地址</span></span><br><span class="line">    s3c_nand-&gt;dev_ready   = s3c2440_dev_ready;      <span class="comment">// 芯片Busy/Ready的状态反馈</span></span><br><span class="line">    s3c_nand-&gt;ecc.mode    = NAND_ECC_SOFT;          <span class="comment">// ECC校验方式. 软件或硬件.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 硬件相关的设置: 根据NAND FLASH的手册设置时间参数 */</span></span><br><span class="line">    <span class="comment">// 使能NAND控制器的时钟</span></span><br><span class="line">    clk = clk_get(<span class="literal">NULL</span>, <span class="string">&quot;nand&quot;</span>);                    <span class="comment">// 由名称&quot;nand&quot;获得时钟</span></span><br><span class="line">    clk_enable(clk);                                <span class="comment">// 实际上就是 CLKCON bit[4]=1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 NFCONF 寄存器. 由启动的打印信息可获得 HCLK=100MHz, 设置时序要求.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TACLS    0  <span class="comment">// 发出CLE/ALE之后多长时间才发出nWE信号, 从NAND手册可知CLE/ALE与nWE可以同时发出,所以TACLS=0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWRPH0   1  <span class="comment">// nWE的脉冲宽度, HCLK x ( TWRPH0 + 1 ), 从NAND手册可知它要&gt;=12ns, 所以TWRPH0&gt;=1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWRPH1   0  <span class="comment">// nWE变为高电平后多长时间CLE/ALE才能变为低电平, 从NAND手册可知它要&gt;=5ns, 所以TWRPH1&gt;=0</span></span></span><br><span class="line">    s3c_nand_regs-&gt;nfconf = (TACLS&lt;&lt;<span class="number">12</span>) | (TWRPH0&lt;&lt;<span class="number">8</span>) | (TWRPH1&lt;&lt;<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 NFCONT 寄存器. BIT1=1, 取消片选. BIT0=1, 使能NAND控制器</span></span><br><span class="line">    s3c_nand_regs-&gt;nfcont = (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. 使用: nand_scan */</span></span><br><span class="line">    s3c_mtd-&gt;owner = THIS_MODULE;</span><br><span class="line">    s3c_mtd-&gt;priv  = s3c_nand;</span><br><span class="line">    nand_scan(s3c_mtd, <span class="number">1</span>);                          <span class="comment">// 识别NAND FLASH, 构造mtd_info. 硬件只有1块NAND Flash.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5. add_mtd_partitions</span></span><br><span class="line"><span class="comment">     * 增加 add_mtd_partitions 函数后,</span></span><br><span class="line"><span class="comment">     * 内核必须去掉自带的NAND Flash驱动, 从NFS启动系统.</span></span><br><span class="line"><span class="comment">     * 确认要做这个实验的时候, 再取消下面的注释, 编译测试</span></span><br><span class="line"><span class="comment">     * 如果不需要分区, 只需调用 add_mtd_device(s3c_mtd);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// add_mtd_partitions(s3c_mtd, s3c_nand_parts, 4);  // 告知分区要求, 调用 add_mtd_partitions</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c_nand_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    del_mtd_partitions(s3c_mtd);</span><br><span class="line">    iounmap(s3c_nand_regs);</span><br><span class="line">    kfree(s3c_mtd);</span><br><span class="line">    kfree(s3c_nand);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(s3c_nand_init);</span><br><span class="line">module_exit(s3c_nand_exit);</span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m       := s3c_nand.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<h2 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h2><p>源码没有调用 <code>add_mtd_partitions</code> 时, 简单测试一下NAND Flash是否正常工作了.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nand/            # NAND flash驱动目录</span></span><br><span class="line">$ make modules                                  <span class="comment"># 生成s3c_nand.ko, 忽略 s3c_nand_parts 没有使用的警告信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nand/            # NAND flash驱动目录, nfs</span></span><br><span class="line">$ insmod s3c_nand.ko                            <span class="comment"># 加载驱动</span></span><br><span class="line">NAND device: Manufacturer ID: 0xec, Chip ID: 0xda (Samsung NAND 256MiB 3,3V 8-bit)</span><br><span class="line">Scanning device <span class="keyword">for</span> bad blocks</span><br><span class="line">......</span><br><span class="line"><span class="comment"># 打印信息正确识别了 Nand Flash, 说明底层操作都成功了.</span></span><br></pre></td></tr></table></figure>

<h2 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h2><p>源码调用 <code>add_mtd_partitions</code> 时, 测试过程比较复杂.</p>
<ol>
<li>卸载内核自带的NAND Flash驱动</li>
<li>导致无法从本地Flash启动, 必须设置为从nfs启动</li>
<li>从nfs启动后, 加载 s3c_nand.ko 驱动.</li>
<li>使用工具 <code>mtd-utils</code> 格式化 NAND Flash</li>
<li>格式化后, 就能挂载测试了.</li>
<li>恢复原来的开发环境.</li>
</ol>
<p><strong>这个实验我没有实际去做, 设置和恢复都太麻烦. 而且正常的开发过程是不会这样去操作的.</strong><br>下面给出实验步骤:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 卸载内核自带的NAND Flash驱动</span></span><br><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6_custom  复制一个新的内核源码目录</span></span><br><span class="line"></span><br><span class="line">$ make clean</span><br><span class="line">$ make menuconfig                               <span class="comment"># 去掉自带的HID USB驱动程序</span></span><br><span class="line"><span class="comment"># -&gt; Device Drivers</span></span><br><span class="line"><span class="comment">#   -&gt; Memory Technology Device (MTD) support</span></span><br><span class="line"><span class="comment">#     -&gt; NAND Device Support</span></span><br><span class="line"><span class="comment">#       &lt; &gt; NAND Flash support for S3C2410/S3C2440 SoC  # 取消内置的NAND Flash驱动</span></span><br><span class="line"></span><br><span class="line">$ make uImage</span><br><span class="line"><span class="comment"># 烧录新的uImage</span></span><br><span class="line"><span class="comment"># 重启开发板进入uboot烧录界面, 按k准备烧录内核. 略过不表</span></span><br><span class="line">$ sudo dnw ./arch/arm/boot/uImage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 导致无法从本地Flash启动, 必须设置为从nfs启动.</span><br><span class="line"><span class="comment"># 可参考 &quot;嵌入式linux环境搭建-jz2440开发板&quot; 一文</span></span><br><span class="line"><span class="comment"># 开发板, uboot命令行下</span></span><br><span class="line"><span class="comment"># 要使用nfs功能, 必须正确设置uboot的ip地址, 并且Ubuntu端正确设置了nfs</span></span><br><span class="line"></span><br><span class="line">printenv                                        <span class="comment"># 看下现有的uboot环境, 记好bootargs, 恢复的时候要用的.</span></span><br><span class="line"><span class="comment"># bootargs=noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0</span></span><br><span class="line"><span class="built_in">set</span> bootargs noinitrd root=/dev/nfs nfsroot=10.0.0.98:/fs ip=10.0.0.111:10.0.0.98:10.0.0.138:255.255.255.0::eth0:off init=/linuxrc console=ttySAC0</span><br><span class="line"><span class="comment"># (简化ip: &#x27;set bootargs noinitrd root=/dev/nfs nfsroot=10.0.0.98:/fs ip=10.0.0.111 init=/linuxrc console=ttySAC0&#x27; 也可以工作)</span></span><br><span class="line">save        <span class="comment"># 保存修改</span></span><br><span class="line">reset       <span class="comment"># 重启.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数简要说明:</span></span><br><span class="line"><span class="comment"># &#x27;root=/dev/nfs&#x27; 加载nfs文件系统</span></span><br><span class="line"><span class="comment"># &#x27;nfsroot=10.0.0.98:/fs&#x27; nfs文件系统的来源, 此处是由Ubuntu当nfs服务器, 共享出/fs文件夹</span></span><br><span class="line"><span class="comment"># &#x27;ip=10.0.0.111:10.0.0.98:10.0.0.138:255.255.255.0::eth0:off&#x27; 分别表示:</span></span><br><span class="line"><span class="comment">#  ip= 开发板ip : nfs服务器ip: 网关ip : 子网掩码 :: 开发板网口 : off</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 从nfs启动后, 加载 s3c_nand.ko 驱动.</span><br><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nand/            # NAND flash驱动目录</span></span><br><span class="line">$ make modules                                  <span class="comment"># 生成s3c_nand.ko</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nand/            # NAND flash驱动目录, nfs</span></span><br><span class="line">$ insmod s3c_nand.ko                            <span class="comment"># 加载驱动</span></span><br><span class="line">NAND device: Manufacturer ID: 0xec, Chip ID: 0xda (Samsung NAND 256MiB 3,3V 8-bit)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. 使用工具 mtd-utils 格式化 NAND Flash</span><br><span class="line"><span class="comment"># Ubuntu 主机端, 需要先编译mtd-utils</span></span><br><span class="line">$ tar xjf mtd-utils-05.07.23.tar.bz2</span><br><span class="line">$ <span class="built_in">cd</span> mtd-utils-05.07.23/util</span><br><span class="line">$ vim Makefile</span><br><span class="line">    <span class="comment"># ===== 文件内容, 修改如下内容: =====</span></span><br><span class="line">    <span class="comment">#CROSS=arm-linux-   # 需要交叉编译, 取消注释</span></span><br><span class="line">    CROSS=arm-linux-</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line">$ make</span><br><span class="line"><span class="comment"># 拷贝可执行文件到挂载的nfs文件系统的bin目录下</span></span><br><span class="line">$ cp flash_erase flash_eraseall /home/draapho/share/jz2440/nfs/fs_mini_mdev/bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5. 格式化后, 就能挂载测试了.</span><br><span class="line"><span class="comment"># 开发板端 bash</span></span><br><span class="line">$ ls -l /dev/mtd*                               <span class="comment"># 查看一下分区情况, 有0-3共四个分区</span></span><br><span class="line"><span class="comment"># 应该是用 &quot;flash_eraseall /dev/mtd1&quot; 格式化 &quot;params&quot; 分区, 恢复起来最方便.</span></span><br><span class="line">$ flash_eraseall /dev/mtd3                      <span class="comment"># 格式化 root分区 (用的字符设备), 文件格式为yaffs</span></span><br><span class="line">$ mount -t yaffs /dev/mtdblock3 /tmp            <span class="comment"># 以yaffs格式挂载 root分区</span></span><br><span class="line">$ ls /tmp                                       <span class="comment"># 应该只有一个 lost+found 文件.</span></span><br><span class="line"><span class="comment"># 然后可以对这个分区进行文件创建, 读写的操作了.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6. 恢复原来的开发环境</span><br><span class="line"><span class="comment"># 开发板 uboot:</span></span><br><span class="line"><span class="comment"># 破坏了root区的话, 就恢复root区, 重新烧写文件系统到flash就行了. 猜测使用 params 区做测试是没有影响的.</span></span><br><span class="line"><span class="comment"># 烧录原来的 uImage 到 kernel.</span></span><br><span class="line"><span class="comment"># 改回 uboot 的 bootargs 参数</span></span><br><span class="line"><span class="comment"># 重启, 从NAND Flash正常启动.</span></span><br></pre></td></tr></table></figure>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/TaigaCon/archive/2012/11/17/2775057.html">Linux操作系统下 NAND FLASH驱动程序框架</a></p>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2018/01/24/1810-drv-nand1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/24/1810-drv-nand1/" class="post-title-link" itemprop="url">驱动之NAND Flash框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-01-24 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-24T00:00:00+11:00">2018-01-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2018-02-06 20:18:14" itemprop="dateModified" datetime="2018-02-06T20:18:14+11:00">2018-02-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/embedded-linux/" itemprop="url" rel="index"><span itemprop="name">embedded linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/22/1809-drv-blk/">驱动之块设备-框架</a></li>
<li><a href="https://draapho.github.io/2018/01/24/1810-drv-nand1/">驱动之NAND Flash框架</a></li>
<li><a href="https://draapho.github.io/2018/01/25/1811-drv-nand2/">驱动之NAND Flash源码</a></li>
<li>[驱动之NOR Flash](<a href="https://draapho.github.io/2018/01/26/1812-drv-nor/">https://draapho.github.io/2018/01/26/1812-drv-nor/</a></li>
<li><a href="https://draapho.github.io/2018/02/06/1813-drv-net/">驱动之网卡驱动</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="NAND-Flash-基础知识"><a href="#NAND-Flash-基础知识" class="headerlink" title="NAND Flash 基础知识"></a>NAND Flash 基础知识</h1><h2 id="NAND-和-NOR-Flash的比较"><a href="#NAND-和-NOR-Flash的比较" class="headerlink" title="NAND 和 NOR Flash的比较"></a>NAND 和 NOR Flash的比较</h2><table>
<thead>
<tr>
<th>NOR FLASH</th>
<th>NAND FLASH</th>
</tr>
</thead>
<tbody><tr>
<td>接口时序同SRAM,易使用</td>
<td>地址/数据线复用，数据位较窄</td>
</tr>
<tr>
<td>读取速度较快</td>
<td>读取速度较慢</td>
</tr>
<tr>
<td>擦除速度慢，以64-128KB的块为单位</td>
<td>擦除速度快，以8－32KB的块为单位</td>
</tr>
<tr>
<td>写入速度慢</td>
<td>写入速度快</td>
</tr>
<tr>
<td>随机存取速度较快，支持XIP(eXecute In Place，芯片内执行)，适用于代码存储。在嵌入式系统中，常用于存放引导程序、根文件系统等。</td>
<td>顺序读取速度较快，随机存取速度慢，适用于数据存储(如大容量的多媒体应用)。在嵌入式系统中，常用于存放用户文件系统等。</td>
</tr>
<tr>
<td>单片容量较小，1-32MB</td>
<td>单片容量较大，8-128MB，提高了单元密度</td>
</tr>
<tr>
<td>最大擦写次数10万次</td>
<td>最大擦写次数100万次</td>
</tr>
</tbody></table>
<h2 id="硬件接口和时序"><a href="#硬件接口和时序" class="headerlink" title="硬件接口和时序"></a>硬件接口和时序</h2><p>看相关数据手册, 以jz2440v3开发板为例:</p>
<ul>
<li><code>K9F2G08U0C.pdf</code> NAND Flash 数据手册</li>
<li><code>S3C2440A_UserManual_Rev13.pdf</code> CPU 数据手册</li>
</ul>
<p>NAND Flash的硬件引脚基本固定, 下面列出各个引脚的含义</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>英文原意</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>I/O</td>
<td>data Inputs/Outputs</td>
<td>数据收发, 8bit或16bit</td>
</tr>
<tr>
<td>CLE</td>
<td>Command Latch Enable</td>
<td>传的是指令, 高电平有效</td>
</tr>
<tr>
<td>ALE</td>
<td>Address Latch Enable</td>
<td>传的是地址, 高电平有效</td>
</tr>
<tr>
<td>_CE 或 nCE</td>
<td>Chip Enable</td>
<td>片选信号, 低电平有效</td>
</tr>
<tr>
<td>_RE 或 nRE</td>
<td>Read Enable</td>
<td>读数据, 低电平有效</td>
</tr>
<tr>
<td>_WE 或 nWE</td>
<td>Write Enable</td>
<td>写数据, 低电平有效</td>
</tr>
<tr>
<td>R/_B 或 R/nB</td>
<td>Ready/Busy</td>
<td>空闲/忙信号, 忙为低电平</td>
</tr>
</tbody></table>
<p>查看三星S3C2440数据手册 <code>NAND Flash Controller</code> 章节可知, 已将nand flash的时序操作打包成了寄存器操作.<br>u-boot里面, 可以使用 <code>md</code> <code>mw</code> 直接对memroy进行操作. 因此可在u-boot下面直接用指令来操作nand flash的时序</p>
<ul>
<li><code>md</code>, Memory Display. 显示指定内存地址的内容. <code>.b</code>表Byte, 字节. <code>.w</code>表Word, 2字节. <code>.l</code>表Long, 4字节.</li>
<li><code>mw</code>, Memory Write. 写入内容到指定内存地址. <code>.b</code>表Byte, 字节. <code>.w</code>表Word, 2字节. <code>.l</code>表Long, 4字节.</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>物理操作</th>
<th>S3C2440 寄存器操作</th>
<th>u-boot 直接操作对应的寄存器地址</th>
</tr>
</thead>
<tbody><tr>
<td>片选</td>
<td>_CE低</td>
<td>NFCONT bit1=0</td>
<td>md.l 读一下, mw.l 0x4E000004 回写bit1=0</td>
</tr>
<tr>
<td>发命令</td>
<td>CLE高, ALE低, I/O命令值, _WE高变低</td>
<td>NFCMMD=命令值</td>
<td>mw.b 0x4E000008 命令值</td>
</tr>
<tr>
<td>发地址</td>
<td>ALE高, CLE低, I/O地址值, _WE高变低</td>
<td>NFADDR=地址值</td>
<td>mw.b 0x4E00000C 地址值</td>
</tr>
<tr>
<td>发数据</td>
<td>CLE低, ALE低, I/O数据值, _WE高变低</td>
<td>NFDATA=数据值</td>
<td>mw.b 0x4E000010 数据值</td>
</tr>
<tr>
<td>读数据</td>
<td>CLE低, ALE低, _RE高变低, 取I/O值</td>
<td>数据值=NFDATA</td>
<td>md.b 0x4E000010 1</td>
</tr>
</tbody></table>
<h2 id="读写实验"><a href="#读写实验" class="headerlink" title="读写实验"></a>读写实验</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot 命令行, 最好是从 NAND Flash 启动的uboot.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 读取 ID, 查看 K9F2G08U0C 数据手册 5.5 Read ID 时序图.</span></span><br><span class="line">md.l 0x4E000004 1           <span class="comment"># 读取 NFCONT 寄存器值. 1表示长度, 就读一个数据. 默认值是16</span></span><br><span class="line">mw.l 0x4E000004 1           <span class="comment"># 置 bit1=0 后, 回写</span></span><br><span class="line">mw.b 0x4E000008 0x90        <span class="comment"># 发命令 NFCMMD=0x90</span></span><br><span class="line">mw.b 0x4E00000C 0x00        <span class="comment"># 发地址 NFADDR=0x00</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 读数据 NFDATA, 应该得到 ec</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 继续读 NFDATA, 应该得到device code, da</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 继续读 NFDATA, 应该得到device code, 10</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 继续读 NFDATA, 应该得到device code, 15 (这里返回了95, 先不管)</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 继续读 NFDATA, 应该得到device code, 44</span></span><br><span class="line"><span class="comment"># 这里不能使用指令 md.b 0x4E000010 5 读取5个字节. 因为其含义是读 0x4E000010-0x4E000014 的寄存器值, 必然是错的.</span></span><br><span class="line">mw.b 0x4E000008 0xff        <span class="comment"># 发RESET命令 NFCMMD=0xFF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 读取0地址的数据, 查看 K9F2G08U0C 数据手册 5.1 Page Read 时序图</span></span><br><span class="line">nand dump 0                 <span class="comment"># 先用nand指令直接读取nand flash的页, 后面在用寄存器操作的方式读一遍来对比</span></span><br><span class="line">17 00 00 ea 14 f0 9f e5  14 f0 9f e5 14 f0 9f e5</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">md.l 0x4E000004 1           <span class="comment"># 读取 NFCONT 寄存器值. 1表示长度, 就读一个数据. 默认值是16</span></span><br><span class="line">mw.l 0x4E000004 1           <span class="comment"># 置 bit1=0 后, 回写</span></span><br><span class="line">mw.b 0x4E000008 0x00        <span class="comment"># 写命令 NFCMMD=0x00</span></span><br><span class="line">mw.b 0x4E00000C 0x00        <span class="comment"># 写地址 NFADDR=0x00</span></span><br><span class="line">mw.b 0x4E00000C 0x00        <span class="comment"># 写地址 NFADDR=0x00</span></span><br><span class="line">mw.b 0x4E00000C 0x00        <span class="comment"># 写地址 NFADDR=0x00</span></span><br><span class="line">mw.b 0x4E00000C 0x00        <span class="comment"># 写地址 NFADDR=0x00</span></span><br><span class="line">mw.b 0x4E00000C 0x00        <span class="comment"># 写地址 NFADDR=0x00</span></span><br><span class="line"><span class="comment"># 这款nand总线是8位, 时序图要求5个周期. 由2字节的列地址和3字节的行地址组成.</span></span><br><span class="line">mw.b 0x4E000008 0x30        <span class="comment"># 读命令 NFCMMD=0x30</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 读数据 NFDATA</span></span><br><span class="line">......                      <span class="comment"># 重复多次这个指令, 譬如16次</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 读数据 NFDATA, 得到的数据应该和 nand dump 0 的一样</span></span><br><span class="line"><span class="comment"># 16此返回值应该和 nand dump 的结果一样: 17 00 00 ea 14 f0 9f e5  14 f0 9f e5 14 f0 9f e5</span></span><br><span class="line"><span class="comment"># 这里不能使用指令 md.b 0x4E000010 16 读取16个字节. 因为其含义是读 0x4E000010-0x4E000020 的寄存器值, 必然是错的.</span></span><br><span class="line">mw.b 0x4E000008 0xff        <span class="comment"># 发RESET命令 NFCMMD=0xFF</span></span><br></pre></td></tr></table></figure>

<h1 id="NAND-Flash-系统框架"><a href="#NAND-Flash-系统框架" class="headerlink" title="NAND Flash 系统框架"></a>NAND Flash 系统框架</h1><p><img src="https://draapho.github.io/images/1810/nand1.jpg" alt="nand1"></p>
<p><img src="https://draapho.github.io/images/1810/nand2.png" alt="nand2"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由Linux系统启动时的打印信息, 可以抓取到 NAND FLASH 相关的初始化信息和分区信息.</span></span><br><span class="line"><span class="comment">// 可得 &quot;S3C24XX NAND Driver, ...&quot; 搜索后, 定位到文件 &quot;/drivers/mtd/nand/s3c2410.c&quot;</span></span><br><span class="line"><span class="comment">// mtd: Memory Technology Device. 记忆体技术设备, 也就是 nand/nor flash.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----&gt; /drivers/mtd/nand/s3c2410.c</span></span><br><span class="line">s3c2410_nand_init                                               <span class="comment">// 看驱动文件, 从 module_init 开始</span></span><br><span class="line">    platform_driver_register(&amp;s3c2440_nand_driver);             <span class="comment">// 很明显用了 platform 框架</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----&gt; /arch/arm/plat-s3c24xx/common-smdk.c              // 这里是 platform 框架的 device 配置</span></span><br><span class="line">    smdk_machine_init</span><br><span class="line">        s3c_device_nand.dev.platform_data = &amp;smdk_nand_info;</span><br><span class="line">        platform_add_devices(smdk_devs);                        <span class="comment">// 找到了 platform 的 devices 端.</span></span><br><span class="line">        <span class="comment">// 这里看下 smdk_nand_info, smdk_devs的s3c_device_nand 就都明白了. 配置nand的名称和参数.</span></span><br><span class="line">    <span class="comment">// -----&gt; 结束, common-smdk.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看完了platform框架, 匹配后就是调用probe函数. 几次跳转后, 最终调用:</span></span><br><span class="line">s3c24xx_nand_probe</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s3c2410_platform_nand</span> *<span class="title">plat</span> =</span> to_nand_plat(pdev);    <span class="comment">// 取出了 smdk_nand_info 的配置信息</span></span><br><span class="line">    s3c2410_nand_inithw                                         <span class="comment">// 初始化硬件, 如时序</span></span><br><span class="line">    s3c2410_nand_init_chip                                      <span class="comment">// 初始化通讯, 如缓冲区, 寄存器值</span></span><br><span class="line">    nand_scan                                                   <span class="comment">// 开始通讯, 检查 nand flash</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----&gt; /drivers/mtd/nand/nand_base.c                     // NAND FLASH 操作的通用文件</span></span><br><span class="line">    nand_scan</span><br><span class="line">        nand_scan_ident                                         <span class="comment">// 第一阶段的初始化, 检查flash硬件</span></span><br><span class="line">            nand_set_defaults                                   <span class="comment">// nand 通信使用默认参数</span></span><br><span class="line">            nand_get_flash_type                                 <span class="comment">// 获取第一块 nand 的ID值</span></span><br><span class="line">                nand_flash_ids                                  <span class="comment">// 常用的 nand flash 表. 可见内核都支持了</span></span><br><span class="line">            printk(KERN_INFO <span class="string">&quot;%d NAND chips detected\n&quot;</span>, i);    <span class="comment">// 接了多块nand的话, 必须是同型号的</span></span><br><span class="line">            mtd-&gt;size = i * chip-&gt;chipsize;                     <span class="comment">// 总容量 = nand数量*单片容量</span></span><br><span class="line">        nand_scan_tail                                          <span class="comment">// 第二阶段的初始化工作, 软件设置</span></span><br><span class="line">    <span class="comment">// -----&gt; 结束, nand_base.c</span></span><br><span class="line"></span><br><span class="line">    s3c2410_nand_add_partition                                  <span class="comment">// 分区工作</span></span><br><span class="line">        add_mtd_device</span><br><span class="line">        <span class="comment">// -----&gt; /drivers/mtd/mtdcore.c                        // mtd 设备核心</span></span><br><span class="line">        <span class="comment">// add_mtd_partitions 最终也调用了 add_mtd_device</span></span><br><span class="line">        add_mtd_device</span><br><span class="line">            <span class="keyword">not</span> = list_entry(<span class="keyword">this</span>, struct mtd_notifier, <span class="built_in">list</span>);  <span class="comment">// struct mtd_notifier 结构体是关键</span></span><br><span class="line">            <span class="keyword">not</span>-&gt;add(mtd);                                      <span class="comment">// 调用了add</span></span><br><span class="line">            <span class="comment">// 搜索 mtd_notifier 查看来源, 可知:</span></span><br><span class="line">            <span class="comment">// 实际调用了 mtd_notify_add         // -----&gt; drivers/mtd/mtdchar.c</span></span><br><span class="line">            <span class="comment">// 实际调用了 blktrans_notify_add    // -----&gt; drivers/mtd/mtd_blkdevs.c</span></span><br><span class="line">        <span class="comment">// -----&gt; 结束, mtdcore.c</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, s3c2410.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----&gt; drivers/mtd/mtdchar.c                                 // 将mtd设备挂载成字符设备</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_notifier</span> <span class="title">notifier</span>;</span>                            <span class="comment">// .add = mtd_notify_add</span></span><br><span class="line">mtd_notify_add</span><br><span class="line">    class_device_create(<span class="string">&quot;mtd%d&quot;</span>)                                <span class="comment">// mtd字符设备, 可读写</span></span><br><span class="line">    class_device_create(<span class="string">&quot;mtd%dro&quot;</span>)                              <span class="comment">// mtd只读字符设备</span></span><br><span class="line">init_mtdchar                                                    <span class="comment">// mtdchar.c 的 module_init</span></span><br><span class="line">    register_chrdev(MTD_CHAR_MAJOR, <span class="string">&quot;mtd&quot;</span>, &amp;mtd_fops)           <span class="comment">// 注册为字符设备</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, mtdchar.c 完成了字符设备的核心步骤.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----&gt; drivers/mtd/mtd_blkdevs.c                             // 将mtd设备挂载成块设备</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_notifier</span> <span class="title">blktrans_notifier</span>;</span>                   <span class="comment">// .add = blktrans_notify_add</span></span><br><span class="line">blktrans_notify_add</span><br><span class="line">    tr = list_entry(<span class="keyword">this</span>, struct mtd_blktrans_ops, <span class="built_in">list</span>);       <span class="comment">// 一样的, 搜索 mtd_blktrans_ops</span></span><br><span class="line">    tr-&gt;add_mtd(tr, mtd);</span><br><span class="line">    <span class="comment">// 可以找到两个文件有初始化, 很明显是块设备读写还是只读的区别. 选取 /drivers/mtd/mtdblock.c</span></span><br><span class="line">    <span class="comment">// 实际调用了 mtdblock_add_mtd</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----&gt; /drivers/mtd/mtdblock.c</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_blktrans_ops</span> <span class="title">mtdblock_tr</span>;</span>                 <span class="comment">// .add_mtd = mtdblock_add_mtd</span></span><br><span class="line">    mtdblock_add_mtd</span><br><span class="line">        add_mtd_blktrans_dev</span><br><span class="line">            alloc_disk                                          <span class="comment">// 分配 gendisk</span></span><br><span class="line">            add_disk                                            <span class="comment">// 注册为块设备</span></span><br><span class="line">    init_mtdblock                                               <span class="comment">// mtdblock.c 的 module_init</span></span><br><span class="line">        register_mtd_blktrans</span><br><span class="line">            register_blkdev                                     <span class="comment">// 获得主设备号</span></span><br><span class="line">            blk_init_queue                                      <span class="comment">// 设置缓冲队列</span></span><br><span class="line">    <span class="comment">// -----&gt; 结束, mtdblock.c 完成了块设备的核心步骤.</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, mtd_blkdevs</span></span><br></pre></td></tr></table></figure>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/TaigaCon/archive/2012/11/17/2775057.html">Linux操作系统下 NAND FLASH驱动程序框架</a><br><a target="_blank" rel="noopener" href="http://www.linuxidc.com/Linux/2017-03/142206.htm">Linux MTD子系统 _从模型分析到Flash驱动模板</a><br><a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_6683e49d0100o18j.html">LINUX NAND FLASH驱动程序框架分析</a></p>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2018/01/22/1809-drv-blk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/22/1809-drv-blk/" class="post-title-link" itemprop="url">驱动之块设备-框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-01-22 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-22T00:00:00+11:00">2018-01-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2018-02-06 20:18:14" itemprop="dateModified" datetime="2018-02-06T20:18:14+11:00">2018-02-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/embedded-linux/" itemprop="url" rel="index"><span itemprop="name">embedded linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/22/1809-drv-blk/">驱动之块设备-框架</a></li>
<li><a href="https://draapho.github.io/2018/01/24/1810-drv-nand1/">驱动之NAND Flash框架</a></li>
<li><a href="https://draapho.github.io/2018/01/25/1811-drv-nand2/">驱动之NAND Flash源码</a></li>
<li>[驱动之NOR Flash](<a href="https://draapho.github.io/2018/01/26/1812-drv-nor/">https://draapho.github.io/2018/01/26/1812-drv-nor/</a></li>
<li><a href="https://draapho.github.io/2018/02/06/1813-drv-net/">驱动之网卡驱动</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="块设备的驱动框架"><a href="#块设备的驱动框架" class="headerlink" title="块设备的驱动框架"></a>块设备的驱动框架</h1><h2 id="驱动框架"><a href="#驱动框架" class="headerlink" title="驱动框架"></a>驱动框架</h2><p><img src="https://draapho.github.io/images/1809/block.png" alt="block.png"></p>
<p><img src="https://draapho.github.io/images/1809/block_fun.png" alt="block_fun.png"></p>
<ul>
<li><code>ll_rw_block</code>: Low Level Read/Write block device</li>
<li><code>submit_bh</code>: submit Buffer Head</li>
<li><code>submit_bio</code>: submit Block IO (Input/Output)</li>
<li><code>elv_merge</code>: elevator merge. 用电梯算法合并数据</li>
</ul>
<h2 id="硬盘基础概念"><a href="#硬盘基础概念" class="headerlink" title="硬盘基础概念"></a>硬盘基础概念</h2><p>块设备为了兼容机械结构的硬盘, 使用了一些硬盘特有的概念.</p>
<p><img src="https://draapho.github.io/images/1809/Platter.jpg" alt="Platter.jpg"></p>
<p><img src="https://draapho.github.io/images/1809/Cylinder.png" alt="Cylinder.png"></p>
<ul>
<li><code>存储容量 = 磁头数 x 柱面数 x 扇区数 x 512(扇区字节数)</code></li>
<li><code>存储容量 = 柱面大小 x 柱面数</code></li>
<li><code>柱面大小 = 磁头数 x 扇区数 x 512(扇区字节数)</code></li>
</ul>
<table>
<thead>
<tr>
<th>英语</th>
<th>中文</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Disk</td>
<td>磁盘</td>
<td>就是硬盘</td>
</tr>
<tr>
<td>Platter</td>
<td>圆盘</td>
<td>硬盘的盘片</td>
</tr>
<tr>
<td>Head</td>
<td>磁头</td>
<td>盘片有2面: 2磁头/圆盘</td>
</tr>
<tr>
<td>Track</td>
<td>磁道</td>
<td>圆盘被分割为多个同心圆, 即磁道</td>
</tr>
<tr>
<td>Sector</td>
<td>扇区</td>
<td>磁道被分割后的扇形区域</td>
</tr>
<tr>
<td>Cylinder</td>
<td>柱面</td>
<td>由多个圆盘的同一磁道构成</td>
</tr>
<tr>
<td>Partition</td>
<td>分区</td>
<td>软件概念, 以柱面为单位</td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://draapho.github.io/2017/02/01/1704-linux-source4/">Linux 0.11 源码阅读笔记-设备驱动程序</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/zdy0_2004/article/details/78206395">Linux-块设备驱动之框架详细分析(详解)</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/hustfoxy/article/details/8723178">Linux块设备驱动</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-23069658-id-3413957.html">硬盘的存储原理和内部架构</a></li>
<li><a target="_blank" rel="noopener" href="http://www.bijishequ.com/detail/193530">计算机机械硬盘的结构和工作原理</a></li>
<li><a target="_blank" rel="noopener" href="http://www.dongcoder.com/detail-473552.html">磁盘的组成</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/joydinghappy/articles/2511948.html">磁盘结构简介</a></li>
</ul>
<h1 id="块设备驱动范例"><a href="#块设备驱动范例" class="headerlink" title="块设备驱动范例"></a>块设备驱动范例</h1><p>块设备驱动的实现更为简单. Linux内核做掉了大部分工作, 驱动层只需要专注于硬件的块读写功能.<br>而且其框架相对固定, 不像字符设备有多种不同的框架组合.</p>
<p>可以参考内核里的两个文件</p>
<ul>
<li><code>drivers\block\xd.c</code> 用于 XT hard disk.</li>
<li><code>drivers\block\z2ram.c</code> ram disk.</li>
<li>给出的源码没有做返回值判断, <strong>实际使用时务必参考上面的范例实现错误处理</strong>.</li>
</ul>
<p>基本步骤如下:</p>
<ol>
<li>分配gendisk: <code>alloc_disk</code></li>
<li>设置<br> 2.1 分配/设置缓冲队列. <code>blk_init_queue</code><br> 2.2 设置gendisk其他信息, 用于提供硬件属性, 如容量</li>
<li>硬件初始化操作</li>
<li>注册: <code>add_disk</code></li>
</ol>
<h2 id="ramblock-c"><a href="#ramblock-c" class="headerlink" title="ramblock.c"></a>ramblock.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/vmalloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/blkdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/hdreg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NAME <span class="meta-string">&quot;RAMDISK&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAMBLOCK_SIZE (1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> major;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> *<span class="title">ramblock_disk</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">request_queue_t</span> *ramblock_queue;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_SPINLOCK</span><span class="params">(ramblock_lock)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *ramblock_buf;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区需要知道&quot;硬盘&quot;的几何结构(geometry), 这里虚拟一下即可.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ramblock_getgeo</span><span class="params">(struct block_device *bdev, struct hd_geometry *geo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    geo-&gt;heads     = <span class="number">2</span>;                                     <span class="comment">// 磁头数=盘面数*2</span></span><br><span class="line">    geo-&gt;cylinders = <span class="number">32</span>;                                    <span class="comment">// 柱面数</span></span><br><span class="line">    geo-&gt;sectors   = RAMBLOCK_SIZE/<span class="number">2</span>/<span class="number">32</span>/<span class="number">512</span>;                <span class="comment">// 扇区数. 利用公式: 存储容量=磁头数x柱面数x扇区数x512</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> <span class="title">ramblock_fops</span> =</span> &#123;</span><br><span class="line">    .owner  = THIS_MODULE,</span><br><span class="line">    .getgeo = ramblock_getgeo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现扇区的读写操作</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_ramblock_request</span><span class="params">(<span class="keyword">request_queue_t</span> * q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> r_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> w_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((req = elv_next_request(q)) != <span class="literal">NULL</span>) &#123;           <span class="comment">// 取出要处理的数据(连续的扇区数据, 即簇)</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> offset = req-&gt;sector*<span class="number">512</span>;             <span class="comment">// 读写的目标地址</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> len = req-&gt;current_nr_sectors*<span class="number">512</span>;    <span class="comment">// 长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rq_data_dir(req) == READ) &#123;                     <span class="comment">// 读操作</span></span><br><span class="line">            printk(<span class="string">&quot;do_ramblock_request read %d\n&quot;</span>, ++r_cnt);</span><br><span class="line">            <span class="built_in">memcpy</span>(req-&gt;buffer, ramblock_buf+offset, len);  <span class="comment">// 直接读 ramblock_buf</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                            <span class="comment">// 写操作</span></span><br><span class="line">            printk(<span class="string">&quot;do_ramblock_request write %d\n&quot;</span>, ++w_cnt);</span><br><span class="line">            <span class="built_in">memcpy</span>(ramblock_buf+offset, req-&gt;buffer, len);  <span class="comment">// 直接写 ramblock_buf</span></span><br><span class="line">        &#125;</span><br><span class="line">        end_request(req, <span class="number">1</span>);                                <span class="comment">// 告知操作完成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ramblock_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 1. 分配一个gendisk结构体 */</span></span><br><span class="line">    ramblock_disk = alloc_disk(<span class="number">16</span>);                         <span class="comment">// 次设备号个数, 也是允许的最大分区个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 设置 */</span></span><br><span class="line">    <span class="comment">/* 2.1 分配/设置缓冲队列 */</span></span><br><span class="line">    ramblock_queue = blk_init_queue(do_ramblock_request, &amp;ramblock_lock);</span><br><span class="line">    ramblock_disk-&gt;<span class="built_in">queue</span> = ramblock_queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2.2 设置其他属性: 比如容量 */</span></span><br><span class="line">    major = register_blkdev(<span class="number">0</span>, DEVICE_NAME);                <span class="comment">// cat /proc/devices 查看块设备</span></span><br><span class="line">    ramblock_disk-&gt;major       = major;                     <span class="comment">// 主设备号</span></span><br><span class="line">    ramblock_disk-&gt;first_minor = <span class="number">0</span>;                         <span class="comment">// 次设备号起始值</span></span><br><span class="line">    <span class="built_in">sprintf</span>(ramblock_disk-&gt;disk_name, <span class="string">&quot;ramblock&quot;</span>);</span><br><span class="line">    ramblock_disk-&gt;fops        = &amp;ramblock_fops;</span><br><span class="line">    set_capacity(ramblock_disk, RAMBLOCK_SIZE / <span class="number">512</span>);       <span class="comment">// 设置扇区的数量, 不是字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 硬件初始化操作 */</span></span><br><span class="line">    ramblock_buf = kzalloc(RAMBLOCK_SIZE, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. 注册 */</span></span><br><span class="line">    add_disk(ramblock_disk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ramblock_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    del_gendisk(ramblock_disk);                     <span class="comment">// 对应 add_disk</span></span><br><span class="line">    put_disk(ramblock_disk);                        <span class="comment">// 对应 blk_init_queue</span></span><br><span class="line">    blk_cleanup_queue(ramblock_queue);              <span class="comment">// 对应 blk_init_queue</span></span><br><span class="line">    unregister_blkdev(major, DEVICE_NAME);          <span class="comment">// 对应 register_blkdev</span></span><br><span class="line">    kfree(ramblock_buf);                            <span class="comment">// 安全起见, 最后释放buf</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(ramblock_init);</span><br><span class="line">module_exit(ramblock_exit);</span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m       := ramblock.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu主机端</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/drv_blk/         # 块设备驱动目录</span></span><br><span class="line">$ make modules                                  <span class="comment"># 生成 ramblock.ko</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/drv_blk/         # 块设备驱动目录, nfs</span></span><br><span class="line">$ insmod ramblock.ko</span><br><span class="line"> ramblock:do_ramblock_request <span class="built_in">read</span> 1</span><br><span class="line"> unknown partition table                        <span class="comment"># ramblock_buf 全是0, 所以显示无效分区表.</span></span><br><span class="line"></span><br><span class="line">$ ls /dev/ramblock*                             <span class="comment"># 可以看到 ramblock 设备了</span></span><br><span class="line">$ cat /proc/devices</span><br><span class="line">254 RAMDISK                                     <span class="comment"># register_blkdev产生的块设备信息</span></span><br><span class="line"></span><br><span class="line">$ mkdosfs /dev/ramblock                         <span class="comment"># 格式化. 没有mkfs指令, 用mkdosfs</span></span><br><span class="line">$ mount /dev/ramblock /tmp                      <span class="comment"># 挂载为 /tmp</span></span><br><span class="line"></span><br><span class="line">$ vi /tmp/<span class="built_in">test</span>                                  <span class="comment"># 在ramblock_disk里读写文件</span></span><br><span class="line">do_ramblock_request <span class="built_in">read</span> 43                     <span class="comment"># 退出后, 只是读取块, 然后在缓冲区修改. 没有真正写入!</span></span><br><span class="line">$ sync                                          <span class="comment"># 多等一会, 或者输入sync同步指令, 开始写入磁盘</span></span><br><span class="line">do_ramblock_request write 6</span><br><span class="line">do_ramblock_request write 7 ......</span><br><span class="line"></span><br><span class="line">$ cp ramblock.c /tmp/                           <span class="comment"># 随便拷贝一个文件</span></span><br><span class="line"><span class="comment"># 没有打印 do_ramblock_request write 说明文件还没有被真正写入磁盘</span></span><br><span class="line">$ sync                                          <span class="comment"># 多等一会, 或者输入sync同步指令, 开始写入磁盘</span></span><br><span class="line">do_ramblock_request write 11</span><br><span class="line">do_ramblock_request write 12 ......</span><br><span class="line"></span><br><span class="line">$ ls /tmp                                       <span class="comment"># 显示 ramblock 里的文件</span></span><br><span class="line">ramblock.c  <span class="built_in">test</span></span><br><span class="line">$ umount /tmp                                   <span class="comment"># 卸载 /tmp</span></span><br><span class="line">do_ramblock_request write 16 ......             <span class="comment"># 如果有未写入的数据, 此时会写入.</span></span><br><span class="line">$ ls /tmp                                       <span class="comment"># 这时候, tmp文件夹就是空的了.</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$cat</span> /dev/ramblock &gt; ./ramblock.bin             <span class="comment"># 把整个磁盘打包成文件. 当前路径是ubuntu的nfs</span></span><br><span class="line">do_ramblock_request <span class="built_in">read</span> ......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后切换到 Ubuntu主机端</span></span><br><span class="line">$ sudo mount -o loop ramblock.bin /mnt          <span class="comment"># -o loop 表示挂载指定文件, 挂载到/mnt目录下</span></span><br><span class="line">$ ls /mnt                                       <span class="comment"># 显示了之前 ramblock 里的内容.</span></span><br><span class="line">ramblock.c  <span class="built_in">test</span></span><br><span class="line">$ sudo umount /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 开发板端</span></span><br><span class="line">$ mkdir /ramdisk</span><br><span class="line">$ mount /dev/ramblock /ramdisk                  <span class="comment"># 重新挂载为 /ramdisk</span></span><br><span class="line">$ ls /ramdisk                                   <span class="comment"># 显示 ramblock 里的文件</span></span><br><span class="line">ramblock.c  <span class="built_in">test</span></span><br><span class="line">$ df                                            <span class="comment"># 可以查看文件系统信息.</span></span><br><span class="line">Filesystem           1k-blocks      Used Available Use% Mounted on</span><br><span class="line">/dev/ramblock             1004         6       998   1% /ramdisk</span><br><span class="line"></span><br><span class="line">$ umount /ramdisk                               <span class="comment"># 卸载ramdisk, 否则无法卸载驱动</span></span><br><span class="line">$ rmdir /ramdisk</span><br><span class="line">$ rmmod ramblock                                <span class="comment"># 卸载驱动, 里面数据就没有了!</span></span><br><span class="line"><span class="comment"># 观察打印信息 do_ramblock_request 可得: 块设备操作都是批量的读或者批量的写.</span></span><br><span class="line"><span class="comment"># 这是由电梯算法实现的, 能大大提高硬盘的物理读写速度, 减缓由磁盘操作造成的速度下降</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始做fdisk分区测试 (分区指令需要 geometry 信息)</span></span><br><span class="line">$ insmod ramblock.ko</span><br><span class="line">$ ls /dev/ramblock*                             <span class="comment"># 查看设备</span></span><br><span class="line">/dev/ramblock                                   <span class="comment"># 没有分区, 只有一个总的磁盘设备</span></span><br><span class="line">$ fdisk /dev/ramblock</span><br><span class="line">m                                               <span class="comment"># m for help</span></span><br><span class="line">n p Partition number: 1 cylinder value: 1-8     <span class="comment"># 增加一个主分区</span></span><br><span class="line">n p Partition number: 2 cylinder value: 9-32    <span class="comment"># 再增加一个主分区</span></span><br><span class="line">p                                               <span class="comment"># 查看设置的分区情况</span></span><br><span class="line">w                                               <span class="comment"># 执行上述配置</span></span><br><span class="line"></span><br><span class="line">$ ls /dev/ramblock* -l                          <span class="comment"># 再次查看设备, b表示块设备</span></span><br><span class="line">brw-rw----    1 0        0        254,   0 Jan  1 00:01 /dev/ramblock   <span class="comment"># 整个磁盘设备</span></span><br><span class="line">brw-rw----    1 0        0        254,   1 Jan  1 00:01 /dev/ramblock1  <span class="comment"># 分区一</span></span><br><span class="line">brw-rw----    1 0        0        254,   2 Jan  1 00:01 /dev/ramblock2  <span class="comment"># 分区二</span></span><br><span class="line"></span><br><span class="line">$ mkdosfs /dev/ramblock1                        <span class="comment"># 格式化</span></span><br><span class="line">$ mkdosfs /dev/ramblock2</span><br><span class="line">$ mkdir /mnt/ramdisk1                           <span class="comment"># 创建挂载文件点</span></span><br><span class="line">$ mkdir /mnt/ramdisk2</span><br><span class="line">$ mount /dev/ramblock1 /mnt/ramdisk1            <span class="comment"># 挂载</span></span><br><span class="line">$ mount /dev/ramblock2 /mnt/ramdisk2</span><br><span class="line"><span class="comment"># 做一些操作, 如读写/拷贝文件...</span></span><br><span class="line">$ mkdosfs /dev/ramblock                         <span class="comment"># 危险操作!!! 依旧能格式化整个磁盘.</span></span><br><span class="line"></span><br><span class="line">$ umount /mnt/ramdisk1</span><br><span class="line">$ umount /mnt/ramdisk2</span><br><span class="line">$ rmdir /mnt/ramdisk1</span><br><span class="line">$ rmdir /mnt/ramdisk2</span><br></pre></td></tr></table></figure>

<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/19/1808-drv-usb2/" class="post-title-link" itemprop="url">驱动之USB设备驱动程序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-01-19 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-19T00:00:00+11:00">2018-01-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2018-02-09 23:08:22" itemprop="dateModified" datetime="2018-02-09T23:08:22+11:00">2018-02-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/embedded-linux/" itemprop="url" rel="index"><span itemprop="name">embedded linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a></li>
<li><a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a></li>
<li><a href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">驱动之RTC分析</a></li>
<li><a href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">驱动之LCD驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/11/1806-drv-ts/">驱动之触摸屏驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">驱动之USB基础概念和框架</a></li>
<li><a href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">驱动之USB设备驱动程序</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="查看USB设备信息"><a href="#查看USB设备信息" class="headerlink" title="查看USB设备信息"></a>查看USB设备信息</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /proc/bus/usb/devices           <span class="comment"># 查看USB设备信息, 但是jz2440里没有devices目录</span></span><br><span class="line">$ cat /proc/bus/input/devices         <span class="comment"># 接入的是USB鼠标, 是输入设备, 这里可以看到USB鼠标的信息</span></span><br><span class="line">I: Bus=0003 Vendor=046d Product=c52b Version=0111</span><br><span class="line">N: Name=<span class="string">&quot;Logitech USB Receiver&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接入USB鼠标后, 会显示如下信息, 可知被分配到input10.</span></span><br><span class="line">usb 1-1: new full speed USB device using s3c2410-ohci and address 8</span><br><span class="line">usb 1-1: configuration <span class="comment">#1 chosen from 1 choice</span></span><br><span class="line">input: Logitech USB Receiver as /class/input/input10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后用如下指令, 可以查处VID, PID</span></span><br><span class="line">$ cat sys/class/input/input10/id/product</span><br><span class="line">c52b</span><br><span class="line">$ cat sys/class/input/input10/id/vendor</span><br><span class="line">046d</span><br><span class="line">$ cat sys/class/input/input10/id/version</span><br><span class="line">0111</span><br></pre></td></tr></table></figure>


<h1 id="源码-第一版"><a href="#源码-第一版" class="headerlink" title="源码, 第一版"></a>源码, 第一版</h1><p>第一版, 先实现USB框架.<br>使用 <code>LinK+ Device Driver Development</code> 生成并部分修改而来.</p>
<p><img src="https://draapho.github.io/images/1808/drv_usb.jpg" alt="drv_usb.jpg"></p>
<p>基本步骤如下:</p>
<ol>
<li>分配/设置 <code>struct usb_driver</code> 结构体<ul>
<li><code>.id_table</code></li>
<li><code>.probe</code></li>
<li><code>.disconnect</code></li>
</ul>
</li>
<li>注册 <code>usb_register</code></li>
</ol>
<h2 id="mousekey-c"><a href="#mousekey-c" class="headerlink" title="mousekey.c"></a>mousekey.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">Driver Name     :       mousekey</span></span><br><span class="line"><span class="comment">Author          :       DRAAPHO</span></span><br><span class="line"><span class="comment">License         :       GPL</span></span><br><span class="line"><span class="comment">Description     :       LINUX DEVICE DRIVER PROJECT</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;mousekey.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO Fill the USB device table */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> <span class="title">mousekey_usb_ids</span>[] =</span> &#123;</span><br><span class="line"><span class="comment">// 可以选择 USB设备类型, 或者 VID/PID 匹配驱动</span></span><br><span class="line">    &#123; USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID, USB_INTERFACE_SUBCLASS_BOOT, USB_INTERFACE_PROTOCOL_MOUSE) &#125;,</span><br><span class="line"><span class="comment">//    &#123; USB_DEVICE(0x046d,0xc52b) &#125;,  // idVendor(VID), idProduct(PID)</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//struct usb_private &#123;</span></span><br><span class="line"><span class="comment">//  struct urb *urb;</span></span><br><span class="line"><span class="comment">//  struct usb_device *udev;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">mousekey_usb_driver</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mousekey_probe</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    struct usb_interface *iface, <span class="keyword">const</span> struct usb_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    struct usb_private *priv;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// struct usb_device_id *id 只记录用于匹配的信息.</span></span><br><span class="line">    <span class="comment">// 因此这里需要通过 iface 获取 usb_device 的信息.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">dev</span> =</span> interface_to_usbdev(iface);</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;found USB mousekey! ==========&gt;\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;USB address=%d\n&quot;</span></span><br><span class="line">           <span class="string">&quot;manufacturer=%s, product=%s, serial=%s\n&quot;</span></span><br><span class="line">           <span class="string">&quot;idVendor=0x%x, idProduct=0x%x\n&quot;</span></span><br><span class="line">           <span class="string">&quot;Device Class=%d, SubClass=%d, Protocol=%d\n&quot;</span>,</span><br><span class="line">           dev-&gt;devnum,</span><br><span class="line">           dev-&gt;manufacturer, dev-&gt;product, dev-&gt;serial,</span><br><span class="line">           dev-&gt;descriptor.idVendor, dev-&gt;descriptor.idProduct,</span><br><span class="line">           dev-&gt;descriptor.bDeviceClass,</span><br><span class="line">           dev-&gt;descriptor.bDeviceSubClass,</span><br><span class="line">           dev-&gt;descriptor.bDeviceProtocol);</span><br><span class="line">    printk(<span class="string">&quot;InterfaceNumber=%d, NumberOfEndpoints=%d\n&quot;</span></span><br><span class="line">           <span class="string">&quot;Interface Class=%d, SubClass=%d, Protocol=%d\n&quot;</span>,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bNumEndpoints,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceClass,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceSubClass,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceProtocol);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span></span><br><span class="line"><span class="comment">//    if (!priv) &#123;</span></span><br><span class="line"><span class="comment">//        PERR(&quot;Failed to allocate the device&#x27;s private data\n&quot;);</span></span><br><span class="line"><span class="comment">//        return -ENOMEM;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    usb_set_intfdata(iface, priv);</span></span><br><span class="line"><span class="comment">//    priv-&gt;udev = interface_to_usbdev(iface);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mousekey_disconnect</span><span class="params">(struct usb_interface *iface)</span>    </span>&#123;</span><br><span class="line"><span class="comment">//    struct usb_private *priv = usb_get_intfdata(iface);</span></span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;disconnect USB mousekey\n&quot;</span>);</span><br><span class="line"><span class="comment">//    kfree(priv);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 分配/设置 struct usb_driver */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">mousekey_usb_driver</span> =</span> &#123;</span><br><span class="line">    .name           = DRIVER_NAME,</span><br><span class="line">    .id_table       = mousekey_usb_ids,</span><br><span class="line">    .probe          = mousekey_probe,</span><br><span class="line">    .disconnect     = mousekey_disconnect,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">mousekey_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 注册 */</span></span><br><span class="line">    res = usb_register(&amp;mousekey_usb_driver);</span><br><span class="line">    <span class="keyword">if</span>( res ) &#123;</span><br><span class="line">        PERR(<span class="string">&quot;Error registering the USB Driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;INIT\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">mousekey_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line">    PINFO(<span class="string">&quot;EXIT\n&quot;</span>);</span><br><span class="line">    usb_deregister(&amp;mousekey_usb_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mousekey_init);</span><br><span class="line">module_exit(mousekey_exit);</span><br></pre></td></tr></table></figure>


<h2 id="mousekey-h"><a href="#mousekey-h" class="headerlink" title="mousekey.h"></a>mousekey.h</h2><figure class="highlight h"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_NAME <span class="meta-string">&quot;mousekey&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDEBUG(fmt,args...) printk(KERN_DEBUG<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERR(fmt,args...) printk(KERN_ERR<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME,##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINFO(fmt,args...) printk(KERN_INFO<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/usb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/hid.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m       := mousekey.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">install:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules_install</span><br><span class="line">    depmod -a</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>由于内核自带了USB鼠标驱动程序, 因此需要重新编译内核, 去掉内核的HID的USB功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6_custom  复制一个新的内核源码目录</span></span><br><span class="line"></span><br><span class="line">$ make clean</span><br><span class="line">$ make menuconfig                               <span class="comment"># 去掉自带的HID USB驱动程序</span></span><br><span class="line"><span class="comment"># -&gt; Device Drivers</span></span><br><span class="line"><span class="comment">#   -&gt; HID Devices</span></span><br><span class="line"><span class="comment">#     &lt; &gt; USB Human Interface Device (full HID) support     # 取消HID的USB支持</span></span><br><span class="line"></span><br><span class="line">$ make uImage</span><br><span class="line"><span class="comment"># 烧录新的uImage</span></span><br><span class="line"><span class="comment"># 重启开发板进入uboot烧录界面, 按k准备烧录内核. 略过不表</span></span><br><span class="line">$ sudo dnw ./arch/arm/boot/uImage</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/mousekey/        # USB鼠标驱动目录</span></span><br><span class="line">$ make modules                                  <span class="comment"># 生成mousekey.ko</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/mousekey/        # USB鼠标驱动目录, nfs</span></span><br><span class="line">$ insmod mousekey.ko                            <span class="comment"># 加载驱动, 开始测试</span></span><br><span class="line">usbcore: registered new interface driver mousekey</span><br><span class="line">mousekey:INIT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板上接入USB鼠标, 会打印如下信息:</span></span><br><span class="line">usb 1-1: new full speed USB device using s3c2410-ohci and address 7</span><br><span class="line">usb 1-1: configuration <span class="comment">#1 chosen from 1 choice</span></span><br><span class="line">mousekey:found USB mousekey! ==========&gt;</span><br><span class="line">......                                          <span class="comment"># 打印具体信息. 可以看出Device不重要, Interface才重要.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板上拔出USB鼠标, 会打印如下信息:</span></span><br><span class="line">usb 1-1: USB disconnect, address 7</span><br><span class="line">mousekey:disconnect USB mousekey</span><br><span class="line"></span><br><span class="line"><span class="comment"># rmmod mousekey</span></span><br><span class="line">mousekey:EXIT</span><br><span class="line">usbcore: deregistering interface driver mousekey</span><br></pre></td></tr></table></figure>

<h1 id="源码-第二版"><a href="#源码-第二版" class="headerlink" title="源码, 第二版"></a>源码, 第二版</h1><p>实现USB设备驱动, 将USB鼠标识别成按键.<br>左键输入<code>l</code>, 右键输入<code>s</code>, 中键输入<code>enter</code></p>
<ul>
<li><code>mousekey.h</code> 和 <code>Makefile</code> 参考 <code>源码, 第一版</code></li>
<li>这里因为是用的input子系统, 所以注册设备用了 <code>input_register_device</code>, 而不是 <code>usb_register_dev</code><ul>
<li>用 <code>input_register_device</code> 注册的话, 会在 <code>/dev/</code> 下面新增一个 <code>event*</code></li>
<li>用 <code>usb_register_dev</code> 注册的话, 会在 <code>/sys/class/usb/</code> 下面看到节点名称.</li>
</ul>
</li>
<li><code>input 子系统</code> 参考 <a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a><ol>
<li>分配一个input_dev变量</li>
<li>设置/初始化此变量</li>
<li>注册, input_register_device</li>
<li>硬件相关代码, open, close, event, sync等等.</li>
</ol>
</li>
<li><code>URB</code>, 即 <code>usb request block</code>. 基本用法:<ol>
<li>分配 URB. <code>usb_alloc_urb</code></li>
<li>初始化 URB 结构体 <code>struct urb</code></li>
<li>提交URB (开始通讯). <code>usb_submit_urb</code></li>
</ol>
</li>
<li>可参考 Linux 内核里的 <code>/drivers/hid/usbhid/usbmouse.c</code></li>
</ul>
<h2 id="mousekey-c-1"><a href="#mousekey-c-1" class="headerlink" title="mousekey.c"></a>mousekey.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">Driver Name     :       mousekey</span></span><br><span class="line"><span class="comment">Author          :       DRAAPHO</span></span><br><span class="line"><span class="comment">License         :       GPL</span></span><br><span class="line"><span class="comment">Description     :       LINUX DEVICE DRIVER PROJECT</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;mousekey.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO Fill the USB device table */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> <span class="title">mousekey_usb_ids</span>[] =</span> &#123;</span><br><span class="line"><span class="comment">// 可以选择 USB设备类型, 或者 VID/PID 匹配驱动</span></span><br><span class="line">    &#123; USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID, USB_INTERFACE_SUBCLASS_BOOT, USB_INTERFACE_PROTOCOL_MOUSE) &#125;,</span><br><span class="line"><span class="comment">//    &#123; USB_DEVICE(0x046d,0xc52b) &#125;,  // idVendor(VID), idProduct(PID)</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">mousekey_usb_driver</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">urb</span> *<span class="title">urb</span>;</span>                <span class="comment">// usb请求块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">udev</span>;</span>        <span class="comment">// usb 设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">idev</span>;</span>         <span class="comment">// input 设备</span></span><br><span class="line">    <span class="keyword">char</span> *buf;                      <span class="comment">// urb 用的缓冲</span></span><br><span class="line">    <span class="keyword">dma_addr_t</span> buf_phys;            <span class="comment">// 缓冲物理地址, dma要用</span></span><br><span class="line">    <span class="keyword">int</span> len;                        <span class="comment">// 缓冲区大小</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mousekey_irq</span><span class="params">(struct urb *urb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_private</span> *<span class="title">priv</span> =</span> urb-&gt;context;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">// 先打印查看usb鼠标发来的数据, 不同的鼠标数据格式略有不同!</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; priv-&gt;len; i++) &#123;</span><br><span class="line">        printk(<span class="string">&quot;%02x &quot;</span>, priv-&gt;buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    usb_submit_urb(priv-&gt;urb, GFP_KERNEL);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (urb-&gt;status) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:             <span class="comment">/* success */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> -ECONNRESET:   <span class="comment">/* unlink */</span></span><br><span class="line">    <span class="keyword">case</span> -ENOENT:</span><br><span class="line">    <span class="keyword">case</span> -ESHUTDOWN:</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* -EPIPE:  should clear the halt */</span></span><br><span class="line">    <span class="keyword">default</span>:            <span class="comment">/* error */</span></span><br><span class="line">        <span class="keyword">goto</span> resubmit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USB鼠标数据含义</span></span><br><span class="line"><span class="comment">     * data[0]: bit0-左键, 1-按下, 0-松开</span></span><br><span class="line"><span class="comment">     *          bit1-右键, 1-按下, 0-松开</span></span><br><span class="line"><span class="comment">     *          bit2-中键, 1-按下, 0-松开</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    input_report_key(priv-&gt;idev, KEY_L,     priv-&gt;buf[<span class="number">0</span>] &amp; <span class="number">0x01</span>);</span><br><span class="line">    input_report_key(priv-&gt;idev, KEY_S,     priv-&gt;buf[<span class="number">0</span>] &amp; <span class="number">0x02</span>);</span><br><span class="line">    input_report_key(priv-&gt;idev, KEY_ENTER, priv-&gt;buf[<span class="number">0</span>] &amp; <span class="number">0x04</span>);</span><br><span class="line">    input_sync(priv-&gt;idev);</span><br><span class="line"></span><br><span class="line">resubmit:</span><br><span class="line">    <span class="comment">/* 重新提交urb */</span></span><br><span class="line">    usb_submit_urb (urb, GFP_ATOMIC);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mousekey_probe</span><span class="params">(struct usb_interface *iface,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> struct usb_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_private</span> *<span class="title">priv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_endpoint_descriptor</span> *<span class="title">endpoint</span>;</span></span><br><span class="line">    PINFO(<span class="string">&quot;found USB mousekey! ==========&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    priv = kzalloc(<span class="keyword">sizeof</span>(*priv), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!priv) &#123;</span><br><span class="line">        PERR(<span class="string">&quot;Failed to allocate the device&#x27;s private data\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    usb_set_intfdata(iface, priv);</span><br><span class="line">    priv-&gt;udev = interface_to_usbdev(iface);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;USB address=%d\n&quot;</span></span><br><span class="line">           <span class="string">&quot;manufacturer=%s, product=%s, serial=%s\n&quot;</span></span><br><span class="line">           <span class="string">&quot;idVendor=0x%x, idProduct=0x%x\n&quot;</span></span><br><span class="line">           <span class="string">&quot;Device Class=%d, SubClass=%d, Protocol=%d\n&quot;</span>,</span><br><span class="line">           priv-&gt;udev-&gt;devnum,</span><br><span class="line">           priv-&gt;udev-&gt;manufacturer, priv-&gt;udev-&gt;product, priv-&gt;udev-&gt;serial,</span><br><span class="line">           priv-&gt;udev-&gt;descriptor.idVendor, priv-&gt;udev-&gt;descriptor.idProduct,</span><br><span class="line">           priv-&gt;udev-&gt;descriptor.bDeviceClass,</span><br><span class="line">           priv-&gt;udev-&gt;descriptor.bDeviceSubClass,</span><br><span class="line">           priv-&gt;udev-&gt;descriptor.bDeviceProtocol);</span><br><span class="line">    printk(<span class="string">&quot;InterfaceNumber=%d, NumberOfEndpoints=%d\n&quot;</span></span><br><span class="line">           <span class="string">&quot;Interface Class=%d, SubClass=%d, Protocol=%d\n&quot;</span>,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bNumEndpoints,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceClass,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceSubClass,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceProtocol);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iface-&gt;cur_altsetting-&gt;desc.bNumEndpoints != <span class="number">1</span>)     <span class="comment">// endpoint 不为1, 认为不是USB鼠标</span></span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    endpoint = &amp;iface-&gt;cur_altsetting-&gt;endpoint[<span class="number">0</span>].desc;</span><br><span class="line">    <span class="keyword">if</span> (!usb_endpoint_is_int_in(endpoint))                  <span class="comment">// endpoint 传输属性必须是中断输入</span></span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* a. 分配一个input_dev */</span></span><br><span class="line">    priv-&gt;idev = input_allocate_device();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* b. 设置 */</span></span><br><span class="line">    <span class="comment">/* b.1 能产生哪类事件 */</span></span><br><span class="line">    set_bit(EV_KEY, priv-&gt;idev-&gt;evbit);</span><br><span class="line">    set_bit(EV_REP, priv-&gt;idev-&gt;evbit);</span><br><span class="line">    <span class="comment">/* b.2 能产生哪些事件 */</span></span><br><span class="line">    set_bit(KEY_L, priv-&gt;idev-&gt;keybit);                     <span class="comment">// 鼠标按键模拟键盘 L S ENTER</span></span><br><span class="line">    set_bit(KEY_S, priv-&gt;idev-&gt;keybit);</span><br><span class="line">    set_bit(KEY_ENTER, priv-&gt;idev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* c. 注册 */</span></span><br><span class="line">    input_register_device(priv-&gt;idev);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* d. 硬件相关操作, 这里就是使用urb进行USB通讯 */</span></span><br><span class="line">    <span class="comment">/* 1. 分配 URB. */</span></span><br><span class="line">    priv-&gt;urb = usb_alloc_urb(<span class="number">0</span>, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 初始化 URB 结构体 */</span></span><br><span class="line">    pipe = usb_rcvintpipe(priv-&gt;udev, endpoint-&gt;bEndpointAddress);  <span class="comment">// 指定USB通讯类型和endpoint</span></span><br><span class="line">    priv-&gt;len = endpoint-&gt;wMaxPacketSize;                           <span class="comment">// buf大小</span></span><br><span class="line">    priv-&gt;buf = usb_buffer_alloc(priv-&gt;udev, priv-&gt;len, GFP_ATOMIC, &amp;priv-&gt;buf_phys);</span><br><span class="line">    <span class="comment">// 分配buf, usb会使用dma进行数据传输, buf_phys用于记录buf的物理地址.</span></span><br><span class="line"></span><br><span class="line">    usb_fill_int_urb(priv-&gt;urb, priv-&gt;udev, pipe, priv-&gt;buf, priv-&gt;len, mousekey_irq, priv, endpoint-&gt;bInterval);</span><br><span class="line">    <span class="comment">// mousekey_irq, usb中断发生时的回调函数. priv, 回调函数用的私有参数, 可以是NULL. bInterval, USB HUB的轮询间隔时间.</span></span><br><span class="line">    priv-&gt;urb-&gt;transfer_dma = priv-&gt;buf_phys;                       <span class="comment">// dma传输需要物理地址</span></span><br><span class="line">    priv-&gt;urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 提交URB (开始通讯) */</span></span><br><span class="line">    usb_submit_urb(priv-&gt;urb, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mousekey_disconnect</span><span class="params">(struct usb_interface *iface)</span>    </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_private</span> *<span class="title">priv</span> =</span> usb_get_intfdata(iface);</span><br><span class="line">    PINFO(<span class="string">&quot;disconnect USB mousekey\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    usb_kill_urb(priv-&gt;urb);</span><br><span class="line">    usb_free_urb(priv-&gt;urb);</span><br><span class="line">    usb_buffer_free(priv-&gt;udev, priv-&gt;len, priv-&gt;buf, priv-&gt;buf_phys);</span><br><span class="line">    input_unregister_device(priv-&gt;idev);</span><br><span class="line">    input_free_device(priv-&gt;idev);</span><br><span class="line">    kfree(priv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 分配/设置 struct usb_driver */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">mousekey_usb_driver</span> =</span> &#123;</span><br><span class="line">    .name           = DRIVER_NAME,</span><br><span class="line">    .id_table       = mousekey_usb_ids,</span><br><span class="line">    .probe          = mousekey_probe,</span><br><span class="line">    .disconnect     = mousekey_disconnect,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">mousekey_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 注册 */</span></span><br><span class="line">    res = usb_register(&amp;mousekey_usb_driver);</span><br><span class="line">    <span class="keyword">if</span>( res ) &#123;</span><br><span class="line">        PERR(<span class="string">&quot;Error registering the USB Driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;INIT\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">mousekey_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line">    PINFO(<span class="string">&quot;EXIT\n&quot;</span>);</span><br><span class="line">    usb_deregister(&amp;mousekey_usb_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mousekey_init);</span><br><span class="line">module_exit(mousekey_exit);</span><br></pre></td></tr></table></figure>

<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先按照此文之前的测试步骤烧录好无HID USB驱动的内核文件.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/mousekey/        # USB鼠标驱动目录, nfs</span></span><br><span class="line">$ insmod mousekey.ko                            <span class="comment"># 加载驱动, 开始测试</span></span><br><span class="line">usbcore: registered new interface driver mousekey</span><br><span class="line">mousekey:INIT</span><br><span class="line"></span><br><span class="line">$ ls /dev/event*                                <span class="comment"># 查看已有的event号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板上接入USB鼠标, 会打印如下信息:</span></span><br><span class="line">usb 1-1: new full speed USB device using s3c2410-ohci and address 7</span><br><span class="line">usb 1-1: configuration <span class="comment">#1 chosen from 1 choice</span></span><br><span class="line">mousekey:found USB mousekey! ==========&gt;</span><br><span class="line">......                                          <span class="comment"># 打印具体信息. 可以看出Device不重要, Interface才重要.</span></span><br><span class="line"></span><br><span class="line">$ ls /dev/event*                                <span class="comment"># 查看新增的event号, 就是此驱动的event</span></span><br><span class="line">/dev/event1                                     <span class="comment"># 譬如, 新增了event1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一 (没有LCD):</span></span><br><span class="line">$ cat /dev/tty1</span><br><span class="line"><span class="comment"># 点击鼠标, 终端会显示输入, 但没有输出反馈.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二 (没有LCD):</span></span><br><span class="line">$ hexdump /dev/event1</span><br><span class="line"><span class="comment"># 字节数|   秒    |  微秒   | 类  |code|  value      # 小端模式, 低位在前!</span></span><br><span class="line">0000000 0bb2 0000 0e48 000c 0001 0026 0001 0000    <span class="comment"># input_event(keydev, EV_KEY, key_val, 1)</span></span><br><span class="line">0000010 0bb2 0000 0e54 000c 0000 0000 0000 0000    <span class="comment"># input_sync(keydev);</span></span><br><span class="line">0000020 0bb2 0000 5815 000e 0001 0026 0000 0000    <span class="comment"># input_event(keydev, EV_KEY, key_val, 0)</span></span><br><span class="line">0000030 0bb2 0000 581f 000e 0000 0000 0000 0000    <span class="comment"># input_sync(keydev);</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三 (有LCD, 没有QT)</span></span><br><span class="line">$ vi /etc/inittab</span><br><span class="line">    <span class="comment"># ===== 设置为如下内容 =====</span></span><br><span class="line">    ::sysinit:/etc/init.d/rcS</span><br><span class="line">    s3c2410_serial0::askfirst:-/bin/sh</span><br><span class="line">    <span class="comment"># 增加了下面一行, 用于屏幕打开终端</span></span><br><span class="line">    tty1::askfirst:-/bin/sh</span><br><span class="line">    ::ctrlaltdel:/sbin/reboot</span><br><span class="line">    ::shutdown:/bin/umount -a -r</span><br><span class="line">    <span class="comment"># ===== wq保存, 退出 =====</span></span><br><span class="line">$ reboot                                        <span class="comment"># 重启终端</span></span><br><span class="line"><span class="comment"># 这样点击鼠标就直接能在LCD上查看输入和输出了.</span></span><br></pre></td></tr></table></figure>

<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/18/1807-drv-usb1/" class="post-title-link" itemprop="url">驱动之USB基础概念和框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-01-18 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-18T00:00:00+11:00">2018-01-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2018-02-09 23:08:22" itemprop="dateModified" datetime="2018-02-09T23:08:22+11:00">2018-02-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/embedded-linux/" itemprop="url" rel="index"><span itemprop="name">embedded linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a></li>
<li><a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a></li>
<li><a href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">驱动之RTC分析</a></li>
<li><a href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">驱动之LCD驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/11/1806-drv-ts/">驱动之触摸屏驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">驱动之USB基础概念和框架</a></li>
<li><a href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">驱动之USB设备驱动程序</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="USB基础知识"><a href="#USB基础知识" class="headerlink" title="USB基础知识"></a>USB基础知识</h1><ul>
<li>USB是主从结构的<ul>
<li>所有的USB传输，都是从USB主机这方发起! USB设备没有”主动”通知USB主机的能力。</li>
<li>例子：USB鼠标滑动一下立刻产生数据，但是它没有能力通知PC机来读数据，只能被动地等得PC机来读。</li>
</ul>
</li>
<li>USB的传输类型:<ul>
<li>控制传输(Control Transfers)：可靠，时间有保证，比如：USB设备的识别过程</li>
<li>批量传输(Bulk Transfers):可靠, 时间没有保证, 比如：U盘</li>
<li>中断传输(Interrupt Transfers)：可靠，实时，比如：USB鼠标</li>
<li>实时传输(Isochronous Transfers)：不可靠，实时，比如：USB摄像头</li>
</ul>
</li>
<li>USB的识别过程<ul>
<li>硬件上(USB2.0)<ul>
<li>USB主机端D-和D+接有15K下拉电阻, 未接USB设备时为低电平.</li>
<li>USB设备端D-或D+接有1.5K上拉电阻.</li>
<li>当USB设备插入USB主机端口时, 就会把D-或D+拉高, 让主机知道有设备接入了</li>
<li>把D-拉高是低速设备, 把D+拉高是高速设备</li>
</ul>
</li>
<li>软件上<ul>
<li>USB核心驱动程序负责: 识别USB设备, 给USB设备找到对应的驱动程序</li>
<li>当USB设备接入USB主机端后, 其默认的address是0. PC使用此adress与之通讯.</li>
<li>建立通讯后, USB核心驱动会给它分配一个新的address, 并查找有没有对应的驱动.</li>
</ul>
</li>
</ul>
</li>
<li>USB通讯速率<ul>
<li>低速设备(USB1.1, Low speed): 1.5Mb/s</li>
<li>全速设备(USB1.1, Full speed): 12Mb/s</li>
<li>高速设备(USB2.0, High speed): 480Mb/s</li>
<li>超高速设备(USB3.0, Super speed): 5Gb/s, 全双工</li>
</ul>
</li>
</ul>
<h1 id="USB主机端驱动框架"><a href="#USB主机端驱动框架" class="headerlink" title="USB主机端驱动框架"></a>USB主机端驱动框架</h1><p><img src="https://draapho.github.io/images/1807/usb_layer.png" alt="usb_layer.png"></p>
<p>各层作用如下:</p>
<ul>
<li>USB设备驱动 (USB Device Driver):<ol>
<li>让USB主机知道特定设备的数据含义</li>
<li>linux USB驱动开发就是在这一层. 更底层都是由linux内核完成的.</li>
</ol>
</li>
<li>USB核心层 (USB Core):<ol>
<li>识别USB设备: 分配并设置USB设备的address, 然后发出命令获取描述符.</li>
<li>查找并安装匹配的设备驱动</li>
<li>提供USB读写函数 (只是一个接口, 不知道数据含义)</li>
</ol>
</li>
<li>USB主机控制器 (USB HCD):<ol>
<li>需要支持的USB接口规范, 譬如USB2.0的设备要向下兼容必须包含USB1.1</li>
<li>OHCI: USB1.1 microsoft等创立的标准. 硬件功能强于软件功能</li>
<li>UHCI: USB1.1 intel创立的标准. 软件功能强于硬件功能, 因此芯片价格更低</li>
<li>EHCI: USB2.0</li>
<li>xHCI: USB3.0</li>
</ol>
</li>
</ul>
<h1 id="USB设备端概念"><a href="#USB设备端概念" class="headerlink" title="USB设备端概念"></a>USB设备端概念</h1><p><img src="https://draapho.github.io/images/1807/usb_dev.png" alt="usb_dev.png"></p>
<p>在USB从设备的结构中，从上到下分为:</p>
<ul>
<li>设备(device)<ul>
<li>设备即硬件概念上的USB从设备.</li>
<li><code>address</code> 的概念就是对设备而言的. 一条USB总线最多外接127个USB设备.</li>
<li>软件数据结构 <code>usb_device</code> <code>usb_device_descriptor</code></li>
</ul>
</li>
<li>配置(config)<ul>
<li>设备可以有一个或多个配置. 但任一时刻只有一个有效配置.</li>
<li>这里其实不难理解. 一个USB硬件设备可以允许多种功能.</li>
<li>个典型的例子是手机, 目前手机自动连接后, 都会弹出问你要用哪种模式连接电脑. 对应了不同的配置</li>
<li>因此选中一个配置后, 就从软件上决定了该USB设备的具体功能.</li>
<li>软件数据结构  <code>usb_device</code> <code>usb_host_config</code> <code>usb_config_descriptor</code></li>
</ul>
</li>
<li>接口(interface)<ul>
<li>接口表示逻辑设备, 包含零个或多个endpoint打包.</li>
<li>Linux的USB设备驱动是绑定到接口上的, 每个接口在主机看来都是一个独立的功能设备.</li>
<li>譬如录音接口, 播放接口, 数据接口等等.</li>
<li>软件数据结构  <code>usb_host_interface</code> <code>usb_interface_descriptor</code>.</li>
</ul>
</li>
<li>端点(endpoint)<ul>
<li>传输数据时, USB使用的就是endpoint概念. endpoint是数据通道.</li>
<li><code>endpoint0</code> 用于控制传输, 可双向传输.</li>
<li>除了 <code>endpoint0</code> 以外, 每个端点只支持一个方向的数据传输.</li>
<li>每个 endpoint 都有传输类型和传输方向.</li>
<li>传输类型: 控制传输, 批量传输, 中断传输, 实时传输.</li>
<li>传输方向: 输入(IN), 输出(OUT). 注意, 都是基于USB主机来说的! 读U盘, 数据方向就是输入.</li>
<li>譬如”读写U盘”, 软件上的概念是: 把数据写到U盘的 endpoint1 上去, 从U盘的 endpoint2 里读数据.</li>
<li>软件数据结构  <code>usb_device</code> <code>usb_host_endpoint</code> <code>usb_endpoint_descriptor</code></li>
</ul>
</li>
</ul>
<h1 id="Linux的USB驱动框架"><a href="#Linux的USB驱动框架" class="headerlink" title="Linux的USB驱动框架"></a>Linux的USB驱动框架</h1><p>以下我们用“usb_skel”的USB接口驱动实例（Linux/drivers/usb/usb-skeleton.c）来看看Linux的USB驱动框架：</p>
<p><img src="https://draapho.github.io/images/1807/usb_skel.png" alt="usb_skel.png"></p>
<h1 id="USB核心层源码分析"><a href="#USB核心层源码分析" class="headerlink" title="USB核心层源码分析"></a>USB核心层源码分析</h1><p>把USB设备接到开发板上，看输出信息:</p>
<blockquote>
<p>usb 1-1: new full speed USB device using s3c2410-ohci and address 2<br>usb 1-1: configuration #1 chosen from 1 choice</p>
</blockquote>
<p>拔掉后, 显示断开</p>
<blockquote>
<p>usb 1-1: USB disconnect, address 2</p>
</blockquote>
<p>尝试寻找源码: <code>grep &quot;USB device using&quot; -nR</code>, 找到 <code>drivers/usb/core/hub.c:2186</code> 文件.<br>由此开始分析.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hub_irq                                 <span class="comment">// 硬件检测到USB总线状态变化</span></span><br><span class="line">    kick_khubd                          <span class="comment">// 踢一脚唤醒, 很形象</span></span><br><span class="line">        wake_up(&amp;khubd_wait);           <span class="comment">// 唤醒 hub_thread</span></span><br><span class="line"></span><br><span class="line">hub_thread</span><br><span class="line">    hub_events</span><br><span class="line">        hub_port_connect_change         <span class="comment">// USB总线状态改变事件处理函数</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">hdev</span> =</span> hub-&gt;hdev             <span class="comment">// 处理usb hub的, 忽略</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">udev</span>;</span>                        <span class="comment">// usb设备, 后面具体分析 usb_device 数据结构</span></span><br><span class="line">            udev = usb_alloc_dev(hdev, hdev-&gt;bus, port1);   <span class="comment">// 申请usb设备, 然后初始化一些参数</span></span><br><span class="line">            choose_address(udev);                           <span class="comment">// 挑出一个空闲的address, 但没有告知这个USB设备</span></span><br><span class="line">            hub_port_init                                   <span class="comment">// 开始对新接入的usb设备进行初始化设置</span></span><br><span class="line">                dev_info                                    <span class="comment">// 打印了如下信息:</span></span><br><span class="line">                <span class="comment">// usb 1-1: new full speed USB device using s3c2410-ohci and address 2</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_descriptor</span> *<span class="title">buf</span>;</span>          <span class="comment">// buf 用于取出 bMaxPacketSize0 的大小</span></span><br><span class="line">                hub_set_address                             <span class="comment">// 这里, 才真正把address告诉USB设备</span></span><br><span class="line">                usb_get_device_descriptor(udev, <span class="number">8</span>);         <span class="comment">// 获取设备描述符, 兼容性考虑</span></span><br><span class="line">                usb_get_device_descriptor(udev, USB_DT_DEVICE_SIZE); <span class="comment">// 获取设备描述符</span></span><br><span class="line"></span><br><span class="line">            usb_new_device(udev)                            <span class="comment">// 查找USB设备驱动</span></span><br><span class="line">                usb_get_configuration(udev);                <span class="comment">// 把所有的描述符都读出来，并解析</span></span><br><span class="line">                    usb_get_descriptor                      <span class="comment">// 读描述符</span></span><br><span class="line">                    usb_parse_configuration                 <span class="comment">// 解析配置</span></span><br><span class="line">                device_add                                  <span class="comment">// platform概念的device部分函数.</span></span><br><span class="line">                <span class="comment">// 很熟悉的一个函数了, 见 &quot;驱动之platform概念&quot;</span></span><br><span class="line">                <span class="comment">// 1. 把device放入usb_bus_type的dev链表,</span></span><br><span class="line">                <span class="comment">// 2. 从usb_bus_type的driver链表里取出usb_driver, 把usb_interface和usb_driver的id_table比较</span></span><br><span class="line">                <span class="comment">// 3. 如果能匹配，调用usb_driver的probe</span></span><br></pre></td></tr></table></figure>

<p>下面, 简单分析一下USB的几个描述符结构体<br>结构体内各个变量的具体含义可参考: <a target="_blank" rel="noopener" href="http://www.beyondlogic.org/usbnutshell/usb5.shtml">USB Descriptors</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usb_device 和 usb_host_XXX 可以在 include\linux\usb.h 看到</span></span><br><span class="line"><span class="comment">// usb_XXX_descriptor 可以在 include\linux\usb\Ch9.h 看到</span></span><br><span class="line"><span class="comment">// Ch9.h 就是 Chapter9 的缩写, 表示USB协议规范第9章</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> &#123;</span>                         <span class="comment">// usb设备数据结构</span></span><br><span class="line">    <span class="keyword">int</span>     devnum;                         <span class="comment">/* Address on USB bus */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">usb_device_state</span>   <span class="title">state</span>;</span>          <span class="comment">/* configured, not attached, etc */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">usb_device_speed</span>   <span class="title">speed</span>;</span>          <span class="comment">/* high/full/low (or error) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// usb_host_*** 里面就包含了 usb 描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span> <span class="title">ep0</span>;</span>           <span class="comment">// 特殊的 endpoint0 可双向传输</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_descriptor</span> <span class="title">descriptor</span>;</span><span class="comment">/* Descriptor */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_config</span> *<span class="title">config</span>;</span>         <span class="comment">/* All of the configs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_config</span> *<span class="title">actconfig</span>;</span>      <span class="comment">/* the active configuration */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span> *<span class="title">ep_in</span>[16];</span>    <span class="comment">// 用做输入的 endpoint</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span> *<span class="title">ep_out</span>[16];</span>   <span class="comment">// 用做输出的 endpoint</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* static strings from the device */</span></span><br><span class="line">    <span class="keyword">char</span> *product;                          <span class="comment">/* iProduct string, if present */</span></span><br><span class="line">    <span class="keyword">char</span> *manufacturer;                     <span class="comment">/* iManufacturer string, if present */</span></span><br><span class="line">    <span class="keyword">char</span> *serial;                           <span class="comment">/* iSerialNumber string, if present */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个USB描述符的数据结构框架如下:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span>                   // <span class="title">usb</span>设备</span></span><br><span class="line"><span class="class">    <span class="keyword">struct</span> <span class="title">usb_device_descriptor</span>        // <span class="title">device</span> 描述符</span></span><br><span class="line"><span class="class">        __<span class="title">le16</span> <span class="title">bcdUSB</span>;</span>                      <span class="comment">// 设备支持的最高USB版本</span></span><br><span class="line">        __u8  bDeviceClass;                 <span class="comment">// 设备类别</span></span><br><span class="line">        __u8  bDeviceSubClass;              <span class="comment">// 设备子类</span></span><br><span class="line">        __u8  bDeviceProtocol;              <span class="comment">// 通信协议</span></span><br><span class="line">        __u8  bMaxPacketSize0;              <span class="comment">// endpoint0 通讯支持的最大数据量</span></span><br><span class="line">        __le16 idVendor;                    <span class="comment">// 经销商ID, 由USB机构分配给厂家</span></span><br><span class="line">        __le16 idProduct;                   <span class="comment">// 产品ID, 由USB厂家自己分配</span></span><br><span class="line">        __u8  iSerialNumber;                <span class="comment">// 产品序列号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_config</span>              // 主机记录的<span class="title">config</span>信息</span></span><br><span class="line"><span class="class">        <span class="keyword">struct</span> <span class="title">usb_config_descriptor</span>        // <span class="title">config</span> 描述符</span></span><br><span class="line"><span class="class">            __<span class="title">le16</span> <span class="title">wTotalLength</span>;</span>                <span class="comment">// config 总数据长度</span></span><br><span class="line">            __u8  bNumInterfaces;               <span class="comment">// config包含的interface数量</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">usb_interface</span>                // <span class="title">USB</span> <span class="title">interface</span></span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">usb_host_interface</span>           // 主机记录的<span class="title">interface</span>信息</span></span><br><span class="line"><span class="class">                <span class="keyword">struct</span> <span class="title">usb_interface_descriptor</span>     // <span class="title">interface</span>描述符</span></span><br><span class="line"><span class="class">                    __<span class="title">u8</span>  <span class="title">bInterfaceNumber</span>;</span>             <span class="comment">// interface编号</span></span><br><span class="line">                    __u8  bNumEndpoints;                <span class="comment">// 包含的endpoint数量</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span>            // 该<span class="title">interface</span>包含的<span class="title">endpoint</span></span></span><br><span class="line"><span class="class">            <span class="title">int</span> <span class="title">minor</span>;</span>                          <span class="comment">// 该USB interface的子设备号</span></span><br><span class="line">            <span class="comment">// 这里可以看出, Linux下, USB设备驱动是被绑到 USB interface 这一层的.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span>            // 主机记录的该<span class="title">USB</span>设备所有的<span class="title">endpoint</span></span></span><br><span class="line"><span class="class">        <span class="keyword">struct</span> <span class="title">usb_endpoint_descriptor</span>      // <span class="title">endpoint</span> 描述符</span></span><br><span class="line"><span class="class">            __<span class="title">u8</span>  <span class="title">bEndpointAddress</span>;</span>             <span class="comment">// endpoint 地址</span></span><br><span class="line">            __le16 wMaxPacketSize;              <span class="comment">// 支持的数据包大小</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">urb_list</span>;</span>          <span class="comment">// URB列表, USB Request Block.</span></span><br><span class="line">        <span class="comment">// URB 是linux内核给USB底层通讯抽象出来一种方法. 类似于TCP/IP协议里的socket方法.</span></span><br></pre></td></tr></table></figure>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/ahskx/article/details/50618983">Linux的USB驱动分析</a></li>
<li><a target="_blank" rel="noopener" href="http://www.embeddedlinux.org.cn/emb-linux/kernel-driver/201710/25-7669.html">Linux USB驱动工作流程</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/u014276460/article/details/47292427">浅谈USB驱动架构</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaojiang1025/p/6500574.html">Linux usb子系统(一) _写一个usb鼠标驱动</a></li>
<li><a target="_blank" rel="noopener" href="http://www.beyondlogic.org/usbnutshell/usb4.shtml">USB in a NutShell</a></li>
<li><a target="_blank" rel="noopener" href="http://www.beyondlogic.org/usbnutshell/usb5.shtml">USB Descriptors</a></li>
<li><a target="_blank" rel="noopener" href="https://www.crifan.com/files/doc/docbook/usb_basic/release/webhelp/four_hci_relations.html">USB控制器类型：OHCI，UHCI，EHCI，xHCI</a></li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">draapho</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
