<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"draapho.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta name="description" content="explore">
<meta property="og:type" content="website">
<meta property="og:title" content="DRA&amp;PHO">
<meta property="og:url" content="https://draapho.github.io/page/4/index.html">
<meta property="og:site_name" content="DRA&amp;PHO">
<meta property="og:description" content="explore">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="draapho">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://draapho.github.io/page/4/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>
<title>DRA&PHO</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">DRA&PHO</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">thinking & logging</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">draapho</p>
  <div class="site-description" itemprop="description">explore</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">123</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">80</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2018/01/11/1806-drv-ts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/11/1806-drv-ts/" class="post-title-link" itemprop="url">驱动之触摸屏驱动框架和实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-01-11 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-11T00:00:00+11:00">2018-01-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2018-02-09 23:08:22" itemprop="dateModified" datetime="2018-02-09T23:08:22+11:00">2018-02-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/embedded-linux/" itemprop="url" rel="index"><span itemprop="name">embedded linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a></li>
<li><a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a></li>
<li><a href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">驱动之RTC分析</a></li>
<li><a href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">驱动之LCD驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/11/1806-drv-ts/">驱动之触摸屏驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">驱动之USB基础概念和框架</a></li>
<li><a href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">驱动之USB设备驱动程序</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="触摸屏驱动框架分析"><a href="#触摸屏驱动框架分析" class="headerlink" title="触摸屏驱动框架分析"></a>触摸屏驱动框架分析</h1><h2 id="回顾input子系统"><a href="#回顾input子系统" class="headerlink" title="回顾input子系统"></a>回顾input子系统</h2><p>在 <a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a> 一文里, 已经介绍了input子系统的框架.<br>触摸驱动作为输入设备, 很自然的需要用到input子系统.<br>input子系统, 核心点如下:</p>
<ul>
<li>软件抽象层, <code>/drivers/input/input.c</code> <code>/drviers/input/*dev.c</code><ul>
<li>初始化 <code>input_handler</code> 结构体变量, 负责软件抽象.</li>
<li>提供 <code>input_register_handler</code> 函数</li>
<li>提供 <code>input_register_handle(没有r)</code> 函数</li>
<li>提供 <code>input_register_device</code> 函数</li>
</ul>
</li>
<li>连接层, <code>/drviers/input/*dev.c</code><ul>
<li>初始化 <code>input_handle(没有r)</code> 结构体变量, 负责input系统的软硬层对接</li>
<li>注册此变量 <code>input_register_handle(没有r)</code></li>
<li>当注册handler或者device时, 会自动调用 <code>handler-&gt;connect</code>, 匹配并关联软件抽象层和硬件设备层.</li>
</ul>
</li>
<li>硬件设备层, 需要自己来实现<ul>
<li>负责具体的硬件功能实现.</li>
<li>初始化 <code>input_dev</code> 结构体变量</li>
<li>注册此变量 <code>input_register_device</code></li>
<li>实现硬件相关代码. 上报事件 <code>input_event</code></li>
</ul>
</li>
</ul>
<h2 id="s3c2410的触摸屏框架"><a href="#s3c2410的触摸屏框架" class="headerlink" title="s3c2410的触摸屏框架"></a>s3c2410的触摸屏框架</h2><p>s3c2410的触摸屏框架使用了input层. 硬件设备层又使用了platform框架来进一步隔离硬件上的通用代码和专用参数设置.<br>platform总线系统的详情可查看 <a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a><br>整个框架层次如下图:</p>
<p><img src="https://draapho.github.io/images/1806/ts.png" alt="ts"></p>
<p>platform 总线框架具体分析如下:</p>
<ul>
<li>platform_driver <code>/drivers/input/touchscreen/s3c2410_ts.c</code><ul>
<li>调用 <code>platform_driver_register(&amp;s3c2410ts_driver);</code></li>
<li>匹配时, 执行 <code>s3c2410ts_probe</code><ul>
<li>和想的不一样, 用的 <code>evbit</code> 而不是 <code>absbit</code></li>
<li><code>ts.dev-&gt;evbit[0] = BIT(EV_SYN) | BIT(EV_KEY) | BIT(EV_ABS);</code></li>
<li><code>ts.dev-&gt;keybit[LONG(BTN_TOUCH)] = BIT(BTN_TOUCH);</code></li>
<li>然后向input系统注册device <code>input_register_device(ts.dev);</code></li>
</ul>
</li>
<li>timer超时函数 <code>touch_timer_fire</code>, 检测和发送触摸事件<ul>
<li><code>input_report_abs</code></li>
<li><code>input_report_key</code></li>
</ul>
</li>
</ul>
</li>
<li>platform_device <code>/arch/arm/plat-s3c24xx/common-smdk.c</code><ul>
<li>调用 <code>platform_add_devices(smdk_devs, ARRAY_SIZE(smdk_devs));</code></li>
<li><code>smdk_devs</code> 里面包含了 <code>s3c_device_ts</code></li>
<li>通过 <code>set_s3c2410ts_info</code> 函数来设置 <code>s3c_device_ts</code></li>
</ul>
</li>
</ul>
<h1 id="测试触摸屏驱动"><a href="#测试触摸屏驱动" class="headerlink" title="测试触摸屏驱动"></a>测试触摸屏驱动</h1><p>这里用的开发板自带的触摸屏驱动, 先测试一下.</p>
<h2 id="方法一-hexdump"><a href="#方法一-hexdump" class="headerlink" title="方法一 hexdump"></a>方法一 hexdump</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板端</span></span><br><span class="line">$ ls /dev/event*</span><br><span class="line"><span class="comment"># 系统自带的一般是 event0, 对应触摸屏事件</span></span><br><span class="line">$ hexdump /dev/event0</span><br><span class="line"><span class="comment"># 字节数|   秒    |   微秒   |type|code|  value       # 小端模式, 低位在前!</span></span><br><span class="line">0000000 04aa 0000 8555 000b 0003 0000 0138 0000     <span class="comment"># input_report_abs(ts.dev, ABS_X, ts.xp);</span></span><br><span class="line">0000010 04aa 0000 8569 000b 0003 0001 020e 0000     <span class="comment"># input_report_abs(ts.dev, ABS_Y, ts.yp);</span></span><br><span class="line">0000020 04aa 0000 856e 000b 0001 014a 0001 0000     <span class="comment"># input_report_key(ts.dev, BTN_TOUCH, 1);</span></span><br><span class="line">0000030 04aa 0000 8570 000b 0003 0018 0001 0000     <span class="comment"># input_report_abs(ts.dev, ABS_PRESSURE, 1);</span></span><br><span class="line">0000040 04aa 0000 8573 000b 0000 0000 0000 0000     <span class="comment"># input_sync(ts.dev);</span></span><br></pre></td></tr></table></figure>

<h2 id="方法二-tslib"><a href="#方法二-tslib" class="headerlink" title="方法二 tslib"></a>方法二 tslib</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端, 需要先编译 tslib</span></span><br><span class="line"><span class="comment"># pwd = ./drivers/ts</span></span><br><span class="line">$ tar xzf tslib-1.4.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> tslib</span><br><span class="line">$ ./autogen.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错: ./autogen.sh: 4: autoreconf: not found</span></span><br><span class="line"><span class="comment"># 报错: configure.ac:25: error: possibly undefined macro: AC_DISABLE_STATIC</span></span><br><span class="line"><span class="comment"># sudo apt-get install autoconf automake libtool # 安装相关软件即可</span></span><br><span class="line"></span><br><span class="line">$ mkdir tmp</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;ac_cv_func_malloc_0_nonnull=yes&quot;</span> &gt;arm-linux.cache</span><br><span class="line">$ ./configure --host=arm-linux --cache-file=arm-linux.cache --prefix=$(<span class="built_in">pwd</span>)/tmp</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br><span class="line">$ ll tmp/bin                                <span class="comment"># 查看一下编译结果.</span></span><br><span class="line">$ vi tmp/etc/ts.conf</span><br><span class="line"><span class="comment"># ===== 修改第二行 =====</span></span><br><span class="line">    <span class="comment"># module_raw input</span></span><br><span class="line">    <span class="comment"># 取消注释, 改为:</span></span><br><span class="line">    module_raw input</span><br><span class="line"><span class="comment"># ===== wq 保存退出 =====</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端</span></span><br><span class="line"><span class="comment"># pwd = ./drivers/ts/tslib/tmp              # 挂载的nfs文件系统</span></span><br><span class="line">$ cp * -rf /                                <span class="comment"># 拷贝到根目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line">$ <span class="built_in">export</span> TSLIB_TSDEVICE=/dev/event0         <span class="comment"># 必须对应ts的event</span></span><br><span class="line">$ <span class="built_in">export</span> TSLIB_CALIBFILE=/etc/pointercal</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_CONFFILE=/etc/ts.conf</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_PLUGINDIR=/lib/ts</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_CONSOLEDEVICE=none</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_FBDEVICE=/dev/fb0            <span class="comment"># 对应屏幕的framebuffer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始测试</span></span><br><span class="line">$ ts_calibrate                              <span class="comment"># 五点校验</span></span><br><span class="line">xres = 480, yres = 272</span><br><span class="line">Top left :</span><br><span class="line">Top right :</span><br><span class="line">Bot right :</span><br><span class="line">Bot left :</span><br><span class="line">Center :</span><br><span class="line">$ ts_test                                   <span class="comment"># 开始测试</span></span><br><span class="line">时间: X坐标 Y坐标 是否按下</span><br><span class="line">$ ts_print_raw                              <span class="comment"># 打印原始数据</span></span><br><span class="line">时间: X电压值 Y电压值 是否按下</span><br></pre></td></tr></table></figure>

<h1 id="源码-第一版"><a href="#源码-第一版" class="headerlink" title="源码, 第一版"></a>源码, 第一版</h1><p>第一版源码, 让触摸屏工作起来即可</p>
<h2 id="ts-c"><a href="#ts-c" class="headerlink" title="ts.c"></a>ts.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/serio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/clk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/plat-s3c24xx/ts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-adc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s3c_ts_regs</span> &#123;</span>                                <span class="comment">// 触摸屏寄存器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> adccon;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> adctsc;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> adcdly;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> adcdat0;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> adcdat1;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> adcupdn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">s3c_ts_dev</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">s3c_ts_regs</span> *<span class="title">s3c_ts_regs</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 几个模式的设置</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enter_wait_pen_down_mode</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s3c_ts_regs-&gt;adctsc = <span class="number">0xd3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enter_wait_pen_up_mode</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s3c_ts_regs-&gt;adctsc = <span class="number">0x1d3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enter_measure_xy_mode</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s3c_ts_regs-&gt;adctsc = (<span class="number">1</span>&lt;&lt;<span class="number">3</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start_adc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s3c_ts_regs-&gt;adccon |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触摸事件中断, 按下或松开触摸屏</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">pen_down_up_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s3c_ts_regs-&gt;adcdat0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;pen up\n&quot;</span>);</span><br><span class="line">        enter_wait_pen_down_mode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printk(&quot;pen down\n&quot;);</span></span><br><span class="line">        <span class="comment">//enter_wait_pen_up_mode();</span></span><br><span class="line">        enter_measure_xy_mode();                    <span class="comment">// 按下了, 准备开始测量</span></span><br><span class="line">        start_adc();                                <span class="comment">// 测量adc</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ADC完成中断</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">adc_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    printk(<span class="string">&quot;adc_irq cnt = %d, x = %d, y = %d\n&quot;</span>, ++cnt,</span><br><span class="line">        s3c_ts_regs-&gt;adcdat0 &amp; <span class="number">0x3ff</span>, s3c_ts_regs-&gt;adcdat1 &amp; <span class="number">0x3ff</span>);</span><br><span class="line">                                                    <span class="comment">// 打印测量结果</span></span><br><span class="line">    enter_wait_pen_up_mode();</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c_ts_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span>* <span class="title">clk</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 分配一个input_dev结构体 */</span></span><br><span class="line">    s3c_ts_dev = input_allocate_device();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 设置 */</span></span><br><span class="line">    <span class="comment">/* 2.1 能产生哪类事件 */</span></span><br><span class="line">    set_bit(EV_KEY, s3c_ts_dev-&gt;evbit);             <span class="comment">// 按键事件</span></span><br><span class="line">    set_bit(EV_ABS, s3c_ts_dev-&gt;evbit);             <span class="comment">// 绝对坐标事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2.2 能产生按键事件里的哪些值 */</span></span><br><span class="line">    set_bit(BTN_TOUCH, s3c_ts_dev-&gt;keybit);         <span class="comment">// 键盘的虚拟按键</span></span><br><span class="line"></span><br><span class="line">    input_set_abs_params(s3c_ts_dev, ABS_X, <span class="number">0</span>, <span class="number">0x3FF</span>, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">// 绝对坐标范围设置</span></span><br><span class="line">    input_set_abs_params(s3c_ts_dev, ABS_Y, <span class="number">0</span>, <span class="number">0x3FF</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    input_set_abs_params(s3c_ts_dev, ABS_PRESSURE, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 是否按压, 理解为Z轴即可.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 注册 */</span></span><br><span class="line">    input_register_device(s3c_ts_dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. 硬件相关的操作 */</span></span><br><span class="line">    <span class="comment">/* 4.1 使能时钟(CLKCON[15]) */</span></span><br><span class="line">    clk = clk_get(<span class="literal">NULL</span>, <span class="string">&quot;adc&quot;</span>);</span><br><span class="line">    clk_enable(clk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4.2 设置S3C2440的ADC/TS寄存器 */</span></span><br><span class="line">    s3c_ts_regs = ioremap(<span class="number">0x58000000</span>, <span class="keyword">sizeof</span>(struct s3c_ts_regs));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bit[14]  : 1-A/D converter prescaler enable</span></span><br><span class="line"><span class="comment">     * bit[13:6]: A/D converter prescaler value,</span></span><br><span class="line"><span class="comment">     *            49, ADCCLK=PCLK/(49+1)=50MHz/(49+1)=1MHz</span></span><br><span class="line"><span class="comment">     * bit[0]: A/D conversion starts by enable. 先设为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s3c_ts_regs-&gt;adccon = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>)|(<span class="number">49</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使能两个中断</span></span><br><span class="line">    request_irq(IRQ_TC, pen_down_up_irq, IRQF_SAMPLE_RANDOM, <span class="string">&quot;ts_pen&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    request_irq(IRQ_ADC, adc_irq, IRQF_SAMPLE_RANDOM, <span class="string">&quot;adc&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    enter_wait_pen_down_mode();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c_ts_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    free_irq(IRQ_TC, <span class="literal">NULL</span>);</span><br><span class="line">    iounmap(s3c_ts_regs);</span><br><span class="line">    input_unregister_device(s3c_ts_dev);</span><br><span class="line">    input_free_device(s3c_ts_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(s3c_ts_init);</span><br><span class="line">module_exit(s3c_ts_exit);</span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-m       := ts.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux<span class="number">-2.6</span><span class="number">.22</span><span class="number">.6</span>/</span><br><span class="line">PWD         := $(shell pwd)</span><br><span class="line"></span><br><span class="line">modules:</span><br><span class="line">    make -C $(KERN_SRC) M=$(PWD) modules</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    make -C $(KERN_SRC) M=$(PWD) clean</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>由于内核自带了驱动程序, 因此需要重新编译内核, 去掉触摸驱动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Ubuntu 主机端</span><br><span class="line"># pwd &#x3D; .&#x2F;linux-2.6.22.6_custom  复制一个新的内核源码目录</span><br><span class="line"></span><br><span class="line">$ make clean</span><br><span class="line">$ make menuconfig                               # 去掉自带的触摸屏驱动程序</span><br><span class="line"># -&gt; Device Drivers</span><br><span class="line">#   -&gt; Input device support</span><br><span class="line">#     -&gt; Touchscreens</span><br><span class="line">#       &lt; &gt; S3C2410&#x2F;S3C2440 touchscreens        # 取消触摸屏驱动</span><br><span class="line"></span><br><span class="line">$ make uImage</span><br><span class="line"># 烧录新的uImage</span><br><span class="line"># 重启开发板进入uboot烧录界面, 按k准备烧录内核. 略过不表</span><br><span class="line">$ sudo dnw .&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;uImage</span><br><span class="line"></span><br><span class="line"># pwd &#x3D; ~&#x2F;share&#x2F;jz2440&#x2F;drivers&#x2F;ts&#x2F;              # 触摸屏驱动目录</span><br><span class="line">$ make modules                                  # 生成ts.ko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 开发板端</span><br><span class="line"># pwd &#x3D; ~&#x2F;share&#x2F;jz2440&#x2F;drivers&#x2F;ts&#x2F;              # 触摸屏驱动目录, nfs</span><br><span class="line">$ insmod ts.ko                                  # 加载驱动, 开始测试</span><br><span class="line">input: Unspecified device as &#x2F;class&#x2F;input&#x2F;input0</span><br><span class="line">adc_irq cnt &#x3D; 1, x &#x3D; 17, y &#x3D; 991</span><br><span class="line">pen up</span><br><span class="line"># 点击触摸屏, 就会打印出坐标, 释放时, 就会显示 pen up</span><br><span class="line"># 至此, 说明触摸屏的硬件设置没有问题!</span><br></pre></td></tr></table></figure>

<h1 id="源码-第二版"><a href="#源码-第二版" class="headerlink" title="源码, 第二版"></a>源码, 第二版</h1><p>第一版的源码用于检测触摸屏的硬件设置是否正确, 触摸屏是否能正常工作.<br>但在实际情况下, 对触摸屏的ADC值还需要进行软件滤波等工作, 以提高可用性.<br>另外我们去掉了printk的打印信息, 改为 <code>input_report_abs</code> <code>input_report_key</code></p>
<h2 id="ts-c-1"><a href="#ts-c-1" class="headerlink" title="ts.c"></a>ts.c</h2><p>为方便理解, 减少代码量, 和源码第一版相同的部分删掉了.<br>譬如头文件, 小函数等.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">ts_timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 软件过滤用, 如果4次ADC值的差值过大, 直接丢弃</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c_filter_ts</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ERR_LIMIT 10                                    <span class="comment">// 这是个经验值</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> avr_x, avr_y;</span><br><span class="line">    <span class="keyword">int</span> det_x, det_y;</span><br><span class="line"></span><br><span class="line">    avr_x = (x[<span class="number">0</span>] + x[<span class="number">1</span>])/<span class="number">2</span>;                                <span class="comment">// 获得数据0,1的平均值</span></span><br><span class="line">    avr_y = (y[<span class="number">0</span>] + y[<span class="number">1</span>])/<span class="number">2</span>;</span><br><span class="line">    det_x = (x[<span class="number">2</span>] &gt; avr_x) ? (x[<span class="number">2</span>] - avr_x) : (avr_x - x[<span class="number">2</span>]);<span class="comment">// 求数据2的差值</span></span><br><span class="line">    det_y = (y[<span class="number">2</span>] &gt; avr_y) ? (y[<span class="number">2</span>] - avr_y) : (avr_y - y[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((det_x &gt; ERR_LIMIT) || (det_y &gt; ERR_LIMIT))         <span class="comment">// 差值太大, 丢弃整组数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    avr_x = (x[<span class="number">1</span>] + x[<span class="number">2</span>])/<span class="number">2</span>;                                <span class="comment">// 获得数据1,2的平均值</span></span><br><span class="line">    avr_y = (y[<span class="number">1</span>] + y[<span class="number">2</span>])/<span class="number">2</span>;</span><br><span class="line">    det_x = (x[<span class="number">3</span>] &gt; avr_x) ? (x[<span class="number">3</span>] - avr_x) : (avr_x - x[<span class="number">3</span>]);<span class="comment">// 求数据3的差值</span></span><br><span class="line">    det_y = (y[<span class="number">3</span>] &gt; avr_y) ? (y[<span class="number">3</span>] - avr_y) : (avr_y - y[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((det_x &gt; ERR_LIMIT) || (det_y &gt; ERR_LIMIT))         <span class="comment">// 差值太大, 丢弃整组数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器, 用去测量触摸屏长按和移动. 在adc中断函数里触发</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c_ts_timer_function</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s3c_ts_regs-&gt;adcdat0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 已经松开 */</span>                                       <span class="comment">// 向input层报告事件</span></span><br><span class="line">        input_report_abs(s3c_ts_dev, ABS_PRESSURE, <span class="number">0</span>);</span><br><span class="line">        input_report_key(s3c_ts_dev, BTN_TOUCH, <span class="number">0</span>);</span><br><span class="line">        input_sync(s3c_ts_dev);</span><br><span class="line">        enter_wait_pen_down_mode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 测量X/Y坐标 */</span></span><br><span class="line">        enter_measure_xy_mode();                            <span class="comment">// 没有松开, 周期性测量</span></span><br><span class="line">        start_adc();                                        <span class="comment">// 触发adc, adc完成后又会触发定时器, 形成周期测量.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触摸事件中断, 按下或松开触摸屏</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">pen_down_up_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s3c_ts_regs-&gt;adcdat0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printk(&quot;pen up\n&quot;);                               // 松开, 向input层报告事件</span></span><br><span class="line">        input_report_abs(s3c_ts_dev, ABS_PRESSURE, <span class="number">0</span>);</span><br><span class="line">        input_report_key(s3c_ts_dev, BTN_TOUCH, <span class="number">0</span>);</span><br><span class="line">        input_sync(s3c_ts_dev);</span><br><span class="line">        enter_wait_pen_down_mode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printk(&quot;pen down\n&quot;);</span></span><br><span class="line">        <span class="comment">//enter_wait_pen_up_mode();</span></span><br><span class="line">        enter_measure_xy_mode();                            <span class="comment">// 刚按下, 开始测量</span></span><br><span class="line">        start_adc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ADC完成中断</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">adc_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x[<span class="number">4</span>], y[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> adcdat0, adcdat1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 优化措施2: 如果ADC完成时, 发现触摸笔已经松开, 则丢弃此次结果 */</span></span><br><span class="line">    adcdat0 = s3c_ts_regs-&gt;adcdat0;</span><br><span class="line">    adcdat1 = s3c_ts_regs-&gt;adcdat1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s3c_ts_regs-&gt;adcdat0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 已经松开 */</span></span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        input_report_abs(s3c_ts_dev, ABS_PRESSURE, <span class="number">0</span>);</span><br><span class="line">        input_report_key(s3c_ts_dev, BTN_TOUCH, <span class="number">0</span>);</span><br><span class="line">        input_sync(s3c_ts_dev);</span><br><span class="line">        enter_wait_pen_down_mode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;adc_irq cnt = %d, x = %d, y = %d\n&quot;, ++cnt, adcdat0 &amp; 0x3ff, adcdat1 &amp; 0x3ff);</span></span><br><span class="line">        <span class="comment">/* 优化措施3: 多次测量求平均值 */</span></span><br><span class="line">        x[cnt] = adcdat0 &amp; <span class="number">0x3ff</span>;</span><br><span class="line">        y[cnt] = adcdat1 &amp; <span class="number">0x3ff</span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 优化措施4: 软件过滤 */</span></span><br><span class="line">            <span class="keyword">if</span> (s3c_filter_ts(x, y))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//printk(&quot;x = %d, y = %d\n&quot;, (x[0]+x[1]+x[2]+x[3])/4, (y[0]+y[1]+y[2]+y[3])/4);</span></span><br><span class="line">                input_report_abs(s3c_ts_dev, ABS_X, (x[<span class="number">0</span>]+x[<span class="number">1</span>]+x[<span class="number">2</span>]+x[<span class="number">3</span>])/<span class="number">4</span>);</span><br><span class="line">                input_report_abs(s3c_ts_dev, ABS_Y, (y[<span class="number">0</span>]+y[<span class="number">1</span>]+y[<span class="number">2</span>]+y[<span class="number">3</span>])/<span class="number">4</span>);</span><br><span class="line">                input_report_abs(s3c_ts_dev, ABS_PRESSURE, <span class="number">1</span>);</span><br><span class="line">                input_report_key(s3c_ts_dev, BTN_TOUCH, <span class="number">1</span>);</span><br><span class="line">                input_sync(s3c_ts_dev);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            enter_wait_pen_up_mode();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 启动定时器处理长按/滑动的情况 */</span></span><br><span class="line">            mod_timer(&amp;ts_timer, jiffies + HZ/<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            enter_measure_xy_mode();</span><br><span class="line">            start_adc();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c_ts_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......                          <span class="comment">// 硬件配置都一样, 略过</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使能两个中断</span></span><br><span class="line">    request_irq(IRQ_TC, pen_down_up_irq, IRQF_SAMPLE_RANDOM, <span class="string">&quot;ts_pen&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    request_irq(IRQ_ADC, adc_irq, IRQF_SAMPLE_RANDOM, <span class="string">&quot;adc&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 优化措施1:</span></span><br><span class="line"><span class="comment">     * 设置ADCDLY为最大值, 这使得电压稳定后再发出IRQ_TC中断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s3c_ts_regs-&gt;adcdly = <span class="number">0xffff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 优化措施5: 使用定时器处理长按,滑动的情况 */</span></span><br><span class="line">    init_timer(&amp;ts_timer);</span><br><span class="line">    ts_timer.function = s3c_ts_timer_function;</span><br><span class="line">    add_timer(&amp;ts_timer);</span><br><span class="line"></span><br><span class="line">    enter_wait_pen_down_mode();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c_ts_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    free_irq(IRQ_TC, <span class="literal">NULL</span>);</span><br><span class="line">    free_irq(IRQ_ADC, <span class="literal">NULL</span>);</span><br><span class="line">    iounmap(s3c_ts_regs);</span><br><span class="line">    input_unregister_device(s3c_ts_dev);</span><br><span class="line">    input_free_device(s3c_ts_dev);</span><br><span class="line">    del_timer(&amp;ts_timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先按照此文之前的测试步骤设置好tslib, 烧录无触摸屏驱动的内核文件.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端</span></span><br><span class="line"><span class="comment"># pwd = ./drivers/ts/                               # 挂载的nfs文件系统</span></span><br><span class="line">$ rmmod ts                                          <span class="comment"># 卸载源码第一版加载的触摸屏驱动</span></span><br><span class="line">$ ls /dev/event*</span><br><span class="line">$ insmod ts.ko                                      <span class="comment"># 加载驱动</span></span><br><span class="line">$ ls /dev/event*</span><br><span class="line"><span class="comment"># 多出的一个event, 就是触摸屏的event, 譬如event0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一, 用hexdump测试</span></span><br><span class="line"></span><br><span class="line">$ hexdump /dev/event0</span><br><span class="line"><span class="comment"># 字节数|   秒    |   微秒   |type|code|  value       # 小端模式, 低位在前!</span></span><br><span class="line">0000000 04aa 0000 8555 000b 0003 0000 0138 0000     <span class="comment"># input_report_abs(ts.dev, ABS_X, ts.xp);</span></span><br><span class="line">0000010 04aa 0000 8569 000b 0003 0001 020e 0000     <span class="comment"># input_report_abs(ts.dev, ABS_Y, ts.yp);</span></span><br><span class="line">0000030 04aa 0000 8570 000b 0003 0018 0001 0000     <span class="comment"># input_report_abs(ts.dev, ABS_PRESSURE, 1);</span></span><br><span class="line">0000020 04aa 0000 856e 000b 0001 014a 0001 0000     <span class="comment"># input_report_key(ts.dev, BTN_TOUCH, 1);</span></span><br><span class="line">0000040 04aa 0000 8573 000b 0000 0000 0000 0000     <span class="comment"># input_sync(ts.dev);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二, 用tslib测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line">$ <span class="built_in">export</span> TSLIB_TSDEVICE=/dev/event0         <span class="comment"># 必须对应ts的event</span></span><br><span class="line">$ <span class="built_in">export</span> TSLIB_CALIBFILE=/etc/pointercal</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_CONFFILE=/etc/ts.conf</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_PLUGINDIR=/lib/ts</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_CONSOLEDEVICE=none</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_FBDEVICE=/dev/fb0            <span class="comment"># 对应屏幕的framebuffer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始测试</span></span><br><span class="line">$ ts_calibrate                              <span class="comment"># 五点校验</span></span><br><span class="line">xres = 480, yres = 272</span><br><span class="line">Top left :</span><br><span class="line">Top right :</span><br><span class="line">Bot right :</span><br><span class="line">Bot left :</span><br><span class="line">Center :</span><br><span class="line">$ ts_test                                   <span class="comment"># 开始测试</span></span><br><span class="line">时间: X坐标 Y坐标 是否按下</span><br><span class="line">$ ts_print_raw                              <span class="comment"># 打印原始数据</span></span><br><span class="line">时间: X电压值 Y电压值 是否按下</span><br></pre></td></tr></table></figure>

<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2018/01/10/1805-interview-general/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/10/1805-interview-general/" class="post-title-link" itemprop="url">面试之常规问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-01-10 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-10T00:00:00+11:00">2018-01-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2018-05-07 22:26:00" itemprop="dateModified" datetime="2018-05-07T22:26:00+10:00">2018-05-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">interview</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/05/04/1714-expression/">逻辑|这样表达，事半功倍</a></li>
<li><a href="https://draapho.github.io/2018/01/10/1805-interview-general/">面试之常规问题</a></li>
<li><a href="https://draapho.github.io/2018/05/07/1816-interview-c/">面试之嵌入式C语言</a></li>
<li><a href="https://draapho.github.io/2017/05/17/1715-c/">C语言知识巩固</a></li>
<li><a href="https://draapho.github.io/2018/05/08/1817-interview-linux/">面试之嵌入式Linux</a></li>
</ul>
<p>我个人面试经验极少, 但这种能力都是需要培养的.<br>此系列总结一下面试中常见的技能要点. 侧重于技术面的准备.</p>
<h1 id="中介面试"><a href="#中介面试" class="headerlink" title="中介面试"></a>中介面试</h1><p>中介面试, 更多的是对个人整体的一个考量. 特别是对你是否适合某雇主的评估.<br>一般而言, 中介是不懂技术的, 所以不用担心他问技术问题; 中介是八面玲珑的, 要小心自己的嘴巴<br>(<strong>有些中介是专门做技术人才的, 所以会问非常专业的问题</strong>, 这里只是说一般情况)<br>如果是电话面试 正常的语速, 有条理的回答, 适当的反问.<br>总之, 个人的看法是要从整体上让对方觉得你是一个思路清晰, 反应敏捷的专业人士.</p>
<p>在澳洲, 工作多集中在几个大城市, 跨地区申请很正常.<br>个人的经验是不跨地区申请 contract 的工作. 跨地区申请时一定要有充足的理由.</p>
<h1 id="雇主面试"><a href="#雇主面试" class="headerlink" title="雇主面试"></a>雇主面试</h1><p>一般来说, 能拿到雇主面试, 机会就比较大了. 分为技术面试和情商面试.</p>
<h2 id="技术面试"><a href="#技术面试" class="headerlink" title="技术面试"></a>技术面试</h2><p>紧扣中介给你的职位说明做准备, 那就是考试大纲!<br>联系自己提交的个人简历, 那就是应试宝典!<br>做过的项目, 时间, 地点, 流程, 型号, 配置, 记忆要具体到最微小的细节.</p>
<p>如果被问到不懂的地方, 直接坦白, 大家都是出来混的. 然后退一步:<br><code>But I do have some experience in XXX, for example XXX</code>, 把话题引到相关的自己熟悉的领域.</p>
<p>如果被问到半懂不懂的地方, 就说 <code>I am major in XXX, so not a XXX guru. But I like learning new staff</code>.<br>然后坦白的谈你对 XXX 的理解.</p>
<p>如果被问到细节自己又想不起来, 就告诉对方暂时记不起来了. 但在自己每天做的工作笔记中有(闪光点), 而且我现在可以把解决该问题的流程(闪光点)讲给你听.<br>总之, 一说实话, 二反应要快.</p>
<p>此处需要注意, 学会换位思考, 见人说人话, 见鬼说鬼话 (国内的技术人员普遍缺乏此种能力).</p>
<ul>
<li>Team Leader 希望你是一个技术专才.</li>
<li>CEO 或 Manager 则希望你的面要广一些.</li>
</ul>
<h2 id="情商面试"><a href="#情商面试" class="headerlink" title="情商面试"></a>情商面试</h2><p>其实这是最不好过的关, 因为主观性实在太强, 加之用非母语表达, 很容易因为紧张而影响反应和思维.<br>在这里只是与大家分享一下个人觉得不错的问题.</p>
<h3 id="你的弱点是什么"><a href="#你的弱点是什么" class="headerlink" title="你的弱点是什么"></a>你的弱点是什么</h3><p>第一种回答. 因为英语毕竟不是我的母语, 所以有时候语言上还会碰到问题, 但我一直在努力.<br>第二个回答. 是工作文化的差异. 因为在中国 Hard working 被认为是一种美德, 所以有时候自己在工作中表现的有些 Aggressive, 但会注意和同事的配合; 面试官的回答是 No Problem. 这个也是以退为进.</p>
<p>语言和文化, 是新一名的两座大山, 我们勇于承认问题, 面对问题, 解决问题, 保持自信. 这样的人才, 能不招人爱么!</p>
<h3 id="你的优点是什么"><a href="#你的优点是什么" class="headerlink" title="你的优点是什么"></a>你的优点是什么</h3><p>Like challenge, Hard working, 还有谁能比我们这些移民有资格这样说. Full of enthusiasm.</p>
<p>When you briefly explain to an employer what you have achived since you arrived in this new country, their reaction would be one of admiration. This says many things about you that make you an attractive candidate for a job - your technical skills and experience are just one of many things that you can offer.</p>
<h3 id="当你和上级意见不统一时怎么办"><a href="#当你和上级意见不统一时怎么办" class="headerlink" title="当你和上级意见不统一时怎么办"></a>当你和上级意见不统一时怎么办</h3><p>Firstly, have a full communication with him/her, demostrate/make clear my opinions and reasons.<br>But I know that generally speaking, the director’s scale of view is large and deep than me, and the finally decision is made by him/her.</p>
<h3 id="你更注重公司的氛围还是所在的团队氛围"><a href="#你更注重公司的氛围还是所在的团队氛围" class="headerlink" title="你更注重公司的氛围还是所在的团队氛围"></a>你更注重公司的氛围还是所在的团队氛围</h3><p>The atmosphere is deeply influenced by the company’s founder. In small company, I think it would be decided by the company atmosphere and in large company, I will pay more attention to the group atmosphere.</p>
<h3 id="你在X年内的职业发展规划"><a href="#你在X年内的职业发展规划" class="headerlink" title="你在X年内的职业发展规划"></a>你在X年内的职业发展规划</h3><p>事先注意收集对方公司的资料, 使自己的发展规划与对方公司的情况以及对你的期望契合.</p>
<h3 id="举一个你职业生涯中失败的例子"><a href="#举一个你职业生涯中失败的例子" class="headerlink" title="举一个你职业生涯中失败的例子"></a>举一个你职业生涯中失败的例子</h3><p>我想每个人都有自己的故事. 单但重要的不是失败, 而是But, 是你在随后的描述, 退一步进二步的策略. (ITT70)</p>
<h3 id="举一个你为过去公司带来实际效益的例子"><a href="#举一个你为过去公司带来实际效益的例子" class="headerlink" title="举一个你为过去公司带来实际效益的例子"></a>举一个你为过去公司带来实际效益的例子</h3><p>这个事情要先想清楚, 不然容易晕. 我举个两个例子:<br>一, 给xx公司做了一个调优, 使其不必升级系统而用现有资源满足了需求.<br>二, 建议xx公司取消了xx选购计划, 因为再过x个月下一代产品就上市了. 目前可以通过别的手段暂时满足需求. 面试官接着就追问我为什么会知道. 就可以说因为我定期看技术网站, 技术期刊(Technical magazine), 参加研讨会(seminar).</p>
<h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h2 id="Tell-me-about-yourself"><a href="#Tell-me-about-yourself" class="headerlink" title="Tell me about yourself"></a>Tell me about yourself</h2><p>Work out what the THREE most important qualities are for the job.<br>Say where you last worked and pick one or two things you achieved at that job<br>Say why you want to work for the particular company you are applying for.<br>Show specific knowledge about the industry and the company that you are applying for.<br>Show enthusiasm about the company.</p>
<h2 id="Work-experience-and-how-to-solve-problems-工作经验-工作遇到什么问题-怎么解决的"><a href="#Work-experience-and-how-to-solve-problems-工作经验-工作遇到什么问题-怎么解决的" class="headerlink" title="Work experience and how to solve problems (工作经验, 工作遇到什么问题, 怎么解决的)"></a>Work experience and how to solve problems (工作经验, 工作遇到什么问题, 怎么解决的)</h2><p>Initiative, Positive, can-do, innovative, work hard<br>先概括一下自己的工作经验. 然后对具体项目展开说.<br>譬如, 改善开发流程，加入敏捷开发思路在嵌入式系统，提升开发效率。</p>
<h2 id="Overtime，Take-home-work-with-you-对于加班的看法。"><a href="#Overtime，Take-home-work-with-you-对于加班的看法。" class="headerlink" title="Overtime，Take home work with you  对于加班的看法。"></a>Overtime，Take home work with you  对于加班的看法。</h2><p>To be honest, I hope to get a good balance between life and work. However, sometimes, overtime work is inevitable with some positions or projects in some emergency, like a problem from client desperately asking, I can understand that well and would solve these problem as quick as possible. I can prioritize well.<br>Furthermore, I am interesting in learning new knowledge and technique, this is a part of my life.<br>业余时间也会自己充电学习.</p>
<h2 id="Over-qualification-应聘的职位过低，容易被问-（隐去管理经验即可）"><a href="#Over-qualification-应聘的职位过低，容易被问-（隐去管理经验即可）" class="headerlink" title="Over qualification, 应聘的职位过低，容易被问 （隐去管理经验即可）"></a>Over qualification, 应聘的职位过低，容易被问 （隐去管理经验即可）</h2><p>I would say , I am well-qualified for the job. My qualification will help me do the job better and bring valuable contribution to your organization. For me, This job is a good chance to rebuild my career in Australia.</p>
<h2 id="did-you-find-this-place-easily？（热身题）"><a href="#did-you-find-this-place-easily？（热身题）" class="headerlink" title="did you find this place easily？（热身题）"></a>did you find this place easily？（热身题）</h2><p>I drive here and it is easy for me to find here. I just paid some time to park my car. Traffic is never a problem to me. I am used to study route in advance and leave enough time for a place I never visited.</p>
<h2 id="Do-you-have-some-questions？（面试结束时）"><a href="#Do-you-have-some-questions？（面试结束时）" class="headerlink" title="Do you have some questions？（面试结束时）"></a>Do you have some questions？（面试结束时）</h2><p>一般我是看人的。</p>
<ul>
<li>如果对方是engineer，将来的team mate，就问些日常需要用到的东西， 比如development process，用git还是svn，怎么test，之类的。或者team相关的。比较有共同语言。</li>
<li>有时候会问些跟工作不太相关的问题，比如为啥不用某某技术等等，不过这些容易引起讨论，最好自己要有点知识，或者有办法漂亮地收尾打住。</li>
<li>如果对方是manager，那当然就是大家据说的那些，比如career path，culture，大方面的projects等等。</li>
<li>如果对方是HR，就问些公司的大概情况，发展等等。</li>
<li>如果对方是再高层甚至CEO，那就灵活变通了。这个可能就以挣印象分为主。事先的功课非常重要。</li>
<li>问公司发展方向。或问些人家以前做过的东西，不管对方说啥一概是点头称是，yeah, right, yes, absolutely, ahha I didn’t know that等等。</li>
</ul>
<p>常见提问如下:</p>
<ul>
<li>what’s your expectation of the position holder in the first 3 months？</li>
<li>部门里有几个员工? structure如何? 一共有几个员工? 这些问题很重要,特别是公司的组织. 所在TEAM的人数和分工,有助于你进一步分析这个职位的前景和吸引度.</li>
<li>What characteristic would you define a great employee in this role?</li>
<li>How will success be measured in this role?</li>
<li>How would I report to you in this role, what is your management style?</li>
<li>What are some of the objectives you would like to see completed in the next 3 to 6 months?</li>
<li>What are some of the longer term objectives you would like to see completed?</li>
<li>How would you describe the culture of the organization?</li>
<li>Are there any advancement opportunities available for me in this role</li>
<li>What are the goals of the organisation during the next 3 years?</li>
<li>What new technologies or systems are you looking to adopt in the near future?</li>
</ul>
<h2 id="What-are-your-greatest-weaknesses-（弱点）"><a href="#What-are-your-greatest-weaknesses-（弱点）" class="headerlink" title="What are your greatest weaknesses?（弱点）"></a>What are your greatest weaknesses?（弱点）</h2><p>secondary language<br>cultural barrier</p>
<h2 id="What-can-you-contribuet-to-this-role-our-company-和what’s-your-stength"><a href="#What-can-you-contribuet-to-this-role-our-company-和what’s-your-stength" class="headerlink" title="What can you contribuet to this role (our company)? 和what’s your stength?"></a>What can you contribuet to this role (our company)? 和what’s your stength?</h2><ul>
<li>What is one of your greatest achievements to date?</li>
<li>Why do you want to work for our company?</li>
<li>Why should we employ you to work at our company? Why should we hire you?</li>
</ul>
<p>面试的基本准则是show your match。 就是要让对方信服你是最合适的人选。所以在回答问题的时候一定要注意不断突出这点。如果你说了半天你自己的特长都不是人家appreciate的，那就没有用了。</p>
<ul>
<li>问题一让你说说你过去的功绩。注意说的时候要挑选match此职位要求的地方说。</li>
<li>问题二主要是考你对公司的了解，为什么要应聘此公司，此公司为什么吸引你。这不是吹公司的优点。而是要突出吸引你的地方。也就是match你的职业发展的地方。</li>
<li>问题三出发点是你的特长，所以要说明你的什么特长对该公司有用。</li>
</ul>
<h2 id="如果你加入了我们公司，你觉得你面临的最大的挑战是什么"><a href="#如果你加入了我们公司，你觉得你面临的最大的挑战是什么" class="headerlink" title="如果你加入了我们公司，你觉得你面临的最大的挑战是什么?"></a>如果你加入了我们公司，你觉得你面临的最大的挑战是什么?</h2><p>说基本要求以外的缺点。技术上没有任何问题，主要还是culture-barrier</p>
<h2 id="did-you-fell-pressure-in-your-previous-job-How-did-you-release-those-pressure-（压力）"><a href="#did-you-fell-pressure-in-your-previous-job-How-did-you-release-those-pressure-（压力）" class="headerlink" title="did you fell pressure in your previous job? How did you release those pressure?（压力）"></a>did you fell pressure in your previous job? How did you release those pressure?（压力）</h2><p>有时, 我确实在会感到压力，但我认为适当的压力是正常的也是有益的(benefit, advantage), improve us to achieve self-break. 首先我会分析我说感到的压力，为什么我会感到压力。压力来自于何方(deadline, new knowledge)。这样有助于我了解自己的思维和正视问题。 在分析了压力以后，我会去想有什么解决产生这样压力根本问题的途径，而不是仅仅去想如何对付压力。<br>Too much pressure will become anxious, we should relief ourselves by psychological analysis<br>心理上，我会努力分析worst case的可能，如果把worst case都分析清楚了，就没有什么可以恐怖的了。 在解决问题的过程中，我会努力注重解决的过程，而不是可能的结果，这样有助于减轻我感到的压力。<br>只要我尽力去做了。所谓的压力，只是怕失败而已。 另外，我很喜欢冥想(meditation)，运动(rope skipping, biking)也是我缓解压力的一种日常手段。</p>
<h2 id="work-to-a-deadline"><a href="#work-to-a-deadline" class="headerlink" title="work to a deadline"></a>work to a deadline</h2><ul>
<li>process control: Monitor progress and communicate with all stakeholder Set milestones</li>
<li>team communication Encourage and push team member</li>
<li>Risk control identify and avoid potenial risk set contigency plan</li>
<li>be careful to make simple example to explain the above points.</li>
</ul>
<h2 id="你过去工作中遇到的最大的挑战是什么？"><a href="#你过去工作中遇到的最大的挑战是什么？" class="headerlink" title="你过去工作中遇到的最大的挑战是什么？"></a>你过去工作中遇到的最大的挑战是什么？</h2><p>我面试人的时候也喜欢问这个问题，</p>
<ul>
<li>一来可以进一步了解工作背景和经验，</li>
<li>二来可以考察面试者对业务的全面掌握程度，</li>
<li>三来考察处理问题的能力。</li>
</ul>
<p>做产品和项目, 最重要的目标就是 fulfill the goal.<br>最大的挑战就是风险控制。。。The Devil’s in the Details，魔鬼藏在细节中。</p>
<p>I’m a very focused person.<br>I divide whole task into smaller tasks then achieve and test them step by step.<br>Then I set time line for those tasks and start working as soon as possible.<br>I’m a kind of can-do person.  (work style)</p>
<h2 id="你如何不小心犯技术错误导致重大故障并且如何recovery"><a href="#你如何不小心犯技术错误导致重大故障并且如何recovery" class="headerlink" title="你如何不小心犯技术错误导致重大故障并且如何recovery?"></a>你如何不小心犯技术错误导致重大故障并且如何recovery?</h2><p>自己很严谨，开发软硬件都会模块化的自我测试，不会允许这种严重错误发生在项目中后期。<br>再强调一下process，然后才是沟通和技术上的细节处理</p>
<h2 id="how-do-you-avoid-mistake"><a href="#how-do-you-avoid-mistake" class="headerlink" title="how do you avoid mistake?"></a>how do you avoid mistake?</h2><ul>
<li>(事前) Before the event Good planning-list critical point Risk analysis Decide procedure Communication</li>
<li>(事中) During the event Keep tracking, double check in every step by using different method or different thinking style, ask third party to check Communication</li>
<li>(事后) After the events Learn the lessons, Improve the procedure</li>
</ul>
<h2 id="为什么跳槽。"><a href="#为什么跳槽。" class="headerlink" title="为什么跳槽。"></a>为什么跳槽。</h2><p>也有些人会问, 你现在工作中最不喜欢的事情是什么，（其实就是在问你什么要跳槽）</p>
<p>可以说因为公司内部要RESTRUCTURE,<br>目前公司没有发展的空间了  （应聘更高职位才说）<br>如果在一个公司工作很长时间了, 可以说, TIME FOR A CHANGE TO EXPERIENCE DIFFERENT STYLE AND HAVING EXPOSURES TO VARIETY<br>结合长期职业发展来阐述，从自己长期职业规划来说明自己需要什么样的机会，<br>同时贵公司（这个职位）有什么吸引我的地方，如何符合我的长期职业规划。<br>同时要表现出原公司也是不错的地方，只是不符合你长期的职业道路规划，<br>这样就更有说服力了。</p>
<h2 id="你是如何处理和老板间的矛盾冲突的"><a href="#你是如何处理和老板间的矛盾冲突的" class="headerlink" title="你是如何处理和老板间的矛盾冲突的"></a>你是如何处理和老板间的矛盾冲突的</h2><p>我的回答是这样的，和老板的冲突，大部分应该是对具体某件事情的不同看法，而不会是大原则性的问题，<br>而有不同的看法是很正常的，也是你在这个公司存在的价值的体现，<br>continuously communication很重要，从出现不同的看法，到如何解决这个差异，必须要懂得倾听，也要懂得适时和恰当的表达，<br>老板站在他决策层面上考虑问题，肯定和你在某些实际操作层面上考虑问题有些不同的，但大家都应是为了达到相同的目标。<br>作为team member，我们更应该服从老板在strategy上的思路，respect大家team共同的目标，<br>但在具体的执行层面提出自己的见解，这些见解可能更具有实际操作性和价值。</p>
<h2 id="说说你工作中不喜欢的同事"><a href="#说说你工作中不喜欢的同事" class="headerlink" title="说说你工作中不喜欢的同事"></a>说说你工作中不喜欢的同事</h2><p>当你的同事很难相处时,你是如何处理的?<br>If you want others respect you and kind to you,you must respect to others and kind to others.<br>Thus we can  easy to get  along with each other.<br>自己举个例子吧。设计师不理解程序员，程序员不理解设计师。事实上，大多是因为缺乏理解，多沟通保持尊重。</p>
<h2 id="如果你和collegue意见不一致时你怎样处理"><a href="#如果你和collegue意见不一致时你怎样处理" class="headerlink" title="如果你和collegue意见不一致时你怎样处理"></a>如果你和collegue意见不一致时你怎样处理</h2><p>先分析自己的观点是否正确，是否和团队目标一致。<br>如果我认为自己的观点正确，则和同事交流，尽量达成一致。<br>如果和同事不能达成一致，而且对团队目标影响较大时，主管交流，征求主管意见</p>
<h2 id="你喜欢亲自lead一个项目，还是喜欢将它break-down给不同的人？"><a href="#你喜欢亲自lead一个项目，还是喜欢将它break-down给不同的人？" class="headerlink" title="你喜欢亲自lead一个项目，还是喜欢将它break down给不同的人？"></a>你喜欢亲自lead一个项目，还是喜欢将它break down给不同的人？</h2><p>不在于我是否喜欢，而取决于TEAM的工作模式。<br>我一直是搞网络的，擅长网络设计，而网络往往是任何项目的核心部分.<br>在我以前公司，作为solution design的重要成员，我会把项目break down给不同的人，让各人发挥他们的专长(服务器、EMAIL、DC…..)，<br>而我作为项目的owner，负责整体协调和集成，包括技术审核、整体proposal，几乎充当了PM的角色，<br>所以，我不但有很强的技术背景，而且有丰富的项目组织协调能力。<br>若我能加入这个新的TEAM，我会follow这里的working model和文化，按照team leade规定的方式很好的完成我的职责。</p>
<h2 id="如果你加入了我们公司，你一年之内的计划是什么"><a href="#如果你加入了我们公司，你一年之内的计划是什么" class="headerlink" title="如果你加入了我们公司，你一年之内的计划是什么"></a>如果你加入了我们公司，你一年之内的计划是什么</h2><p>1年内的计划无疑是问你如何准备适应这个环境。<br>除非对方明确说明短期内的机会，否则绝大多数职位一年内应该没有promotion或job transfer的机会的。<br>所以在回答这个问题的时候，要着重阐述自己如何在此职位上发挥自己的能力，独档一面。<br>建议分入公司3个月，半年，1年三点来回答。着重于link职位的job responsibility阐述自己准备如何做好。</p>
<ul>
<li>Team member</li>
<li>try to merge yourself into the team</li>
<li>understanding of all corp processes involved</li>
<li>take over job and achieve required KPI</li>
</ul>
<h2 id="五年计划"><a href="#五年计划" class="headerlink" title="五年计划"></a>五年计划</h2><p>5年计划其实就是在问你长期职业规划。<br>这道题目的回答也可以注重soft 方面，而不是基于职位来回答。<br>比如你说5年后你要成为某个技术方面的专家，并在组织中起技术权威的作用，作为team leader引导组员等等。<br>这样既显示了自己的理想，又回避了具体的职位。</p>
<p>举个例子:<br>我笑笑说：我没有特别的计划，如果有，就是希望在今后的几年里有机会去塔斯马尼亚，珀斯，布里斯班旅游，最好能周游澳洲。<br>到了我这个年龄，已经不相信什么雄心壮志了，我只知道，工作自己会一一回报我的。或许回报我职位，或许回报我要的生活。 当时，我们大家都笑了。这的确是我当时真实的想法。面试者还说，对啊，工作就是为了生活。</p>
<h2 id="manage-internal-expectations（老板期望）-vs-external-expectations（客户期望）"><a href="#manage-internal-expectations（老板期望）-vs-external-expectations（客户期望）" class="headerlink" title="manage internal expectations（老板期望） vs. external expectations（客户期望）"></a>manage internal expectations（老板期望） vs. external expectations（客户期望）</h2><p>you boss probablay expect you to be cost efficent，improve bottom line， promote corp brand or image，custome relations<br>your client probably expect cheapest price with the best quality of service (usually is the case) ，time efficient ，instantaneous response （俗称随传随到）</p>
<h2 id="你喜欢工作在team里还是独立工作"><a href="#你喜欢工作在team里还是独立工作" class="headerlink" title="你喜欢工作在team里还是独立工作"></a>你喜欢工作在team里还是独立工作</h2><p>应该说，I can handle  both of them. 但是呢，应该偏向Team Work一点。<br>好象是说，我自己可以独立解决问题，比如说，Urgent Production Issue。<br>不过，Team Work那种Brain Storm的气氛也很不错，可以让问题被解决得更全面，而且本身的能力业务能更快提高。<br>当我们做大型项目的时候，Team Work绝对是必须的。</p>
<h2 id="你喜欢自己工作还是按照policy工作"><a href="#你喜欢自己工作还是按照policy工作" class="headerlink" title="你喜欢自己工作还是按照policy工作"></a>你喜欢自己工作还是按照policy工作</h2><p>Policy重要！ Policy不科学，那就改进它！Policy不灵活，那就使它灵活！ Policy是人制定的，为我们服务的，不是用来限制和框住大家的。</p>
<h2 id="你期望薪水是多少"><a href="#你期望薪水是多少" class="headerlink" title="你期望薪水是多少?"></a>你期望薪水是多少?</h2><p>Money is never a priority over knowledge and the role you would offer me.<br>Give me around the average rate in the market.<br>As the only earner member of my family , my purpose is XXX</p>
<h2 id="How-do-you-evaluate-Success"><a href="#How-do-you-evaluate-Success" class="headerlink" title="How do you evaluate Success?"></a>How do you evaluate Success?</h2><ul>
<li>When do some hard work, pay more attention to the process instead of the result and enjoy the process, and usually I will get a good result. This is success in work method.</li>
<li>Balance between work and life, pay attention to spiritual satisfaction instead of material requirement. This is success in life.</li>
<li>Be able to contribute back to society and improve the world better, This is the biggest success and one of my dream.</li>
</ul>
<h2 id="Are-you-willing-to-relocate-or-travel"><a href="#Are-you-willing-to-relocate-or-travel" class="headerlink" title="Are you willing to relocate or travel ?"></a>Are you willing to relocate or travel ?</h2><ul>
<li>Sure, I am willing to relocate as well as travel as required by my role. I am practical enough to understand the requirements of business.</li>
</ul>
<h2 id="Why-don’t-you-start-your-own-business"><a href="#Why-don’t-you-start-your-own-business" class="headerlink" title="Why don’t you start your own business?"></a>Why don’t you start your own business?</h2><p>Currently my family condition does not allow me to even think about taking higher risk and start my own business.<br>I also feel that if one is committed to the work, it always feel like you’re doing business.</p>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/09/1804-drv-lcd/" class="post-title-link" itemprop="url">驱动之LCD驱动框架和实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-01-09 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-09T00:00:00+11:00">2018-01-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2018-02-09 23:08:22" itemprop="dateModified" datetime="2018-02-09T23:08:22+11:00">2018-02-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/embedded-linux/" itemprop="url" rel="index"><span itemprop="name">embedded linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a></li>
<li><a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a></li>
<li><a href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">驱动之RTC分析</a></li>
<li><a href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">驱动之LCD驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/11/1806-drv-ts/">驱动之触摸屏驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">驱动之USB基础概念和框架</a></li>
<li><a href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">驱动之USB设备驱动程序</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="LCD驱动框架分析"><a href="#LCD驱动框架分析" class="headerlink" title="LCD驱动框架分析"></a>LCD驱动框架分析</h1><h2 id="字符驱动基本步骤"><a href="#字符驱动基本步骤" class="headerlink" title="字符驱动基本步骤"></a>字符驱动基本步骤</h2><p>根据之前写的驱动, 已经对linux驱动基本步骤比较熟悉了.</p>
<ul>
<li>所有的驱动都会调用 <code>module_init</code> 和 <code>module_exit</code>, 从 <code>module_init</code> 开始看比较好.</li>
<li>定义并设置 <code>file_operations</code> 结构体, 然后实现里面的函数, 如open等.</li>
<li>获取<code>主设备号</code>, 可以手动分配, 也可以由系统自动分配</li>
<li>用 <code>register_chrdev</code> 注册字符设备. 核心过程如下:<ul>
<li><code>__register_chrdev_region</code> 注册/申请主设备号, 并申请子设备号范围.</li>
<li><code>cdev_init</code> 用 <code>file_operations</code> 结构体初始化一个字符设备</li>
<li><code>cdev_add</code> 用设备号向系统添加字符设备.</li>
</ul>
</li>
<li>如果要用mdev自动加载驱动, 还需要在init里实现如下函数<ul>
<li><code>class_create</code>, 创建一个设备类. 可以在 <code>/sys/class/</code> 看到设备类名称</li>
<li><code>device_create</code>, 创建和注册设备. 可以在 <code>/dev/</code> 看到设备名称</li>
<li><code>class_device_create</code> 是低版本Linux的函数. 本质就是 <code>device_create</code></li>
</ul>
</li>
</ul>
<h2 id="LCD驱动框架分析-1"><a href="#LCD驱动框架分析-1" class="headerlink" title="LCD驱动框架分析"></a>LCD驱动框架分析</h2><p>Linux的LCD驱动用了分层分离的思想, 用到了platform框架.</p>
<ul>
<li><code>/drivers/video/fbmem.c</code> frame buffer memory, 显存操作相关<ul>
<li><code>subsys_initcall(fbmem_init);</code> fbmem的初始化.<ul>
<li><code>register_chrdev(FB_MAJOR,&quot;fb&quot;,&amp;fb_fops)</code> 注册字符设备,</li>
<li><code>fb_class = class_create(THIS_MODULE, &quot;graphics&quot;);</code> 注册 graphics 设备类</li>
<li>可以去<code>/sys/class/graphics</code> 看看, 下面有 fb0 和 fbcon 两个文件.</li>
<li><strong>这里没有注册设备, 因为视频控制器和具体硬件相关</strong></li>
</ul>
</li>
<li><code>registered_fb</code> 是具体设备给fbmem.c提供信息的关键!<ul>
<li><code>fb_read</code> <code>fb_write</code> 里都可以看到 <code>struct fb_info *info = registered_fb[fbidx];</code></li>
<li>然后, 函数根据 info 信息, 决定是进一步调用具体设备的 read write等函数, 还是使用默认代码.</li>
</ul>
</li>
<li><code>register_framebuffer(struct fb_info *fb_info)</code> 供LCD设备调用, 提交<code>registered_fb</code>信息并注册设备.<ul>
<li><code>device_create(fb_class, fb_info-&gt;device, MKDEV(FB_MAJOR, i), &quot;fb%d&quot;, i)</code></li>
<li>真正注册一个LCD设备, 名字是fb0, fb1这样递加上去. 可以在 <code>/dev/</code> 里找到.</li>
</ul>
</li>
</ul>
</li>
<li><code>/drviers/video/s3c2410fb.c</code> 具体硬件的LCD驱动.<ul>
<li>这里用到了platform框架. <code>s3c2410fb.c</code> 是硬件相关的通用操作, 属于 <code>platform_driver</code></li>
<li><code>module_init</code> 里, 直接就是 <code>platform_driver_register</code>.</li>
<li>我们知道platform框架里, <code>probe</code>函数是很关键的, 在drive和device匹配时, 就会调用它.</li>
<li><code>probe</code>函数里, 初始化后, 可看到 <code>register_framebuffer(fbinfo);</code> 将LCD设备信息提交给fbmem.c, 并注册设备.</li>
</ul>
</li>
<li><code>/arch/arm/mach-s3c2440/mach-smdk2440.c</code> 配置硬件参数的地方.<ul>
<li>这里是platform框架的 <code>platform_device</code>.</li>
<li><code>smdk2440_machine_init</code> 初始化里<ul>
<li><code>s3c24xx_fb_set_platdata(&amp;smdk2440_lcd_cfg);</code> 将LCD配置信息拷贝到 <code>s3c_device_lcd</code></li>
<li><code>platform_add_devices(smdk2440_devices, ARRAY_SIZE(smdk2440_devices));</code> 注册 platform_device 设备.</li>
<li><code>smdk2440_devices</code> 里就包含了 <code>s3c_device_lcd</code></li>
</ul>
</li>
<li>如果硬件平台不变, 只是换屏的话, 只需要修改 <code>mach-smdk2440.c</code> 即可. 这就是分层分离概念的意义所在.</li>
</ul>
</li>
</ul>
<p>补充说明 <code>fbmem.c</code> 的上层:</p>
<ul>
<li><code>/drivers/video/console/fbcon.c</code> 在lcd上显示终端, 此文件和tty1关联.<ul>
<li><code>class_device_create(fb_class, NULL, MKDEV(0, 0), NULL, &quot;fbcon&quot;);</code> 注册 <code>fbcon</code> 设备</li>
<li><code>fbcon_start</code>  和 fb设备对接, 开始显示.</li>
</ul>
</li>
<li>app层调用 <code>open(&quot;/dev/fb0&quot;, ...)</code>, 主设备号为29, 次设备号为0<ul>
<li>会对应到kernel层 <code>fbmem.c</code> 的 <code>fb_open</code>函数:</li>
<li><code>int fbidx = iminor(inode);</code></li>
<li><code>struct fb_info *info = = registered_fb[0];</code></li>
</ul>
</li>
<li>app层调用 <code>read()</code><ul>
<li>会对应到kernel层 <code>fbmem.c</code> 的 <code>fb_read</code>函数:</li>
<li><code>registered_fb</code> 由 <code>register_framebuffer</code> 设置.</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fb_read(struct file *file, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos) &#123;</span><br><span class="line">    <span class="keyword">int</span> fbidx = iminor(inode);                              <span class="comment">// 子设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">info</span> =</span> registered_fb[fbidx];            <span class="comment">// LCD硬件信息.</span></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;fbops-&gt;fb_read)                               <span class="comment">// 如果硬件由自己的read函数</span></span><br><span class="line">        <span class="keyword">return</span> info-&gt;fbops-&gt;fb_read(info, buf, count, ppos);<span class="comment">// 调用后, 直接返回</span></span><br><span class="line"></span><br><span class="line">    src = (u32 __iomem *) (info-&gt;screen_base + p);          <span class="comment">// 获取显存地址</span></span><br><span class="line">    dst = buffer;</span><br><span class="line">    *dst++ = fb_readl(src++);</span><br><span class="line">    copy_to_user(buf, buffer, c)                            <span class="comment">// 将值返回给应用层. 获取显存内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="LCD驱动源码"><a href="#LCD驱动源码" class="headerlink" title="LCD驱动源码"></a>LCD驱动源码</h1><p>现在尝试忽略 <code>/drviers/video/s3c2410fb.c</code> 使用的platform框架.<br>直接自己写一个 LCD 驱动, 和 <code>/drivers/video/fbmem.c</code> 进行对接.<br><strong>此处只是为了练习, 实际项目不建议这样使用</strong></p>
<p>驱动的核心步骤如下:</p>
<ol>
<li>分配一个fb_info: <code>s3c_lcd = framebuffer_alloc(0, NULL);</code></li>
<li>设置fb_info<br> 2.1 设置固定的参数, <code>struct fb_fix_screeninfo</code><br> 2.2 设置可变的参数, <code>struct fb_var_screeninfo</code><br> 2.3 设置操作函数, <code>fbops</code><br> 2.4 其他的设置</li>
<li>硬件相关的操作<br> 3.1 配置GPIO用于LCD<br> 3.2 根据LCD手册设置LCD控制器, 比如VCLK的频率等<br> 3.3 分配显存(framebuffer), 并把地址告诉LCD控制器</li>
<li>注册 <code>register_framebuffer(s3c_lcd);</code></li>
</ol>
<h2 id="测试-原系统"><a href="#测试-原系统" class="headerlink" title="测试, 原系统"></a>测试, 原系统</h2><p>在使用自己写的LCD驱动源码之前, 先用系统提供的LCD框架驱动测试一下显示屏</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板端</span></span><br><span class="line">$ vi /etc/inittab</span><br><span class="line">    <span class="comment"># ===== 设置为如下内容 =====</span></span><br><span class="line">    ::sysinit:/etc/init.d/rcS</span><br><span class="line">    s3c2410_serial0::askfirst:-/bin/sh</span><br><span class="line">    <span class="comment"># 增加了下面一行, 用于屏幕打开终端</span></span><br><span class="line">    tty1::askfirst:-/bin/sh</span><br><span class="line">    ::ctrlaltdel:/sbin/reboot</span><br><span class="line">    ::shutdown:/bin/umount -a -r</span><br><span class="line">    <span class="comment"># ===== wq保存, 退出 =====</span></span><br><span class="line">$ reboot</span><br><span class="line"><span class="comment"># 重启终端</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启后, 屏幕就会显示终端信息了. 提示输入Enter键来触发终端.</span></span><br><span class="line"><span class="comment"># 加载 &quot;驱动之input子系统&quot; 里的驱动</span></span><br><span class="line">$ insmod input_keys.ko</span><br><span class="line"><span class="comment"># 按下S4按键, 相当于输入了 Enter</span></span><br><span class="line"><span class="comment"># 依次按下 S2, S3, S4, 就是输入了ls指令, 屏幕上会列出文件列表.</span></span><br></pre></td></tr></table></figure>

<h2 id="lcd-c"><a href="#lcd-c" class="headerlink" title="lcd.c"></a>lcd.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/dma-mapping.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/clk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/div64.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-lcd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/fb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c_lcdfb_setcolreg</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> regno, <span class="keyword">unsigned</span> <span class="keyword">int</span> red,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> green, <span class="keyword">unsigned</span> <span class="keyword">int</span> blue,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> transp, struct fb_info *info)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcd_regs</span> &#123;</span>                                   <span class="comment">// LCD相关寄存器, 方便操作</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdcon1;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdcon2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdcon3;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdcon4;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdcon5;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdsaddr1;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdsaddr2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdsaddr3;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   redlut;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   greenlut;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   bluelut;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   reserved[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   dithmode;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   tpal;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdintpnd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdsrcpnd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lcdintmsk;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   lpcsel;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> <span class="title">s3c_lcdfb_ops</span> =</span> &#123;</span><br><span class="line">    .owner          = THIS_MODULE,</span><br><span class="line">    .fb_setcolreg   = s3c_lcdfb_setcolreg,          <span class="comment">// 设置调色板, 用于色域转换(RGB-&gt;RGB565)</span></span><br><span class="line">    <span class="comment">/* 下面三个函数, 需要用 make modules 获得ko文件. 路径 &quot;/drivers/video/cfb*.ko&quot; */</span></span><br><span class="line">    .fb_fillrect    = cfb_fillrect,                 <span class="comment">// 理解为画矩形</span></span><br><span class="line">    .fb_copyarea    = cfb_copyarea,                 <span class="comment">// 理解为拷贝区域</span></span><br><span class="line">    .fb_imageblit   = cfb_imageblit,                <span class="comment">// 理解为画图</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">s3c_lcd</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *gpbcon;              <span class="comment">// GPIO口的操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *gpbdat;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *gpccon;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *gpdcon;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *gpgcon;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">lcd_regs</span>* <span class="title">lcd_regs</span>;</span></span><br><span class="line"><span class="keyword">static</span> u32 pseudo_palette[<span class="number">16</span>];                      <span class="comment">// 假调色板</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* from pxafb.c */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">chan_to_field</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> chan, struct fb_bitfield *bf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    chan &amp;= <span class="number">0xffff</span>;</span><br><span class="line">    chan &gt;&gt;= <span class="number">16</span> - bf-&gt;length;</span><br><span class="line">    <span class="keyword">return</span> chan &lt;&lt; bf-&gt;offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置调色板, 用于色域转换(RGB-&gt;RGB565)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c_lcdfb_setcolreg</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> regno, <span class="keyword">unsigned</span> <span class="keyword">int</span> red,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> green, <span class="keyword">unsigned</span> <span class="keyword">int</span> blue,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> transp, struct fb_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (regno &gt; <span class="number">16</span>)                                 <span class="comment">// 一个调色板里, 最多有16个小碟子</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用red,green,blue三原色构造出val */</span>             <span class="comment">// 这里是压缩作用, 将红绿蓝压缩成16位真彩色.</span></span><br><span class="line">    val  = chan_to_field(red,   &amp;info-&gt;var.red);</span><br><span class="line">    val |= chan_to_field(green, &amp;info-&gt;var.green);</span><br><span class="line">    val |= chan_to_field(blue,  &amp;info-&gt;var.blue);</span><br><span class="line"></span><br><span class="line">    pseudo_palette[regno] = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lcd_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 1. 分配一个fb_info */</span></span><br><span class="line">    s3c_lcd = framebuffer_alloc(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 设置 */</span></span><br><span class="line">    <span class="comment">/* 2.1 设置固定的参数, struct fb_fix_screeninfo */</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s3c_lcd-&gt;fix.id, <span class="string">&quot;mylcd&quot;</span>);</span><br><span class="line">    s3c_lcd-&gt;fix.smem_len = <span class="number">480</span>*<span class="number">272</span>*<span class="number">16</span>/<span class="number">8</span>;           <span class="comment">// 显存大小(字节), 长*宽*位宽/8 (这里用的RGB565, 2字节)</span></span><br><span class="line">    s3c_lcd-&gt;fix.type     = FB_TYPE_PACKED_PIXELS;  <span class="comment">// 压缩格式. 另外有 逐行/隔行/VGA等等</span></span><br><span class="line">    s3c_lcd-&gt;fix.visual   = FB_VISUAL_TRUECOLOR;    <span class="comment">// 真彩, 即65536色.</span></span><br><span class="line">    s3c_lcd-&gt;fix.line_length = <span class="number">480</span>*<span class="number">2</span>;               <span class="comment">// 一行占用的字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2.2 设置可变的参数, struct fb_var_screeninfo */</span></span><br><span class="line">    s3c_lcd-&gt;var.xres           = <span class="number">480</span>;              <span class="comment">// 实际的屏幕分辨率(像素点)</span></span><br><span class="line">    s3c_lcd-&gt;var.yres           = <span class="number">272</span>;</span><br><span class="line">    s3c_lcd-&gt;var.xres_virtual   = <span class="number">480</span>;              <span class="comment">// 虚拟分辨率</span></span><br><span class="line">    s3c_lcd-&gt;var.yres_virtual   = <span class="number">272</span>;</span><br><span class="line">    s3c_lcd-&gt;var.bits_per_pixel = <span class="number">16</span>;               <span class="comment">// 每个像素点的位宽</span></span><br><span class="line">    s3c_lcd-&gt;var.red.offset     = <span class="number">11</span>;               <span class="comment">// RGB565的位和位偏移</span></span><br><span class="line">    s3c_lcd-&gt;var.red.length     = <span class="number">5</span>;</span><br><span class="line">    s3c_lcd-&gt;var.green.offset   = <span class="number">5</span>;</span><br><span class="line">    s3c_lcd-&gt;var.green.length   = <span class="number">6</span>;</span><br><span class="line">    s3c_lcd-&gt;var.blue.offset    = <span class="number">0</span>;</span><br><span class="line">    s3c_lcd-&gt;var.blue.length    = <span class="number">5</span>;</span><br><span class="line">    s3c_lcd-&gt;var.activate       = FB_ACTIVATE_NOW;  <span class="comment">// 实时显示</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2.3 设置操作函数, fbops */</span></span><br><span class="line">    s3c_lcd-&gt;fbops              = &amp;s3c_lcdfb_ops;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2.4 其他的设置 */</span></span><br><span class="line">    <span class="comment">/* 调色板, 可以理解为色域转换用, 譬如输入是8位, 输出是16位的颜色, 就需要用到调色板 */</span></span><br><span class="line">    s3c_lcd-&gt;pseudo_palette = pseudo_palette;       <span class="comment">// 真彩屏需要使用假调色板, 用于色域转换</span></span><br><span class="line">    <span class="comment">//s3c_lcd-&gt;screen_base  = ;                     // 3.3处会设置, 显存的虚拟地址</span></span><br><span class="line">    s3c_lcd-&gt;screen_size   = <span class="number">480</span>*<span class="number">272</span>*<span class="number">16</span>/<span class="number">8</span>;          <span class="comment">// Amount of ioremapped VRAM or 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 硬件相关的操作 */</span></span><br><span class="line">    <span class="comment">/* 3.1 配置GPIO用于LCD */</span>                        <span class="comment">// 看原理图和数据手册. 此处不详述了.</span></span><br><span class="line">    gpbcon = ioremap(<span class="number">0x56000010</span>, <span class="number">8</span>);</span><br><span class="line">    gpbdat = gpbcon+<span class="number">1</span>;</span><br><span class="line">    gpccon = ioremap(<span class="number">0x56000020</span>, <span class="number">4</span>);</span><br><span class="line">    gpdcon = ioremap(<span class="number">0x56000030</span>, <span class="number">4</span>);</span><br><span class="line">    gpgcon = ioremap(<span class="number">0x56000060</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    *gpccon  = <span class="number">0xaaaaaaaa</span>;                          <span class="comment">/* GPIO管脚用于VD[7:0],LCDVF[2:0],VM,VFRAME,VLINE,VCLK,LEND */</span></span><br><span class="line">    *gpdcon  = <span class="number">0xaaaaaaaa</span>;                          <span class="comment">/* GPIO管脚用于VD[23:8] */</span></span><br><span class="line">    *gpbcon &amp;= ~(<span class="number">3</span>);                                <span class="comment">/* GPB0设置为输出引脚 */</span></span><br><span class="line">    *gpbcon |= <span class="number">1</span>;</span><br><span class="line">    *gpbdat &amp;= ~<span class="number">1</span>;                                  <span class="comment">/* 输出低电平 */</span></span><br><span class="line">    *gpgcon |= (<span class="number">3</span>&lt;&lt;<span class="number">8</span>);                              <span class="comment">/* GPG4用作LCD_PWREN */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3.2 根据LCD手册设置LCD控制器, 比如VCLK的频率等 */</span></span><br><span class="line">    lcd_regs = ioremap(<span class="number">0x4D000000</span>, <span class="keyword">sizeof</span>(struct lcd_regs));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bit[17:8]: VCLK = HCLK / [(CLKVAL+1) x 2], LCD手册P14</span></span><br><span class="line"><span class="comment">     *            10MHz(100ns) = 100MHz / [(CLKVAL+1) x 2]</span></span><br><span class="line"><span class="comment">     *            CLKVAL = 4</span></span><br><span class="line"><span class="comment">     * bit[6:5]: 0b11, TFT LCD</span></span><br><span class="line"><span class="comment">     * bit[4:1]: 0b1100, 16 bpp for TFT</span></span><br><span class="line"><span class="comment">     * bit[0]  : 0 = Disable the video output and the LCD control signal.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lcd_regs-&gt;lcdcon1  = (<span class="number">4</span>&lt;&lt;<span class="number">8</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">0x0c</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line">    <span class="comment">/* 垂直方向的时间参数</span></span><br><span class="line"><span class="comment">     * bit[31:24]: VBPD, VSYNC之后再过多长时间才能发出第1行数据</span></span><br><span class="line"><span class="comment">     *             LCD手册 T0-T2-T1=4</span></span><br><span class="line"><span class="comment">     *             VBPD=3</span></span><br><span class="line"><span class="comment">     * bit[23:14]: 多少行, 320, 所以LINEVAL=320-1=319</span></span><br><span class="line"><span class="comment">     * bit[13:6] : VFPD, 发出最后一行数据之后，再过多长时间才发出VSYNC</span></span><br><span class="line"><span class="comment">     *             LCD手册T2-T5=322-320=2, 所以VFPD=2-1=1</span></span><br><span class="line"><span class="comment">     * bit[5:0]  : VSPW, VSYNC信号的脉冲宽度, LCD手册T1=1, 所以VSPW=1-1=0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lcd_regs-&gt;lcdcon2  = (<span class="number">1</span>&lt;&lt;<span class="number">24</span>) | (<span class="number">271</span>&lt;&lt;<span class="number">14</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 水平方向的时间参数</span></span><br><span class="line"><span class="comment">     * bit[25:19]: HBPD, VSYNC之后再过多长时间才能发出第1行数据</span></span><br><span class="line"><span class="comment">     *             LCD手册 T6-T7-T8=17</span></span><br><span class="line"><span class="comment">     *             HBPD=16</span></span><br><span class="line"><span class="comment">     * bit[18:8]: 多少列, 240, 所以HOZVAL=240-1=239</span></span><br><span class="line"><span class="comment">     * bit[7:0] : HFPD, 发出最后一行里最后一个象素数据之后，再过多长时间才发出HSYNC</span></span><br><span class="line"><span class="comment">     *             LCD手册T8-T11=251-240=11, 所以HFPD=11-1=10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lcd_regs-&gt;lcdcon3 = (<span class="number">1</span>&lt;&lt;<span class="number">19</span>) | (<span class="number">479</span>&lt;&lt;<span class="number">8</span>) | (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 水平方向的同步信号</span></span><br><span class="line"><span class="comment">     * bit[7:0] : HSPW, HSYNC信号的脉冲宽度, LCD手册T7=5, 所以HSPW=5-1=4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lcd_regs-&gt;lcdcon4 = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    lcd_regs-&gt;lcdcon2 = S3C2410_LCDCON2_VBPD(<span class="number">5</span>) | \</span><br><span class="line">        S3C2410_LCDCON2_LINEVAL(<span class="number">319</span>) | \</span><br><span class="line">        S3C2410_LCDCON2_VFPD(<span class="number">3</span>) | \</span><br><span class="line">        S3C2410_LCDCON2_VSPW(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    lcd_regs-&gt;lcdcon3 = S3C2410_LCDCON3_HBPD(<span class="number">10</span>) | \</span><br><span class="line">        S3C2410_LCDCON3_HOZVAL(<span class="number">239</span>) | \</span><br><span class="line">        S3C2410_LCDCON3_HFPD(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    lcd_regs-&gt;lcdcon4 = S3C2410_LCDCON4_MVAL(<span class="number">13</span>) | \</span><br><span class="line">        S3C2410_LCDCON4_HSPW(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 信号的极性</span></span><br><span class="line"><span class="comment">     * bit[11]: 1=565 format</span></span><br><span class="line"><span class="comment">     * bit[10]: 0 = The video data is fetched at VCLK falling edge</span></span><br><span class="line"><span class="comment">     * bit[9] : 1 = HSYNC信号要反转,即低电平有效</span></span><br><span class="line"><span class="comment">     * bit[8] : 1 = VSYNC信号要反转,即低电平有效</span></span><br><span class="line"><span class="comment">     * bit[6] : 0 = VDEN不用反转</span></span><br><span class="line"><span class="comment">     * bit[3] : 0 = PWREN输出0</span></span><br><span class="line"><span class="comment">     * bit[1] : 0 = BSWP</span></span><br><span class="line"><span class="comment">     * bit[0] : 1 = HWSWP 2440手册P413</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lcd_regs-&gt;lcdcon5 = (<span class="number">1</span>&lt;&lt;<span class="number">11</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">10</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">9</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">8</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3.3 分配显存(framebuffer), 并把地址告诉LCD控制器 */</span></span><br><span class="line">    <span class="comment">/* dma_alloc_writecombine 会分配一段连续的内存地址给内核, 返回的是虚拟地址, 因此此处直接赋值给 s3c_lcd-&gt;screen_base</span></span><br><span class="line"><span class="comment">     * s3c_lcd-&gt;fix.smem_start, 表示显存的物理起始地址, 同样由函数 dma_alloc_writecombine 设置.</span></span><br><span class="line"><span class="comment">     * 关于分配函数的比较, 可以参考 http://blog.sina.com.cn/s/blog_4770ef020101oy2e.html 看最后一张图</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s3c_lcd-&gt;screen_base = dma_alloc_writecombine(<span class="literal">NULL</span>, s3c_lcd-&gt;fix.smem_len, &amp;s3c_lcd-&gt;fix.smem_start, GFP_KERNEL);</span><br><span class="line">    lcd_regs-&gt;lcdsaddr1  = (s3c_lcd-&gt;fix.smem_start &gt;&gt; <span class="number">1</span>) &amp; ~(<span class="number">3</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">    lcd_regs-&gt;lcdsaddr2  = ((s3c_lcd-&gt;fix.smem_start + s3c_lcd-&gt;fix.smem_len) &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x1fffff</span>;</span><br><span class="line">    lcd_regs-&gt;lcdsaddr3  = (<span class="number">480</span>*<span class="number">16</span>/<span class="number">16</span>);                 <span class="comment">/* 一行的长度(单位: 2字节) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 启动LCD */</span></span><br><span class="line">    lcd_regs-&gt;lcdcon1 |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);                        <span class="comment">/* 使能LCD控制器 */</span></span><br><span class="line">    lcd_regs-&gt;lcdcon5 |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);                        <span class="comment">/* 使能LCD本身 */</span></span><br><span class="line">    *gpbdat |= <span class="number">1</span>;                                       <span class="comment">/* 输出高电平, 使能背光 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. 注册 */</span></span><br><span class="line">    register_framebuffer(s3c_lcd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lcd_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unregister_framebuffer(s3c_lcd);</span><br><span class="line">    lcd_regs-&gt;lcdcon1 &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);                       <span class="comment">/* 关闭LCD本身 */</span></span><br><span class="line">    *gpbdat &amp;= ~<span class="number">1</span>;                                      <span class="comment">/* 关闭背光 */</span></span><br><span class="line">    dma_free_writecombine(<span class="literal">NULL</span>, s3c_lcd-&gt;fix.smem_len, s3c_lcd-&gt;screen_base, s3c_lcd-&gt;fix.smem_start);</span><br><span class="line">    iounmap(lcd_regs);</span><br><span class="line">    iounmap(gpbcon);</span><br><span class="line">    iounmap(gpccon);</span><br><span class="line">    iounmap(gpdcon);</span><br><span class="line">    iounmap(gpgcon);</span><br><span class="line">    framebuffer_release(s3c_lcd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(lcd_init);</span><br><span class="line">module_exit(lcd_exit);</span><br></pre></td></tr></table></figure>


<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m       := lcd.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>这个测试比较复杂, 需要去掉自带的LCD驱动, 重新编译和烧录内核.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6_no_lcd  复制一个新的内核源码目录</span></span><br><span class="line"></span><br><span class="line">$ make clean</span><br><span class="line">$ make menuconfig                       <span class="comment"># 去掉原来的S3C2410驱动程序</span></span><br><span class="line"><span class="comment"># -&gt; Device Drivers</span></span><br><span class="line"><span class="comment"># -&gt; Graphics support</span></span><br><span class="line"><span class="comment"># &lt;M&gt; S3C2410 LCD framebuffer support</span></span><br><span class="line"><span class="comment"># 改为 M, 因为我们需要编译出里面的 &quot;/drivers/video/cfb*.ko&quot; 三个文件</span></span><br><span class="line"></span><br><span class="line">$ make uImage</span><br><span class="line">$ make modules</span><br><span class="line">$ cp ./drivers/video/cfb*.ko ~/share/jz2440/drivers/lcd/    <span class="comment"># 拷贝到lcd驱动目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 烧录新的uImage</span></span><br><span class="line"><span class="comment"># 重启开发板进入uboot烧录界面, 按k准备烧录内核. 略过不表</span></span><br><span class="line">$ sudo dnw ./arch/arm/boot/uImage</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/lcd/     # lcd驱动目录</span></span><br><span class="line">$ make modules                          <span class="comment"># 生成lcd.ko</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端</span></span><br><span class="line"><span class="comment"># pwd = ./share/jz2440/drivers/lcd/    # lcd驱动源码目录, nfs文件</span></span><br><span class="line">$ insmod cfbcopyarea.ko</span><br><span class="line">$ insmod cfbfillrect.ko</span><br><span class="line">$ insmod cfbimgblt.ko</span><br><span class="line">$ insmod lcd.ko</span><br><span class="line"><span class="comment"># 如果 /etc/inittab 已经增加过 tty1::askfirst:-/bin/sh 这么一行, 屏幕就会显示终端信息了.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd = ./share/jz2440/drivers/input_keys/KERN_SRC  # input_keys源码路径, nfs文件</span></span><br><span class="line">$ insmod input_keys.ko</span><br><span class="line"><span class="comment"># 按下 S4 输入Enter, 使能屏幕终端(即tty1),</span></span><br><span class="line"><span class="comment"># 依次按下 S2, S3, S4, 就是输入了ls指令, 屏幕上会列出文件列表.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 其它测试方法</span></span><br><span class="line"><span class="built_in">echo</span> hello &gt; /dev/tty1  // 可以在LCD上看见hello, tty1会用到 fbcon.c文件</span><br><span class="line">cat lcd.ko &gt; /dev/fb0   // 花屏</span><br></pre></td></tr></table></figure>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="http://daydreamer.idv.tw/rewrite.php/read-42.html">Framebuffer兩三事-Test On QT2410</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_4770ef020101oy2e.html">常见的Linux内核中内存分配函数</a> 看最后一张图</li>
</ul>
<hr>
<p><em><strong>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></strong></em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2018/01/08/1803-drv-platform/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/08/1803-drv-platform/" class="post-title-link" itemprop="url">驱动之platform概念</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-01-08 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-08T00:00:00+11:00">2018-01-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2018-02-09 23:08:22" itemprop="dateModified" datetime="2018-02-09T23:08:22+11:00">2018-02-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/embedded-linux/" itemprop="url" rel="index"><span itemprop="name">embedded linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a></li>
<li><a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a></li>
<li><a href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">驱动之RTC分析</a></li>
<li><a href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">驱动之LCD驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/11/1806-drv-ts/">驱动之触摸屏驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">驱动之USB基础概念和框架</a></li>
<li><a href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">驱动之USB设备驱动程序</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="platform概念"><a href="#platform概念" class="headerlink" title="platform概念"></a>platform概念</h1><p><img src="https://draapho.github.io/images/1803/bus.png" alt="bus.png"></p>
<p>platform 的主要作用是给开发人员搭好了框架.<br>便于将底层驱动的通用部分放在 <code>driver</code> 端实现, 而硬件高度相关部分放在 <code>device</code> 端实现.<br>由于只是架构, 因此这里 <code>driver</code> 和 <code>device</code> 两个部分都是自己写代码实现的, platform自动完成匹配.</p>
<p>这种架构特别适用于总线设备! 将总线设备的共性提炼成 driver 文件.<br>而正对支持总线的不同硬件, 分别单独写 device 即可.<br>因此一般情况下, platform的driver对应多个device.<br>linux基于platform的概念, 已经帮我们实现了常用总线的driver如: I2C, SPI, USB等</p>
<p>要更细致的了解linux platform 分离分层的概念, 建议参考如下博文:</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.wowotech.net/gpio_subsystem/io-port-control.html">linux内核中的GPIO系统之（1）：软件框架</a></li>
<li><a target="_blank" rel="noopener" href="http://www.wowotech.net/linux_kenrel/platform_device.html">Linux设备模型(8)_platform设备</a></li>
</ul>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>LinK+软件也支持配置platform设备, 但是生成的源码放在了同一个文件, 不便于理解.<br>为了便于理解, 采用点led来说明platform概念. 为保持代码简介, 忽略错误判断, 不支持多个device.<br>实际开发中, 自己用到platform的机会不多, 因为linux已经将常用的总线写好了.</p>
<h2 id="led-driver-c-硬件通用代码"><a href="#led-driver-c-硬件通用代码" class="headerlink" title="led_driver.c (硬件通用代码)"></a>led_driver.c (硬件通用代码)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;led_platform.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> led_major=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">led_class</span>=</span><span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *gpio_con;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *gpio_dat;</span><br><span class="line"><span class="keyword">int</span> pin;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== led driver 通用文件操作 =====</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_driver_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PINFO(<span class="string">&quot;led_driver_open\n&quot;</span>);</span><br><span class="line">    *gpio_con &amp;= ~(<span class="number">0x3</span>&lt;&lt;(pin*<span class="number">2</span>));       <span class="comment">// 配置为输出</span></span><br><span class="line">    *gpio_con |= (<span class="number">0x1</span>&lt;&lt;(pin*<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">led_driver_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> * ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    PINFO(<span class="string">&quot;led_driver_write\n&quot;</span>);</span><br><span class="line">    copy_from_user(&amp;val, buf, count);</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="number">1</span>)</span><br><span class="line">        *gpio_dat &amp;= ~(<span class="number">1</span>&lt;&lt;pin);         <span class="comment">// 点灯</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *gpio_dat |= (<span class="number">1</span>&lt;&lt;pin);          <span class="comment">// 灭灯</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_driver_release</span> <span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PINFO(<span class="string">&quot;led_driver_release\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_fops</span>=</span> &#123;</span><br><span class="line">    .owner              = THIS_MODULE,</span><br><span class="line">    .open               = led_driver_open,</span><br><span class="line">    .write              = led_driver_write,</span><br><span class="line">    .release            = led_driver_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== platform 框架使用的函数 =====</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_driver_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">resource</span>;</span></span><br><span class="line">    PINFO(<span class="string">&quot;led_driver_probe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据platform_device的资源进行ioremap</span></span><br><span class="line">    resource = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    gpio_con = ioremap(resource-&gt;start, resource-&gt;end - resource-&gt;start + <span class="number">1</span>);</span><br><span class="line">    gpio_dat = gpio_con + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    resource = platform_get_resource(pdev, IORESOURCE_IRQ, <span class="number">0</span>);</span><br><span class="line">    pin = resource-&gt;start;              <span class="comment">// 这里只是借用IRQ获取PIN值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_driver_remove</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iounmap(gpio_con);</span><br><span class="line">    PINFO(<span class="string">&quot;led_platform_remove\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">led_driver</span> =</span> &#123;</span><br><span class="line">        .driver = &#123;</span><br><span class="line">            .name   = DRIVER_NAME,</span><br><span class="line">            .owner  = THIS_MODULE,</span><br><span class="line">        &#125;,</span><br><span class="line">        .probe      = led_driver_probe,</span><br><span class="line">        .remove     = led_driver_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">led_driver_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PINFO(<span class="string">&quot;led_driver_init\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册字符设备驱动程序.</span></span><br><span class="line">    <span class="comment">// 由于driver和device可以是一对多的关系. 因此注册工作不能放在probe里, 否则会被注册多次.</span></span><br><span class="line">    led_major = register_chrdev(<span class="number">0</span>, DRIVER_NAME, &amp;led_fops);</span><br><span class="line">    led_class = class_create(THIS_MODULE, DRIVER_NAME);</span><br><span class="line">    class_device_create(led_class, <span class="literal">NULL</span>, MKDEV(led_major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;led&quot;</span>); <span class="comment">// /dev/led</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册platform的driver</span></span><br><span class="line">    platform_driver_register(&amp;led_driver);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">led_driver_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注销platform的driver</span></span><br><span class="line">    platform_driver_unregister(&amp;led_driver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卸载字符设备驱动程序</span></span><br><span class="line">    class_device_destroy(led_class, MKDEV(led_major, <span class="number">0</span>));</span><br><span class="line">    class_destroy(led_class);</span><br><span class="line">    unregister_chrdev(led_major, DRIVER_NAME);</span><br><span class="line">    PINFO(<span class="string">&quot;led_platform_exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_driver_init);</span><br><span class="line">module_exit(led_driver_exit);</span><br></pre></td></tr></table></figure>

<h2 id="led-device-c-硬件专用代码"><a href="#led-device-c-硬件专用代码" class="headerlink" title="led_device.c (硬件专用代码)"></a>led_device.c (硬件专用代码)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;led_platform.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">led_devs_res1</span>[] =</span> &#123;         <span class="comment">// 硬件专用资源信息</span></span><br><span class="line">    &#123;</span><br><span class="line">        .start  = <span class="number">0x56000050</span>,</span><br><span class="line">        .end    = <span class="number">0x56000050</span> + <span class="number">8</span> - <span class="number">1</span>,</span><br><span class="line">        .flags  = IORESOURCE_MEM,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .start  = <span class="number">5</span>,                        <span class="comment">// 借用IRQ表示PIN引脚</span></span><br><span class="line">        .flags  = IORESOURCE_IRQ,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">led_dev_release</span><span class="params">(struct device * dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PINFO(<span class="string">&quot;led_dev_release\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">led_devs1</span> =</span> &#123;</span><br><span class="line">    .name           = DRIVER_NAME,</span><br><span class="line">    .resource       = led_devs_res1,</span><br><span class="line">    .num_resources  = ARRAY_SIZE(led_devs_res1),</span><br><span class="line">    .id             = <span class="number">0</span>,</span><br><span class="line">    .dev = &#123;</span><br><span class="line">        .release = led_dev_release,         <span class="comment">// 必须实现, 否则报错</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PINFO(<span class="string">&quot;led_dev_init\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 注册device</span></span><br><span class="line">    platform_device_register(&amp;led_devs1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">led_dev_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注销device</span></span><br><span class="line">    platform_device_unregister(&amp;led_devs1);</span><br><span class="line">    PINFO(<span class="string">&quot;led_dev_exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_dev_init);</span><br><span class="line">module_exit(led_dev_exit);</span><br></pre></td></tr></table></figure>

<h2 id="led-platform-h"><a href="#led-platform-h" class="headerlink" title="led_platform.h"></a>led_platform.h</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_NAME <span class="meta-string">&quot;led_platform&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDEBUG(fmt,args...) printk(KERN_DEBUG<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERR(fmt,args...) printk(KERN_ERR<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME,##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINFO(fmt,args...) printk(KERN_INFO<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="led-test-c"><a href="#led-test-c" class="headerlink" title="led_test.c"></a>led_test.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* led_test on</span></span><br><span class="line"><span class="comment"> * led_test off</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/led&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage :\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &lt;on|off&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;on&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        val  = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write(fd, &amp;val, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TEST_FILE   := led_test</span><br><span class="line">obj-m       += led_driver.o</span><br><span class="line">obj-m       += led_device.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">install:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules_install</span><br><span class="line">    depmod -a</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br><span class="line">    rm -f <span class="variable">$(TEST_FILE)</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">    arm-linux-gcc <span class="variable">$(TEST_FILE)</span>.c -o <span class="variable">$(TEST_FILE)</span></span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu主机端, 编译所有源码</span></span><br><span class="line">$ make clean</span><br><span class="line">$ make modules</span><br><span class="line">$ make <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端</span></span><br><span class="line">$ insmod led_driver.ko              <span class="comment"># driver和device的调用顺序不重要</span></span><br><span class="line">led_platform:led_driver_init</span><br><span class="line">$ insmod led_device.ko</span><br><span class="line">led_platform:led_dev_init</span><br><span class="line">led_platform:led_driver_probe       <span class="comment"># platform 在匹配driver和device后, 调用probe</span></span><br><span class="line">$ ./led_test on</span><br><span class="line">led_platform:led_driver_open        <span class="comment"># open</span></span><br><span class="line">led_platform:led_driver_write       <span class="comment"># write</span></span><br><span class="line">led_platform:led_driver_release     <span class="comment"># close</span></span><br><span class="line">$ ./led_test off</span><br><span class="line">led_platform:led_driver_open</span><br><span class="line">led_platform:led_driver_write</span><br><span class="line">led_platform:led_driver_release</span><br><span class="line">$ rmmod led_device.ko</span><br><span class="line">led_platform:led_platform_remove    <span class="comment"># 解绑后, 自动调用remove</span></span><br><span class="line">led_platform:led_dev_release</span><br><span class="line">led_platform:led_dev_exit</span><br><span class="line">$ rmmod led_driver.ko</span><br><span class="line">led_platform:led_platform_exit</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/tianzhihen_wq/article/details/42176467">linux驱动之分离分层的概念</a></li>
<li><a target="_blank" rel="noopener" href="http://www.wowotech.net/gpio_subsystem/io-port-control.html">linux内核中的GPIO系统之（1）：软件框架</a></li>
<li><a target="_blank" rel="noopener" href="http://www.wowotech.net/linux_kenrel/platform_device.html">Linux设备模型(8)_platform设备</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2018/01/05/1802-drv-input/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/05/1802-drv-input/" class="post-title-link" itemprop="url">驱动之input子系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-01-05 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-05T00:00:00+11:00">2018-01-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2018-02-09 23:08:22" itemprop="dateModified" datetime="2018-02-09T23:08:22+11:00">2018-02-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/embedded-linux/" itemprop="url" rel="index"><span itemprop="name">embedded linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a></li>
<li><a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a></li>
<li><a href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">驱动之RTC分析</a></li>
<li><a href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">驱动之LCD驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/11/1806-drv-ts/">驱动之触摸屏驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">驱动之USB基础概念和框架</a></li>
<li><a href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">驱动之USB设备驱动程序</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="输入子系统"><a href="#输入子系统" class="headerlink" title="输入子系统"></a>输入子系统</h1><p>输入子系统是Linux对硬件设备进一步的抽象.<br>将输入系统的逻辑概念统一写好, 我们称之为软件抽象层.<br>而硬件部分的底层工作需要由开发人员具体实现, 我们称之为硬件设备层.<br>中间还有个连接层, 用于实现软件抽象层和硬件设备层的多对多关联.</p>
<p>按键, 鼠标, 键盘, 触摸屏等设备都可以归属为输入子系统.<br>这些设备的硬件驱动和输入子系统对接, 输入子系统再统一将输入事件传递给应用层.<br>这样, 应用层的设备就无需考虑底层硬件的区别.<br>而我们之前写的按键驱动, LED驱动, 一般只是给公司内部调用的, 不具有通用性!</p>
<p>整个输入子系统完成的工作其实和自己写的驱动是一样的.<br>只是部分可以软件抽象的功能被输入子系统打包掉了.<br>其核心代码在 <code>/drivers/input/input.c</code><br>整体框架如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ===== 输入子系统, 核心层 =====</span></span><br><span class="line">文件 /drivers/input/input.c 内, 关键函数</span><br><span class="line">    input_init              <span class="comment">// 初始化</span></span><br><span class="line">    class_register          <span class="comment">// 注册类</span></span><br><span class="line">    register_chrdev         <span class="comment">// 注册设备(主设备号13)</span></span><br><span class="line"></span><br><span class="line">    input_register_device   <span class="comment">// 注册硬件设备 input_dev</span></span><br><span class="line">    input_register_handler  <span class="comment">// 注册软件抽象 input_handler</span></span><br><span class="line">    input_register_handle   <span class="comment">// 注册连接     input_handle</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 软件抽象层, 系统已实现 =====</span></span><br><span class="line"><span class="number">1.</span> <span class="keyword">static</span> 初始化一个 input_handler 全局变量</span><br><span class="line"><span class="number">2.</span> 注册此变量, input_register_handler</span><br><span class="line"><span class="number">3.</span> 实现 event connect 等函数</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> &#123;</span></span><br><span class="line">    event,connect, disconnect, start        <span class="comment">// 函数具体实现的指针</span></span><br><span class="line">    <span class="keyword">int</span> minor;                              <span class="comment">// 次设备号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;                       <span class="comment">// 显示在proc/bus/input/handlers</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id_table</span>;</span> <span class="comment">// 驱动支持的id表(用于匹配input_dev)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">blacklist</span>;</span><span class="comment">// id表黑名单</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_list</span>;</span>             <span class="comment">// 存放input_handle(没有r)的链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">node</span>;</span>               <span class="comment">// 存放input_handler自身的链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 连接层, 系统已实现 =====</span></span><br><span class="line">多个文件 /drivers/input<span class="comment">/*dev.c 内*/</span></span><br><span class="line"><span class="number">1.</span> *dev_connect里分配 input_handle(没有r)变量</span><br><span class="line"><span class="number">2.</span> 设置/初始化此变量</span><br><span class="line"><span class="number">3.</span> 注册, input_register_handle(没有r)</span><br><span class="line"></span><br><span class="line"><span class="function">struct <span class="title">input_handle</span><span class="params">(没有r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;                          <span class="comment">// 私有数据, 指向了父指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span>                  <span class="comment">// 指向input_dev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span>          <span class="comment">// 指向 input_handler</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">d_node</span>;</span>             <span class="comment">// 存放input_dev-&gt;h_list的链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_node</span>;</span>             <span class="comment">// 存放input_handler-&gt;h_list的链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 硬件设备层, 自己写 =====</span></span><br><span class="line"><span class="number">1.</span> 分配一个input_dev变量</span><br><span class="line"><span class="number">2.</span> 设置/初始化此变量</span><br><span class="line"><span class="number">3.</span> 注册, input_register_device</span><br><span class="line"><span class="number">4.</span> 硬件相关代码, open, close, event, sync等等.</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;                       <span class="comment">// 设备描述</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *phys;                       <span class="comment">// 设备路径?</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span>                     <span class="comment">// 总线类型. 供应商/产品/版本信息. 用于匹配 input_handler</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> evbit[NBITS(EV_MAX)];     <span class="comment">// 记录支持的事件类型位图</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> keybit[NBITS(KEY_MAX)];   <span class="comment">// 记录支持的按键值位图</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> relbit[NBITS(REL_MAX)];   <span class="comment">// 记录支持的相对坐标位图, 如滚轮</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> absbit[NBITS(ABS_MAX)];   <span class="comment">// 记录支持的绝对坐标位图, 如触摸屏</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_list</span>;</span>             <span class="comment">// 存放input_handle(没有r)的链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">node</span>;</span>               <span class="comment">// 存放input_dev自身的链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如图, 较为直观的说明了三者的指针关系, 以及 <code>input_handler</code> 和 <code>input_dev</code> 通过 <code>input_handle(没有r)</code> 的建立的多对多关系</p>
<p><img src="https://draapho.github.io/images/1802/input_struct_relation.png" alt="input_struct_relation"></p>
<h2 id="input核心层"><a href="#input核心层" class="headerlink" title="input核心层"></a>input核心层</h2><p>整个input初始化流程大致如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/input/input.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">input_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">class_register</span><span class="params">(&amp;input_class)</span></span>;       <span class="comment">// 注册input类. 对应于自己写的驱动的 class_create, 也会class_register</span></span><br><span class="line">    input_proc_init();                  <span class="comment">// 初始化一些交互文件</span></span><br><span class="line">    register_chrdev(INPUT_MAJOR, <span class="string">&quot;input&quot;</span>, &amp;input_fops); <span class="comment">// 对应于自己写的驱动的 register_chrdev, 注册设备</span></span><br><span class="line">        <span class="comment">// input的主设备号固定为13, 子设备号后面会自动分配. 核心是 input_fops 这么一个结构.</span></span><br><span class="line">        <span class="comment">// 查看 input_fops 变量, 只有一个 .open 函数, 指向 input_open_file</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_open_file</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function">            struct input_handler *handler </span>= input_table[iminor(inode) &gt;&gt; <span class="number">5</span>];    <span class="comment">// 取出子设备号高3位, 低5位用于自动分配</span></span><br><span class="line">            new_fops = fops_get(handler-&gt;fops)  <span class="comment">// 打开handler指向的fop, 譬如 &amp;evdev_fops (后面会讲到)</span></span><br><span class="line">            file-&gt;f_op = new_fops;</span><br><span class="line">            new_fops-&gt;open(inode, file);        <span class="comment">// 打开真正可操作的文件, 里面会有 read, write</span></span><br><span class="line">            <span class="comment">// 这样 app:read &gt; ... &gt; file-&gt;f_op-&gt;read</span></span><br><span class="line">    <span class="comment">// 另外一个 class_device_create 是在 input_handler.connect 的函数里实现的.</span></span><br></pre></td></tr></table></figure>

<p>上述代码, 关键点在于从 input_table 取出 input_handler的指针.<br>那么 input_table 由谁构造呢? 搜索可知是: <code>input_register_handler</code>. 继续往下看.</p>
<h2 id="软件抽象层"><a href="#软件抽象层" class="headerlink" title="软件抽象层"></a>软件抽象层</h2><p>注册 input_handler 的过程:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// input_open_file 函数里, 有个关键数组为 input_table, 存储了input_handler的指针!</span></span><br><span class="line"><span class="comment">// 函数 input_register_handler 会设置 input_table. 它被如下代码调用:</span></span><br><span class="line"><span class="comment">// drivers/char/keyboard.c  // 按键抽象</span></span><br><span class="line"><span class="comment">// drivers/input/evbug.c    // 调试用, 所用的事件存到 syslog文件中</span></span><br><span class="line"><span class="comment">// drivers/input/evdev.c    // input_table[2], 子设备号0x40-0x5F, 设备事件抽象</span></span><br><span class="line"><span class="comment">// drivers/input/joydev.c   // input_table[0], 子设备号0x00-0x0F, 游戏杆抽象</span></span><br><span class="line"><span class="comment">// drivers/input/mousedev.c // input_table[1], 子设备号0x20-0x3F, 鼠标抽象</span></span><br><span class="line"><span class="comment">// drivers/input/tsdev.c    // input_table[4], 子设备号0x80-0x9F, 触摸屏抽象</span></span><br><span class="line"><span class="comment">// 上述几个文件真正定义了 input_handler 的变量如 evdev_handler, 并对其初始化, 包括 id_table</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_handler</span><span class="params">(struct input_handler *handler)</span></span></span><br><span class="line">    input_table[handler-&gt;minor &gt;&gt; 5] = handler;         // 将input_handler指针放入数组</span><br><span class="line">    list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list); <span class="comment">// 放入链表</span></span><br><span class="line">    list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);             <span class="comment">// 对于每个input_dev, 调用input_attach_handler</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_attach_handler</span><span class="params">(struct input_dev *dev, struct input_handler *handler)</span></span></span><br><span class="line"><span class="function">    id </span>= input_match_device(handler-&gt;id_table, dev);    <span class="comment">// 根据input_handler的id_table判断能否支持这个input_dev</span></span><br><span class="line">    error = handler-&gt;connect(handler, dev, id);         <span class="comment">// 匹配的话, 就自动建立连接, 连接函数由软件抽象层实现</span></span><br></pre></td></tr></table></figure>


<h2 id="硬件设备层"><a href="#硬件设备层" class="headerlink" title="硬件设备层"></a>硬件设备层</h2><p>注册 input_dev 的过程:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数 input_register_device 用于注册硬件设备, 由开发人员写的驱动代码调用.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_device</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function">    <span class="title">list_add_tail</span><span class="params">(&amp;dev-&gt;node, &amp;input_dev_list)</span></span>;         <span class="comment">// 放入链表</span></span><br><span class="line">    list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);             <span class="comment">// 对于每一个input_handler，调用 input_attach_handler</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_attach_handler</span><span class="params">(struct input_dev *dev, struct input_handler *handler)</span></span></span><br><span class="line"><span class="function">    id </span>= input_match_device(handler-&gt;id_table, dev);    <span class="comment">// 根据input_handler的id_table判断能否支持这个input_dev</span></span><br><span class="line">    error = handler-&gt;connect(handler, dev, id);         <span class="comment">// 匹配的话, 就自动建立连接, 连接函数由软件抽象层实现</span></span><br></pre></td></tr></table></figure>

<h2 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h2><p>有上述分析可知, 软件抽象层和硬件设备层建立连接的关键是 <code>handler-&gt;connect</code> 指向的函数.<br>建立连接的基本步骤如下:</p>
<ol>
<li>分配一个 <code>input_handle(没有r)</code> 结构体</li>
<li>设置/初始化 <code>input_handle(没有r)</code><ul>
<li><code>input_handle.dev = input_dev;</code> 保存硬件设备, input_dev</li>
<li><code>input_handle.handler = input_handler;</code> 保存软件抽象, input_handler</li>
</ul>
</li>
<li>软件层和硬件层分别注册 <code>input_handle(没有r)</code>, 将其指针保存到各自结构体的<code>h_list</code>项中<ul>
<li><code>input_handler-&gt;h_list = &amp;input_handle;</code></li>
<li><code>inpu_dev-&gt;h_list = &amp;input_handle;</code></li>
</ul>
</li>
</ol>
<p>硬件设备层的代码最终是要自己写的, 因此我们会比较熟悉.<br>下面以软件抽象层的 <code>drivers/input/evdev.c</code> 为例, 分析一下整个匹配过程.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前已经分析到, 调用 input_register_handler 和 input_register_device 时, 都会进行匹配</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_attach_handler</span><span class="params">(struct input_dev *dev, struct input_handler *handler)</span></span></span><br><span class="line"><span class="function">    id </span>= input_match_device(handler-&gt;id_table, dev);    <span class="comment">// 根据input_handler的id_table判断能否支持这个input_dev</span></span><br><span class="line">    error = handler-&gt;connect(handler, dev, id);         <span class="comment">// 匹配的话, 就自动建立连接, 连接函数由软件抽象层实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里说明一下, handler-&gt;id_table 和 handler-&gt;connect 的初始值都是由软件抽象层几个文件完成的. 具体就是下面几个:</span></span><br><span class="line"><span class="comment">// drivers/char/keyboard.c  // 按键抽象</span></span><br><span class="line"><span class="comment">// drivers/input/evbug.c    // 调试用, 所用的事件存到 syslog文件中</span></span><br><span class="line"><span class="comment">// drivers/input/evdev.c    // input_table[2], 子设备号0x40-0x5F, 设备事件抽象</span></span><br><span class="line"><span class="comment">// drivers/input/joydev.c   // input_table[0], 子设备号0x00-0x0F, 游戏杆抽象</span></span><br><span class="line"><span class="comment">// drivers/input/mousedev.c // input_table[1], 子设备号0x20-0x3F, 鼠标抽象</span></span><br><span class="line"><span class="comment">// drivers/input/tsdev.c    // input_table[4], 子设备号0x80-0x9F, 触摸屏抽象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们以 evdev.c 为例深入分析一下. 其定义的 input_handler 变量名为 evdev_handler. connect会调用evdev_connect</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evdev_connect</span><span class="params">(struct input_handler *handler, struct input_dev *dev, <span class="keyword">const</span> struct input_device_id *id)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 1. 分配一个evdev, 里面包含了input_handle(没有r)</span></span></span><br><span class="line"><span class="function">    evdev </span>= kzalloc(<span class="keyword">sizeof</span>(struct evdev), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置/初始化</span></span><br><span class="line">    evdev-&gt;handle.dev = dev;            <span class="comment">// 保存硬件设备的input_dev指针</span></span><br><span class="line">    evdev-&gt;handle.name = evdev-&gt;name;</span><br><span class="line">    evdev-&gt;handle.handler = handler;    <span class="comment">// 保存软件抽象的input_handler指针</span></span><br><span class="line">    evdev-&gt;handle.<span class="keyword">private</span> = evdev;      <span class="comment">// 保存 evdev 这个指针. 让handle知道归属.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里对应于自己写的驱动的 class_device_create, 注册input类下面的设备.</span></span><br><span class="line">    <span class="comment">// 另外两个, 注册驱动和注册类都是在 input_init() 里完成的</span></span><br><span class="line">    class_device_create(&amp;input_class, &amp;dev-&gt;cdev, devt,dev-&gt;cdev.dev, evdev-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 注册</span></span><br><span class="line">    error = input_register_handle(&amp;evdev-&gt;handle);              <span class="comment">// 注意没有r, 不是 input_register_handler</span></span><br><span class="line">        list_add_tail(&amp;handle-&gt;d_node, &amp;handle-&gt;dev-&gt;h_list);   <span class="comment">// 将 handle 加入 dev-&gt;h_list 链表中</span></span><br><span class="line">        list_add_tail(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);       <span class="comment">// 将 handle 加入 handler-&gt;h_list 链表中</span></span><br><span class="line">        <span class="comment">// 这里可以分析出, 软件抽象层和硬件设备层的对应关系是可以多对多的, 两者都维护着一个handle列表(h_list).</span></span><br></pre></td></tr></table></figure>

<h2 id="APP层相关函数"><a href="#APP层相关函数" class="headerlink" title="APP层相关函数"></a>APP层相关函数</h2><p>最后, 从APP层读取输入子系统进行分析. 以按键为例, 用到 <code>drivers/input/evdev.c</code> 和 <code>drivers/char/keyboard.c</code><br>在书写按键的硬件模块时, input子系统会自动匹配关联到上述两个软件抽象层.<br>(猜测, keyboard的抽象层次比evdev更高. 因此keyboard没有input_table初始值)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app: read 试着读取按键值后:</span></span><br><span class="line"><span class="comment">// ....... 中间过程省略掉, 最后会调用:</span></span><br><span class="line">    evdev_read</span><br><span class="line">        <span class="comment">// 无数据(用的环形缓冲区)并且是非阻塞方式打开，则立刻返回</span></span><br><span class="line">        <span class="keyword">if</span> (client-&gt;head == client-&gt;tail &amp;&amp; evdev-&gt;exist &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">            <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">        <span class="comment">// 否则休眠</span></span><br><span class="line">        retval = wait_event_interruptible(evdev-&gt;wait, client-&gt;head != client-&gt;tail || !evdev-&gt;exist);</span><br><span class="line"></span><br><span class="line">    evdev_event     <span class="comment">// 休眠后, 由evdev_event来唤醒, 此时间和硬件相关, 由硬件设备层实现</span></span><br><span class="line">        wake_up_interruptible(&amp;evdev-&gt;wait);</span><br></pre></td></tr></table></figure>



<h1 id="硬件设备端源码"><a href="#硬件设备端源码" class="headerlink" title="硬件设备端源码"></a>硬件设备端源码</h1><p>由于input子系统的实际上是帮我们完成了相当一部分的注册工作, 并实现了通用的逻辑功能.<br>因此实际写硬件设备驱动时, 反而变得更简单了. 核心步骤如下:</p>
<ol>
<li>分配一个input_dev结构体. <code>input_allocate_device</code></li>
<li>设置事件, 设置事件支持的操作类型</li>
<li>注册 <code>input_register_device</code></li>
<li>硬件初始化和逻辑判断<ul>
<li>上报事件: <code>input_event</code> <code>input_sync</code></li>
</ul>
</li>
</ol>
<p>依旧通过 LinK+ 软件来写驱动. LinK+设置步骤可参考 <a href="https://draapho.github.io/2017/11/30/1740-drv-chr2/">驱动之基于LinK+设计按键驱动</a></p>
<p>与input有关的设置页面如下:<br><img src="https://draapho.github.io/images/1802/link+input.JPG" alt="link+input"></p>
<h2 id="input-keys-c"><a href="#input-keys-c" class="headerlink" title="input_keys.c"></a>input_keys.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">Driver Name     :       input_keys</span></span><br><span class="line"><span class="comment">Author          :       DRAAPHO</span></span><br><span class="line"><span class="comment">License         :       GPL</span></span><br><span class="line"><span class="comment">Description     :       LINUX DEVICE DRIVER PROJECT</span></span><br><span class="line"><span class="comment">                :       参考drivers\input\keyboard\gpio_keys.c</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;input_keys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keys_desc</span>&#123;</span>                                       <span class="comment">// 硬件相关参数</span></span><br><span class="line">    <span class="keyword">int</span> irq;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pin;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> key_val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keys_desc</span> <span class="title">keys_desc_public</span>[4] =</span> &#123;                <span class="comment">// 硬件参数初始化</span></span><br><span class="line">    &#123;IRQ_EINT0,  <span class="string">&quot;S2&quot;</span>, S3C2410_GPF0,  KEY_L&#125;,</span><br><span class="line">    &#123;IRQ_EINT2,  <span class="string">&quot;S3&quot;</span>, S3C2410_GPF2,  KEY_S&#125;,</span><br><span class="line">    &#123;IRQ_EINT11, <span class="string">&quot;S4&quot;</span>, S3C2410_GPG3,  KEY_ENTER&#125;,</span><br><span class="line">    &#123;IRQ_EINT19, <span class="string">&quot;S5&quot;</span>, S3C2410_GPG11, KEY_LEFTSHIFT&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_keys_private</span> &#123;</span>                             <span class="comment">// 私有变量结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">keys_desc</span> *<span class="title">keysdesc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">keys_timer</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_keys_private</span> *<span class="title">input_keys_priv</span>;</span>             <span class="comment">// 私有变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">keys_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span>      <span class="comment">// 按键中断函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!input_keys_priv)</span><br><span class="line">        <span class="keyword">return</span> IRQ_NONE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10ms后启动定时器, 用于按键防抖动</span></span><br><span class="line">    input_keys_priv-&gt;keysdesc = (struct keys_desc *)dev_id;</span><br><span class="line">    mod_timer(&amp;input_keys_priv-&gt;keys_timer, jiffies+HZ/<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keys_timer_function</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span>     <span class="comment">// 定时器超时中断函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">keydev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">keys_desc</span> *<span class="title">keydesc</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pinval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!input_keys_priv)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    keydesc= input_keys_priv-&gt;keysdesc;</span><br><span class="line">    keydev = input_keys_priv-&gt;dev;</span><br><span class="line">    pinval = s3c2410_gpio_getpin(keydesc-&gt;pin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pinval) &#123;</span><br><span class="line">        <span class="comment">/* 松开 : 最后一个参数: 0-松开, 1-按下 */</span></span><br><span class="line">        input_event(keydev, EV_KEY, keydesc-&gt;key_val, <span class="number">0</span>);   <span class="comment">// 触发按键事件</span></span><br><span class="line">        input_sync(keydev);                                 <span class="comment">// 事件结束, 同步到用户空间</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 按下 */</span></span><br><span class="line">        input_event(keydev, EV_KEY, keydesc-&gt;key_val, <span class="number">1</span>);   <span class="comment">// 触发按键事件</span></span><br><span class="line">        input_sync(keydev);                                 <span class="comment">// 事件结束, 同步到用户空间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_keys_open</span><span class="params">(struct input_dev *dev)</span>           <span class="comment">// 观察用, 初始化代码建议全部放在init函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PINFO(<span class="string">&quot;input_keys_open \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_keys_close</span><span class="params">(struct input_dev *dev)</span>         <span class="comment">// 观察用, 退出代码建议全部放在exit函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PINFO(<span class="string">&quot;input_keys_close \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">input_keys_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, res;</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;input_keys_init\n&quot;</span>);</span><br><span class="line">    input_keys_priv = kzalloc(<span class="keyword">sizeof</span>(struct input_keys_private),GFP_KERNEL);</span><br><span class="line">    <span class="comment">/*===== 1. 分配一个input_dev结构体, 并初始化 =====*/</span></span><br><span class="line">    input_keys_priv-&gt;dev = input_allocate_device();</span><br><span class="line">    <span class="comment">// 1.1 初始化后dev的一些内容</span></span><br><span class="line">    input_keys_priv-&gt;dev-&gt;name = DRIVER_NAME;</span><br><span class="line">    input_keys_priv-&gt;dev-&gt;open = input_keys_open;           <span class="comment">// 可以注释掉</span></span><br><span class="line">    input_keys_priv-&gt;dev-&gt;close = input_keys_close;         <span class="comment">// 可以注释掉</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*===== 2. 设置事件. =====*/</span></span><br><span class="line">    <span class="comment">// 2.1 设置event事件</span></span><br><span class="line">    set_bit(EV_KEY,input_keys_priv-&gt;dev-&gt;evbit);            <span class="comment">// 支持按键事件</span></span><br><span class="line">    set_bit(EV_REP,input_keys_priv-&gt;dev-&gt;evbit);            <span class="comment">// 支持按键连发功能</span></span><br><span class="line">    <span class="comment">// 2.2 设置key事件支持的按键值</span></span><br><span class="line">    set_bit(KEY_L, input_keys_priv-&gt;dev-&gt;keybit);           <span class="comment">// 支持按键 l</span></span><br><span class="line">    set_bit(KEY_S, input_keys_priv-&gt;dev-&gt;keybit);           <span class="comment">// 支持按键 s</span></span><br><span class="line">    set_bit(KEY_ENTER, input_keys_priv-&gt;dev-&gt;keybit);       <span class="comment">// 支持按键 enter</span></span><br><span class="line">    set_bit(KEY_LEFTSHIFT, input_keys_priv-&gt;dev-&gt;keybit);   <span class="comment">// shift</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2 其它初始化, 然后赋值这个私有结构体给 dev-&gt;private</span></span><br><span class="line">    input_keys_priv-&gt;keysdesc = keys_desc_public;</span><br><span class="line">    input_keys_priv-&gt;keys_timer.function = keys_timer_function;</span><br><span class="line">    input_set_drvdata(input_keys_priv-&gt;dev , input_keys_priv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*===== 3. 注册 input_device, 此处会去调用 open 函数 =====*/</span></span><br><span class="line">    PINFO(<span class="string">&quot;input_keys_init_befor_register\n&quot;</span>);</span><br><span class="line">    res = input_register_device(input_keys_priv-&gt;dev);</span><br><span class="line">    <span class="keyword">if</span>(res&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        PERR(<span class="string">&quot;input registration failed. error_id=%d\n&quot;</span>, res);</span><br><span class="line">        <span class="keyword">goto</span> fail1;</span><br><span class="line">    &#125;</span><br><span class="line">    PINFO(<span class="string">&quot;input_keys_init_after_register\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*===== 4. 硬件相关的操作, 这部分也可以放在open函数中 =====*/</span></span><br><span class="line">    <span class="comment">// 4.1 注册中断号, 设置中断类型, 设置中断名称(和设备名称无关), 传入自用的数据指针</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        res = request_irq(keys_desc_public[i].irq, keys_irq, IRQT_BOTHEDGE, keys_desc_public[i].name, &amp;keys_desc_public[i]);</span><br><span class="line">        <span class="keyword">if</span> (res&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            PERR(<span class="string">&quot;request_irq(%d), error_id=%d\n&quot;</span>, i, res);</span><br><span class="line">            <span class="keyword">goto</span> fail2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.2 初始化timer, 用于按键延时防抖.</span></span><br><span class="line">    init_timer(&amp;input_keys_priv-&gt;keys_timer);</span><br><span class="line">    add_timer(&amp;input_keys_priv-&gt;keys_timer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误处理部分.</span></span><br><span class="line">fail2:</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        free_irq(keys_desc_public[i].irq, &amp;keys_desc_public[i]);</span><br><span class="line">    &#125;</span><br><span class="line">fail1:</span><br><span class="line">    input_unregister_device(input_keys_priv-&gt;dev);</span><br><span class="line">    input_free_device(input_keys_priv-&gt;dev);</span><br><span class="line">    kfree(input_keys_priv);</span><br><span class="line">    <span class="keyword">return</span> -EBUSY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">input_keys_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exit 是 init 的反操作, 严格按照init的倒序执行!</span></span><br><span class="line">    del_timer(&amp;input_keys_priv-&gt;keys_timer);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        free_irq(keys_desc_public[i].irq, &amp;keys_desc_public[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;input_keys_exit_before_unregister\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 此处会调用 close 函数, 因此之前的内容也可以放到close函数中.</span></span><br><span class="line">    input_unregister_device(input_keys_priv-&gt;dev);</span><br><span class="line">    PINFO(<span class="string">&quot;input_keys_exit_after_unregister\n&quot;</span>);</span><br><span class="line">    input_free_device(input_keys_priv-&gt;dev);</span><br><span class="line">    kfree(input_keys_priv);</span><br><span class="line">    PINFO(<span class="string">&quot;input_keys_exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(input_keys_init);</span><br><span class="line">module_exit(input_keys_exit);</span><br></pre></td></tr></table></figure>

<h2 id="input-keys-h"><a href="#input-keys-h" class="headerlink" title="input_keys.h"></a>input_keys.h</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_NAME <span class="meta-string">&quot;input_keys&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDEBUG(fmt,args...) printk(KERN_DEBUG<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERR(fmt,args...) printk(KERN_ERR<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME,##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINFO(fmt,args...) printk(KERN_INFO<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-gpio.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m       := input_keys.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">install:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules_install</span><br><span class="line">    depmod -a</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ insmod input_keys.ko</span><br><span class="line">input_keys:input_keys_init</span><br><span class="line">input_keys:input_keys_init_befor_register</span><br><span class="line">input: input_keys as /class/input/input1</span><br><span class="line">input_keys:input_keys_open</span><br><span class="line">input_keys:input_keys_init_after_register</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一 (没有LCD):</span></span><br><span class="line">$ cat /dev/tty1             <span class="comment"># keyboard.c 里面和tty有关联, 不去深究了.</span></span><br><span class="line"><span class="comment"># 依次按下 s2,s3 相当于输入了ls. 此处没有回显! 输入s4, 终端仅显示ls.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二 (没有LCD):</span></span><br><span class="line">$ <span class="built_in">exec</span> 0&lt;/dev/tty1          <span class="comment"># 将标准输入改为 /dey/tty1. (没有改标准输出, 因此还是会回显$)</span></span><br><span class="line">$ ls                        <span class="comment"># 依次按下 s2,s3,s4, 相当于输入了ls enter</span></span><br><span class="line"><span class="comment"># 显示文件夹内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明, 由于改了标准输入, 只能重启后键盘才会有效</span></span><br><span class="line"><span class="comment"># ls -l /proc/pid/fd 查看进程的文件描述符. pid值可以由top指令获得.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三 (有LCD, 没有QT)</span></span><br><span class="line">$ vi /etc/inittab</span><br><span class="line">    <span class="comment"># ===== 设置为如下内容 =====</span></span><br><span class="line">    ::sysinit:/etc/init.d/rcS</span><br><span class="line">    s3c2410_serial0::askfirst:-/bin/sh</span><br><span class="line">    <span class="comment"># 增加了下面一行, 用于屏幕打开终端</span></span><br><span class="line">    tty1::askfirst:-/bin/sh</span><br><span class="line">    ::ctrlaltdel:/sbin/reboot</span><br><span class="line">    ::shutdown:/bin/umount -a -r</span><br><span class="line">    <span class="comment"># ===== wq保存, 退出 =====</span></span><br><span class="line">$ reboot                    <span class="comment"># 重启终端</span></span><br><span class="line"><span class="comment"># 这样点击按键就直接能在LCD上查看输入和输出了.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三 (有QT)</span></span><br><span class="line"><span class="comment"># 打开开发板上的记事本或终端, 依次按下 s2,s3,s4, 会看到输入了.</span></span><br><span class="line"></span><br><span class="line">$ rmmod input_keys.ko</span><br><span class="line">input_keys:input_keys_exit_before_unregister</span><br><span class="line">input_keys:input_keys_close</span><br><span class="line">input_keys:input_keys_exit_after_unregister</span><br><span class="line">input_keys:input_keys_exit</span><br></pre></td></tr></table></figure>

<p>额外说一下 <code>hexdump</code> 的测试方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ insmod input_keys.ko                             <span class="comment"># 加载模块后, 会自动生成 /dev/event1</span></span><br><span class="line">$ hexdump /dev/event1                              <span class="comment"># 16进制显示event1设备在用户空间获得的数据</span></span><br><span class="line"><span class="comment"># 字节数|   秒    |  微秒   | 类  |code|  value      # 小端模式, 低位在前!</span></span><br><span class="line">0000000 0bb2 0000 0e48 000c 0001 0026 0001 0000    <span class="comment"># input_event(keydev, EV_KEY, key_val, 1)</span></span><br><span class="line">0000010 0bb2 0000 0e54 000c 0000 0000 0000 0000    <span class="comment"># input_sync(keydev);</span></span><br><span class="line">0000020 0bb2 0000 5815 000e 0001 0026 0000 0000    <span class="comment"># input_event(keydev, EV_KEY, key_val, 0)</span></span><br><span class="line">0000030 0bb2 0000 581f 000e 0000 0000 0000 0000    <span class="comment"># input_sync(keydev);</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析这些数值含义的方法:</span></span><br><span class="line"><span class="comment"># 就是从硬件驱动调用了 input_event 开始逐步深入看, 发现会调用 input_handler-&gt;event.</span></span><br><span class="line"><span class="comment"># 于是找到 evdev.c 下的 evdev_event. 看到 client的赋值 和 kill_fasync给用户空间发送异步信号, 可知hexdump显示就是这些数据</span></span><br><span class="line"><span class="comment"># 然后, 查看 struct input_event, 将数据类型一一对应起来就可以了.</span></span><br></pre></td></tr></table></figure>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/ITmelody/archive/2012/05/22/2513028.html">arm 驱动进阶：输入子系统概念及架构</a> 图和流程说明很好</li>
<li><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-29151914-id-3887032.html">Linux Input子系统之第一篇（input_dev/input_handle/input_handler</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/Golf_research/article/details/53293601">输入子系统（1）：数据结构总结</a></li>
<li><a target="_blank" rel="noopener" href="http://www.bijishequ.com/detail/482153">linux内核input子系统分析</a></li>
<li><a target="_blank" rel="noopener" href="http://www.360doc.com/content/12/0606/21/7775902_216485127.shtml">input_dev结构体分析</a> 对结构体的注释比较完整</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2018/01/04/1801-drv-chr7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/04/1801-drv-chr7/" class="post-title-link" itemprop="url">驱动之定时器按键防抖</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-01-04 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-04T00:00:00+11:00">2018-01-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2018-01-06 21:28:34" itemprop="dateModified" datetime="2018-01-06T21:28:34+11:00">2018-01-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/embedded-linux/" itemprop="url" rel="index"><span itemprop="name">embedded linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/11/22/1733-drv-chr1/">驱动之字符设备-框架</a></li>
<li><a href="https://draapho.github.io/2017/11/30/1740-drv-chr2/">驱动之基于LinK+设计按键驱动</a></li>
<li><a href="https://draapho.github.io/2017/12/07/1741-drv-chr3/">驱动之基于中断设计按键驱动</a></li>
<li><a href="https://draapho.github.io/2017/12/11/1742-drv-chr4/">驱动之poll机制</a></li>
<li><a href="https://draapho.github.io/2017/12/12/1743-drv-chr5/">驱动之异步通知</a></li>
<li><a href="https://draapho.github.io/2017/12/13/1744-drv-chr6/">驱动之同步互斥阻塞</a></li>
<li><a href="https://draapho.github.io/2017/12/13/1744-drv-chr6/">驱动之同步互斥阻塞</a></li>
<li><a href="https://draapho.github.io/2018/01/04/1801-drv-chr7/">驱动之定时器按键防抖</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.<br>硬件具备唯一性, 因此某一时刻应该只有一个应用程序能对驱动进行操作.</p>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>定时器的用法一般分为如下步骤:</p>
<ol>
<li>声明一个 timer<ul>
<li><code>struct timer_list newTimer</code></li>
</ul>
</li>
<li>声明并初始化 timer<ul>
<li>方法一: <code>DEFINE_TIMER(newTimer, timer_function, expires, data);</code></li>
<li>方法二: <code>setup_timer(&amp;newTimer, timer_function, data)</code></li>
<li>方法三: <code>init_timer(&amp;newTimer)</code></li>
<li>timer_function 就是定时器的中断服务函数</li>
</ul>
</li>
<li>完善定时中断服务函数<ul>
<li>要周期性调用定时器, 使用 <code>mod_timer(&amp;newTimer, jiffies+interval)</code> 重新注册</li>
<li>此部分代码特别注意锁的问题!</li>
</ul>
</li>
<li>注册 timer 到定时器链表<ul>
<li>相当于启动定时器, 可用 <code>add_timer(&amp;newTimer)</code></li>
<li>实际上 <code>add_timer</code> 并非必须调用, 直接使用<code>mod_timer</code>也没问题.</li>
<li><code>mod_timer</code> 等效于 <code>del_timer(); set expires; add_timer();</code></li>
</ul>
</li>
<li>重新注册 timer<ul>
<li>定时器配在置好后只运行一次，执行完中断服务函数后定时器就会自动销毁!</li>
<li>想要实现周期性定时中断就必须在中断服务程序的结尾重新给定时器写入超时值</li>
<li>使用 <code>mod_timer(&amp;newTimer, jiffies+interval)</code> 重新注册</li>
</ul>
</li>
<li>提前停止定时器 timer （非必需步骤）<ul>
<li>定时器计时结束后, 系统会自动销毁相关定时器.</li>
<li><code>del_timer(&amp;newTimer)</code></li>
<li><code>del_timer_sync(&amp;newTimer)</code>, 用于多核CPU. 单核的话等同于 <code>del_timer</code></li>
</ul>
</li>
<li>其它相关概念<ul>
<li><code>jiffies</code> 是linux系统启动后芯片时钟的节拍总数</li>
<li><code>HZ</code> 每秒经过的jiffies数. 其值就是系统时钟的频率</li>
<li><code>jiffies/HZ</code> 就是当前系统运行了多少秒</li>
<li>64位系统中, jiffies 只访问到低32位值, 需要使用 <code>get_jiffies_64()</code> 才能获取完整的64位数值.</li>
</ul>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/armeasy/article/details/6027709">内核sem、wait_queue_head_t、timer和kernel_thread使用驱动范例</a> 内核线程和定时器的用法</li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/qidi_huang/article/details/51318157">Linux内核 定时器 用法</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/chen-farsight/p/6226562.html">Linux设备驱动——内核定时器</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-timers-list/index.html">Linux内核中的计时器和列表</a></li>
</ul>
<h1 id="驱动源码"><a href="#驱动源码" class="headerlink" title="驱动源码"></a>驱动源码</h1><p>此驱动源码是韦东山教程里按键的最终版本. 驱动有如下特性:</p>
<ul>
<li>按键使用了中断</li>
<li>多线程/进程安全, 硬件使用了互斥量.</li>
<li>支持应用层阻塞或者非阻塞访问</li>
<li>支持poll机制. 应用层可以使用poll</li>
<li>支持异步机制. 应用层可以用信号中断来处理按键事件</li>
</ul>
<p>但对我个人而言, 这一版本的按键依旧不够好, 有机会自己写一版按键驱动</p>
<ul>
<li>按键状态反馈过于简单, 没有提供诸如短按, 长按, 连发, 释放的按键信息.</li>
<li>经典的按键范例是状态机模型, 用定时器定时扫描按键状态, 可以不用硬件中断.</li>
<li>没有实现对单个按键的open/closse操作.</li>
</ul>
<h2 id="drv-keys-c"><a href="#drv-keys-c" class="headerlink" title="drv_keys.c"></a>drv_keys.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">===============================================================================</span><br><span class="line">Driver Name     :       drv_keys</span><br><span class="line">Author          :       DRAAPHO</span><br><span class="line">License         :       GPL</span><br><span class="line">Description     :       LINUX DEVICE DRIVER PROJECT</span><br><span class="line">===============================================================================</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;drv_keys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEYS_N_MINORS 1                 <span class="comment">// 子设备号, 可用于区别按键.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEYS_FIRST_MINOR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEYS_NODE_NAME <span class="meta-string">&quot;key&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_KEYS_BUFF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;DRAAPHO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> drv_keys_major=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">dev_t</span> drv_keys_device_num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">drv_keys_class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">keys_async</span>;</span>            <span class="comment">// 新增, kill_fasync使用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_MUTEX</span><span class="params">(keys_lock)</span></span>;             <span class="comment">// 定义互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">privatedata</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nMinor;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">drv_keys_device</span>;</span></span><br><span class="line">&#125; drv_keys_private;</span><br><span class="line"></span><br><span class="line">drv_keys_private devices[DRV_KEYS_N_MINORS];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 中断和定时器增加的代码 =====</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(key_waitq)</span></span>;  <span class="comment">// 作用类似于信号量, 这里是向系统加入一个等待列表.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> ev_press = <span class="number">0</span>;           <span class="comment">// 中断事件标记, 手动值1或者清0</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> keys_val;              <span class="comment">// 记录按键值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pin_desc</span> * <span class="title">pindesc</span>;</span>                  <span class="comment">// 用于保存中断内的数据指针, 给超时函数使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">keys_timer</span>;</span>               <span class="comment">// 定时器</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pin_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pin;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> key_val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pin_desc</span> <span class="title">pins_desc</span>[3] =</span> &#123;            <span class="comment">// 设置好按键的引脚和对应的值</span></span><br><span class="line">    &#123;S3C2410_GPF0, <span class="number">0x01</span>&#125;,</span><br><span class="line">    &#123;S3C2410_GPF2, <span class="number">0x02</span>&#125;,</span><br><span class="line">    &#123;S3C2410_GPG3, <span class="number">0x04</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">keys_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PINFO(<span class="string">&quot;keys_irq, irq=%d\n&quot;</span>, irq);</span><br><span class="line">    pindesc = (struct pin_desc *)dev_id;    <span class="comment">// 获取自用的数据指针</span></span><br><span class="line">    mod_timer(&amp;keys_timer, jiffies+HZ/<span class="number">100</span>); <span class="comment">// 每次产生中断, 都等待10ms, 避开按键抖动</span></span><br><span class="line">    <span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keys_wait_10ms</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span> </span>&#123;            <span class="comment">// 中断发生10ms后, 在读取电平值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pinval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pindesc)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    pinval = s3c2410_gpio_getpin(pindesc-&gt;pin);             <span class="comment">// 读取按键电平</span></span><br><span class="line">    <span class="keyword">if</span> (pinval) &#123;                                           <span class="comment">// 松开</span></span><br><span class="line">        keys_val &amp;= ~pindesc-&gt;key_val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                <span class="comment">// 按下</span></span><br><span class="line">        keys_val |= pindesc-&gt;key_val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ev_press = <span class="number">1</span>;                                           <span class="comment">// 表示中断发生</span></span><br><span class="line">    wake_up_interruptible(&amp;key_waitq);                      <span class="comment">// 唤醒休眠的进程</span></span><br><span class="line">    kill_fasync(&amp;keys_async, SIGIO, POLL_IN);               <span class="comment">// 发送SIGIO信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 部分修改模板代码 =====</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_keys_open</span><span class="params">(struct inode *inode,struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;               <span class="comment">// 非阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (down_trylock(&amp;keys_lock))               <span class="comment">// 尝试获取信号量</span></span><br><span class="line">            <span class="keyword">return</span> -EBUSY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        down(&amp;keys_lock);                           <span class="comment">// 获取信号量, 阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    drv_keys_private *priv = container_of(inode-&gt;i_cdev ,</span><br><span class="line">            drv_keys_private ,cdev);</span><br><span class="line">    filp-&gt;private_data = priv;</span><br><span class="line">    PINFO(<span class="string">&quot;drv_keys_open\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册中断号, 设置中断类型, 设置中断名称(和设备名称无关), 传入自用的数据指针</span></span><br><span class="line">    ret  = request_irq(IRQ_EINT0, keys_irq, IRQT_BOTHEDGE, <span class="string">&quot;S2&quot;</span>, &amp;pins_desc[<span class="number">0</span>]);</span><br><span class="line">    ret |= request_irq(IRQ_EINT2, keys_irq, IRQT_BOTHEDGE, <span class="string">&quot;S3&quot;</span>, &amp;pins_desc[<span class="number">1</span>]);</span><br><span class="line">    ret |= request_irq(IRQ_EINT11, keys_irq, IRQT_BOTHEDGE, <span class="string">&quot;S4&quot;</span>, &amp;pins_desc[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器初始化.</span></span><br><span class="line">    setup_timer(&amp;keys_timer, keys_wait_10ms, <span class="number">0</span>);</span><br><span class="line">    add_timer(&amp;keys_timer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_keys_release</span><span class="params">(struct inode *inode,struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    drv_keys_private *priv;</span><br><span class="line">    priv=filp-&gt;private_data;</span><br><span class="line">    PINFO(<span class="string">&quot;drv_keys_release\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    del_timer_sync(&amp;keys_timer);                    <span class="comment">// 删除定时器</span></span><br><span class="line">    free_irq(IRQ_EINT11, &amp;pins_desc[<span class="number">2</span>]);            <span class="comment">// 注销中断</span></span><br><span class="line">    free_irq(IRQ_EINT2, &amp;pins_desc[<span class="number">1</span>]);</span><br><span class="line">    free_irq(IRQ_EINT0, &amp;pins_desc[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    up(&amp;keys_lock);                                 <span class="comment">// 释放信号量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">drv_keys_read</span><span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span> __user *ubuff,<span class="keyword">size_t</span> count,<span class="keyword">loff_t</span> *offp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    drv_keys_private *priv;</span><br><span class="line">    priv = filp-&gt;private_data;</span><br><span class="line">    PINFO(<span class="string">&quot;drv_keys_read()\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;               <span class="comment">// 非阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (!ev_press)                              <span class="comment">// 无按键, 立刻返回</span></span><br><span class="line">            <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ev_press, 用于判断是否可以让当前进程睡眠(让出CPU, 进程切换)</span></span><br><span class="line">        wait_event_interruptible(key_waitq, ev_press);      <span class="comment">// 阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ev_press = <span class="number">0</span>;                                           <span class="comment">// 运行后, 立刻清零</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ubuff, &amp;keys_val, <span class="number">1</span>)) &#123;                <span class="comment">// 传回按键值</span></span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="title">drv_keys_poll</span><span class="params">(struct file *file, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">    poll_wait(file, &amp;key_waitq, wait);      <span class="comment">// 这里不会休眠. 进程不阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ev_press)</span><br><span class="line">        mask |= POLLIN | POLLRDNORM;        <span class="comment">// 关键是返回值, 返回值为0, 进程可能休眠.</span></span><br><span class="line">        <span class="comment">// POLLIN, 是标准的事件值, 测试程序就基于此判断.</span></span><br><span class="line">        <span class="comment">// POLLRDNORM, Normal data may be read without blocking. 作用应该是告知应用程序类型和后续动作.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_keys_fasync</span> <span class="params">(<span class="keyword">int</span> fd, struct file *filp, <span class="keyword">int</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PINFO(<span class="string">&quot;drv_key_fasync\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> fasync_helper (fd, filp, on, &amp;keys_async);       <span class="comment">// 初始化keys_async</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 模板代码, 没有修改 =====</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">drv_keys_fops</span>=</span> &#123;</span><br><span class="line">    .owner              = THIS_MODULE,</span><br><span class="line">    .open               = drv_keys_open,</span><br><span class="line">    .release            = drv_keys_release,</span><br><span class="line">    .read               = drv_keys_read,</span><br><span class="line">    .poll               = drv_keys_poll,</span><br><span class="line">    .fasync             = drv_keys_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">drv_keys_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    res = alloc_chrdev_region(&amp;drv_keys_device_num,DRV_KEYS_FIRST_MINOR,DRV_KEYS_N_MINORS ,DRIVER_NAME);</span><br><span class="line">    <span class="keyword">if</span>(res) &#123;</span><br><span class="line">        PERR(<span class="string">&quot;register device no failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    drv_keys_major = MAJOR(drv_keys_device_num);</span><br><span class="line"></span><br><span class="line">    drv_keys_class = class_create(THIS_MODULE , DRIVER_NAME);</span><br><span class="line">    <span class="keyword">if</span>(!drv_keys_class) &#123;</span><br><span class="line">        PERR(<span class="string">&quot;class creation failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;DRV_KEYS_N_MINORS;i++) &#123;</span><br><span class="line">        drv_keys_device_num= MKDEV(drv_keys_major ,DRV_KEYS_FIRST_MINOR+i);</span><br><span class="line">        cdev_init(&amp;devices[i].cdev , &amp;drv_keys_fops);</span><br><span class="line">        cdev_add(&amp;devices[i].cdev,drv_keys_device_num,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        devices[i].drv_keys_device  =</span><br><span class="line">                device_create(drv_keys_class , <span class="literal">NULL</span> ,drv_keys_device_num ,</span><br><span class="line">                            <span class="comment">// NULL ,DRV_KEYS_NODE_NAME&quot;%d&quot;,DRV_KEYS_FIRST_MINOR+i);    // for higher kernel version</span></span><br><span class="line">                            DRV_KEYS_NODE_NAME<span class="string">&quot;%d&quot;</span>,DRV_KEYS_FIRST_MINOR+i);             <span class="comment">// for 2.6 kernel version</span></span><br><span class="line">        <span class="keyword">if</span>(!devices[i].drv_keys_device) &#123;</span><br><span class="line">            class_destroy(drv_keys_class);</span><br><span class="line">            PERR(<span class="string">&quot;device creation failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        devices[i].nMinor = DRV_KEYS_FIRST_MINOR+i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;INIT\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">drv_keys_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">&quot;EXIT\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;DRV_KEYS_N_MINORS;i++) &#123;</span><br><span class="line">        drv_keys_device_num= MKDEV(drv_keys_major ,DRV_KEYS_FIRST_MINOR+i);</span><br><span class="line"></span><br><span class="line">        cdev_del(&amp;devices[i].cdev);</span><br><span class="line"></span><br><span class="line">        device_destroy(drv_keys_class ,drv_keys_device_num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class_destroy(drv_keys_class);</span><br><span class="line"></span><br><span class="line">    unregister_chrdev_region(drv_keys_device_num ,DRV_KEYS_N_MINORS);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(drv_keys_init);</span><br><span class="line">module_exit(drv_keys_exit);</span><br></pre></td></tr></table></figure>


<h2 id="drv-keys-h"><a href="#drv-keys-h" class="headerlink" title="drv_keys.h"></a>drv_keys.h</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_NAME <span class="meta-string">&quot;drv_keys&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDEBUG(fmt,args...) printk(KERN_DEBUG<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERR(fmt,args...) printk(KERN_ERR<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME,##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINFO(fmt,args...) printk(KERN_INFO<span class="meta-string">&quot;%s:&quot;</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch-s3c2410/irqs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/hardware.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>这里我修改了一下, 把测试文件的编译也放进了这个文件.<br>用 <code>make test</code> 就能编译测试文件.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TEST_FILE   := drv_keys_test</span><br><span class="line"></span><br><span class="line">obj-m       := drv_keys.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br><span class="line">    rm -f <span class="variable">$(TEST_FILE)</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">    arm-linux-gcc <span class="variable">$(TEST_FILE)</span>.c -o <span class="variable">$(TEST_FILE)</span></span><br></pre></td></tr></table></figure>


<h2 id="drv-keys-test-c"><a href="#drv-keys-test-c" class="headerlink" title="drv_keys_test.c"></a>drv_keys_test.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void keys_signal_handler(int signum)         // 信号中断处理函数</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">// unsigned char key_val = 0;</span></span><br><span class="line">    <span class="comment">// read(fd,&amp;key_val,1);</span></span><br><span class="line">    <span class="comment">// printf(&quot;key_val: 0x%x\n&quot;,key_val);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> oflags;                                 <span class="comment">// 用于异步通知的设置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span>                       <span class="comment">// poll 关联的文件, 可多个文件</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> key_val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/key0&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">// fd = open(&quot;/dev/key0&quot;, O_RDWR | O_NONBLOCK); // 非阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===== 使用异步通知 =====</span></span><br><span class="line">    <span class="comment">// signal(SIGIO, keys_signal_handler);      // 注册信号中断处理函数</span></span><br><span class="line">    <span class="comment">// fcntl(fd,F_SETOWN,getpid());             // 告诉内核，发给本进程</span></span><br><span class="line">    <span class="comment">// oflags = fcntl(fd,F_GETFL);</span></span><br><span class="line">    <span class="comment">// fcntl(fd, F_SETFL, oflags | FASYNC);     // 改变fasync标记, 内核会调用驱动fasync, 完成初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===== POLL轮询 =====</span></span><br><span class="line">    <span class="comment">// fds[0].fd     = fd;                      // 关联的驱动文件</span></span><br><span class="line">    <span class="comment">// fds[0].events = POLLIN;                  // 事件类型</span></span><br><span class="line">    <span class="comment">// while (1) &#123;</span></span><br><span class="line">        <span class="comment">// ret = poll(fds, 1, 5000);            // 执行poll. 最多阻塞5s (有按键事件会立刻返回)</span></span><br><span class="line">        <span class="comment">// if (ret == 0) &#123;</span></span><br><span class="line">        <span class="comment">//     printf(&quot;time out\n&quot;);            // 5s后超时</span></span><br><span class="line">        <span class="comment">// &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//     read(fd, &amp;keys_val, 1);          // 有按键, 读取按键值</span></span><br><span class="line">        <span class="comment">//     printf(&quot;keys_val = 0x%x\n&quot;, keys_val);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===== 阻塞查询 =====</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;                                  <span class="comment">// 开始主任务</span></span><br><span class="line">        ret = read(fd,&amp;key_val,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;key_val: 0x%x, ret = %d\n&quot;</span>, key_val, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="编译和测试"><a href="#编译和测试" class="headerlink" title="编译和测试"></a>编译和测试</h1><h2 id="Ubuntu主机端"><a href="#Ubuntu主机端" class="headerlink" title="Ubuntu主机端"></a>Ubuntu主机端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主机端, 编译源码</span></span><br><span class="line"><span class="comment"># pwd = /home/draapho/share/drv/drv_key_poll/KERN_SRC   # 驱动源码路径, share是nfs共享文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译驱动</span></span><br><span class="line">$ make clean</span><br><span class="line">$ make modules                  <span class="comment"># 编译驱动</span></span><br><span class="line">$ make <span class="built_in">test</span>                     <span class="comment"># 编译测试代码</span></span><br></pre></td></tr></table></figure>

<h2 id="开发板端"><a href="#开发板端" class="headerlink" title="开发板端"></a>开发板端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板端, 测试驱动功能</span></span><br><span class="line"><span class="comment"># pwd = /home/draapho/share/drv/drv_key_poll/KERN_SRC   # 驱动源码路径, share是nfs共享文件夹</span></span><br><span class="line"></span><br><span class="line">$ insmod drv_keys.ko            <span class="comment"># 加载模块</span></span><br><span class="line">$ ./drv_keys_test               <span class="comment"># 检测按键中断</span></span><br><span class="line"><span class="comment"># 按键测试...</span></span><br><span class="line"><span class="comment"># 按ctrl+c 终止进程</span></span><br><span class="line"></span><br><span class="line">$ ./drv_keys_test &amp;             <span class="comment"># 后台运行, 会运行</span></span><br><span class="line">$ ./drv_keys_test &amp;             <span class="comment"># 后台运行, 进程被挂起, 因为资源被锁.</span></span><br><span class="line">$ top                           <span class="comment"># 查看进程情况</span></span><br><span class="line">$ <span class="built_in">kill</span> 789                      <span class="comment"># 杀死第一个进程</span></span><br><span class="line"><span class="comment"># 第二个进程就能获得资源, 开始运行</span></span><br><span class="line">$ <span class="built_in">kill</span> 790                      <span class="comment"># 杀死第二个进程</span></span><br><span class="line">$ rmmod drv_keys.ko             <span class="comment"># 卸载模块</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2017/12/23/1749-qqiot-demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/12/23/1749-qqiot-demo/" class="post-title-link" itemprop="url">QQ物联演示项目</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-12-23 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-23T00:00:00+11:00">2017-12-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2017-12-22 18:16:34" itemprop="dateModified" datetime="2017-12-22T18:16:34+11:00">2017-12-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/qqiot/" itemprop="url" rel="index"><span itemprop="name">qqiot</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/12/18/1746-qqiot-env/">嵌入式linux环境搭建-QQ物联</a></li>
<li><a href="https://draapho.github.io/2017/12/22/1748-qqiot-procedure/">QQ物联开发步骤简介</a></li>
<li><a href="https://draapho.github.io/2017/12/20/1747-qqiot-bind/">QQ物联绑定分析</a></li>
<li><a href="https://draapho.github.io/2017/12/23/1749-qqiot-demo/">QQ物联演示项目</a></li>
</ul>
<p>本文使用 linux-3.4.2 内核, 使用jz2440开发板.</p>
<h1 id="编译和安装驱动"><a href="#编译和安装驱动" class="headerlink" title="编译和安装驱动"></a>编译和安装驱动</h1><p>先编译安装一下LED, 测试一下LCD功能</p>
<h2 id="LED驱动"><a href="#LED驱动" class="headerlink" title="LED驱动"></a>LED驱动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu主机端</span></span><br><span class="line"></span><br><span class="line">unzip led_driver.zip</span><br><span class="line"><span class="built_in">cd</span> led_driver/</span><br><span class="line">ll /work/system/linux-3.4.2/            <span class="comment"># 确定内核目录存在, 编译要用到</span></span><br><span class="line">make                                    <span class="comment"># 编译LED驱动</span></span><br><span class="line">arm-linux-gcc jz2440_led_app.c -o jz2440_led_app    <span class="comment"># 编译测试文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># jz2440开发板</span></span><br><span class="line"><span class="comment">#pwd = .../share/.../led_driver/        # 共享文件进入ubuntu下的驱动目录</span></span><br><span class="line">cp jz2440_led_drv.ko /lib/modules/3.4.2/</span><br><span class="line">insmod jz2440_led_drv.ko</span><br><span class="line">./jz2440_led_app</span><br><span class="line"><span class="comment"># 可以看到打印信息, 并且开发板的LED灯亮灭.</span></span><br><span class="line">rmmod jz2440_led_drv.ko                 <span class="comment"># 卸载设备模块</span></span><br></pre></td></tr></table></figure>

<h2 id="LCD测试"><a href="#LCD测试" class="headerlink" title="LCD测试"></a>LCD测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu主机端</span></span><br><span class="line"></span><br><span class="line">unzip lcd_gui_simple.zip</span><br><span class="line"><span class="built_in">cd</span> lcd_gui_simple/</span><br><span class="line">make                                    <span class="comment"># 编译LED测试源码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># jz2440开发板</span></span><br><span class="line"><span class="comment">#pwd = .../share/.../lcd_gui_simple/    # 共享文件进入ubuntu下的驱动目录</span></span><br><span class="line">ls /dev/fb0                             <span class="comment"># 确认已存在设备fb0</span></span><br><span class="line">./lcd_gui_simple                        <span class="comment"># 测试屏幕</span></span><br></pre></td></tr></table></figure>

<h1 id="演示项目"><a href="#演示项目" class="headerlink" title="演示项目"></a>演示项目</h1><h2 id="编译和测试"><a href="#编译和测试" class="headerlink" title="编译和测试"></a>编译和测试</h2><p>必须将应用程序需要用到的文件都准备好, 这样才能正常原型.<br>有如下重点:</p>
<ul>
<li>密钥文件放到 <code>/etc/qq_iot/demo_bind/</code></li>
<li>QQ SDK动态库放到 <code>/lib/</code></li>
<li>应用文件和资源文件放在一起, 譬如 <code>/qqiot/</code></li>
<li>准备好开发板必要驱动, 这里是led驱动. 其它驱动已经打包进内核.</li>
<li>确保网络正确, 能ping通外网.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu主机端</span></span><br><span class="line">unzip net_bind_detector.zip</span><br><span class="line"><span class="built_in">cd</span> net_bind_detector/</span><br><span class="line"><span class="comment"># 确认一下./lib/libtxdevicesdk.so的版本. 保证所有代码用的同一个库</span></span><br><span class="line">make clean</span><br><span class="line">make                                    <span class="comment"># 生成 net_bind_detector</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># jz2440开发板</span></span><br><span class="line"><span class="comment">#pwd=.../share/.../密钥文件目录/</span></span><br><span class="line">mkdir -p /etc/qq_iot/demo_bind/</span><br><span class="line">tar xzf 1700003137001488.tar.gz         <span class="comment"># 解压密钥文件</span></span><br><span class="line">mv 1700003137001488/* /etc/qq_iot/demo_bind/</span><br><span class="line">rm -r 1700003137001488</span><br><span class="line">ls /etc/qq_iot/demo_bind/               <span class="comment"># 确认一下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pwd=.../share/.../net_bind_detector/   # 共享文件进入ubuntu下的驱动目录</span></span><br><span class="line">cp net_bind_detector /qqiot/            <span class="comment"># 拷贝到开发板flash中</span></span><br><span class="line">cp lib/libtxdevicesdk.so /lib/          <span class="comment"># 拷贝QQ SKD库</span></span><br><span class="line">cp -rfd res/ /qqiot/                    <span class="comment"># 拷贝测试用资源, d表示忽略软连接</span></span><br><span class="line">ls /qqiot</span><br><span class="line">ls /qqiot/res                           <span class="comment"># 确认拷贝结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始测试</span></span><br><span class="line"><span class="built_in">cd</span> /qqiot/</span><br><span class="line">insmod /lib/modules/3.4.2/jz2440_led_drv.ko     <span class="comment"># 加载led模块</span></span><br><span class="line">./net_bind_detector</span><br><span class="line"><span class="comment"># 开始演示, 在QQ界面上操作, 开发板屏幕或LED就会有响应</span></span><br><span class="line"><span class="comment"># 然后测试QQ物联设备给手机QQ发送消息 (需要QQ服务器端正确配置)</span></span><br><span class="line">sendtextmsg                             <span class="comment"># 测试文本的发送</span></span><br><span class="line">sendpic                                 <span class="comment"># 测试图片文件的发送</span></span><br><span class="line">sendaudio                               <span class="comment"># 测试音频文件的发送</span></span><br><span class="line">sendvideo                               <span class="comment"># 测试视频文件的发送</span></span><br></pre></td></tr></table></figure>

<p>如果要实现开机自启动, 把相关命令放在 <code>/etc/init.d/rcS</code> 结尾处即可.<br>注意, 此程序用到了相对路径. 如果直接用 <code>/qqiot/net_bind_detector</code>, 加载相对路径文件时就会失败!</p>
<h1 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h1><p>这里就不分析了, 仅列出其文件结构</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>led</td>
<td>led的应用程序(很简单)</td>
</tr>
<tr>
<td>framebuffer</td>
<td>framebuffer底层实现</td>
</tr>
<tr>
<td>gui</td>
<td>自制gui</td>
</tr>
<tr>
<td>lib</td>
<td>腾讯QQ物联SDK的库文件存放位置</td>
</tr>
<tr>
<td>include</td>
<td>头文件</td>
</tr>
<tr>
<td>… qq_dev_sdk</td>
<td>腾讯QQ物联SDK的头文件存放位置</td>
</tr>
<tr>
<td>initDevice</td>
<td>设备初始化</td>
</tr>
<tr>
<td>DataPoint</td>
<td>实现 <code>tx_init_data_point</code> <code>tx_ack_data_point</code> <code>tx_report_data_point</code></td>
</tr>
<tr>
<td>fileTransfer</td>
<td>实现 <code>tx_init_file_transfer</code></td>
</tr>
<tr>
<td>msg</td>
<td>实现 <code>tx_send_text_msg</code> <code>tx_send_structuring_msg</code></td>
</tr>
<tr>
<td>res</td>
<td>存放图片文件, 音频文件, 视频文件</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2017/12/22/1748-qqiot-procedure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/12/22/1748-qqiot-procedure/" class="post-title-link" itemprop="url">QQ物联开发步骤简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2017-12-22 00:00:00 / Modified: 18:17:02" itemprop="dateCreated datePublished" datetime="2017-12-22T00:00:00+11:00">2017-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/qqiot/" itemprop="url" rel="index"><span itemprop="name">qqiot</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/12/18/1746-qqiot-env/">嵌入式linux环境搭建-QQ物联</a></li>
<li><a href="https://draapho.github.io/2017/12/22/1748-qqiot-procedure/">QQ物联开发步骤简介</a></li>
<li><a href="https://draapho.github.io/2017/12/20/1747-qqiot-bind/">QQ物联绑定分析</a></li>
<li><a href="https://draapho.github.io/2017/12/23/1749-qqiot-demo/">QQ物联演示项目</a></li>
</ul>
<p>本文使用 linux-3.4.2 内核, 使用jz2440开发板.</p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="硬件设备概念"><a href="#硬件设备概念" class="headerlink" title="硬件设备概念"></a>硬件设备概念</h2><ul>
<li>SN (serial number), 序列号<ul>
<li>由产品开发商提供, 但QQ规定了格式要求</li>
<li>需要保证唯一性. 即同一种类的单品都有其唯一的SN</li>
<li>格式: 16个字符长度. 由字母, 数字, 下划线, 连词符, 冒号组成.</li>
<li>譬如 <code>ABC-0032-1234567</code></li>
<li>历史原因, 源码里面的名称是 <code>guid</code></li>
</ul>
</li>
<li>LICENSE, 数字签名<ul>
<li>license 是对sn的数字签名, 所以与sn是一一对应的关系</li>
<li>license由腾讯提供的工具来实现, 输入sn即可</li>
<li>其目的就是保护设备信息, 避免设备被山寨.</li>
</ul>
</li>
<li>PID(product identify), 产品ID.<ul>
<li>即产品类别ID, 类似于超市商品的二维码, 表明产品类别</li>
<li>有了PID和SN后, QQ就可以唯一确定一台智能设备</li>
<li>QQ物联的设备二维码就是由PID和SN这两个信息组成的</li>
<li>QQ会提供PID值</li>
</ul>
</li>
<li>DIN(device identify number), 设备ID<ul>
<li>可以认为就是此设备的QQ号码, 64位长度.</li>
<li>DIN 由 PID + SN + LICENSE 产生.</li>
<li>QQ会保证DIN的唯一性</li>
</ul>
</li>
<li>SDK, 开发套件<ul>
<li>分为设备SDK和应用SDK</li>
<li>设备SDK, 就是给智能硬件使用的开发套件. 以后学习的重点是在这里.</li>
<li>应用SDK, 如果要开发独立APP, 就需要此SDK. 提供QQ开放接口. 此处略过不表.</li>
</ul>
</li>
</ul>
<h2 id="QQ云端概念"><a href="#QQ云端概念" class="headerlink" title="QQ云端概念"></a>QQ云端概念</h2><ul>
<li>datapoint, 数据点<ul>
<li>理解为QQ指定的一套数据格式规范即可.</li>
</ul>
</li>
<li>PropertyID, 属性ID<ul>
<li>每个datapoint都有自己的id, 用于表明此数值的属性.</li>
<li>譬如property_id (200001), 表示摄像头分辨率.</li>
<li>简单的理解, datapoint传输整个键值对. PropertyID是key.</li>
</ul>
</li>
</ul>
<h2 id="轻APP前端"><a href="#轻APP前端" class="headerlink" title="轻APP前端"></a>轻APP前端</h2><p>QQ物联轻APP是手机QQ里“我的设备”控制器内嵌的HTML5页面（模板），分为通用/公共模板和开发商自定义模板</p>
<ul>
<li>通用/公共模板<ul>
<li>公共模板的样式不可自定义, 但可以自行配置功能控件.</li>
<li>可节省软件端的研发和维护成本, 缩短产品研发周期.</li>
</ul>
</li>
<li>自定义模板<ul>
<li>使用Html5, 根据QQ物联提供的设计规范和接口实现定制化用户界面 (内嵌在QQ里)</li>
<li>自定义模板需要开发者将页面发布到自有的服务器, 然后将url地址提交到平台.</li>
</ul>
</li>
<li>deviceAPI<ul>
<li>QQ物联提供的给自定义模板调用的JS接口.</li>
<li>注意, 目前其对视屏功能仅部分支持.</li>
</ul>
</li>
</ul>
<h2 id="手机APP"><a href="#手机APP" class="headerlink" title="手机APP"></a>手机APP</h2><p>手机端概念只有在需要自己开发app, 调用应用SDK时, 才会用到!</p>
<ul>
<li>AppID<ul>
<li>标识APP, 此App使用QQ登录组件. 即调用了QQ的应用SDK</li>
</ul>
</li>
<li>OpenID<ul>
<li>等同于用户QQ号码的身份. 长度128bit</li>
<li>OpenID 由 appid + qq号码 产生</li>
</ul>
</li>
<li>TinyID (Tiny OpenID)<ul>
<li>QQ内部由于兼容问题, 对OpenID的一个缩略, 使用64bit长度</li>
</ul>
</li>
</ul>
<h2 id="配网方式-wifi下"><a href="#配网方式-wifi下" class="headerlink" title="配网方式(wifi下)"></a>配网方式(wifi下)</h2><p>不少硬件设备是没有屏幕的, 如何接入wifi就成为一个大问题. QQ物联提供如下几种方式</p>
<ul>
<li>WiFi Router： 设备自行解决入网问题，适用于有屏幕的智能设备</li>
<li>SmartLink： 博通合作方案, 其wifi芯片支持Monitor模式(可实现数据包注入), 内置了AES-CCM加密库</li>
<li>SmartLinkEx: 额外采用声波通讯技术协同配网, 提高极端环境下的配网成功率. 适合有麦克风的设备</li>
<li>QQLink： SmartLink的弱加密版本, 安全性没有SmartLink方案高.</li>
<li>QQLinkEx： 额外采用声波通讯技术协同配网. 适合有麦克风的设备</li>
</ul>
<h1 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h1><ol>
<li>建立企业开发账号.<ul>
<li><a target="_blank" rel="noopener" href="http://iot.open.qq.com/wiki/index.html#!FUNC/Register_On_WebSite.md">Step1. 申请开发者账号</a>, 申请一个公司用QQ</li>
<li><a target="_blank" rel="noopener" href="http://iot.open.qq.com/wiki/index.html#!FUNC/Register_On_WebSite.md">Step2. 申请加入白名单</a>, 需等待审核结果.</li>
<li><a target="_blank" rel="noopener" href="http://iot.open.qq.com/wiki/index.html#!FUNC/Register_On_WebSite.md">Step3. 进入配置平台</a>, 成功后, 就有开发配置平台了.</li>
</ul>
</li>
<li>创建新设备.<ul>
<li>在配置平台里面, 可以创建新设备.</li>
<li>慎重选择设备类型, 不同的设备类型提供不同的后台功能!</li>
<li>测试环境不要点击 <code>提交上线</code>, 最多有100台设备任意调试.</li>
<li>如果提交上线, 设备就会被锁定, 等待QQ审核结果. 此过程无法开发调试!</li>
<li>开发和测试完成后, 再去 <code>提交上线</code>, 等待审核结果.</li>
<li>已审核通过的产品如果还要更改配置页面, 则需要再次通过腾讯审核.</li>
</ul>
</li>
<li>配置设备后台<ul>
<li>新建设备之设备类型: 决定QQ物联设备大致需要的功能(控制/音视频).</li>
<li>设备信息之公钥上传: 用工具生成<code>public.pem</code>, 然后上传. 用于认证GUID/SN号.</li>
<li>设备信息之联网方式: 如果设备有界面可以自行入网, 可以选择自行入网. 如果没有输入界面, 则需要选wifi配网方式.</li>
<li>功能配置之公有功能: 设定手机QQ和QQ物联设备的收发内容</li>
<li>功能配置之特殊功能: 用来定义手机QQ与QQ物联设备两者之间特殊消息的数据格式<ul>
<li>显示类型：只能是QQ物联设备向手机QQ发送用于显示的的数据</li>
<li>控制类型：QQ物联设备与手机QQ可以互传控制消息的数据</li>
<li>设置好后, 会获得一个ID值! 数据传输格式是腾讯的 datapoint</li>
<li><strong>功能描述</strong>:  自定义数据的组织格式. 参考 <a target="_blank" rel="noopener" href="http://iot.open.qq.com/wiki/index.html#!FUNC/DataPoint_Custom_CMD.md">自定义指令</a> 里的说明</li>
</ul>
</li>
<li>控制器设置: 配置手机QQ的控制UI界面<ul>
<li>自动生成控制器, 就是使用QQ提供的通用模板. 模板里的元素可以自定义</li>
<li>自定义控制器, 就是自定义模板. 需要HTML5开发并放到自己的服务器端</li>
</ul>
</li>
</ul>
</li>
<li>创建设备序列号和密钥<ul>
<li>整个过程有两组公钥私钥配对.</li>
<li>服务器生成的公钥私钥, 开发者需下载公钥<code>170000xxxx.pem</code>. 此配对用于加密数据, 保证通讯安全.</li>
<li>开发者生成的公钥私钥, 开发者需上传公钥<code>public.pem</code>. 保证私钥安全性. 此配对用于认证设备SN没有被盗用.</li>
<li>设备SN的认证方法是, 开发者用私钥加密SN生成license, 将SN和license传给QQ服务器, QQ服务器会用上传的公钥去检查SN合法性.</li>
<li>license最好也保存好. 因为如果别人获取license和SN后, 可以仿冒特定的设备.</li>
<li><code>公钥&amp;证书工具</code>, 在设备信息的公钥上传里提供了下载.</li>
</ul>
</li>
<li>QQ物联设备端功能开发<ul>
<li><a target="_blank" rel="noopener" href="http://iot.open.qq.com/wiki/#!FUNC/DataPoint_Common_CMD.md">控制指令</a></li>
<li><a target="_blank" rel="noopener" href="http://iot.open.qq.com/wiki/#!FUNC/DataPoint_Custom_CMD.md">自定义指令</a></li>
<li><a target="_blank" rel="noopener" href="http://iot.open.qq.com/wiki/#!FUNC/DataPoint_Sync_Status.md">状态同步</a></li>
</ul>
</li>
<li>开发者测试</li>
<li>交给QQ物联官方审核</li>
<li>发布产品</li>
</ol>
<h1 id="收发消息的过程"><a href="#收发消息的过程" class="headerlink" title="收发消息的过程"></a>收发消息的过程</h1><h2 id="QQ物联设备接收消息"><a href="#QQ物联设备接收消息" class="headerlink" title="QQ物联设备接收消息"></a>QQ物联设备接收消息</h2><p>datapoint的主要函数:</p>
<ul>
<li><code>tx_init_data_point</code>: 初始化</li>
<li><code>tx_report_data_point</code>: 上报</li>
<li><code>tx_ack_data_point</code>: 回应</li>
</ul>
<p>QQ物联设备端, 对消息处理的主要过程如下:</p>
<ul>
<li><code>tx_init_data_point</code> 进行初始化后, 并定义回调函数 <code>on_receive_datapoint</code></li>
<li>手机QQ发送datapoint消息给QQ物联设备</li>
<li>QQ物联设备接收到后, 使用回调函数处理消息</li>
<li>处理方式是通过datapoint的ID来分辨消息类型(特殊功能里设置)</li>
</ul>
<h2 id="QQ物联设备发送消息"><a href="#QQ物联设备发送消息" class="headerlink" title="QQ物联设备发送消息"></a>QQ物联设备发送消息</h2><ul>
<li>QQ设备发送消息给QQ服务器<ul>
<li><code>tx_send_text_msg</code> 发送文本</li>
<li><code>tx_send_structuring_msg</code> 发送图文和音视频</li>
</ul>
</li>
<li>QQ服务器更具配置情况(触发器-动作-模板), 只转发满足条件的消息给手机QQ</li>
<li>触发器页面: 设置过滤条件并制定动作<ul>
<li>该消息由哪个QQ物联设备发送来的</li>
<li>该消息的ID号</li>
<li>触发后要执行的动作</li>
</ul>
</li>
<li>动作页面: 动作制定模板(文本/图片/语音/视频)</li>
<li>QQ服务器根据模板构造发送给手机QQ的消息</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="http://iot.open.qq.com/wiki/index.html">QQ物联资料库</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2017/12/20/1747-qqiot-bind/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/12/20/1747-qqiot-bind/" class="post-title-link" itemprop="url">QQ物联绑定分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-12-20 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-20T00:00:00+11:00">2017-12-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2017-12-22 18:17:02" itemprop="dateModified" datetime="2017-12-22T18:17:02+11:00">2017-12-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/qqiot/" itemprop="url" rel="index"><span itemprop="name">qqiot</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/12/18/1746-qqiot-env/">嵌入式linux环境搭建-QQ物联</a></li>
<li><a href="https://draapho.github.io/2017/12/22/1748-qqiot-procedure/">QQ物联开发步骤简介</a></li>
<li><a href="https://draapho.github.io/2017/12/20/1747-qqiot-bind/">QQ物联绑定分析</a></li>
<li><a href="https://draapho.github.io/2017/12/23/1749-qqiot-demo/">QQ物联演示项目</a></li>
</ul>
<p>本文使用 linux-3.4.2 内核, 使用jz2440开发板.</p>
<h1 id="demo-bind-c-的分析与测试"><a href="#demo-bind-c-的分析与测试" class="headerlink" title="demo_bind.c 的分析与测试"></a>demo_bind.c 的分析与测试</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>打开demo_bind.c, 说明很详细, 主要流程如下</p>
<ul>
<li>调用 <code>tx_init_device</code> 初始化设备信息. 可理解为将设备在QQ服务器上注册一下</li>
<li>打开QQ, 保证和设备连在同一个路由器上且能上网.</li>
<li>然后就可以在QQ我的设备中, 点击搜索新设备.</li>
<li>扫描设备并绑定成功后, 即触发设备的登录逻辑. 调用指定的回调函数.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initDevice</span><span class="params">()</span> </span>&#123;                 <span class="comment">// bind的核心函数, 初始化设备</span></span><br><span class="line">    <span class="comment">// 先读取三个重要文件</span></span><br><span class="line">    <span class="comment">// license, 认证文件. 文件名 ./licence.sign.file.txt</span></span><br><span class="line">    <span class="comment">// guid, 即SN设备序列号. 文件名 ./GUID_file.txt</span></span><br><span class="line">    <span class="comment">// svrPubkey变量中, 公钥. 文件名 ./1000000004.pem</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置设备的基本信息</span></span><br><span class="line">    tx_device_info info = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    info.os_platform            = <span class="string">&quot;Linux&quot;</span>;              <span class="comment">// os平台</span></span><br><span class="line"></span><br><span class="line">    info.device_name            = <span class="string">&quot;demo1&quot;</span>;              <span class="comment">// 设备名称</span></span><br><span class="line">    info.device_serial_number   = guid;                 <span class="comment">// 设备SN</span></span><br><span class="line">    info.device_license         = license;              <span class="comment">// 由SN生成的LICENSE</span></span><br><span class="line">    info.product_version        = <span class="number">1</span>;</span><br><span class="line">    info.network_type           = network_type_wifi;    <span class="comment">// 入网方式</span></span><br><span class="line">    info.product_id             = <span class="number">1000000004</span>;           <span class="comment">// PID, QQ分配</span></span><br><span class="line">    info.server_pub_key         = svrPubkey;            <span class="comment">// 公钥</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置回调函数</span></span><br><span class="line">    tx_device_notify notify      = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    notify.on_login_complete     = on_login_complete;   <span class="comment">// 登录完成</span></span><br><span class="line">    notify.on_online_status      = on_online_status;    <span class="comment">// 状态改变</span></span><br><span class="line">    notify.on_binder_list_change = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置目录和文件大小</span></span><br><span class="line">    tx_init_path init_path = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心语句, 向QQ服务器注册此设备.</span></span><br><span class="line">    <span class="keyword">int</span> ret = tx_init_device(&amp;info, &amp;notify, &amp;init_path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>示例里面的 <code>readBufferFromFile</code> 已经对license和SN进行文件化管理了.<br>为了以后的批量生产, 这里将必要的配置信息再打包一层, 统一放入一个配置文件.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu端</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立一个分支, 用来修改和测试bind</span></span><br><span class="line">sudo cp -rf Tencent_iot_SDK/ bind_test/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压获得的QQ物联相关文件, 包括 licence, sn和公钥</span></span><br><span class="line">sudo tar xzf 1700003137001488.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名后放到测试目录</span></span><br><span class="line">sudo mv 1700003137001488/ conf/</span><br><span class="line">sudo mv conf/ bind_test/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改下权限</span></span><br><span class="line">sudo chmod -R 777 bind_test/</span><br></pre></td></tr></table></figure>

<p>然后打开 <code>./bind_test/demo_bind.c</code> 文件, 仿照readBufferFromFile进行修改</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新增如下内容</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conf_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>  pid;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> pubkey_file[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> guid_file[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> license_file[<span class="number">128</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conf_info</span> <span class="title">configInfo</span> =</span> &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;, &#123;<span class="number">0</span>&#125;, &#123;<span class="number">0</span>&#125;, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">readConfigFromFile</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> read;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">char</span> *pconf[] = &#123;configInfo.pubkey_file, configInfo.guid_file,  configInfo.license_file&#125;;</span><br><span class="line">    <span class="comment">// 尝试打开目录下的配置文件</span></span><br><span class="line">    FILE * file = fopen(<span class="string">&quot;./conf/config&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open ./conf/config failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取第一行的数据, PID信息</span></span><br><span class="line">    read = getline(&amp;line, &amp;len, file);</span><br><span class="line">    <span class="keyword">if</span> (read &gt; <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">        ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read PID failed...\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(buf,line,read<span class="number">-1</span>);</span><br><span class="line">        buf[read]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        configInfo.pid = atoi(buf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;PID=%d\n&quot;</span>,configInfo.pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取第二行的数据, Name信息</span></span><br><span class="line">    read = getline(&amp;line, &amp;len, file);</span><br><span class="line">    <span class="keyword">if</span> (read &gt; <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">        ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read Name failed...\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(buf,line,read<span class="number">-1</span>);</span><br><span class="line">        buf[read]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">sprintf</span>(configInfo.name, buf);</span><br><span class="line">        <span class="comment">// printf(&quot;Name=%s\n&quot;,configInfo.name);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取剩下的行, 都是文件数据</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(pconf)/<span class="keyword">sizeof</span>(<span class="keyword">char</span> *); i++) &#123;</span><br><span class="line">        read = getline(&amp;line, &amp;len, file);</span><br><span class="line">        <span class="keyword">if</span> (read &gt; <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">            ret = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read line%d failed...\n&quot;</span>, i+<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(buf,line,read<span class="number">-1</span>);</span><br><span class="line">            buf[read]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (access(buf, R_OK)) &#123;</span><br><span class="line">                ret = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;fail to read %s\n&quot;</span>,buf);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(pconf[i], buf);</span><br><span class="line">                <span class="comment">// printf(&quot;line%d: %s\n&quot;, i+2, pconf[i]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;                                  <span class="comment">// 调试检查</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NAME=%s\n&quot;</span>,configInfo.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;PEM =%s\n&quot;</span>,configInfo.pubkey_file);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GUID=%s\n&quot;</span>,configInfo.guid_file);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LICENSE=%s\n&quot;</span>,configInfo.license_file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (line) <span class="built_in">free</span>(line);</span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改如下内容, -为原内容, +为修改后的内容</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initDevice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">+   <span class="keyword">if</span>(readConfigFromFile() == <span class="literal">false</span>)&#123;</span><br><span class="line">+       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">+   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 license</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> license[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> nLicenseSize = <span class="number">0</span>;</span><br><span class="line">-   <span class="keyword">if</span> (!readBufferFromFile(<span class="string">&quot;./licence.sign.file.txt&quot;</span>, license, <span class="keyword">sizeof</span>(license), &amp;nLicenseSize)) &#123;</span><br><span class="line">+   <span class="keyword">if</span> (!readBufferFromFile(configInfo.license_file, license, <span class="keyword">sizeof</span>(license), &amp;nLicenseSize)) &#123;</span><br><span class="line"></span><br><span class="line">-   <span class="keyword">if</span>(!readBufferFromFile(<span class="string">&quot;./GUID_file.txt&quot;</span>, guid, <span class="keyword">sizeof</span>(guid), &amp;nGUIDSize)) &#123;</span><br><span class="line">+   <span class="keyword">if</span> (!readBufferFromFile(configInfo.guid_file, guid, <span class="keyword">sizeof</span>(guid), &amp;nGUIDSize)) &#123;</span><br><span class="line"></span><br><span class="line">-   <span class="keyword">if</span> (!readBufferFromFile(<span class="string">&quot;./1000000004.pem&quot;</span>, svrPubkey, <span class="keyword">sizeof</span>(svrPubkey), &amp;nPubkeySize))</span><br><span class="line">+   <span class="keyword">if</span> (!readBufferFromFile(configInfo.pubkey_file, svrPubkey, <span class="keyword">sizeof</span>(svrPubkey), &amp;nPubkeySize))</span><br><span class="line"></span><br><span class="line">-   info.device_name            = <span class="string">&quot;demo1&quot;</span>;</span><br><span class="line">+   info.device_name            = configInfo.name;</span><br><span class="line">    info.device_serial_number   = guid;</span><br><span class="line">    info.device_license         = license;</span><br><span class="line">    info.product_version        = <span class="number">1</span>;</span><br><span class="line">    info.network_type           = network_type_wifi;</span><br><span class="line">-   info.product_id             = <span class="number">1000000004</span>;</span><br><span class="line">+   info.product_id             = configInfo.pid;</span><br><span class="line">    info.server_pub_key         = svrPubkey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后, 需要修改makefile文件, 用的交叉编译. (注意空格改为TAB)</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 改为交叉编译!</span></span><br><span class="line">CROSS_COMPILE = arm-linux-</span><br><span class="line">CC  = <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line"></span><br><span class="line"><span class="section">all:app1</span></span><br><span class="line">    @echo build complete</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    -rm SDKDemo_bind</span><br><span class="line"></span><br><span class="line"><span class="section">app1:demo_bind.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> demo_bind.c -o SDKDemo_bind -O0 -g3 -I<span class="string">&quot;./include&quot;</span> -L<span class="string">&quot;./lib&quot;</span> -ltxdevicesdk -lpthread -ldl -lstdc++</span><br></pre></td></tr></table></figure>


<p>最后, 设置conf文件.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1700003137</span><br><span class="line">jz2440_bind_demo</span><br><span class="line">.&#x2F;conf&#x2F;1700003137.pem</span><br><span class="line">.&#x2F;conf&#x2F;GUID_file[1700003137001488].txt</span><br><span class="line">.&#x2F;conf&#x2F;licence.sign.file[1700003137001488].txt</span><br></pre></td></tr></table></figure>


<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu端</span></span><br><span class="line"><span class="comment"># pwd = share/.../bind_test         # 共享文件夹下的bind_test目录</span></span><br><span class="line">$ make                              <span class="comment"># 编译</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># jz2440端</span></span><br><span class="line"><span class="comment"># pwd = mnt/share/.../bind_test     # 共享文件夹下的bind_test目录</span></span><br><span class="line">$ cp ./lib/libtxdevicesdk.so /lib   <span class="comment"># 拷贝动态库到开发板本地lib</span></span><br><span class="line">$ ls -l /lib/libtxdevicesdk.so      <span class="comment"># 检查一下</span></span><br><span class="line"></span><br><span class="line">$ mkdir /qqiot</span><br><span class="line">$ cp SDKDemo_bind /qqiot            <span class="comment"># 拷贝执行文件</span></span><br><span class="line">$ cp -rf conf/ /qqiot               <span class="comment"># 拷贝配置文件</span></span><br><span class="line">$ <span class="built_in">cd</span> /qqiot                         <span class="comment"># 切换目录</span></span><br><span class="line">$ ls                                <span class="comment"># 查看结果</span></span><br><span class="line"></span><br><span class="line">$ ./SDKDemo_bind                    <span class="comment"># 运行范例</span></span><br><span class="line"><span class="comment"># 会打印很多信息. 查看是否有如下类似信息</span></span><br><span class="line">WLAN connection with tencent iot server ... is setting up</span><br><span class="line">xpnet_gethostbyname: Begin gethostbyname device msf.3g.qq.com</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:<br>必须正确设置开发板的网络. 我已设置开发板为dhcp, 因此没有遇到网络方面的问题.<br>如果使用的是静态IP, 记得设置一下网关等信息.<br>可以用 <code>route</code> 指令查看网络路由表</p>
<p>然后, 打开手机端QQ, 保证手机和开发板在同一局域网下.<br>联系人-&gt;设备-&gt;发现新设备-&gt;绑定设备…就能看到jz2440_demo设备的界面了.</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="http://iot.open.qq.com/wiki/index.html">QQ物联资料库</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://draapho.github.io/2017/12/18/1746-qqiot-env/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="draapho">
      <meta itemprop="description" content="explore">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DRA&PHO">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/12/18/1746-qqiot-env/" class="post-title-link" itemprop="url">嵌入式linux环境搭建-QQ物联</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-12-18 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-18T00:00:00+11:00">2017-12-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2017-12-22 18:17:02" itemprop="dateModified" datetime="2017-12-22T18:17:02+11:00">2017-12-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/qqiot/" itemprop="url" rel="index"><span itemprop="name">qqiot</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/12/18/1746-qqiot-env/">嵌入式linux环境搭建-QQ物联</a></li>
<li><a href="https://draapho.github.io/2017/12/22/1748-qqiot-procedure/">QQ物联开发步骤简介</a></li>
<li><a href="https://draapho.github.io/2017/12/20/1747-qqiot-bind/">QQ物联绑定分析</a></li>
<li><a href="https://draapho.github.io/2017/12/23/1749-qqiot-demo/">QQ物联演示项目</a></li>
</ul>
<p>为学习QQ物联而搭建的jz2440开发环境.<br>需要升级交叉编译环境, 然后编译和烧录<br>使用如下软件版本:</p>
<ul>
<li>u-boot-1.1.6</li>
<li>linux-3.4.2</li>
<li>arm-linux-gcc-4.3.2</li>
</ul>
<p>另可参考:</p>
<ul>
<li><a href="https://draapho.github.io/2017/02/16/1705-linux-env/">嵌入式linux环境搭建-主机端</a>, 搭建Ubuntu开发环境</li>
<li><a href="https://draapho.github.io/2017/02/21/1707-jz2440-env/">嵌入式linux环境搭建-jz2440开发板</a>, 基于2.6.22内核的编译和烧录</li>
<li><a href="https://draapho.github.io/2017/11/28/1738-dhcp-env/">基于DHCP建立嵌入式Linux开发环境</a>, 修改jz2440的内核和文件系统以支持DHCP</li>
</ul>
<h1 id="安装交叉编译工具链"><a href="#安装交叉编译工具链" class="headerlink" title="安装交叉编译工具链"></a>安装交叉编译工具链</h1><p>新的linux内核需要用 arm-linux-gcc-4.3.2 这个版本的交叉编译.<br>对已安装的arm-linux-gcc-3.4.5, 无需删除, 但需要从环境变量中去除.<br>因此整个过程需要安装新软件, 重新设置一下Ubuntu的环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接拷贝解压 arm-linux-gcc-4.3.2.tar.bz2, 提供的压缩包包含了路径 /usr/local/arm/4.3.2</span></span><br><span class="line">$ sudo tar xjf arm-linux-gcc-4.3.2.tar.bz2 -C /</span><br><span class="line"><span class="comment"># 添加路径到环境变量, 记得去掉 gcc-3.4.5-glibc-2.3.6</span></span><br><span class="line">$ sudo vim /etc/bash.bashrc</span><br><span class="line">    <span class="comment"># ===== 文件内容, 末尾加入如下语句 =====</span></span><br><span class="line">    <span class="comment"># if [ -d /usr/local/gcc-3.4.5-glibc-2.3.6 ] ; then</span></span><br><span class="line">    <span class="comment">#   PATH=/usr/local/gcc-3.4.5-glibc-2.3.6/bin:&quot;$&#123;PATH&#125;&quot;</span></span><br><span class="line">    <span class="comment"># fi</span></span><br><span class="line">    <span class="keyword">if</span> [ -d /usr/<span class="built_in">local</span>/arm/4.3.2 ] ; <span class="keyword">then</span></span><br><span class="line">        PATH=/usr/<span class="built_in">local</span>/arm/4.3.2/bin:<span class="string">&quot;<span class="variable">$&#123;PATH&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line"><span class="comment"># 如果直接修改 /etc/environment 文件也可以.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试安装结果</span></span><br><span class="line">$ <span class="built_in">source</span> /etc/bash.bashrc                           <span class="comment"># 不重启更新PATH</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span>                                        <span class="comment"># 查看PATH</span></span><br><span class="line">$ arm-linux-gcc -v                                  <span class="comment"># 测试是否安装成功</span></span><br><span class="line">gcc version 4.3.2</span><br></pre></td></tr></table></figure>

<h1 id="uboot的编译和烧录"><a href="#uboot的编译和烧录" class="headerlink" title="uboot的编译和烧录"></a>uboot的编译和烧录</h1><h2 id="编译uboot"><a href="#编译uboot" class="headerlink" title="编译uboot"></a>编译uboot</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu shell</span></span><br><span class="line"></span><br><span class="line">tar xjvf u-boot-1.1.6.tar.bz2               <span class="comment"># 解压uboot源码</span></span><br><span class="line"><span class="built_in">cd</span> u-boot-1.1.6                             <span class="comment"># 进入uboot源码目录</span></span><br><span class="line">patch -p1 &lt; ../u-boot-1.1.6_20161226_all.patch </span><br><span class="line">make clean</span><br><span class="line">make 100ask24x0_config                      <span class="comment"># uboot config文件</span></span><br><span class="line">make                                        <span class="comment"># uboot 编译, 得到u-boot.bin文件</span></span><br></pre></td></tr></table></figure>

<h2 id="烧录uboot"><a href="#烧录uboot" class="headerlink" title="烧录uboot"></a>烧录uboot</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"><span class="comment"># 打开 jz2440 开发板串口终端, 启动时输入空格键, 进入如下菜单</span></span><br><span class="line"><span class="comment">##### 100ask Bootloader for OpenJTAG #####</span></span><br><span class="line">[n] Download u-boot to Nand Flash</span><br><span class="line">...</span><br><span class="line">Enter your selection: n / o                 <span class="comment"># 输入n 或者 o, 烧录uboot</span></span><br><span class="line">USB host is connected. Waiting a download.  <span class="comment"># 提示连接成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 Ubuntu 终端, 输入</span></span><br><span class="line"><span class="comment"># pwd = ./u-boot-1.1.6                      # 确保在 uboot 源码路径下</span></span><br><span class="line">sudo dnw u-boot.bin                         <span class="comment"># 使用dnw烧录uboot</span></span><br></pre></td></tr></table></figure>

<h2 id="设置uboot"><a href="#设置uboot" class="headerlink" title="设置uboot"></a>设置uboot</h2><p>如果希望通过uboot直接加载nfs文件系统, 还需进行如下设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"><span class="comment"># 设置ip地址, 在OpenJTAG&gt; 提示符下</span></span><br><span class="line"><span class="built_in">set</span> ipaddr 10.0.0.111           <span class="comment"># 设置开发板的ip地址</span></span><br><span class="line"><span class="built_in">set</span> serverip 10.0.0.138</span><br><span class="line">save                            <span class="comment"># 保存</span></span><br><span class="line">printenv                        <span class="comment"># 打印环境变量, 查看设置结果</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> bootargs noinitrd root=/dev/nfs nfsroot=10.0.0.98:/fs ip=10.0.0.111:10.0.0.98:10.0.0.138:255.255.255.0::eth0:off init=/linuxrc console=ttySAC0</span><br><span class="line"><span class="comment"># (简化ip: &#x27;set bootargs noinitrd root=/dev/nfs nfsroot=10.0.0.98:/fs ip=10.0.0.111 init=/linuxrc console=ttySAC0&#x27; 也可以工作)</span></span><br><span class="line">save        <span class="comment"># 保存修改</span></span><br><span class="line">reset       <span class="comment"># 重启. (稍后再重启, 先修改好 filesystem 内的初始化文件)</span></span><br><span class="line"><span class="comment"># 参数简要说明:</span></span><br><span class="line"><span class="comment"># &#x27;root=/dev/nfs&#x27; 加载nfs文件系统</span></span><br><span class="line"><span class="comment"># &#x27;nfsroot=10.0.0.98:/fs&#x27; nfs文件系统的来源, 此处是由win10当nfs服务器, 共享出/fs文件夹</span></span><br><span class="line"><span class="comment"># &#x27;ip=10.0.0.111:10.0.0.98:10.0.0.138:255.255.255.0::eth0:off&#x27; 分别表示:</span></span><br><span class="line"><span class="comment">#  ip= 开发板ip : nfs服务器ip: 网关ip : 子网掩码 :: 开发板网口 : off</span></span><br></pre></td></tr></table></figure>

<h1 id="kernel的编译和烧录"><a href="#kernel的编译和烧录" class="headerlink" title="kernel的编译和烧录"></a>kernel的编译和烧录</h1><h2 id="编译kernel"><a href="#编译kernel" class="headerlink" title="编译kernel"></a>编译kernel</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu shell</span></span><br><span class="line"></span><br><span class="line">tar xjvf linux-3.4.2.tar.bz2                <span class="comment"># 解压kernel源码</span></span><br><span class="line"><span class="built_in">cd</span> linux-3.4.2                              <span class="comment"># 进入kernel源码目录</span></span><br><span class="line">patch -p1 &lt; ../linux-3.4.2_20161226_all.patch  <span class="comment"># 打补丁文件, p1表忽略patch文件内的1层目录</span></span><br><span class="line"></span><br><span class="line">make clean                                  <span class="comment"># 清空 (先清空再在SI内查看)</span></span><br><span class="line">cp config_jz2440 .config                    <span class="comment"># 设置config文件, 此配置文件已支持dhcp</span></span><br><span class="line">make uImage                                 <span class="comment"># 编译获得内核image</span></span><br></pre></td></tr></table></figure>

<p>编译时, 遇到一个错误: <code>Can&#39;t use &#39;defined(@array)&#39; (Maybe you should just omit the defined()?) at kernel/timeconst.pl line 373.</code><br>参考 <a target="_blank" rel="noopener" href="http://sunyongfeng.com/201701/programmer/linux/kernel_compile_fail.html">Linux kernel 编译问题记录</a>. 原因是perl版本升级了.<br>将 <code>if (!defined(@val))</code> 改为 <code>if (!@val)</code> 再次编译就可以了.</p>
<h2 id="烧录kernel"><a href="#烧录kernel" class="headerlink" title="烧录kernel"></a>烧录kernel</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"><span class="comment"># 打开 jz2440 开发板串口终端, 启动时输入空格键, 进入如下菜单</span></span><br><span class="line"><span class="comment">##### 100ask Bootloader for OpenJTAG #####</span></span><br><span class="line">[k] Download Linux kernel uImage</span><br><span class="line">...</span><br><span class="line">Enter your selection: k                     <span class="comment"># 输入k, 烧录 kernel</span></span><br><span class="line">USB host is connected. Waiting a download.  <span class="comment"># 提示连接成功</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 Ubuntu 终端, 输入</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6                    # 确保在 kernel 源码路径下</span></span><br><span class="line">sudo dnw ./arch/arm/boot/uImage             <span class="comment"># 输入dnw指令, 指明烧录文件</span></span><br><span class="line"><span class="comment"># DNW usb device found!                     # 开始烧录</span></span><br></pre></td></tr></table></figure>

<h1 id="filesystem的制作和烧录"><a href="#filesystem的制作和烧录" class="headerlink" title="filesystem的制作和烧录"></a>filesystem的制作和烧录</h1><p><strong>注意</strong>, QQ物联的应用, 文件系统必须烧录到nand flash中, 而不能采用NFS的方式加载.</p>
<h2 id="制作-filesystem"><a href="#制作-filesystem" class="headerlink" title="制作 filesystem"></a>制作 filesystem</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ubuntu shell</span></span><br><span class="line">sudo tar xjvf fs_mini_mdev_new_auto_wifi.tar.bz2        <span class="comment"># 解压缩</span></span><br><span class="line">mkyaffs2image fs_mini_mdev_new fs_mini_mdev_new.yaffs2  <span class="comment"># 生成文件系统</span></span><br></pre></td></tr></table></figure>

<h2 id="烧录-filesystem"><a href="#烧录-filesystem" class="headerlink" title="烧录 filesystem"></a>烧录 filesystem</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot</span></span><br><span class="line"><span class="comment"># 打开 jz2440 开发板串口终端, 启动时输入空格键, 进入如下菜单</span></span><br><span class="line"><span class="comment">##### 100ask Bootloader for OpenJTAG #####</span></span><br><span class="line">[y] Download root_yaffs image</span><br><span class="line">...</span><br><span class="line">Enter your selection: y                     <span class="comment"># 输入k, 烧录 root_yaffs</span></span><br><span class="line">USB host is connected. Waiting a download.  <span class="comment"># 提示连接成功</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 Ubuntu 终端, 输入</span></span><br><span class="line">sudo dnw fs_mini_mdev_new.yaffs2            <span class="comment"># 输入dnw指令, 指明烧录文件</span></span><br><span class="line"><span class="comment"># DNW usb device found!                     # 开始烧录</span></span><br><span class="line"><span class="comment"># 这样就成功把文件系统烧录到 jz2440 开发板中了.</span></span><br></pre></td></tr></table></figure>

<h1 id="查看分区"><a href="#查看分区" class="headerlink" title="查看分区"></a><del>查看分区</del></h1><ul>
<li>bootloader, 512k</li>
<li>params, 128k</li>
<li>kernel, 4m</li>
<li>rootfs, 剩下的空间</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot, 进入命令行模式</span></span><br><span class="line">&gt; printenv</span><br><span class="line">mtdparts=mtdparts=nandflash0:512k@0(bootloader),128k(params),4m(kernel),-(root)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ubuntu端, kernel 源码下</span></span><br><span class="line">$ vim arch/arm/mach-s3c24xx/common-smdk.c</span><br><span class="line"><span class="comment"># 查看 smdk_default_nand_part 可知分区情况</span></span><br><span class="line">static struct mtd_partition smdk_default_nand_part[] = &#123;</span><br><span class="line">        [0] = &#123;</span><br><span class="line">                .name   = <span class="string">&quot;bootloader&quot;</span>,</span><br><span class="line">                .size   = SZ_512K,</span><br><span class="line">                .offset = 0,</span><br><span class="line">        &#125;,</span><br><span class="line">        [1] = &#123;</span><br><span class="line">                .name   = <span class="string">&quot;params&quot;</span>,</span><br><span class="line">                .offset = MTDPART_OFS_APPEND,</span><br><span class="line">                .size   = SZ_128K,</span><br><span class="line">        &#125;,</span><br><span class="line">        [2] = &#123;</span><br><span class="line">                .name   = <span class="string">&quot;kernel&quot;</span>,</span><br><span class="line">                .offset = MTDPART_OFS_APPEND,</span><br><span class="line">                .size   = SZ_4M,</span><br><span class="line">        &#125;,</span><br><span class="line">        [3] = &#123;</span><br><span class="line">                .name   = <span class="string">&quot;rootfs&quot;</span>,</span><br><span class="line">                .offset = MTDPART_OFS_APPEND,</span><br><span class="line">                .size   = MTDPART_SIZ_FULL,</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="配置网络-支持nfs"><a href="#配置网络-支持nfs" class="headerlink" title="配置网络, 支持nfs"></a>配置网络, 支持nfs</h1><h2 id="实现dhcp功能"><a href="#实现dhcp功能" class="headerlink" title="实现dhcp功能"></a>实现dhcp功能</h2><p>为了正常使用udhcpc, 还需要对文件系统稍加修改. 如下工作即可以在开发板端做, 也可以先在文件系统上做好, 然后编译烧录进开发板</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发板bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># udhcpc需要一个脚本文件, 否则无法完整实现dhcp功能. (测试了一下, 这个版本没有脚本也不报错, 但无法正常使用!)</span></span><br><span class="line">mkdir -p /usr/share/udhcpc/     <span class="comment"># 自动建立多层目录</span></span><br><span class="line">vi /usr/share/udhcpc/default.script</span><br><span class="line"><span class="comment"># ===== 打开vim, 写入如下内容 =====</span></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">[ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Error: should be called from udhcpc&quot;</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">RESOLV_CONF=<span class="string">&quot;/etc/resolv.conf&quot;</span></span><br><span class="line">[ -n <span class="string">&quot;<span class="variable">$broadcast</span>&quot;</span> ] &amp;&amp; BROADCAST=<span class="string">&quot;broadcast <span class="variable">$broadcast</span>&quot;</span></span><br><span class="line">[ -n <span class="string">&quot;<span class="variable">$subnet</span>&quot;</span> ] &amp;&amp; NETMASK=<span class="string">&quot;netmask <span class="variable">$subnet</span>&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  deconfig)</span><br><span class="line">    /sbin/ifconfig <span class="variable">$interface</span> 0.0.0.0</span><br><span class="line">    ;;</span><br><span class="line"> </span><br><span class="line">  renew|bound)</span><br><span class="line">    /sbin/ifconfig <span class="variable">$interface</span> <span class="variable">$ip</span> <span class="variable">$BROADCAST</span> <span class="variable">$NETMASK</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$router</span>&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;deleting routers&quot;</span></span><br><span class="line">      <span class="keyword">while</span> route del default gw 0.0.0.0 dev <span class="variable">$interface</span> ; <span class="keyword">do</span></span><br><span class="line">        :</span><br><span class="line">      <span class="keyword">done</span></span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$router</span> ; <span class="keyword">do</span></span><br><span class="line">        route add default gw <span class="variable">$i</span> dev <span class="variable">$interface</span></span><br><span class="line">      <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">echo</span> -n &gt; <span class="variable">$RESOLV_CONF</span></span><br><span class="line">    [ -n <span class="string">&quot;<span class="variable">$domain</span>&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> search <span class="variable">$domain</span> &gt;&gt; <span class="variable">$RESOLV_CONF</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$dns</span> ; <span class="keyword">do</span></span><br><span class="line">      <span class="built_in">echo</span> adding dns <span class="variable">$i</span></span><br><span class="line">      <span class="built_in">echo</span> nameserver <span class="variable">$i</span> &gt;&gt; <span class="variable">$RESOLV_CONF</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line"><span class="comment"># ===== wq保存文件, 退出 =====</span></span><br><span class="line">chmod +x /usr/share/udhcpc/default.script       <span class="comment"># 加入可执行属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后测试一下</span></span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc eth0</span><br><span class="line"><span class="comment"># 如果没有脚本文件, 只能获得IP地址, 没有dns的信息!</span></span><br><span class="line">ifconfig</span><br><span class="line"><span class="comment"># 能看到IP地址, 广播地址, 子网掩码信息</span></span><br><span class="line">ping 192.168.1.100</span><br><span class="line"><span class="comment"># 能ping通ubuntu主机</span></span><br></pre></td></tr></table></figure>

<h2 id="开机自动挂载nfs"><a href="#开机自动挂载nfs" class="headerlink" title="开机自动挂载nfs"></a>开机自动挂载nfs</h2><p>要使用nfs, Ubuntu主机首先必须支持nfs. 主机端配置详情见 <a href="https://draapho.github.io/2017/11/29/1739-ubuntu-nfs/">Ubuntu 16.04安装配置NFS</a><br>使用 <code>ifconfig</code> 查看主机IP地址, <code>vim /etc/exports</code> 查看共享目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># jz2440开发板</span></span><br><span class="line">vi /etc/init.d/rcS             <span class="comment"># 开机自动执行udhcpc. S是大写!</span></span><br><span class="line"><span class="comment"># ===== 打开vim, 修改/增加如下内容 =====</span></span><br><span class="line"><span class="comment">#ifconfig eth0 192.168.1.17</span></span><br><span class="line"></span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc eth0</span><br><span class="line"><span class="comment"># 上述两行放在最前面. 这样才能成功自动挂载nfs</span></span><br><span class="line"><span class="comment"># ===== wq保存文件, 退出 =====</span></span><br><span class="line"></span><br><span class="line">vi /etc/fstab</span><br><span class="line"><span class="comment"># ===== 打开vim, 增加如下内容 =====</span></span><br><span class="line"><span class="comment"># 文件最后加入这样一句nfs模板, 便于日后修改</span></span><br><span class="line"><span class="comment"># 192.168.1.100:/home/draapho/share /mnt/share nfs rsize=1024,wsize=1024,timeo=14,intr,nolock 0 0</span></span><br><span class="line"><span class="comment"># ===== wq保存文件, 退出 =====</span></span><br><span class="line"></span><br><span class="line">mkdir /mnt/share                <span class="comment"># 创建挂载点</span></span><br><span class="line">mount -a                        <span class="comment"># 不重启挂载, 测试一下</span></span><br></pre></td></tr></table></figure>

<h1 id="编译并测试驱动模块"><a href="#编译并测试驱动模块" class="headerlink" title="编译并测试驱动模块"></a>编译并测试驱动模块</h1><p>默认提供的驱动关联了 <code>/work/system/linux-3.4.2</code>作为内核关联.<br>另外, 可以把编译好的驱动拷贝到jz2440 flash中, 统一放在 <code>/lib/modules/3.4.2</code> 目录下面.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># jz2440开发板</span></span><br><span class="line">mkdir -p /lib/modules/3.4.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu端firstdrvtest.c </span></span><br><span class="line">sudo mkdir -p /work/system/</span><br><span class="line">firstdrvtest.c </span><br></pre></td></tr></table></figure>

<h2 id="LED驱动"><a href="#LED驱动" class="headerlink" title="LED驱动"></a>LED驱动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu端</span></span><br><span class="line"><span class="comment"># pwd = ./jz2440/first_drv                  # nfs共享文件</span></span><br><span class="line">make</span><br><span class="line">arm-linux-gcc firstdrvtest.c -o firstdrvtest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># jz2440开发板</span></span><br><span class="line"><span class="comment"># pwd = /mnt/share/.../jz2440/first_drv     # nfs共享文件</span></span><br><span class="line">cp first_drv.ko /lib/modules/3.4.2/</span><br><span class="line">ls /lib/modules/3.4.2/                      <span class="comment"># 查看拷贝结果</span></span><br><span class="line">insmod first_drv.ko</span><br><span class="line">lsmod                                       <span class="comment"># 列出已加载模块</span></span><br><span class="line">./firstdrvtest on                           <span class="comment"># 测试</span></span><br><span class="line">./firstdrvtest off</span><br></pre></td></tr></table></figure>

<h2 id="按键驱动"><a href="#按键驱动" class="headerlink" title="按键驱动"></a>按键驱动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu端</span></span><br><span class="line"><span class="comment"># pwd = ./jz2440/7th_buttons_all                # nfs共享文件</span></span><br><span class="line">make</span><br><span class="line">arm-linux-gcc buttons_test.c -o buttons_test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># jz2440开发板</span></span><br><span class="line"><span class="comment"># pwd = /mnt/share/.../jz2440/7th_buttons_all   # nfs共享文件</span></span><br><span class="line">cp buttons.ko /lib/modules/3.4.2/</span><br><span class="line">ls /lib/modules/3.4.2/                          <span class="comment"># 查看拷贝结果</span></span><br><span class="line">insmod buttons.ko</span><br><span class="line">lsmod                                           <span class="comment"># 列出已加载模块</span></span><br><span class="line">./buttons_test                                  <span class="comment"># 测试</span></span><br></pre></td></tr></table></figure>


<h2 id="LCD驱动"><a href="#LCD驱动" class="headerlink" title="LCD驱动"></a>LCD驱动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu端</span></span><br><span class="line"><span class="comment"># pwd = ./jz2440/10th_lcd                       # nfs共享文件, 屏幕驱动</span></span><br><span class="line">cp lcd_4.3.c lcd.c                              <span class="comment"># jz2440, 用的4.3寸屏</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># pwd = ./jz2440/fb_test                        # nfs共享文件, 屏幕测试</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># jz2440开发板</span></span><br><span class="line"><span class="comment"># pwd = /mnt/share/.../jz2440/10th_lcd          # nfs共享文件, 屏幕驱动</span></span><br><span class="line">cp lcd.ko /lib/modules/3.4.2/</span><br><span class="line">ls /lib/modules/3.4.2/                          <span class="comment"># 查看拷贝结果</span></span><br><span class="line">insmod lcd.ko</span><br><span class="line">lsmod                                           <span class="comment"># 列出已加载模块</span></span><br><span class="line"><span class="comment"># pwd = /mnt/share/.../jz2440/fb_test           # nfs共享文件, 屏幕测试</span></span><br><span class="line">./fb_test                                       <span class="comment"># 测试, 显示用法</span></span><br><span class="line">ls /dev/fb*                                     <span class="comment"># 显示设备</span></span><br><span class="line">./fb_test /dev/fb0                              <span class="comment"># 测试指定设备</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">draapho</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
